{"prompt": "Please complete the code given below. \nsrc/kademlia/operation/KadRefreshOperation.java\npublic class KadRefreshOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public KadRefreshOperation(KadServer server, KademliaNode localNode, KademliaDHT dht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public void execute() throws IOException\n    {\n        /* Run our BucketRefreshOperation to refresh buckets */\n        new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n\n        /* After buckets have been refreshed, we refresh content */\n        new ContentRefreshOperation(this.server, this.localNode, this.dht, this.config).execute();\n    }\n}\nsrc/kademlia/operation/StoreOperation.java\npublic class StoreOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final JKademliaStorageEntry storageEntry;\n    private final KademliaDHT localDht;\n    private final KadConfiguration config;\n\n    /**\n     * @param server\n     * @param localNode\n     * @param storageEntry The content to be stored on the DHT\n     * @param localDht     The local DHT\n     * @param config\n     */\n    public StoreOperation(KadServer server, KademliaNode localNode, JKademliaStorageEntry storageEntry, KademliaDHT localDht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.storageEntry = storageEntry;\n        this.localDht = localDht;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        /* Get the nodes on which we need to store the content */\n        NodeLookupOperation ndlo = new NodeLookupOperation(this.server, this.localNode, this.storageEntry.getContentMetadata().getKey(), this.config);\n        ndlo.execute();\n        List<Node> nodes = ndlo.getClosestNodes();\n\n        /* Create the message */\n        Message msg = new StoreContentMessage(this.localNode.getNode(), this.storageEntry);\n\n        /*Store the message on all of the K-Nodes*/\n        for (Node n : nodes)\n        {\n            if (n.equals(this.localNode.getNode()))\n            {\n                /* Store the content locally */\n                this.localDht.store(this.storageEntry);\n            }\n            else\n            {\n                /**\n                 * @todo Create a receiver that receives a store acknowledgement message to count how many nodes a content have been stored at\n                 */\n                this.server.sendMessage(n, msg, null);\n            }\n        }\n    }\n\n    /**\n     * @return The number of nodes that have stored this content\n     *\n     * @todo Implement this method\n     */\n    public int numNodesStoredAt()\n    {\n        return 1;\n    }\n}\nsrc/kademlia/dht/JKademliaStorageEntry.java\npublic class JKademliaStorageEntry implements KademliaStorageEntry\n{\n\n    private String content;\n    private final StorageEntryMetadata metadata;\n\n    public JKademliaStorageEntry(final KadContent content)\n    {\n        this(content, new StorageEntryMetadata(content));\n    }\n\n    public JKademliaStorageEntry(final KadContent content, final StorageEntryMetadata metadata)\n    {\n        this.setContent(content.toSerializedForm());\n        this.metadata = metadata;\n    }\n\n    @Override\n    public final void setContent(final byte[] data)\n    {\n        this.content = new String(data);\n    }\n\n    @Override\n    public final byte[] getContent()\n    {\n        return this.content.getBytes();\n    }\n\n    @Override\n    public final KademliaStorageEntryMetadata getContentMetadata()\n    {\n        return this.metadata;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"[StorageEntry: \");\n\n        sb.append(\"[Content: \");\n        sb.append(this.getContent());\n        sb.append(\"]\");\n\n        sb.append(this.getContentMetadata());\n\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/dht/DHT.java\npublic class DHT implements KademliaDHT\n{\n\n    private transient StoredContentManager contentManager;\n    private transient KadSerializer<JKademliaStorageEntry> serializer = null;\n    private transient KadConfiguration config;\n\n    private final String ownerId;\n\n    public DHT(String ownerId, KadConfiguration config)\n    {\n        this.ownerId = ownerId;\n        this.config = config;\n        this.initialize();\n    }\n\n    @Override\n    public final void initialize()\n    {\n        contentManager = new StoredContentManager();\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration con)\n    {\n        this.config = con;\n    }\n\n    @Override\n    public KadSerializer<JKademliaStorageEntry> getSerializer()\n    {\n        if (null == serializer)\n        {\n            serializer = new JsonSerializer<>();\n        }\n\n        return serializer;\n    }\n\n    @Override\n    public boolean store(JKademliaStorageEntry content) throws IOException\n    {\n        /* Lets check if we have this content and it's the updated version */\n        if (this.contentManager.contains(content.getContentMetadata()))\n        {\n            KademliaStorageEntryMetadata current = this.contentManager.get(content.getContentMetadata());\n\n            /* update the last republished time */\n            current.updateLastRepublished();\n\n            if (current.getLastUpdatedTimestamp() >= content.getContentMetadata().getLastUpdatedTimestamp())\n            {\n                /* We have the current content, no need to update it! just leave this method now */\n                return false;\n            }\n            else\n            {\n                /* We have this content, but not the latest version, lets delete it so the new version will be added below */\n                try\n                {\n                    //System.out.println(\"Removing older content to update it\");\n                    this.remove(content.getContentMetadata());\n                }\n                catch (ContentNotFoundException ex)\n                {\n                    /* This won't ever happen at this point since we only get here if the content is found, lets ignore it  */\n                }\n            }\n        }\n\n        /**\n         * If we got here means we don't have this content, or we need to update the content\n         * If we need to update the content, the code above would've already deleted it, so we just need to re-add it\n         */\n        try\n        {\n            //System.out.println(\"Adding new content.\");\n            /* Keep track of this content in the entries manager */\n            KademliaStorageEntryMetadata sEntry = this.contentManager.put(content.getContentMetadata());\n\n            /* Now we store the content locally in a file */\n            String contentStorageFolder = this.getContentStorageFolderName(content.getContentMetadata().getKey());\n\n            try (FileOutputStream fout = new FileOutputStream(contentStorageFolder + File.separator + sEntry.hashCode() + \".kct\");\n                    DataOutputStream dout = new DataOutputStream(fout))\n            {\n                this.getSerializer().write(content, dout);\n            }\n            return true;\n        }\n        catch (ContentExistException e)\n        {\n            /**\n             * Content already exist on the DHT\n             * This won't happen because above takes care of removing the content if it's older and needs to be updated,\n             * or returning if we already have the current content version.\n             */\n            return false;\n        }\n    }\n\n    @Override\n    public boolean store(KadContent content) throws IOException\n    {\n        return this.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(key);\n        DataInputStream din = new DataInputStream(new FileInputStream(folder + File.separator + hashCode + \".kct\"));\n        return this.getSerializer().read(din);\n    }\n\n    @Override\n    public boolean contains(GetParameter param)\n    {\n        return this.contentManager.contains(param);\n    }\n\n    @Override\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException\n    {\n        try\n        {\n            return this.retrieve(entry.getKey(), entry.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException\n    {\n        /* Load a KadContent if any exist for the given criteria */\n        try\n        {\n            KademliaStorageEntryMetadata e = this.contentManager.get(param);\n            return this.retrieve(e.getKey(), e.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove(KadContent content) throws ContentNotFoundException\n    {\n        this.remove(new StorageEntryMetadata(content));\n    }\n\n    @Override\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(entry.getKey());\n        File file = new File(folder + File.separator + entry.hashCode() + \".kct\");\n\n        contentManager.remove(entry);\n\n        if (file.exists())\n        {\n            file.delete();\n        }\n        else\n        {\n            throw new ContentNotFoundException();\n        }\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @param key The key of the content\n     *\n     * @return String The name of the folder\n     */\n    private String getContentStorageFolderName(KademliaId key)\n    {\n        /**\n         * Each content is stored in a folder named after the first 2 characters of the NodeId\n         *\n         * The name of the file containing the content is the hash of this content\n         */\n        String folderName = key.hexRepresentation().substring(0, 2);\n        File contentStorageFolder = new File(this.config.getNodeDataFolder(ownerId) + File.separator + folderName);\n\n        /* Create the content folder if it doesn't exist */\n        if (!contentStorageFolder.isDirectory())\n        {\n            contentStorageFolder.mkdir();\n        }\n\n        return contentStorageFolder.toString();\n    }\n\n    @Override\n    public List<KademliaStorageEntryMetadata> getStorageEntries()\n    {\n        return contentManager.getAllEntries();\n    }\n\n    @Override\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries)\n    {\n        for (KademliaStorageEntryMetadata e : ientries)\n        {\n            try\n            {\n                this.contentManager.put(e);\n            }\n            catch (ContentExistException ex)\n            {\n                /* Entry already exist, no need to store it again */\n            }\n        }\n    }\n\n    @Override\n    public synchronized String toString()\n    {\n        return this.contentManager.toString();\n    }\n}\nsrc/kademlia/routing/KademliaRoutingTable.java\npublic interface KademliaRoutingTable\n{\n\n    /**\n     * Initialize the RoutingTable to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Sets the configuration file for this routing table\n     *\n     * @param config\n     */\n    public void setConfiguration(KadConfiguration config);\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    public void insert(Contact c);\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    public void insert(Node n);\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    public int getBucketId(KademliaId nid);\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    public List<Node> findClosest(KademliaId target, int numNodesRequired);\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllNodes();\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllContacts();\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    public KademliaBucket[] getBuckets();\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    public void setUnresponsiveContacts(List<Node> contacts);\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    public void setUnresponsiveContact(Node n);\n\n}\nsrc/kademlia/dht/KadContent.java\npublic interface KadContent\n{\n\n    /**\n     * @return NodeId The DHT key for this content\n     */\n    public KademliaId getKey();\n\n    /**\n     * @return String The type of content\n     */\n    public String getType();\n\n    /**\n     * Each content will have an created date\n     * This allows systems to know when to delete a content form his/her machine\n     *\n     * @return long The create date of this content\n     */\n    public long getCreatedTimestamp();\n\n    /**\n     * Each content will have an update timestamp\n     * This allows the DHT to keep only the latest version of a content\n     *\n     * @return long The timestamp of when this content was last updated\n     */\n    public long getLastUpdatedTimestamp();\n\n    /**\n     * @return The ID of the owner of this content\n     */\n    public String getOwnerId();\n\n    /**\n     * Each content needs to be in byte format for transporting and storage,\n     * this method takes care of that.\n     *\n     * Each object is responsible for transforming itself to byte format since the\n     * structure of methods may differ.\n     *\n     * @return The content in byte format\n     */\n    public byte[] toSerializedForm();\n\n    /**\n     * Given the Content in byte format, read it\n     *\n     * @param data The object in byte format\n     *\n     * @return A new object from the given\n     */\n    public KadContent fromSerializedForm(byte[] data);\n}\nsrc/kademlia/util/serializer/JsonRoutingTableSerializer.java\npublic class JsonRoutingTableSerializer implements KadSerializer<KademliaRoutingTable>\n{\n\n    private final Gson gson;\n\n    Type contactCollectionType = new TypeToken<List<Contact>>()\n    {\n    }.getType();\n\n    private final KadConfiguration config;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    /**\n     * Initialize the class\n     *\n     * @param config\n     */\n    public JsonRoutingTableSerializer(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    @Override\n    public void write(KademliaRoutingTable data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic JKademliaRoutingTable */\n            gson.toJson(data, JKademliaRoutingTable.class, writer);\n\n            /* Now Store the Contacts  */\n            gson.toJson(data.getAllContacts(), contactCollectionType, writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public KademliaRoutingTable read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic JKademliaRoutingTable */\n            KademliaRoutingTable tbl = gson.fromJson(reader, KademliaRoutingTable.class);\n            tbl.setConfiguration(config);\n            \n            /* Now get the Contacts and add them back to the JKademliaRoutingTable */\n            List<Contact> contacts = gson.fromJson(reader, contactCollectionType);\n            tbl.initialize();\n\n            for (Contact c : contacts)\n            {\n                tbl.insert(c);\n            }\n\n            reader.endArray();\n            /* Read and return the Content*/\n            return tbl;\n        }\n    }\n}\nsrc/kademlia/operation/ConnectOperation.java\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final Node bootstrapNode;\n    private final KadConfiguration config;\n\n    private boolean error;\n    private int attempts;\n\n    /**\n     * @param server    The message server used to send/receive messages\n     * @param local     The local node\n     * @param bootstrap Node to use to bootstrap the local node onto the network\n     * @param config\n     */\n    public ConnectOperation(KadServer server, KademliaNode local, Node bootstrap, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = local;\n        this.bootstrapNode = bootstrap;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        try\n        {\n            /* Contact the bootstrap node */\n            this.error = true;\n            this.attempts = 0;\n            Message m = new ConnectMessage(this.localNode.getNode());\n\n            /* Send a connect message to the bootstrap node */\n            server.sendMessage(this.bootstrapNode, m, this);\n\n            /* If we haven't finished as yet, wait for a maximum of config.operationTimeout() time */\n            int totalTimeWaited = 0;\n            int timeInterval = 50;     // We re-check every 300 milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (error)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            if (error)\n            {\n                /* If we still haven't received any responses by then, do a routing timeout */\n                throw new RoutingException(\"ConnectOperation: Bootstrap node did not respond: \" + bootstrapNode);\n            }\n\n            /* Perform lookup for our own ID to get nodes close to us */\n            Operation lookup = new NodeLookupOperation(this.server, this.localNode, this.localNode.getNode().getNodeId(), this.config);\n            lookup.execute();\n\n            /**\n             * Refresh buckets to get a good routing table\n             * After the above lookup operation, K nodes will be in our routing table,\n             * Now we try to populate all of our buckets.\n             */\n            new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n        }\n        catch (InterruptedException e)\n        {\n            System.err.println(\"Connect operation was interrupted. \");\n        }\n    }\n\n    /**\n     * Receives an AcknowledgeMessage from the bootstrap node.\n     *\n     * @param comm\n     */\n    @Override\n    public synchronized void receive(Message incoming, int comm)\n    {\n        /* The incoming message will be an acknowledgement message */\n        AcknowledgeMessage msg = (AcknowledgeMessage) incoming;\n\n        /* The bootstrap node has responded, insert it into our space */\n        this.localNode.getRoutingTable().insert(this.bootstrapNode);\n\n        /* We got a response, so the error is false */\n        error = false;\n\n        /* Wake up any waiting thread */\n        notify();\n    }\n\n    /**\n     * Resends a ConnectMessage to the boot strap node a maximum of MAX_ATTEMPTS\n     * times.\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        if (++this.attempts < MAX_CONNECT_ATTEMPTS)\n        {\n            this.server.sendMessage(this.bootstrapNode, new ConnectMessage(this.localNode.getNode()), this);\n        }\n        else\n        {\n            /* We just exit, so notify all other threads that are possibly waiting */\n            notify();\n        }\n    }\n}\nsrc/kademlia/dht/KademliaStorageEntry.java\npublic interface KademliaStorageEntry\n{\n\n    /**\n     * Add the content to the storage entry\n     *\n     * @param data The content data in byte[] format\n     */\n    public void setContent(final byte[] data);\n\n    /**\n     * Get the content from this storage entry\n     *\n     * @return The content in byte format\n     */\n    public byte[] getContent();\n\n    /**\n     * Get the metadata for this storage entry\n     *\n     * @return the storage entry metadata\n     */\n    public KademliaStorageEntryMetadata getContentMetadata();\n}\nsrc/kademlia/message/MessageFactory.java\npublic class MessageFactory implements KademliaMessageFactory\n{\n\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public MessageFactory(KademliaNode local, KademliaDHT dht, KadConfiguration config)\n    {\n        this.localNode = local;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public Message createMessage(byte code, DataInputStream in) throws IOException\n    {\n        switch (code)\n        {\n            case AcknowledgeMessage.CODE:\n                return new AcknowledgeMessage(in);\n            case ConnectMessage.CODE:\n                return new ConnectMessage(in);\n            case ContentMessage.CODE:\n                return new ContentMessage(in);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupMessage(in);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupMessage(in);\n            case NodeReplyMessage.CODE:\n                return new NodeReplyMessage(in);\n            case SimpleMessage.CODE:\n                return new SimpleMessage(in);\n            case StoreContentMessage.CODE:\n                return new StoreContentMessage(in);\n            default:\n                //System.out.println(this.localNode + \" - No Message handler found for message. Code: \" + code);\n                return new SimpleMessage(in);\n\n        }\n    }\n\n    @Override\n    public Receiver createReceiver(byte code, KadServer server)\n    {\n        switch (code)\n        {\n            case ConnectMessage.CODE:\n                return new ConnectReceiver(server, this.localNode);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupReceiver(server, this.localNode, this.dht, this.config);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupReceiver(server, this.localNode, this.config);\n            case StoreContentMessage.CODE:\n                return new StoreContentReceiver(server, this.localNode, this.dht);\n            default:\n                //System.out.println(\"No receiver found for message. Code: \" + code);\n                return new SimpleReceiver();\n        }\n    }\n}\nsrc/kademlia/util/serializer/JsonSerializer.java\npublic class JsonSerializer<T> implements KadSerializer<T>\n{\n\n    private final Gson gson;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    @Override\n    public void write(T data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Store the content type */\n            gson.toJson(data.getClass().getName(), String.class, writer);\n\n            /* Now Store the content */\n            gson.toJson(data, data.getClass(), writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public T read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the class name */\n            String className = gson.fromJson(reader, String.class);\n\n            /* Read and return the Content*/\n            T ret = gson.fromJson(reader, Class.forName(className));\n            \n            reader.endArray();\n            \n            return ret;\n        }\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/node/KademliaId.java\npublic class KademliaId implements Streamable, Serializable\n{\n\n    public final transient static int ID_LENGTH = 160;\n    private byte[] keyBytes;\n\n    /**\n     * Construct the NodeId from some string\n     *\n     * @param data The user generated key string\n     */\n    public KademliaId(String data)\n    {\n        keyBytes = data.getBytes();\n        if (keyBytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long.\");\n        }\n    }\n\n    /**\n     * Generate a random key\n     */\n    public KademliaId()\n    {\n        keyBytes = new byte[ID_LENGTH / 8];\n        new Random().nextBytes(keyBytes);\n    }\n\n    /**\n     * Generate the NodeId from a given byte[]\n     *\n     * @param bytes\n     */\n    public KademliaId(byte[] bytes)\n    {\n        if (bytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long. Data Given: '\" + new String(bytes) + \"'\");\n        }\n        this.keyBytes = bytes;\n    }\n\n    /**\n     * Load the NodeId from a DataInput stream\n     *\n     * @param in The stream from which to load the NodeId\n     *\n     * @throws IOException\n     */\n    public KademliaId(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    public byte[] getBytes()\n    {\n        return this.keyBytes;\n    }\n\n    /**\n     * @return The BigInteger representation of the key\n     */\n    public BigInteger getInt()\n    {\n        return new BigInteger(1, this.getBytes());\n    }\n\n    /**\n     * Compares a NodeId to this NodeId\n     *\n     * @param o The NodeId to compare to this NodeId\n     *\n     * @return boolean Whether the 2 NodeIds are equal\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof KademliaId)\n        {\n            KademliaId nid = (KademliaId) o;\n            return this.hashCode() == nid.hashCode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 7;\n        hash = 83 * hash + Arrays.hashCode(this.keyBytes);\n        return hash;\n    }\n\n    /**\n     * Checks the distance between this and another NodeId\n     *\n     * @param nid\n     *\n     * @return The distance of this NodeId from the given NodeId\n     */\n    public KademliaId xor(KademliaId nid)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n        byte[] nidBytes = nid.getBytes();\n\n        for (int i = 0; i < ID_LENGTH / 8; i++)\n        {\n            result[i] = (byte) (this.keyBytes[i] ^ nidBytes[i]);\n        }\n\n        KademliaId resNid = new KademliaId(result);\n\n        return resNid;\n    }\n\n    /**\n     * Generates a NodeId that is some distance away from this NodeId\n     *\n     * @param distance in number of bits\n     *\n     * @return NodeId The newly generated NodeId\n     */\n    public KademliaId generateNodeIdByDistance(int distance)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n\n        /* Since distance = ID_LENGTH - prefixLength, we need to fill that amount with 0's */\n        int numByteZeroes = (ID_LENGTH - distance) / 8;\n        int numBitZeroes = 8 - (distance % 8);\n\n        /* Filling byte zeroes */\n        for (int i = 0; i < numByteZeroes; i++)\n        {\n            result[i] = 0;\n        }\n\n        /* Filling bit zeroes */\n        BitSet bits = new BitSet(8);\n        bits.set(0, 8);\n\n        for (int i = 0; i < numBitZeroes; i++)\n        {\n            /* Shift 1 zero into the start of the value */\n            bits.clear(i);\n        }\n        bits.flip(0, 8);        // Flip the bits since they're in reverse order\n        result[numByteZeroes] = (byte) bits.toByteArray()[0];\n\n        /* Set the remaining bytes to Maximum value */\n        for (int i = numByteZeroes + 1; i < result.length; i++)\n        {\n            result[i] = Byte.MAX_VALUE;\n        }\n\n        return this.xor(new KademliaId(result));\n    }\n\n    /**\n     * Counts the number of leading 0's in this NodeId\n     *\n     * @return Integer The number of leading 0's\n     */\n    public int getFirstSetBitIndex()\n    {\n        int prefixLength = 0;\n\n        for (byte b : this.keyBytes)\n        {\n            if (b == 0)\n            {\n                prefixLength += 8;\n            }\n            else\n            {\n                /* If the byte is not 0, we need to count how many MSBs are 0 */\n                int count = 0;\n                for (int i = 7; i >= 0; i--)\n                {\n                    boolean a = (b & (1 << i)) == 0;\n                    if (a)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        break;   // Reset the count if we encounter a non-zero number\n                    }\n                }\n\n                /* Add the count of MSB 0s to the prefix length */\n                prefixLength += count;\n\n                /* Break here since we've now covered the MSB 0s */\n                break;\n            }\n        }\n        return prefixLength;\n    }\n\n    /**\n     * Gets the distance from this NodeId to another NodeId\n     *\n     * @param to\n     *\n     * @return Integer The distance\n     */\n    public int getDistance(KademliaId to)\n    {\n        /**\n         * Compute the xor of this and to\n         * Get the index i of the first set bit of the xor returned NodeId\n         * The distance between them is ID_LENGTH - i\n         */\n        return ID_LENGTH - this.xor(to).getFirstSetBitIndex();\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        out.write(this.getBytes());\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        byte[] input = new byte[ID_LENGTH / 8];\n        in.readFully(input);\n        this.keyBytes = input;\n    }\n\n    public String hexRepresentation()\n    {\n        /* Returns the hex format of this NodeId */\n        BigInteger bi = new BigInteger(1, this.keyBytes);\n        return String.format(\"%0\" + (this.keyBytes.length << 1) + \"X\", bi);\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hexRepresentation();\n    }\n\n}\nsrc/kademlia/dht/KademliaDHT.java\npublic interface KademliaDHT\n{\n\n    /**\n     * Initialize this DHT to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Set a new configuration. Mainly used when we restore the DHT state from a file\n     *\n     * @param con The new configuration file\n     */\n    public void setConfiguration(KadConfiguration con);\n\n    /**\n     * Creates a new Serializer or returns an existing serializer\n     *\n     * @return The new ContentSerializer\n     */\n    public KadSerializer<JKademliaStorageEntry> getSerializer();\n\n    /**\n     * Handle storing content locally\n     *\n     * @param content The DHT content to store\n     *\n     * @return boolean true if we stored the content, false if the content already exists and is up to date\n     *\n     * @throws java.io.IOException\n     */\n    public boolean store(JKademliaStorageEntry content) throws IOException;\n\n    public boolean store(KadContent content) throws IOException;\n\n    /**\n     * Retrieves a Content from local storage\n     *\n     * @param key      The Key of the content to retrieve\n     * @param hashCode The hash code of the content to retrieve\n     *\n     * @return A KadContent object\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException;\n\n    /**\n     * Check if any content for the given criteria exists in this DHT\n     *\n     * @param param The content search criteria\n     *\n     * @return boolean Whether any content exist that satisfy the criteria\n     */\n    public boolean contains(GetParameter param);\n\n    /**\n     * Retrieve and create a KadContent object given the StorageEntry object\n     *\n     * @param entry The StorageEntry used to retrieve this content\n     *\n     * @return KadContent The content object\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException;\n\n    /**\n     * Get the StorageEntry for the content if any exist.\n     *\n     * @param param The parameters used to filter the content needed\n     *\n     * @return KadContent A KadContent found on the DHT satisfying the given criteria\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException;\n\n    /**\n     * Delete a content from local storage\n     *\n     * @param content The Content to Remove\n     *\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public void remove(KadContent content) throws ContentNotFoundException;\n\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException;\n\n    /**\n     * @return A List of all StorageEntries for this node\n     */\n    public List<KademliaStorageEntryMetadata> getStorageEntries();\n\n    /**\n     * Used to add a list of storage entries for existing content to the DHT.\n     * Mainly used when retrieving StorageEntries from a saved state file.\n     *\n     * @param ientries The entries to add\n     */\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries);\n\n}\nsrc/kademlia/operation/Operation.java\npublic interface Operation\n{\n\n    /**\n     * Starts an operation and returns when the operation is finished\n     *\n     * @throws kademlia.exceptions.RoutingException\n     */\n    public void execute() throws IOException, RoutingException;\n}\nsrc/kademlia/routing/JKademliaRoutingTable.java\npublic class JKademliaRoutingTable implements KademliaRoutingTable\n{\n\n    private final Node localNode;  // The current node\n    private transient KademliaBucket[] buckets;\n\n    private transient KadConfiguration config;\n\n    public JKademliaRoutingTable(Node localNode, KadConfiguration config)\n    {\n        this.localNode = localNode;\n        this.config = config;\n\n        /* Initialize all of the buckets to a specific depth */\n        this.initialize();\n\n        /* Insert the local node */\n        this.insert(localNode);\n    }\n\n    /**\n     * Initialize the JKademliaRoutingTable to it's default state\n     */\n    @Override\n    public final void initialize()\n    {\n        this.buckets = new KademliaBucket[KademliaId.ID_LENGTH];\n        for (int i = 0; i < KademliaId.ID_LENGTH; i++)\n        {\n            buckets[i] = new JKademliaBucket(i, this.config);\n        }\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    @Override\n    public synchronized final void insert(Contact c)\n    {\n        this.buckets[this.getBucketId(c.getNode().getNodeId())].insert(c);\n    }\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    @Override\n    public synchronized final void insert(Node n)\n    {\n        this.buckets[this.getBucketId(n.getNodeId())].insert(n);\n    }\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    @Override\n    public final int getBucketId(KademliaId nid)\n    {\n        int bId = this.localNode.getNodeId().getDistance(nid) - 1;\n\n        /* If we are trying to insert a node into it's own routing table, then the bucket ID will be -1, so let's just keep it in bucket 0 */\n        return bId < 0 ? 0 : bId;\n    }\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    @Override\n    public synchronized final List<Node> findClosest(KademliaId target, int numNodesRequired)\n    {\n        TreeSet<Node> sortedSet = new TreeSet<>(new KeyComparator(target));\n        sortedSet.addAll(this.getAllNodes());\n\n        List<Node> closest = new ArrayList<>(numNodesRequired);\n\n        /* Now we have the sorted set, lets get the top numRequired */\n        int count = 0;\n        for (Node n : sortedSet)\n        {\n            closest.add(n);\n            if (++count == numNodesRequired)\n            {\n                break;\n            }\n        }\n        return closest;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public synchronized final List<Node> getAllNodes()\n    {\n        List<Node> nodes = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            for (Contact c : b.getContacts())\n            {\n                nodes.add(c.getNode());\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public final List<Contact> getAllContacts()\n    {\n        List<Contact> contacts = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            contacts.addAll(b.getContacts());\n        }\n\n        return contacts;\n    }\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    @Override\n    public final KademliaBucket[] getBuckets()\n    {\n        return this.buckets;\n    }\n\n    /**\n     * Set the KadBuckets of this routing table, mainly used when retrieving saved state\n     *\n     * @param buckets\n     */\n    public final void setBuckets(KademliaBucket[] buckets)\n    {\n        this.buckets = buckets;\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    @Override\n    public void setUnresponsiveContacts(List<Node> contacts)\n    {\n        if (contacts.isEmpty())\n        {\n            return;\n        }\n        for (Node n : contacts)\n        {\n            this.setUnresponsiveContact(n);\n        }\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    @Override\n    public synchronized void setUnresponsiveContact(Node n)\n    {\n        int bucketId = this.getBucketId(n.getNodeId());\n\n        /* Remove the contact from the bucket */\n        this.buckets[bucketId].removeNode(n);\n    }\n\n    @Override\n    public synchronized final String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\nPrinting Routing Table Started ***************** \\n\");\n        int totalContacts = 0;\n        for (KademliaBucket b : this.buckets)\n        {\n            if (b.numContacts() > 0)\n            {\n                totalContacts += b.numContacts();\n                sb.append(\"# nodes in Bucket with depth \");\n                sb.append(b.getDepth());\n                sb.append(\": \");\n                sb.append(b.numContacts());\n                sb.append(\"\\n\");\n                sb.append(b.toString());\n                sb.append(\"\\n\");\n            }\n        }\n\n        sb.append(\"\\nTotal Contacts: \");\n        sb.append(totalContacts);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"Printing Routing Table Ended ******************** \");\n\n        return sb.toString();\n    }\n\n}\nsrc/kademlia/util/serializer/JsonDHTSerializer.java\npublic class JsonDHTSerializer implements KadSerializer<KademliaDHT>\n{\n\n    private final Gson gson;\n    private final Type storageEntriesCollectionType;\n\n    \n    {\n        gson = new Gson();\n\n        storageEntriesCollectionType = new TypeToken<List<KademliaStorageEntryMetadata>>()\n        {\n        }.getType();\n    }\n\n    @Override\n    public void write(KademliaDHT data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic DHT */\n            gson.toJson(data, DHT.class, writer);\n\n            /* Now Store the Entries  */\n            gson.toJson(data.getStorageEntries(), this.storageEntriesCollectionType, writer);\n\n            writer.endArray();\n        }\n\n    }\n\n    @Override\n    public KademliaDHT read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic DHT */\n            DHT dht = gson.fromJson(reader, DHT.class);\n            dht.initialize();\n\n            /* Now get the entries and add them back to the DHT */\n            List<KademliaStorageEntryMetadata> entries = gson.fromJson(reader, this.storageEntriesCollectionType);\n            dht.putStorageEntries(entries);\n\n            reader.endArray();\n            return dht;\n        }\n    }\n}\nsrc/kademlia/exceptions/ContentNotFoundException.java\npublic class ContentNotFoundException extends Exception\n{\n\n    public ContentNotFoundException()\n    {\n        super();\n    }\n\n    public ContentNotFoundException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/dht/GetParameter.java\npublic class GetParameter\n{\n\n    private KademliaId key;\n    private String ownerId = null;\n    private String type = null;\n\n    /**\n     * Construct a GetParameter to search for data by NodeId and owner\n     *\n     * @param key\n     * @param type\n     */\n    public GetParameter(KademliaId key, String type)\n    {\n        this.key = key;\n        this.type = type;\n    }\n\n    /**\n     * Construct a GetParameter to search for data by NodeId, owner, type\n     *\n     * @param key\n     * @param type\n     * @param owner\n     */\n    public GetParameter(KademliaId key, String type, String owner)\n    {\n        this(key, type);\n        this.ownerId = owner;\n    }\n\n    /**\n     * Construct our get parameter from a Content\n     *\n     * @param c\n     */\n    public GetParameter(KadContent c)\n    {\n        this.key = c.getKey();\n\n        if (c.getType() != null)\n        {\n            this.type = c.getType();\n        }\n\n        if (c.getOwnerId() != null)\n        {\n            this.ownerId = c.getOwnerId();\n        }\n    }\n\n    /**\n     * Construct our get parameter from a StorageEntryMeta data\n     *\n     * @param md\n     */\n    public GetParameter(KademliaStorageEntryMetadata md)\n    {\n        this.key = md.getKey();\n\n        if (md.getType() != null)\n        {\n            this.type = md.getType();\n        }\n\n        if (md.getOwnerId() != null)\n        {\n            this.ownerId = md.getOwnerId();\n        }\n    }\n\n    public KademliaId getKey()\n    {\n        return this.key;\n    }\n\n    public void setOwnerId(String ownerId)\n    {\n        this.ownerId = ownerId;\n    }\n\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    public void setType(String type)\n    {\n        this.type = type;\n    }\n\n    public String getType()\n    {\n        return this.type;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"GetParameter - [Key: \" + key + \"][Owner: \" + this.ownerId + \"][Type: \" + this.type + \"]\";\n    }\n}\nsrc/kademlia/operation/ContentLookupOperation.java\npublic class ContentLookupOperation implements Operation, Receiver\n{\n\n    /* Constants */\n    private static final Byte UNASKED = (byte) 0x00;\n    private static final Byte AWAITING = (byte) 0x01;\n    private static final Byte ASKED = (byte) 0x02;\n    private static final Byte FAILED = (byte) 0x03;\n\n    private final KadServer server;\n    private final JKademliaNode localNode;\n    private JKademliaStorageEntry contentFound = null;\n    private final KadConfiguration config;\n\n    private final ContentLookupMessage lookupMessage;\n\n    private boolean isContentFound;\n    private final SortedMap<Node, Byte> nodes;\n\n    /* Tracks messages in transit and awaiting reply */\n    private final Map<Integer, Node> messagesTransiting;\n\n    /* Used to sort nodes */\n    private final Comparator comparator;\n\n    /* Statistical information */\n    private final RouteLengthChecker routeLengthChecker;\n\n    \n    {\n        messagesTransiting = new HashMap<>();\n        isContentFound = false;\n        routeLengthChecker = new RouteLengthChecker();\n    }\n\n    /**\n     * @param server\n     * @param localNode\n     * @param params    The parameters to search for the content which we need to find\n     * @param config\n     */\n    public ContentLookupOperation(KadServer server, JKademliaNode localNode, GetParameter params, KadConfiguration config)\n    {\n        /* Construct our lookup message */\n        this.lookupMessage = new ContentLookupMessage(localNode.getNode(), params);\n\n        this.server = server;\n        this.localNode = localNode;\n        this.config = config;\n\n        /**\n         * We initialize a TreeMap to store nodes.\n         * This map will be sorted by which nodes are closest to the lookupId\n         */\n        this.comparator = new KeyComparator(params.getKey());\n        this.nodes = new TreeMap(this.comparator);\n    }\n\n    /**\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.RoutingException\n     */\n    @Override\n    public synchronized void execute() throws IOException, RoutingException\n    {\n        try\n        {\n            /* Set the local node as already asked */\n            nodes.put(this.localNode.getNode(), ASKED);\n\n            /**\n             * We add all nodes here instead of the K-Closest because there may be the case that the K-Closest are offline\n             * - The operation takes care of looking at the K-Closest.\n             */\n            List<Node> allNodes = this.localNode.getRoutingTable().getAllNodes();\n            this.addNodes(allNodes);\n            \n            /* Also add the initial set of nodes to the routeLengthChecker */\n            this.routeLengthChecker.addInitialNodes(allNodes);\n\n            /**\n             * If we haven't found the requested amount of content as yet,\n             * keey trying until config.operationTimeout() time has expired\n             */\n            int totalTimeWaited = 0;\n            int timeInterval = 10;     // We re-check every n milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (!this.askNodesorFinish() && !isContentFound)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add nodes from this list to the set of nodes to lookup\n     *\n     * @param list The list from which to add nodes\n     */\n    public void addNodes(List<Node> list)\n    {\n        for (Node o : list)\n        {\n            /* If this node is not in the list, add the node */\n            if (!nodes.containsKey(o))\n            {\n                nodes.put(o, UNASKED);\n            }\n        }\n    }\n\n    /**\n     * Asks some of the K closest nodes seen but not yet queried.\n     * Assures that no more than DefaultConfiguration.CONCURRENCY messages are in transit at a time\n     *\n     * This method should be called every time a reply is received or a timeout occurs.\n     *\n     * If all K closest nodes have been asked and there are no messages in transit,\n     * the algorithm is finished.\n     *\n     * @return <code>true</code> if finished OR <code>false</code> otherwise\n     */\n    private boolean askNodesorFinish() throws IOException\n    {\n        /* If >= CONCURRENCY nodes are in transit, don't do anything */\n        if (this.config.maxConcurrentMessagesTransiting() <= this.messagesTransiting.size())\n        {\n            return false;\n        }\n\n        /* Get unqueried nodes among the K closest seen that have not FAILED */\n        List<Node> unasked = this.closestNodesNotFailed(UNASKED);\n\n        if (unasked.isEmpty() && this.messagesTransiting.isEmpty())\n        {\n            /* We have no unasked nodes nor any messages in transit, we're finished! */\n            return true;\n        }\n\n        /* Sort nodes according to criteria */\n        Collections.sort(unasked, this.comparator);\n\n        /**\n         * Send messages to nodes in the list;\n         * making sure than no more than CONCURRENCY messsages are in transit\n         */\n        for (int i = 0; (this.messagesTransiting.size() < this.config.maxConcurrentMessagesTransiting()) && (i < unasked.size()); i++)\n        {\n            Node n = (Node) unasked.get(i);\n\n            int comm = server.sendMessage(n, lookupMessage, this);\n\n            this.nodes.put(n, AWAITING);\n            this.messagesTransiting.put(comm, n);\n        }\n\n        /* We're not finished as yet, return false */\n        return false;\n    }\n\n    /**\n     * Find The K closest nodes to the target lookupId given that have not FAILED.\n     * From those K, get those that have the specified status\n     *\n     * @param status The status of the nodes to return\n     *\n     * @return A List of the closest nodes\n     */\n    private List<Node> closestNodesNotFailed(Byte status)\n    {\n        List<Node> closestNodes = new ArrayList<>(this.config.k());\n        int remainingSpaces = this.config.k();\n\n        for (Map.Entry e : this.nodes.entrySet())\n        {\n            if (!FAILED.equals(e.getValue()))\n            {\n                if (status.equals(e.getValue()))\n                {\n                    /* We got one with the required status, now add it */\n                    closestNodes.add((Node) e.getKey());\n                }\n\n                if (--remainingSpaces == 0)\n                {\n                    break;\n                }\n            }\n        }\n\n        return closestNodes;\n    }\n\n    @Override\n    public synchronized void receive(Message incoming, int comm) throws IOException, RoutingException\n    {\n        if (this.isContentFound)\n        {\n            return;\n        }\n\n        if (incoming instanceof ContentMessage)\n        {\n            /* The reply received is a content message with the required content, take it in */\n            ContentMessage msg = (ContentMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            this.localNode.getRoutingTable().insert(msg.getOrigin());\n\n            /* Get the Content and check if it satisfies the required parameters */\n            JKademliaStorageEntry content = msg.getContent();\n            this.contentFound = content;\n            this.isContentFound = true;\n        }\n        else\n        {\n            /* The reply received is a NodeReplyMessage with nodes closest to the content needed */\n            NodeReplyMessage msg = (NodeReplyMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            Node origin = msg.getOrigin();\n            this.localNode.getRoutingTable().insert(origin);\n\n            /* Set that we've completed ASKing the origin node */\n            this.nodes.put(origin, ASKED);\n\n            /* Remove this msg from messagesTransiting since it's completed now */\n            this.messagesTransiting.remove(comm);\n            \n            /* Add the received nodes to the routeLengthChecker */\n            this.routeLengthChecker.addNodes(msg.getNodes(), origin);\n\n            /* Add the received nodes to our nodes list to query */\n            this.addNodes(msg.getNodes());\n            this.askNodesorFinish();\n        }\n    }\n\n    /**\n     * A node does not respond or a packet was lost, we set this node as failed\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        /* Get the node associated with this communication */\n        Node n = this.messagesTransiting.get(new Integer(comm));\n\n        if (n == null)\n        {\n            throw new UnknownMessageException(\"Unknown comm: \" + comm);\n        }\n\n        /* Mark this node as failed and inform the routing table that it's unresponsive */\n        this.nodes.put(n, FAILED);\n        this.localNode.getRoutingTable().setUnresponsiveContact(n);\n        this.messagesTransiting.remove(comm);\n\n        this.askNodesorFinish();\n    }\n    \n    /**\n     * @return Whether the content was found or not.\n     */\n    public boolean isContentFound()\n    {\n        return this.isContentFound;\n    }\n\n    /**\n     * @return The list of all content found during the lookup operation\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry getContentFound() throws ContentNotFoundException\n    {\n        if (this.isContentFound)\n        {\n            return this.contentFound;\n        }\n        else\n        {\n            throw new ContentNotFoundException(\"No Value was found for the given key.\");\n        }\n    }\n\n    /**\n     * @return How many hops it took in order to get to the content.\n     */\n    public int routeLength()\n    {\n        return this.routeLengthChecker.getRouteLength();\n    }\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\npackage kademlia;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.NoSuchElementException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport kademlia.dht.GetParameter;\nimport kademlia.dht.DHT;\nimport kademlia.dht.KadContent;\nimport kademlia.dht.KademliaDHT;\nimport kademlia.dht.KademliaStorageEntry;\nimport kademlia.dht.JKademliaStorageEntry;\nimport kademlia.exceptions.ContentNotFoundException;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.MessageFactory;\nimport kademlia.node.Node;\nimport kademlia.node.KademliaId;\nimport kademlia.operation.ConnectOperation;\nimport kademlia.operation.ContentLookupOperation;\nimport kademlia.operation.Operation;\nimport kademlia.operation.KadRefreshOperation;\nimport kademlia.operation.StoreOperation;\nimport kademlia.routing.JKademliaRoutingTable;\nimport kademlia.routing.KademliaRoutingTable;\nimport kademlia.util.serializer.JsonDHTSerializer;\nimport kademlia.util.serializer.JsonRoutingTableSerializer;\nimport kademlia.util.serializer.JsonSerializer;\n\n\n/**\n * The main Kademlia Node on the network, this node manages everything for this local system.\n *\n * @author Joshua Kissoon\n * @since 20140215\n *\n * @todo When we receive a store message - if we have a newer version of the content, re-send this newer version to that node so as to update their version\n * @todo Handle IPv6 Addresses\n *\n */\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;Next line of code:\n", "input": "package kademlia;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.NoSuchElementException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport kademlia.dht.GetParameter;\nimport kademlia.dht.DHT;\nimport kademlia.dht.KadContent;\nimport kademlia.dht.KademliaDHT;\nimport kademlia.dht.KademliaStorageEntry;\nimport kademlia.dht.JKademliaStorageEntry;\nimport kademlia.exceptions.ContentNotFoundException;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.MessageFactory;\nimport kademlia.node.Node;\nimport kademlia.node.KademliaId;\nimport kademlia.operation.ConnectOperation;\nimport kademlia.operation.ContentLookupOperation;\nimport kademlia.operation.Operation;\nimport kademlia.operation.KadRefreshOperation;\nimport kademlia.operation.StoreOperation;\nimport kademlia.routing.JKademliaRoutingTable;\nimport kademlia.routing.KademliaRoutingTable;\nimport kademlia.util.serializer.JsonDHTSerializer;\nimport kademlia.util.serializer.JsonRoutingTableSerializer;\nimport kademlia.util.serializer.JsonSerializer;\n\n\n/**\n * The main Kademlia Node on the network, this node manages everything for this local system.\n *\n * @author Joshua Kissoon\n * @since 20140215\n *\n * @todo When we receive a store message - if we have a newer version of the content, re-send this newer version to that node so as to update their version\n * @todo Handle IPv6 Addresses\n *\n */\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;", "context": "src/kademlia/operation/KadRefreshOperation.java\npublic class KadRefreshOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public KadRefreshOperation(KadServer server, KademliaNode localNode, KademliaDHT dht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public void execute() throws IOException\n    {\n        /* Run our BucketRefreshOperation to refresh buckets */\n        new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n\n        /* After buckets have been refreshed, we refresh content */\n        new ContentRefreshOperation(this.server, this.localNode, this.dht, this.config).execute();\n    }\n}\nsrc/kademlia/operation/StoreOperation.java\npublic class StoreOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final JKademliaStorageEntry storageEntry;\n    private final KademliaDHT localDht;\n    private final KadConfiguration config;\n\n    /**\n     * @param server\n     * @param localNode\n     * @param storageEntry The content to be stored on the DHT\n     * @param localDht     The local DHT\n     * @param config\n     */\n    public StoreOperation(KadServer server, KademliaNode localNode, JKademliaStorageEntry storageEntry, KademliaDHT localDht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.storageEntry = storageEntry;\n        this.localDht = localDht;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        /* Get the nodes on which we need to store the content */\n        NodeLookupOperation ndlo = new NodeLookupOperation(this.server, this.localNode, this.storageEntry.getContentMetadata().getKey(), this.config);\n        ndlo.execute();\n        List<Node> nodes = ndlo.getClosestNodes();\n\n        /* Create the message */\n        Message msg = new StoreContentMessage(this.localNode.getNode(), this.storageEntry);\n\n        /*Store the message on all of the K-Nodes*/\n        for (Node n : nodes)\n        {\n            if (n.equals(this.localNode.getNode()))\n            {\n                /* Store the content locally */\n                this.localDht.store(this.storageEntry);\n            }\n            else\n            {\n                /**\n                 * @todo Create a receiver that receives a store acknowledgement message to count how many nodes a content have been stored at\n                 */\n                this.server.sendMessage(n, msg, null);\n            }\n        }\n    }\n\n    /**\n     * @return The number of nodes that have stored this content\n     *\n     * @todo Implement this method\n     */\n    public int numNodesStoredAt()\n    {\n        return 1;\n    }\n}\nsrc/kademlia/dht/JKademliaStorageEntry.java\npublic class JKademliaStorageEntry implements KademliaStorageEntry\n{\n\n    private String content;\n    private final StorageEntryMetadata metadata;\n\n    public JKademliaStorageEntry(final KadContent content)\n    {\n        this(content, new StorageEntryMetadata(content));\n    }\n\n    public JKademliaStorageEntry(final KadContent content, final StorageEntryMetadata metadata)\n    {\n        this.setContent(content.toSerializedForm());\n        this.metadata = metadata;\n    }\n\n    @Override\n    public final void setContent(final byte[] data)\n    {\n        this.content = new String(data);\n    }\n\n    @Override\n    public final byte[] getContent()\n    {\n        return this.content.getBytes();\n    }\n\n    @Override\n    public final KademliaStorageEntryMetadata getContentMetadata()\n    {\n        return this.metadata;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"[StorageEntry: \");\n\n        sb.append(\"[Content: \");\n        sb.append(this.getContent());\n        sb.append(\"]\");\n\n        sb.append(this.getContentMetadata());\n\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/dht/DHT.java\npublic class DHT implements KademliaDHT\n{\n\n    private transient StoredContentManager contentManager;\n    private transient KadSerializer<JKademliaStorageEntry> serializer = null;\n    private transient KadConfiguration config;\n\n    private final String ownerId;\n\n    public DHT(String ownerId, KadConfiguration config)\n    {\n        this.ownerId = ownerId;\n        this.config = config;\n        this.initialize();\n    }\n\n    @Override\n    public final void initialize()\n    {\n        contentManager = new StoredContentManager();\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration con)\n    {\n        this.config = con;\n    }\n\n    @Override\n    public KadSerializer<JKademliaStorageEntry> getSerializer()\n    {\n        if (null == serializer)\n        {\n            serializer = new JsonSerializer<>();\n        }\n\n        return serializer;\n    }\n\n    @Override\n    public boolean store(JKademliaStorageEntry content) throws IOException\n    {\n        /* Lets check if we have this content and it's the updated version */\n        if (this.contentManager.contains(content.getContentMetadata()))\n        {\n            KademliaStorageEntryMetadata current = this.contentManager.get(content.getContentMetadata());\n\n            /* update the last republished time */\n            current.updateLastRepublished();\n\n            if (current.getLastUpdatedTimestamp() >= content.getContentMetadata().getLastUpdatedTimestamp())\n            {\n                /* We have the current content, no need to update it! just leave this method now */\n                return false;\n            }\n            else\n            {\n                /* We have this content, but not the latest version, lets delete it so the new version will be added below */\n                try\n                {\n                    //System.out.println(\"Removing older content to update it\");\n                    this.remove(content.getContentMetadata());\n                }\n                catch (ContentNotFoundException ex)\n                {\n                    /* This won't ever happen at this point since we only get here if the content is found, lets ignore it  */\n                }\n            }\n        }\n\n        /**\n         * If we got here means we don't have this content, or we need to update the content\n         * If we need to update the content, the code above would've already deleted it, so we just need to re-add it\n         */\n        try\n        {\n            //System.out.println(\"Adding new content.\");\n            /* Keep track of this content in the entries manager */\n            KademliaStorageEntryMetadata sEntry = this.contentManager.put(content.getContentMetadata());\n\n            /* Now we store the content locally in a file */\n            String contentStorageFolder = this.getContentStorageFolderName(content.getContentMetadata().getKey());\n\n            try (FileOutputStream fout = new FileOutputStream(contentStorageFolder + File.separator + sEntry.hashCode() + \".kct\");\n                    DataOutputStream dout = new DataOutputStream(fout))\n            {\n                this.getSerializer().write(content, dout);\n            }\n            return true;\n        }\n        catch (ContentExistException e)\n        {\n            /**\n             * Content already exist on the DHT\n             * This won't happen because above takes care of removing the content if it's older and needs to be updated,\n             * or returning if we already have the current content version.\n             */\n            return false;\n        }\n    }\n\n    @Override\n    public boolean store(KadContent content) throws IOException\n    {\n        return this.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(key);\n        DataInputStream din = new DataInputStream(new FileInputStream(folder + File.separator + hashCode + \".kct\"));\n        return this.getSerializer().read(din);\n    }\n\n    @Override\n    public boolean contains(GetParameter param)\n    {\n        return this.contentManager.contains(param);\n    }\n\n    @Override\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException\n    {\n        try\n        {\n            return this.retrieve(entry.getKey(), entry.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException\n    {\n        /* Load a KadContent if any exist for the given criteria */\n        try\n        {\n            KademliaStorageEntryMetadata e = this.contentManager.get(param);\n            return this.retrieve(e.getKey(), e.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove(KadContent content) throws ContentNotFoundException\n    {\n        this.remove(new StorageEntryMetadata(content));\n    }\n\n    @Override\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(entry.getKey());\n        File file = new File(folder + File.separator + entry.hashCode() + \".kct\");\n\n        contentManager.remove(entry);\n\n        if (file.exists())\n        {\n            file.delete();\n        }\n        else\n        {\n            throw new ContentNotFoundException();\n        }\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @param key The key of the content\n     *\n     * @return String The name of the folder\n     */\n    private String getContentStorageFolderName(KademliaId key)\n    {\n        /**\n         * Each content is stored in a folder named after the first 2 characters of the NodeId\n         *\n         * The name of the file containing the content is the hash of this content\n         */\n        String folderName = key.hexRepresentation().substring(0, 2);\n        File contentStorageFolder = new File(this.config.getNodeDataFolder(ownerId) + File.separator + folderName);\n\n        /* Create the content folder if it doesn't exist */\n        if (!contentStorageFolder.isDirectory())\n        {\n            contentStorageFolder.mkdir();\n        }\n\n        return contentStorageFolder.toString();\n    }\n\n    @Override\n    public List<KademliaStorageEntryMetadata> getStorageEntries()\n    {\n        return contentManager.getAllEntries();\n    }\n\n    @Override\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries)\n    {\n        for (KademliaStorageEntryMetadata e : ientries)\n        {\n            try\n            {\n                this.contentManager.put(e);\n            }\n            catch (ContentExistException ex)\n            {\n                /* Entry already exist, no need to store it again */\n            }\n        }\n    }\n\n    @Override\n    public synchronized String toString()\n    {\n        return this.contentManager.toString();\n    }\n}\nsrc/kademlia/routing/KademliaRoutingTable.java\npublic interface KademliaRoutingTable\n{\n\n    /**\n     * Initialize the RoutingTable to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Sets the configuration file for this routing table\n     *\n     * @param config\n     */\n    public void setConfiguration(KadConfiguration config);\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    public void insert(Contact c);\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    public void insert(Node n);\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    public int getBucketId(KademliaId nid);\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    public List<Node> findClosest(KademliaId target, int numNodesRequired);\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllNodes();\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllContacts();\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    public KademliaBucket[] getBuckets();\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    public void setUnresponsiveContacts(List<Node> contacts);\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    public void setUnresponsiveContact(Node n);\n\n}\nsrc/kademlia/dht/KadContent.java\npublic interface KadContent\n{\n\n    /**\n     * @return NodeId The DHT key for this content\n     */\n    public KademliaId getKey();\n\n    /**\n     * @return String The type of content\n     */\n    public String getType();\n\n    /**\n     * Each content will have an created date\n     * This allows systems to know when to delete a content form his/her machine\n     *\n     * @return long The create date of this content\n     */\n    public long getCreatedTimestamp();\n\n    /**\n     * Each content will have an update timestamp\n     * This allows the DHT to keep only the latest version of a content\n     *\n     * @return long The timestamp of when this content was last updated\n     */\n    public long getLastUpdatedTimestamp();\n\n    /**\n     * @return The ID of the owner of this content\n     */\n    public String getOwnerId();\n\n    /**\n     * Each content needs to be in byte format for transporting and storage,\n     * this method takes care of that.\n     *\n     * Each object is responsible for transforming itself to byte format since the\n     * structure of methods may differ.\n     *\n     * @return The content in byte format\n     */\n    public byte[] toSerializedForm();\n\n    /**\n     * Given the Content in byte format, read it\n     *\n     * @param data The object in byte format\n     *\n     * @return A new object from the given\n     */\n    public KadContent fromSerializedForm(byte[] data);\n}\nsrc/kademlia/util/serializer/JsonRoutingTableSerializer.java\npublic class JsonRoutingTableSerializer implements KadSerializer<KademliaRoutingTable>\n{\n\n    private final Gson gson;\n\n    Type contactCollectionType = new TypeToken<List<Contact>>()\n    {\n    }.getType();\n\n    private final KadConfiguration config;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    /**\n     * Initialize the class\n     *\n     * @param config\n     */\n    public JsonRoutingTableSerializer(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    @Override\n    public void write(KademliaRoutingTable data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic JKademliaRoutingTable */\n            gson.toJson(data, JKademliaRoutingTable.class, writer);\n\n            /* Now Store the Contacts  */\n            gson.toJson(data.getAllContacts(), contactCollectionType, writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public KademliaRoutingTable read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic JKademliaRoutingTable */\n            KademliaRoutingTable tbl = gson.fromJson(reader, KademliaRoutingTable.class);\n            tbl.setConfiguration(config);\n            \n            /* Now get the Contacts and add them back to the JKademliaRoutingTable */\n            List<Contact> contacts = gson.fromJson(reader, contactCollectionType);\n            tbl.initialize();\n\n            for (Contact c : contacts)\n            {\n                tbl.insert(c);\n            }\n\n            reader.endArray();\n            /* Read and return the Content*/\n            return tbl;\n        }\n    }\n}\nsrc/kademlia/operation/ConnectOperation.java\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final Node bootstrapNode;\n    private final KadConfiguration config;\n\n    private boolean error;\n    private int attempts;\n\n    /**\n     * @param server    The message server used to send/receive messages\n     * @param local     The local node\n     * @param bootstrap Node to use to bootstrap the local node onto the network\n     * @param config\n     */\n    public ConnectOperation(KadServer server, KademliaNode local, Node bootstrap, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = local;\n        this.bootstrapNode = bootstrap;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        try\n        {\n            /* Contact the bootstrap node */\n            this.error = true;\n            this.attempts = 0;\n            Message m = new ConnectMessage(this.localNode.getNode());\n\n            /* Send a connect message to the bootstrap node */\n            server.sendMessage(this.bootstrapNode, m, this);\n\n            /* If we haven't finished as yet, wait for a maximum of config.operationTimeout() time */\n            int totalTimeWaited = 0;\n            int timeInterval = 50;     // We re-check every 300 milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (error)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            if (error)\n            {\n                /* If we still haven't received any responses by then, do a routing timeout */\n                throw new RoutingException(\"ConnectOperation: Bootstrap node did not respond: \" + bootstrapNode);\n            }\n\n            /* Perform lookup for our own ID to get nodes close to us */\n            Operation lookup = new NodeLookupOperation(this.server, this.localNode, this.localNode.getNode().getNodeId(), this.config);\n            lookup.execute();\n\n            /**\n             * Refresh buckets to get a good routing table\n             * After the above lookup operation, K nodes will be in our routing table,\n             * Now we try to populate all of our buckets.\n             */\n            new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n        }\n        catch (InterruptedException e)\n        {\n            System.err.println(\"Connect operation was interrupted. \");\n        }\n    }\n\n    /**\n     * Receives an AcknowledgeMessage from the bootstrap node.\n     *\n     * @param comm\n     */\n    @Override\n    public synchronized void receive(Message incoming, int comm)\n    {\n        /* The incoming message will be an acknowledgement message */\n        AcknowledgeMessage msg = (AcknowledgeMessage) incoming;\n\n        /* The bootstrap node has responded, insert it into our space */\n        this.localNode.getRoutingTable().insert(this.bootstrapNode);\n\n        /* We got a response, so the error is false */\n        error = false;\n\n        /* Wake up any waiting thread */\n        notify();\n    }\n\n    /**\n     * Resends a ConnectMessage to the boot strap node a maximum of MAX_ATTEMPTS\n     * times.\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        if (++this.attempts < MAX_CONNECT_ATTEMPTS)\n        {\n            this.server.sendMessage(this.bootstrapNode, new ConnectMessage(this.localNode.getNode()), this);\n        }\n        else\n        {\n            /* We just exit, so notify all other threads that are possibly waiting */\n            notify();\n        }\n    }\n}\nsrc/kademlia/dht/KademliaStorageEntry.java\npublic interface KademliaStorageEntry\n{\n\n    /**\n     * Add the content to the storage entry\n     *\n     * @param data The content data in byte[] format\n     */\n    public void setContent(final byte[] data);\n\n    /**\n     * Get the content from this storage entry\n     *\n     * @return The content in byte format\n     */\n    public byte[] getContent();\n\n    /**\n     * Get the metadata for this storage entry\n     *\n     * @return the storage entry metadata\n     */\n    public KademliaStorageEntryMetadata getContentMetadata();\n}\nsrc/kademlia/message/MessageFactory.java\npublic class MessageFactory implements KademliaMessageFactory\n{\n\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public MessageFactory(KademliaNode local, KademliaDHT dht, KadConfiguration config)\n    {\n        this.localNode = local;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public Message createMessage(byte code, DataInputStream in) throws IOException\n    {\n        switch (code)\n        {\n            case AcknowledgeMessage.CODE:\n                return new AcknowledgeMessage(in);\n            case ConnectMessage.CODE:\n                return new ConnectMessage(in);\n            case ContentMessage.CODE:\n                return new ContentMessage(in);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupMessage(in);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupMessage(in);\n            case NodeReplyMessage.CODE:\n                return new NodeReplyMessage(in);\n            case SimpleMessage.CODE:\n                return new SimpleMessage(in);\n            case StoreContentMessage.CODE:\n                return new StoreContentMessage(in);\n            default:\n                //System.out.println(this.localNode + \" - No Message handler found for message. Code: \" + code);\n                return new SimpleMessage(in);\n\n        }\n    }\n\n    @Override\n    public Receiver createReceiver(byte code, KadServer server)\n    {\n        switch (code)\n        {\n            case ConnectMessage.CODE:\n                return new ConnectReceiver(server, this.localNode);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupReceiver(server, this.localNode, this.dht, this.config);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupReceiver(server, this.localNode, this.config);\n            case StoreContentMessage.CODE:\n                return new StoreContentReceiver(server, this.localNode, this.dht);\n            default:\n                //System.out.println(\"No receiver found for message. Code: \" + code);\n                return new SimpleReceiver();\n        }\n    }\n}\nsrc/kademlia/util/serializer/JsonSerializer.java\npublic class JsonSerializer<T> implements KadSerializer<T>\n{\n\n    private final Gson gson;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    @Override\n    public void write(T data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Store the content type */\n            gson.toJson(data.getClass().getName(), String.class, writer);\n\n            /* Now Store the content */\n            gson.toJson(data, data.getClass(), writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public T read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the class name */\n            String className = gson.fromJson(reader, String.class);\n\n            /* Read and return the Content*/\n            T ret = gson.fromJson(reader, Class.forName(className));\n            \n            reader.endArray();\n            \n            return ret;\n        }\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/node/KademliaId.java\npublic class KademliaId implements Streamable, Serializable\n{\n\n    public final transient static int ID_LENGTH = 160;\n    private byte[] keyBytes;\n\n    /**\n     * Construct the NodeId from some string\n     *\n     * @param data The user generated key string\n     */\n    public KademliaId(String data)\n    {\n        keyBytes = data.getBytes();\n        if (keyBytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long.\");\n        }\n    }\n\n    /**\n     * Generate a random key\n     */\n    public KademliaId()\n    {\n        keyBytes = new byte[ID_LENGTH / 8];\n        new Random().nextBytes(keyBytes);\n    }\n\n    /**\n     * Generate the NodeId from a given byte[]\n     *\n     * @param bytes\n     */\n    public KademliaId(byte[] bytes)\n    {\n        if (bytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long. Data Given: '\" + new String(bytes) + \"'\");\n        }\n        this.keyBytes = bytes;\n    }\n\n    /**\n     * Load the NodeId from a DataInput stream\n     *\n     * @param in The stream from which to load the NodeId\n     *\n     * @throws IOException\n     */\n    public KademliaId(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    public byte[] getBytes()\n    {\n        return this.keyBytes;\n    }\n\n    /**\n     * @return The BigInteger representation of the key\n     */\n    public BigInteger getInt()\n    {\n        return new BigInteger(1, this.getBytes());\n    }\n\n    /**\n     * Compares a NodeId to this NodeId\n     *\n     * @param o The NodeId to compare to this NodeId\n     *\n     * @return boolean Whether the 2 NodeIds are equal\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof KademliaId)\n        {\n            KademliaId nid = (KademliaId) o;\n            return this.hashCode() == nid.hashCode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 7;\n        hash = 83 * hash + Arrays.hashCode(this.keyBytes);\n        return hash;\n    }\n\n    /**\n     * Checks the distance between this and another NodeId\n     *\n     * @param nid\n     *\n     * @return The distance of this NodeId from the given NodeId\n     */\n    public KademliaId xor(KademliaId nid)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n        byte[] nidBytes = nid.getBytes();\n\n        for (int i = 0; i < ID_LENGTH / 8; i++)\n        {\n            result[i] = (byte) (this.keyBytes[i] ^ nidBytes[i]);\n        }\n\n        KademliaId resNid = new KademliaId(result);\n\n        return resNid;\n    }\n\n    /**\n     * Generates a NodeId that is some distance away from this NodeId\n     *\n     * @param distance in number of bits\n     *\n     * @return NodeId The newly generated NodeId\n     */\n    public KademliaId generateNodeIdByDistance(int distance)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n\n        /* Since distance = ID_LENGTH - prefixLength, we need to fill that amount with 0's */\n        int numByteZeroes = (ID_LENGTH - distance) / 8;\n        int numBitZeroes = 8 - (distance % 8);\n\n        /* Filling byte zeroes */\n        for (int i = 0; i < numByteZeroes; i++)\n        {\n            result[i] = 0;\n        }\n\n        /* Filling bit zeroes */\n        BitSet bits = new BitSet(8);\n        bits.set(0, 8);\n\n        for (int i = 0; i < numBitZeroes; i++)\n        {\n            /* Shift 1 zero into the start of the value */\n            bits.clear(i);\n        }\n        bits.flip(0, 8);        // Flip the bits since they're in reverse order\n        result[numByteZeroes] = (byte) bits.toByteArray()[0];\n\n        /* Set the remaining bytes to Maximum value */\n        for (int i = numByteZeroes + 1; i < result.length; i++)\n        {\n            result[i] = Byte.MAX_VALUE;\n        }\n\n        return this.xor(new KademliaId(result));\n    }\n\n    /**\n     * Counts the number of leading 0's in this NodeId\n     *\n     * @return Integer The number of leading 0's\n     */\n    public int getFirstSetBitIndex()\n    {\n        int prefixLength = 0;\n\n        for (byte b : this.keyBytes)\n        {\n            if (b == 0)\n            {\n                prefixLength += 8;\n            }\n            else\n            {\n                /* If the byte is not 0, we need to count how many MSBs are 0 */\n                int count = 0;\n                for (int i = 7; i >= 0; i--)\n                {\n                    boolean a = (b & (1 << i)) == 0;\n                    if (a)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        break;   // Reset the count if we encounter a non-zero number\n                    }\n                }\n\n                /* Add the count of MSB 0s to the prefix length */\n                prefixLength += count;\n\n                /* Break here since we've now covered the MSB 0s */\n                break;\n            }\n        }\n        return prefixLength;\n    }\n\n    /**\n     * Gets the distance from this NodeId to another NodeId\n     *\n     * @param to\n     *\n     * @return Integer The distance\n     */\n    public int getDistance(KademliaId to)\n    {\n        /**\n         * Compute the xor of this and to\n         * Get the index i of the first set bit of the xor returned NodeId\n         * The distance between them is ID_LENGTH - i\n         */\n        return ID_LENGTH - this.xor(to).getFirstSetBitIndex();\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        out.write(this.getBytes());\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        byte[] input = new byte[ID_LENGTH / 8];\n        in.readFully(input);\n        this.keyBytes = input;\n    }\n\n    public String hexRepresentation()\n    {\n        /* Returns the hex format of this NodeId */\n        BigInteger bi = new BigInteger(1, this.keyBytes);\n        return String.format(\"%0\" + (this.keyBytes.length << 1) + \"X\", bi);\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hexRepresentation();\n    }\n\n}\nsrc/kademlia/dht/KademliaDHT.java\npublic interface KademliaDHT\n{\n\n    /**\n     * Initialize this DHT to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Set a new configuration. Mainly used when we restore the DHT state from a file\n     *\n     * @param con The new configuration file\n     */\n    public void setConfiguration(KadConfiguration con);\n\n    /**\n     * Creates a new Serializer or returns an existing serializer\n     *\n     * @return The new ContentSerializer\n     */\n    public KadSerializer<JKademliaStorageEntry> getSerializer();\n\n    /**\n     * Handle storing content locally\n     *\n     * @param content The DHT content to store\n     *\n     * @return boolean true if we stored the content, false if the content already exists and is up to date\n     *\n     * @throws java.io.IOException\n     */\n    public boolean store(JKademliaStorageEntry content) throws IOException;\n\n    public boolean store(KadContent content) throws IOException;\n\n    /**\n     * Retrieves a Content from local storage\n     *\n     * @param key      The Key of the content to retrieve\n     * @param hashCode The hash code of the content to retrieve\n     *\n     * @return A KadContent object\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException;\n\n    /**\n     * Check if any content for the given criteria exists in this DHT\n     *\n     * @param param The content search criteria\n     *\n     * @return boolean Whether any content exist that satisfy the criteria\n     */\n    public boolean contains(GetParameter param);\n\n    /**\n     * Retrieve and create a KadContent object given the StorageEntry object\n     *\n     * @param entry The StorageEntry used to retrieve this content\n     *\n     * @return KadContent The content object\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException;\n\n    /**\n     * Get the StorageEntry for the content if any exist.\n     *\n     * @param param The parameters used to filter the content needed\n     *\n     * @return KadContent A KadContent found on the DHT satisfying the given criteria\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException;\n\n    /**\n     * Delete a content from local storage\n     *\n     * @param content The Content to Remove\n     *\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public void remove(KadContent content) throws ContentNotFoundException;\n\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException;\n\n    /**\n     * @return A List of all StorageEntries for this node\n     */\n    public List<KademliaStorageEntryMetadata> getStorageEntries();\n\n    /**\n     * Used to add a list of storage entries for existing content to the DHT.\n     * Mainly used when retrieving StorageEntries from a saved state file.\n     *\n     * @param ientries The entries to add\n     */\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries);\n\n}\nsrc/kademlia/operation/Operation.java\npublic interface Operation\n{\n\n    /**\n     * Starts an operation and returns when the operation is finished\n     *\n     * @throws kademlia.exceptions.RoutingException\n     */\n    public void execute() throws IOException, RoutingException;\n}\nsrc/kademlia/routing/JKademliaRoutingTable.java\npublic class JKademliaRoutingTable implements KademliaRoutingTable\n{\n\n    private final Node localNode;  // The current node\n    private transient KademliaBucket[] buckets;\n\n    private transient KadConfiguration config;\n\n    public JKademliaRoutingTable(Node localNode, KadConfiguration config)\n    {\n        this.localNode = localNode;\n        this.config = config;\n\n        /* Initialize all of the buckets to a specific depth */\n        this.initialize();\n\n        /* Insert the local node */\n        this.insert(localNode);\n    }\n\n    /**\n     * Initialize the JKademliaRoutingTable to it's default state\n     */\n    @Override\n    public final void initialize()\n    {\n        this.buckets = new KademliaBucket[KademliaId.ID_LENGTH];\n        for (int i = 0; i < KademliaId.ID_LENGTH; i++)\n        {\n            buckets[i] = new JKademliaBucket(i, this.config);\n        }\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    @Override\n    public synchronized final void insert(Contact c)\n    {\n        this.buckets[this.getBucketId(c.getNode().getNodeId())].insert(c);\n    }\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    @Override\n    public synchronized final void insert(Node n)\n    {\n        this.buckets[this.getBucketId(n.getNodeId())].insert(n);\n    }\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    @Override\n    public final int getBucketId(KademliaId nid)\n    {\n        int bId = this.localNode.getNodeId().getDistance(nid) - 1;\n\n        /* If we are trying to insert a node into it's own routing table, then the bucket ID will be -1, so let's just keep it in bucket 0 */\n        return bId < 0 ? 0 : bId;\n    }\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    @Override\n    public synchronized final List<Node> findClosest(KademliaId target, int numNodesRequired)\n    {\n        TreeSet<Node> sortedSet = new TreeSet<>(new KeyComparator(target));\n        sortedSet.addAll(this.getAllNodes());\n\n        List<Node> closest = new ArrayList<>(numNodesRequired);\n\n        /* Now we have the sorted set, lets get the top numRequired */\n        int count = 0;\n        for (Node n : sortedSet)\n        {\n            closest.add(n);\n            if (++count == numNodesRequired)\n            {\n                break;\n            }\n        }\n        return closest;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public synchronized final List<Node> getAllNodes()\n    {\n        List<Node> nodes = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            for (Contact c : b.getContacts())\n            {\n                nodes.add(c.getNode());\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public final List<Contact> getAllContacts()\n    {\n        List<Contact> contacts = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            contacts.addAll(b.getContacts());\n        }\n\n        return contacts;\n    }\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    @Override\n    public final KademliaBucket[] getBuckets()\n    {\n        return this.buckets;\n    }\n\n    /**\n     * Set the KadBuckets of this routing table, mainly used when retrieving saved state\n     *\n     * @param buckets\n     */\n    public final void setBuckets(KademliaBucket[] buckets)\n    {\n        this.buckets = buckets;\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    @Override\n    public void setUnresponsiveContacts(List<Node> contacts)\n    {\n        if (contacts.isEmpty())\n        {\n            return;\n        }\n        for (Node n : contacts)\n        {\n            this.setUnresponsiveContact(n);\n        }\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    @Override\n    public synchronized void setUnresponsiveContact(Node n)\n    {\n        int bucketId = this.getBucketId(n.getNodeId());\n\n        /* Remove the contact from the bucket */\n        this.buckets[bucketId].removeNode(n);\n    }\n\n    @Override\n    public synchronized final String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\nPrinting Routing Table Started ***************** \\n\");\n        int totalContacts = 0;\n        for (KademliaBucket b : this.buckets)\n        {\n            if (b.numContacts() > 0)\n            {\n                totalContacts += b.numContacts();\n                sb.append(\"# nodes in Bucket with depth \");\n                sb.append(b.getDepth());\n                sb.append(\": \");\n                sb.append(b.numContacts());\n                sb.append(\"\\n\");\n                sb.append(b.toString());\n                sb.append(\"\\n\");\n            }\n        }\n\n        sb.append(\"\\nTotal Contacts: \");\n        sb.append(totalContacts);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"Printing Routing Table Ended ******************** \");\n\n        return sb.toString();\n    }\n\n}\nsrc/kademlia/util/serializer/JsonDHTSerializer.java\npublic class JsonDHTSerializer implements KadSerializer<KademliaDHT>\n{\n\n    private final Gson gson;\n    private final Type storageEntriesCollectionType;\n\n    \n    {\n        gson = new Gson();\n\n        storageEntriesCollectionType = new TypeToken<List<KademliaStorageEntryMetadata>>()\n        {\n        }.getType();\n    }\n\n    @Override\n    public void write(KademliaDHT data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic DHT */\n            gson.toJson(data, DHT.class, writer);\n\n            /* Now Store the Entries  */\n            gson.toJson(data.getStorageEntries(), this.storageEntriesCollectionType, writer);\n\n            writer.endArray();\n        }\n\n    }\n\n    @Override\n    public KademliaDHT read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic DHT */\n            DHT dht = gson.fromJson(reader, DHT.class);\n            dht.initialize();\n\n            /* Now get the entries and add them back to the DHT */\n            List<KademliaStorageEntryMetadata> entries = gson.fromJson(reader, this.storageEntriesCollectionType);\n            dht.putStorageEntries(entries);\n\n            reader.endArray();\n            return dht;\n        }\n    }\n}\nsrc/kademlia/exceptions/ContentNotFoundException.java\npublic class ContentNotFoundException extends Exception\n{\n\n    public ContentNotFoundException()\n    {\n        super();\n    }\n\n    public ContentNotFoundException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/dht/GetParameter.java\npublic class GetParameter\n{\n\n    private KademliaId key;\n    private String ownerId = null;\n    private String type = null;\n\n    /**\n     * Construct a GetParameter to search for data by NodeId and owner\n     *\n     * @param key\n     * @param type\n     */\n    public GetParameter(KademliaId key, String type)\n    {\n        this.key = key;\n        this.type = type;\n    }\n\n    /**\n     * Construct a GetParameter to search for data by NodeId, owner, type\n     *\n     * @param key\n     * @param type\n     * @param owner\n     */\n    public GetParameter(KademliaId key, String type, String owner)\n    {\n        this(key, type);\n        this.ownerId = owner;\n    }\n\n    /**\n     * Construct our get parameter from a Content\n     *\n     * @param c\n     */\n    public GetParameter(KadContent c)\n    {\n        this.key = c.getKey();\n\n        if (c.getType() != null)\n        {\n            this.type = c.getType();\n        }\n\n        if (c.getOwnerId() != null)\n        {\n            this.ownerId = c.getOwnerId();\n        }\n    }\n\n    /**\n     * Construct our get parameter from a StorageEntryMeta data\n     *\n     * @param md\n     */\n    public GetParameter(KademliaStorageEntryMetadata md)\n    {\n        this.key = md.getKey();\n\n        if (md.getType() != null)\n        {\n            this.type = md.getType();\n        }\n\n        if (md.getOwnerId() != null)\n        {\n            this.ownerId = md.getOwnerId();\n        }\n    }\n\n    public KademliaId getKey()\n    {\n        return this.key;\n    }\n\n    public void setOwnerId(String ownerId)\n    {\n        this.ownerId = ownerId;\n    }\n\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    public void setType(String type)\n    {\n        this.type = type;\n    }\n\n    public String getType()\n    {\n        return this.type;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"GetParameter - [Key: \" + key + \"][Owner: \" + this.ownerId + \"][Type: \" + this.type + \"]\";\n    }\n}\nsrc/kademlia/operation/ContentLookupOperation.java\npublic class ContentLookupOperation implements Operation, Receiver\n{\n\n    /* Constants */\n    private static final Byte UNASKED = (byte) 0x00;\n    private static final Byte AWAITING = (byte) 0x01;\n    private static final Byte ASKED = (byte) 0x02;\n    private static final Byte FAILED = (byte) 0x03;\n\n    private final KadServer server;\n    private final JKademliaNode localNode;\n    private JKademliaStorageEntry contentFound = null;\n    private final KadConfiguration config;\n\n    private final ContentLookupMessage lookupMessage;\n\n    private boolean isContentFound;\n    private final SortedMap<Node, Byte> nodes;\n\n    /* Tracks messages in transit and awaiting reply */\n    private final Map<Integer, Node> messagesTransiting;\n\n    /* Used to sort nodes */\n    private final Comparator comparator;\n\n    /* Statistical information */\n    private final RouteLengthChecker routeLengthChecker;\n\n    \n    {\n        messagesTransiting = new HashMap<>();\n        isContentFound = false;\n        routeLengthChecker = new RouteLengthChecker();\n    }\n\n    /**\n     * @param server\n     * @param localNode\n     * @param params    The parameters to search for the content which we need to find\n     * @param config\n     */\n    public ContentLookupOperation(KadServer server, JKademliaNode localNode, GetParameter params, KadConfiguration config)\n    {\n        /* Construct our lookup message */\n        this.lookupMessage = new ContentLookupMessage(localNode.getNode(), params);\n\n        this.server = server;\n        this.localNode = localNode;\n        this.config = config;\n\n        /**\n         * We initialize a TreeMap to store nodes.\n         * This map will be sorted by which nodes are closest to the lookupId\n         */\n        this.comparator = new KeyComparator(params.getKey());\n        this.nodes = new TreeMap(this.comparator);\n    }\n\n    /**\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.RoutingException\n     */\n    @Override\n    public synchronized void execute() throws IOException, RoutingException\n    {\n        try\n        {\n            /* Set the local node as already asked */\n            nodes.put(this.localNode.getNode(), ASKED);\n\n            /**\n             * We add all nodes here instead of the K-Closest because there may be the case that the K-Closest are offline\n             * - The operation takes care of looking at the K-Closest.\n             */\n            List<Node> allNodes = this.localNode.getRoutingTable().getAllNodes();\n            this.addNodes(allNodes);\n            \n            /* Also add the initial set of nodes to the routeLengthChecker */\n            this.routeLengthChecker.addInitialNodes(allNodes);\n\n            /**\n             * If we haven't found the requested amount of content as yet,\n             * keey trying until config.operationTimeout() time has expired\n             */\n            int totalTimeWaited = 0;\n            int timeInterval = 10;     // We re-check every n milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (!this.askNodesorFinish() && !isContentFound)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add nodes from this list to the set of nodes to lookup\n     *\n     * @param list The list from which to add nodes\n     */\n    public void addNodes(List<Node> list)\n    {\n        for (Node o : list)\n        {\n            /* If this node is not in the list, add the node */\n            if (!nodes.containsKey(o))\n            {\n                nodes.put(o, UNASKED);\n            }\n        }\n    }\n\n    /**\n     * Asks some of the K closest nodes seen but not yet queried.\n     * Assures that no more than DefaultConfiguration.CONCURRENCY messages are in transit at a time\n     *\n     * This method should be called every time a reply is received or a timeout occurs.\n     *\n     * If all K closest nodes have been asked and there are no messages in transit,\n     * the algorithm is finished.\n     *\n     * @return <code>true</code> if finished OR <code>false</code> otherwise\n     */\n    private boolean askNodesorFinish() throws IOException\n    {\n        /* If >= CONCURRENCY nodes are in transit, don't do anything */\n        if (this.config.maxConcurrentMessagesTransiting() <= this.messagesTransiting.size())\n        {\n            return false;\n        }\n\n        /* Get unqueried nodes among the K closest seen that have not FAILED */\n        List<Node> unasked = this.closestNodesNotFailed(UNASKED);\n\n        if (unasked.isEmpty() && this.messagesTransiting.isEmpty())\n        {\n            /* We have no unasked nodes nor any messages in transit, we're finished! */\n            return true;\n        }\n\n        /* Sort nodes according to criteria */\n        Collections.sort(unasked, this.comparator);\n\n        /**\n         * Send messages to nodes in the list;\n         * making sure than no more than CONCURRENCY messsages are in transit\n         */\n        for (int i = 0; (this.messagesTransiting.size() < this.config.maxConcurrentMessagesTransiting()) && (i < unasked.size()); i++)\n        {\n            Node n = (Node) unasked.get(i);\n\n            int comm = server.sendMessage(n, lookupMessage, this);\n\n            this.nodes.put(n, AWAITING);\n            this.messagesTransiting.put(comm, n);\n        }\n\n        /* We're not finished as yet, return false */\n        return false;\n    }\n\n    /**\n     * Find The K closest nodes to the target lookupId given that have not FAILED.\n     * From those K, get those that have the specified status\n     *\n     * @param status The status of the nodes to return\n     *\n     * @return A List of the closest nodes\n     */\n    private List<Node> closestNodesNotFailed(Byte status)\n    {\n        List<Node> closestNodes = new ArrayList<>(this.config.k());\n        int remainingSpaces = this.config.k();\n\n        for (Map.Entry e : this.nodes.entrySet())\n        {\n            if (!FAILED.equals(e.getValue()))\n            {\n                if (status.equals(e.getValue()))\n                {\n                    /* We got one with the required status, now add it */\n                    closestNodes.add((Node) e.getKey());\n                }\n\n                if (--remainingSpaces == 0)\n                {\n                    break;\n                }\n            }\n        }\n\n        return closestNodes;\n    }\n\n    @Override\n    public synchronized void receive(Message incoming, int comm) throws IOException, RoutingException\n    {\n        if (this.isContentFound)\n        {\n            return;\n        }\n\n        if (incoming instanceof ContentMessage)\n        {\n            /* The reply received is a content message with the required content, take it in */\n            ContentMessage msg = (ContentMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            this.localNode.getRoutingTable().insert(msg.getOrigin());\n\n            /* Get the Content and check if it satisfies the required parameters */\n            JKademliaStorageEntry content = msg.getContent();\n            this.contentFound = content;\n            this.isContentFound = true;\n        }\n        else\n        {\n            /* The reply received is a NodeReplyMessage with nodes closest to the content needed */\n            NodeReplyMessage msg = (NodeReplyMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            Node origin = msg.getOrigin();\n            this.localNode.getRoutingTable().insert(origin);\n\n            /* Set that we've completed ASKing the origin node */\n            this.nodes.put(origin, ASKED);\n\n            /* Remove this msg from messagesTransiting since it's completed now */\n            this.messagesTransiting.remove(comm);\n            \n            /* Add the received nodes to the routeLengthChecker */\n            this.routeLengthChecker.addNodes(msg.getNodes(), origin);\n\n            /* Add the received nodes to our nodes list to query */\n            this.addNodes(msg.getNodes());\n            this.askNodesorFinish();\n        }\n    }\n\n    /**\n     * A node does not respond or a packet was lost, we set this node as failed\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        /* Get the node associated with this communication */\n        Node n = this.messagesTransiting.get(new Integer(comm));\n\n        if (n == null)\n        {\n            throw new UnknownMessageException(\"Unknown comm: \" + comm);\n        }\n\n        /* Mark this node as failed and inform the routing table that it's unresponsive */\n        this.nodes.put(n, FAILED);\n        this.localNode.getRoutingTable().setUnresponsiveContact(n);\n        this.messagesTransiting.remove(comm);\n\n        this.askNodesorFinish();\n    }\n    \n    /**\n     * @return Whether the content was found or not.\n     */\n    public boolean isContentFound()\n    {\n        return this.isContentFound;\n    }\n\n    /**\n     * @return The list of all content found during the lookup operation\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry getContentFound() throws ContentNotFoundException\n    {\n        if (this.isContentFound)\n        {\n            return this.contentFound;\n        }\n        else\n        {\n            throw new ContentNotFoundException(\"No Value was found for the given key.\");\n        }\n    }\n\n    /**\n     * @return How many hops it took in order to get to the content.\n     */\n    public int routeLength()\n    {\n        return this.routeLengthChecker.getRouteLength();\n    }\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\n", "answers": ["    private transient KademliaRoutingTable routingTable;"], "pred": "  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht", "length": 6425, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "03b9c503110e4dc8f2d7690f56be9e9b2733744da1a855ff"}
{"prompt": "Please complete the code given below. \nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nimport android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;\n    private ImmersiveTouchNavigation mImmersiveTouchNavigation;\n\n    public EffectManager(Activity activity, int parameterListViewId, SpectaculumView glView) {\n        mActivity = activity;\n        mParameterListView = (ViewGroup) activity.findViewById(parameterListViewId);\n        mSpectaculumView = glView;\n        mEffects = new ArrayList<>();\n        mSpectaculumView.setEffectEventListener(this);\n\n        // Spectaculum-Core filtersNext line of code:\n", "input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;\n    private ImmersiveTouchNavigation mImmersiveTouchNavigation;\n\n    public EffectManager(Activity activity, int parameterListViewId, SpectaculumView glView) {\n        mActivity = activity;\n        mParameterListView = (ViewGroup) activity.findViewById(parameterListViewId);\n        mSpectaculumView = glView;\n        mEffects = new ArrayList<>();\n        mSpectaculumView.setEffectEventListener(this);\n\n        // Spectaculum-Core filters", "context": "Spectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\n", "answers": ["        mEffects.add(new NoEffect());"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 8194, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cb75af27199120a4d11be40c2968da895ebd2e8795dfc692"}
{"prompt": "Please complete the code given below. \narxpy/differential/characteristic.py\nclass RelatedKeyCh(object):\n    \"\"\"Represent related-key characteristics of block ciphers.\n\n    A related-key characteristic of a `Cipher` is a pair `BvCharacteristic`,\n    one over the `KeySchedule` of the cipher, and another one over the\n    the `Encryption` function of the cipher, where the output differences\n    of the key schedule characteristic are used as round key differences\n    in the encryption characteristic.\n\n    The master key differences start with the prefix ``\"dmk\"``,\n    the round key differences start with the prefix ``\"dk\"``,\n    the plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import RelatedKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives.lea import LeaCipher\n        >>> issubclass(LeaCipher, Cipher)\n        True\n        >>> LeaCipher.set_rounds(1)\n        >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n        >>> rkch .key_schedule_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dmk0, dmk1, dmk2, dmk3),\n        'output_vars': (dk1, dk3, dk5, dk3, dk7, dk3),\n        'assignments': ((dk0, 0xc3efe9db + dmk0), (dk1, dk0 <<< 1), (dk2, 0x87dfd3b7 + dmk1), (dk3, dk2 <<< 3),\n        (dk4, 0x0fbfa76f + dmk2), (dk5, dk4 <<< 6), (dk6, 0x1f7f4ede + dmk3), (dk7, dk6 <<< 11))}\n        >>> rkch.key_schedule_ch.input_diff\n        (XorDiff(dmk0), XorDiff(dmk1), XorDiff(dmk2), XorDiff(dmk3))\n        >>> rkch.key_schedule_ch.output_diff  # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dk1), XorDiff(dk0 <<< 1)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk5), XorDiff(dk4 <<< 6)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk7), XorDiff(dk6 <<< 11)], [XorDiff(dk3), XorDiff(dk2 <<< 3)]]\n        >>> rkch.key_schedule_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dk0), XDCA_0xc3efe9db(XorDiff(dmk0))),\n        (XorDiff(dk2), XDCA_0x87dfd3b7(XorDiff(dmk1))),\n        (XorDiff(dk4), XDCA_0x0fbfa76f(XorDiff(dmk2))),\n        (XorDiff(dk6), XDCA_0x1f7f4ede(XorDiff(dmk3)))])\n        >>> rkch.encryption_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1, dp2, dp3),\n        'output_vars': (dx3, dx7, dx11, dp0),\n        'assignments': ((dx0, dk1 ^ dp0), (dx1, dk3 ^ dp1), (dx2, dx0 + dx1), (dx3, dx2 <<< 9),\n        (dx4, dk5 ^ dp1), (dx5, dk3 ^ dp2), (dx6, dx4 + dx5), (dx7, dx6 >>> 5), (dx8, dk7 ^ dp2),\n        (dx9, dk3 ^ dp3), (dx10, dx8 + dx9), (dx11, dx10 >>> 3))}\n        >>> rkch.encryption_ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1), XorDiff(dp2), XorDiff(dp3))\n        >>> rkch.encryption_ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dx3), XorDiff(dx2 <<< 9)], [XorDiff(dx7), XorDiff(dx6 >>> 5)],\n        [XorDiff(dx11), XorDiff(dx10 >>> 3)], [XorDiff(dp0), XorDiff(dp0)]]\n        >>> rkch.encryption_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dx2), XDA(XorDiff(dp0 ^ (dk0 <<< 1)), XorDiff(dp1 ^ (dk2 <<< 3)))),\n        (XorDiff(dx6), XDA(XorDiff(dp1 ^ (dk4 <<< 6)), XorDiff(dp2 ^ (dk2 <<< 3)))),\n        (XorDiff(dx10), XDA(XorDiff(dp2 ^ (dk6 <<< 11)), XorDiff(dp3 ^ (dk2 <<< 3))))])\n\n    Attributes:\n        key_schedule_ch: the `BvCharacteristic` over the key schedule\n        encryption_ch: the `BvCharacteristic` over the encryption function\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        func = bv_cipher.key_schedule\n        prefix = \"dk\"\n        input_diff_names = tuple([\"dmk\" + str(i) for i in range(len(func.input_widths))])\n        ks_ch = BvCharacteristic(func, diff_type, input_diff_names, prefix)\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = ks_ch.ssa[\"output_vars\"]\n\n        func = Encryption\n        prefix = \"dx\"\n        input_diff_names = [\"dp\" + str(i) for i in range(len(func.input_widths))]\n        round_key_diff = {}\n        for var, diff in ks_ch.output_diff:\n            round_key_diff[var.val] = diff\n        encryption_ch = BvCharacteristic(func, diff_type, input_diff_names,\n                                         prefix, round_key_diff)\n\n        self.diff_type = diff_type\n        self.key_schedule_ch = ks_ch\n        self.encryption_ch = encryption_ch\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n        \"\"\"Return the empirical weight of a given differential for multiple keys.\n\n        This method returns the differential probability weight for the\n        key schedule characteristic (see `BvCharacteristic.empirical_weight`)\n        and the `collections.Counter` storing the distribution of weights for the encryption\n        characteristic (see `SingleKeyCh.empirical_weight`).\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> kid, kod = [zero]*4, [zero]*6\n            >>> eid, eod = [zero]*4, [zero]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (0.0, Counter({0.0: 10}))\n            >>> kid, kod = [zero]*4, [one]*6\n            >>> eid, eod = [zero]*4, [one]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (inf, Counter({inf: 10}))\n\n        \"\"\"\n        key_weight = self.key_schedule_ch.empirical_weight(key_input_diff, key_output_diff, key_samples)\n        # noinspection PyProtectedMember\n        enc_counter = self.encryption_ch._empirical_weight_distribution(self._cipher,\n                                                                        enc_input_diff, enc_output_diff, enc_samples,\n                                                                        key_samples, precision, key_output_diff)\n        return key_weight, enc_counter\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the related-key characteristic.\n\n        The signature of a related-key characteristic is the\n        concatenation of the key schedule and encryption signatures.\n\n        See also `BvCharacteristic.signature`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh, ChSignatureType\n            >>> from arxpy.primitives.primitives import Cipher\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> rkch.signature(ChSignatureType.Full)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk0, dk2, dk4, dk6, dp0, dp1, dp2, dp3, dx2, dx6, dx10]\n            >>> rkch.signature(ChSignatureType.InputOutput)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk1, dk3, dk5, dk3, dk7, dk3, dp0, dp1, dp2, dp3, dx3, dx7, dx11]\n\n        \"\"\"\n        return self.key_schedule_ch.signature(ch_signature_type) + self.encryption_ch.signature(ch_signature_type)\n\n    def _to_dict(self):\n        dict_ch = {\n            \"key_schedule_ch\": self.key_schedule_ch._to_dict(),\n            \"encryption_ch\": self.encryption_ch._to_dict(),\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/differential/difference.py\nclass XorDiff(Difference):\n    \"\"\"Represent XOR differences.\n\n    The XOR difference of two `Term` is given by the XOR\n    of the terms. In other words, the *difference operation*\n    of `XorDiff` is the `BvXor` (see `Difference`).\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b010, 3), Constant(0b101, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b111)\n        >>> alpha.get_pair_element(x)\n        0b101\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = XorDiff.from_pair(k, k)\n        >>> alpha\n        XorDiff(0x00)\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = operation.BvXor\n    inv_diff_op = operation.BvXor\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft, BvSub\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import XorDiff\n            >>> d1, d2 = XorDiff(Variable(\"d1\", 8)), XorDiff(Variable(\"d2\", 8))\n            >>> XorDiff.derivative(BvXor, [d1, d2])\n            XorDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(Xor1, d1)\n            XorDiff(d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> XorDiff.derivative(Rotate1, d1)\n            XorDiff(d1 <<< 1)\n            >>> XorDiff.derivative(BvAdd, [d1, d2])\n            XDA(XorDiff(d1), XorDiff(d2))\n            >>> XorDiff.derivative(BvSub, [d1, d2])\n            XDS(XorDiff(d1), XorDiff(d2))\n            >>> CteAdd1 = make_partial_operation(BvAdd, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(CteAdd1, d1)\n            XDCA_0x01(XorDiff(d1))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.Concat:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.XDA(input_diff)\n\n        if op == operation.BvSub:\n            from arxpy.differential import derivative\n            return derivative.XDS(input_diff)\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAnd:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                if isinstance(val, core.Constant):\n                    return cls(op.base_op(d1.val, val))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op in [operation.BvShl, operation.BvLshr]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Extract:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None and op.fixed_args[2] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1], op.fixed_args[2]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Concat:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                if op.fixed_args[0] is not None:\n                    val = op.fixed_args[0]\n                    input_diff = [cls.from_pair(val, val), d1]\n                else:\n                    val = op.fixed_args[1]\n                    input_diff = [d1, cls.from_pair(val, val)]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAdd:\n                assert len(input_diff) == 1\n                d = input_diff[0]\n                cte = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                from arxpy.differential import derivative\n                return derivative.XDCA(d, cte)\n            else:\n                raise ValueError(msg)\n\n        if hasattr(op, \"xor_derivative\"):\n            return op.xor_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\narxpy/differential/characteristic.py\nclass BvCharacteristic(object):\n    \"\"\"Represent characteristics of bit-vector functions.\n\n    Given a bit-vector function `BvFunction` :math:`f`,\n    a characteristic is a trail of differences obtained by\n    propagating an input difference over :math:`f`.\n\n    In particular, a characteristic is composed of the\n    input difference and the output difference of each\n    non-linear operation.\n\n    This class manages symbolic characteristics,\n    where the input difference is given symbolically\n    and the intermediate differences are `Term`\n    that depend on the input difference.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff, RXDiff\n        >>> from arxpy.differential.characteristic import BvCharacteristic\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi.set_rounds(1)\n        >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dv0, dv1, dv2, dv3),\n        'output_vars': (d7, d12, d13, d9),\n        'assignments': ((d0, dv0 + dv1), (d1, dv1 <<< 5), (d2, d0 ^ d1), (d3, d0 <<< 16), (d4, dv2 + dv3),\n        (d5, dv3 <<< 8), (d6, d4 ^ d5), (d7, d3 + d6), (d8, d6 <<< 13), (d9, d7 ^ d8), (d10, d2 + d4),\n        (d11, d2 <<< 7), (d12, d10 ^ d11), (d13, d10 <<< 16))}\n        >>> ch.input_diff\n        (XorDiff(dv0), XorDiff(dv1), XorDiff(dv2), XorDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(d0), XDA(XorDiff(dv0), XorDiff(dv1))),\n        (XorDiff(d4), XDA(XorDiff(dv2), XorDiff(dv3))),\n        (XorDiff(d7), XDA(XorDiff(d0 <<< 16), XorDiff(d4 ^ (dv3 <<< 8)))),\n        (XorDiff(d10), XDA(XorDiff(d0 ^ (dv1 <<< 5)), XorDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(d7), XorDiff(d7)],\n        [XorDiff(d12), XorDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [XorDiff(d13), XorDiff(d10 <<< 16)],\n        [XorDiff(d9), XorDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n        >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.input_diff\n        (RXDiff(dv0), RXDiff(dv1), RXDiff(dv2), RXDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(RXDiff(d0), RXDA(RXDiff(dv0), RXDiff(dv1))),\n        (RXDiff(d4), RXDA(RXDiff(dv2), RXDiff(dv3))),\n        (RXDiff(d7), RXDA(RXDiff(d0 <<< 16), RXDiff(d4 ^ (dv3 <<< 8)))),\n        (RXDiff(d10), RXDA(RXDiff(d0 ^ (dv1 <<< 5)), RXDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[RXDiff(d7), RXDiff(d7)],\n        [RXDiff(d12), RXDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [RXDiff(d13), RXDiff(d10 <<< 16)],\n        [RXDiff(d9), RXDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n\n    Attributes:\n        func: the `BvFunction`\n        diff_type: the `Difference` of the characteristic\n        input_diff: a list containing the input symbolic differences\n        nonlinear_diffs: an `collections.OrderedDict` mapping non-linear symbolic differences\n            to their corresponding `Derivative`\n        output_diff: a list, where the i-th element is a pair containing\n            the i-th output symbolic difference and its value\n    \"\"\"\n\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n        assert issubclass(func, primitives.BvFunction)\n        assert issubclass(diff_type, difference.Difference)\n\n        assert len(input_diff_names) == len(func.input_widths)\n        input_diff = []\n        for name, width in zip(input_diff_names, func.input_widths):\n            input_diff.append(diff_type(core.Variable(name, width)))\n        input_diff = tuple(input_diff)\n\n        self.func = func\n        self.diff_type = diff_type\n        self.input_diff = input_diff\n\n        # Propagate the input difference through the function\n\n        names = [d.val.name for d in self.input_diff]\n        ssa = self.func.ssa(names, id_prefix=prefix)\n        self.ssa = ssa\n        self._prefix = prefix\n        self._input_diff_names = input_diff_names\n\n        for var in ssa[\"output_vars\"]:\n            if isinstance(var, core.Constant):\n                raise ValueError(\"constant outputs (independent of the inputs) are not supported\")\n\n        var2diff = {}  # Variable to Difference\n        for var, diff in zip(ssa[\"input_vars\"], self.input_diff):\n            var2diff[var] = diff\n\n        if initial_var2diff is not None:\n            for var in initial_var2diff:\n                if str(var) in names:\n                    raise ValueError(\"the input differences cannot be replaced by initial_var2diff\")\n            var2diff.update(initial_var2diff)\n\n        self.nonlinear_diffs = collections.OrderedDict()\n        for var, expr in ssa[\"assignments\"]:\n            expr_args = []\n            for arg in expr.args:\n                if isinstance(arg, int):\n                    expr_args.append(arg)  # 'int' object has no attribute 'xreplace'\n                else:\n                    expr_args.append(arg.xreplace(var2diff))\n\n            if all(not isinstance(arg, diff_type) for arg in expr_args):\n                # symbolic computations with the key\n                var2diff[var] = expr\n                continue\n\n            if all(isinstance(arg, diff_type) for arg in expr_args):\n                der = self.diff_type.derivative(type(expr), expr_args)\n            else:\n                def contains_key_var(term):\n                    from sympy import basic\n                    for sub in basic.preorder_traversal(term):\n                        if sub in func.round_keys:\n                            return True\n                    else:\n                        return False\n\n                if type(expr) == operation.BvAdd and hasattr(func, 'round_keys') and \\\n                        all(isinstance(r, core.Variable) for r in func.round_keys) and \\\n                        any(contains_key_var(a) for a in expr_args):\n                    # temporary solution to Derivative(BvAddCte_k(x)) != Derivative(x + k)\n                    # with x a Diff and k a key variable\n                    keyed_indices = []\n                    for i, a in enumerate(expr_args):\n                        if contains_key_var(a):\n                            keyed_indices.append(i)\n                    if len(keyed_indices) != 1 or expr_args[keyed_indices[0]] not in func.round_keys:\n                        raise NotImplementedError(\"invalid expression: op={}, args={}\".format(\n                            type(expr).__name__, expr_args))\n                    # expr_args[keyed_indices[0]] replaced to the zero diff\n                    zero_diff = diff_type(core.Constant(0, expr_args[keyed_indices[0]].width))\n                    der = self.diff_type.derivative(type(expr), [expr_args[(keyed_indices[0] + 1) % 2], zero_diff])\n                elif hasattr(expr, \"xor_derivative\"):\n                    # temporary solution to operations containing a custom derivative\n                    input_diff_expr = []\n                    for i, arg in enumerate(expr_args):\n                        if isinstance(arg, diff_type):\n                            input_diff_expr.append(arg)\n                        else:\n                            assert isinstance(arg, core.Term)  # int arguments currently not supported\n                            input_diff_expr.append(diff_type.from_pair(arg, arg))\n                    der = self.diff_type.derivative(type(expr), input_diff_expr)\n                else:\n                    fixed_args = []\n                    for i, arg in enumerate(expr_args):\n                        if not isinstance(arg, diff_type):\n                            fixed_args.append(arg)\n                        else:\n                            fixed_args.append(None)\n                    new_op = extraop.make_partial_operation(type(expr), tuple(fixed_args))\n                    der = self.diff_type.derivative(new_op, [arg for arg in expr_args if isinstance(arg, diff_type)])\n\n            if isinstance(der, derivative.Derivative):\n                diff = self.diff_type(var)\n                var2diff[var] = diff\n                self.nonlinear_diffs[diff] = der\n            else:\n                var2diff[var] = der\n\n        self._var2diff = var2diff\n\n        self.output_diff = []\n        for var in ssa[\"output_vars\"]:\n            self.output_diff.append([self.diff_type(var), var2diff[var]])\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n        \"\"\"Return the empirical weight of a given differential.\n\n        Given a differential (a pair of input and output differences),\n        the differential probability is the fraction of input pairs\n        with the given input difference leading to output pairs\n        with the given output difference.\n\n        This method returns an approximation of the weight of the\n        differential probability by sampling a given number\n        of input pairs.\n\n        If no correct output pairs are found, `math.inf` is returned.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff, RXDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> ch.empirical_weight([zero, zero, zero, zero], [zero, zero, zero, zero], 100)\n            0.0\n            >>> ch.empirical_weight([zero, zero, zero, zero], [one, one, one, one], 100)\n            inf\n            >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = RXDiff(Constant(0, 32)), RXDiff(Constant(1, 32))\n            >>> 4 - 1 <= ch.empirical_weight([zero]*4, [zero]*4, 3 * 2**6) <= 8\n            True\n            >>> ch.empirical_weight([zero]*4, [one]*4, 3 * 2**6)\n            inf\n\n        \"\"\"\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            correct_pairs = 0\n\n            for index_input in range(pair_samples):\n                pt, other_pt = list_pairs[index_input]\n                ct = self.func(*pt)\n                other_ct = self.func(*other_pt)\n\n                assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                for i, diff in enumerate(output_diff):\n                    # noinspection PyUnresolvedReferences\n                    if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                        break\n                else:\n                    correct_pairs += 1\n\n            if correct_pairs == 0:\n                weight = math.inf\n            else:\n                weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n\n        return weight\n\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n        # this function is not part of SingleKeyCh since it must be accessible\n        # for the encryption characteristic of RelatedKeyCh (which is a\n        # plain BvCharacteristic)\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        old_round_keys = self.func.round_keys\n\n        empirical_weights = collections.Counter()\n\n        if rk_output_diff is not None:\n            class RelatedFunc(self.func):\n                pass\n        else:\n            RelatedFunc = self.func\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            for _ in range(key_samples):\n                master_key = []\n                for width in cipher.key_schedule.input_widths:\n                    master_key.append(core.Constant(random.randrange(2 ** width), width))\n                self.func.round_keys = cipher.key_schedule(*master_key)\n                assert all(isinstance(rk, core.Constant) for rk in self.func.round_keys), str(self.func.round_keys)\n\n                if rk_output_diff is not None:\n                    RelatedFunc.round_keys = [d.get_pair_element(r) for r, d in zip(self.func.round_keys, rk_output_diff)]\n                    assert all(isinstance(rk, core.Constant) for rk in RelatedFunc.round_keys), str(RelatedFunc.round_keys)\n\n                correct_pairs = 0\n\n                for index_input in range(pair_samples):\n                    pt, other_pt = list_pairs[index_input]\n                    ct = self.func(*pt)\n                    other_ct = RelatedFunc(*other_pt)\n\n                    assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                    assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                    for i, diff in enumerate(output_diff):\n                        # noinspection PyUnresolvedReferences\n                        if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                            break\n                    else:\n                        correct_pairs += 1\n\n                if correct_pairs == 0:\n                    weight = math.inf\n                else:\n                    weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n                # weight = float((\"{0:.\"+str(precision)+\"f}\").format(weight))\n                weight = round(weight, precision)\n                empirical_weights[weight] += 1\n\n        self.func.round_keys = old_round_keys\n\n        return empirical_weights\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the characteristic.\n\n        The signature is a \"hash\" of the characteristic used for comparing.\n\n        For the type of the signature, see `ChSignatureType`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic, ChSignatureType\n            >>> from arxpy.primitives.primitives import BvFunction\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> issubclass(ChaskeyPi, BvFunction)\n            True\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n            >>> ch.signature(ChSignatureType.Full)\n            [dv0, dv1, dv2, dv3, d0, d4, d7, d10]\n            >>> ch.signature(ChSignatureType.InputOutput)\n            [dv0, dv1, dv2, dv3, d7, d12, d13, d9]\n\n        \"\"\"\n        if ch_signature_type == ChSignatureType.Full:\n            return [d.val for d in self.input_diff] + [d.val for d in self.nonlinear_diffs]\n        elif ch_signature_type == ChSignatureType.InputOutput:\n            # sig = [d for d in self.input_diff]\n            sig_var = [d.val for d in self.input_diff]\n\n            for out_diff, _ in self.output_diff:\n                for aux_var in self._var2diff[out_diff.val].val.atoms(core.Variable):\n                    if aux_var not in sig_var:\n                        # sig.append(out_diff)\n                        sig_var.append(out_diff.val)\n                        break\n\n            return sig_var\n        else:\n            raise ValueError(\"invalid ch_signature_type: {}\".format(ch_signature_type))\n\n    def _to_dict(self):\n        dict_ch = {\n            \"ssa\": self.ssa,\n            \"input_diff\": self.input_diff,\n            \"output_diff\": self.output_diff,\n            \"nonlinear_diffs\": self.nonlinear_diffs,\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/primitives/primitives.py\nclass Encryption(BvFunction):\n    \"\"\"Represent encryption functions.\n\n    An encryption function is a `BvFunction` that takes\n    the plaintext as input and returns the ciphertext\n    for some fixed key.\n    See `BvFunction` for more information.\n\n    Attributes:\n        round_keys: a list of `Term` representing the round keys\n\n    \"\"\"\n    round_keys = None\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/differential/characteristic.py\nclass SingleKeyCh(BvCharacteristic):\n    \"\"\"Represent single-key characteristics of block ciphers.\n\n    A single-key characteristic of a `Cipher` is a `BvCharacteristic`\n    over the `Encryption` function of the cipher.\n\n    The plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import SingleKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> Speck32.set_rounds(1)\n        >>> ch = SingleKeyCh(Speck32, XorDiff)\n        >>> ch .ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1), 'output_vars': (dx2, dx4),\n        'assignments': ((dx0, dp0 >>> 7), (dx1, dp1 + dx0), (dx2, dx1 ^ k0), (dx3, dp1 <<< 2), (dx4, dx2 ^ dx3))}\n        >>> ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1))\n        >>> ch.nonlinear_diffs\n        OrderedDict([(XorDiff(dx1), XDA(XorDiff(dp1), XorDiff(dp0 >>> 7)))])\n        >>> ch.output_diff\n        [[XorDiff(dx2), XorDiff(dx1)], [XorDiff(dx4), XorDiff(dx1 ^ (dp1 <<< 2))]]\n\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        rk = []\n        for i, width in enumerate(bv_cipher.key_schedule.output_widths):\n            rk.append(core.Variable(\"k\" + str(i), width))\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = tuple(rk)\n\n        func = Encryption\n        num_inputs = len(func.input_widths)\n        input_diff_names = [\"dp\" + str(i) for i in range(num_inputs)]\n        prefix = \"dx\"\n        super().__init__(func, diff_type, input_diff_names, prefix)\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n        \"\"\"Return the empirical weight distribution of a given differential.\n\n        This method returns a `collections.Counter` storing the distribution of\n        differential probability weights over the given number of keys.\n\n        The weights are rounded to the given number of precision\n        digits after the decimal point.\n\n        See also `BvCharacteristic.empirical_weight`.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import SingleKeyCh\n            >>> from arxpy.primitives import speck\n            >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n            >>> Speck32.set_rounds(1)\n            >>> ch = SingleKeyCh(Speck32, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 16)), XorDiff(Constant(1, 16))\n            >>> ch.empirical_weight([zero, zero], [zero, zero], 100, 10)\n            Counter({0.0: 10})\n            >>> ch.empirical_weight([zero, zero], [one, one], 100, 10)\n            Counter({inf: 10})\n\n        \"\"\"\n        return self._empirical_weight_distribution(self._cipher, input_diff, output_diff, pair_samples, key_samples,\n                                                   precision, rk_diffs)\narxpy/differential/characteristic.py\nclass ChSignatureType(enum.Enum):\nclass BvCharacteristic(object):\n            class RelatedFunc(self.func):\nclass SingleKeyCh(BvCharacteristic):\n        class Encryption(bv_cipher.encryption):\nclass RelatedKeyCh(object):\n        class Encryption(bv_cipher.encryption):\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n                def contains_key_var(term):\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\narxpy/differential/difference.py\nclass RXDiff(Difference):\n    \"\"\"Represent rotational-XOR (RX) differences.\n\n    The pair ``(x, (x <<< 1) ^ d)`` has RX difference ``d``.\n    In other words,  the RX difference of two `Term` ``x`` and ``y``\n    is defined as ``(x <<< 1) ^ y``.\n\n    See `Difference` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import RXDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b000, 3), Constant(0b001, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b001)\n        >>> alpha.get_pair_element(x)\n        0b001\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = RXDiff.from_pair(k, k)\n        >>> alpha\n        RXDiff(k ^ (k <<< 1))\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = RXOp\n    inv_diff_op = RXInvOp\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import RXDiff\n            >>> d1, d2 = RXDiff(Variable(\"d1\", 8)), RXDiff(Variable(\"d2\", 8))\n            >>> RXDiff.derivative(BvXor, [d1, d2])\n            RXDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> RXDiff.derivative(Xor1, d1)\n            RXDiff(0x03 ^ d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> RXDiff.derivative(Rotate1, d1)\n            RXDiff(d1 <<< 1)\n            >>> RXDiff.derivative(BvAdd, [d1, d2])\n            RXDA(RXDiff(d1), RXDiff(d2))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.RXDA(input_diff)\n\n        # Concact, BvSub\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            # BvShl, Extract\n\n        if hasattr(op, \"rx_derivative\"):\n            return op.rx_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/primitives/primitives.py\nclass BvFunction(object):\n    \"\"\"Represent (iterated) fixed-width bit-vector functions.\n\n    A `BvFunction` takes fixed-width `Constant` operands and return a\n    tuple of fixed-width `Constant`. An iterated bit-vector function\n    contains a subroutine that is iterated a certain number of *rounds*,\n    which can be changed using `set_rounds`.\n\n    Similar to `Operation`, `BvFunction` is evaluated\n    using the operator ``()`` and provides *Automatic Constant Conversion*.\n    Note that `BvFunction` only accepts `Constant` operands and\n    always return a tuple, as opposed to `Operation` that accepts\n    `Term` and scalar operands and returns a single `Term`.\n\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi(0, 0, 0, 0)  # automatic conversion from int to Constant\n        (0x00000000, 0x00000000, 0x00000000, 0x00000000)\n\n    Attributes:\n        input_widths: a list containing the widths of the inputs\n        output_widths: a list containing the widths of the outputs\n        rounds: the number of iterations\n\n    \"\"\"\n    input_widths = None\n    output_widths = None\n    rounds = None\n\n    def __new__(cls, *args, **options):\n        if len(cls.input_widths) != len(args):\n            raise ValueError(\"{} requires {} inputs but {} were given: {}\".format(\n                cls.__name__, len(cls.input_widths), len(args), args))\n        newargs = []\n        for arg, width in zip(args, cls.input_widths):\n            newargs.append(core.bitvectify(arg, width))\n        args = newargs\n\n        if all(isinstance(arg, core.Constant) for arg in args) or \\\n                options.pop(\"symbolic_inputs\", False):\n            result = cls.eval(*args)\n        else:\n            raise TypeError(\"expected bit-vector constant arguments\")\n\n        assert isinstance(result, collections.abc.Sequence)\n        assert len(cls.output_widths) == len(result)\n\n        output = []\n        for r, width in zip(result, cls.output_widths):\n            output.append(core.bitvectify(r, width))\n\n        return tuple(output)\n\n    @classmethod\n    def eval(cls, *args):\n        \"\"\"Evaluate the function (internal method).\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    # noinspection PyArgumentList\n    @classmethod\n    def ssa(cls, input_names, id_prefix):\n        \"\"\"Return a static single assignment program representing the function.\n\n        Args:\n            input_names: the names  for the input variables\n            id_prefix: the prefix to denote the intermediate variables\n\n        Return:\n            : a dictionary with three keys\n\n            - *input_vars*: a list of `Variable` representing the inputs\n            - *output_vars*: a list of `Variable` representing the outputs\n            - *assignments*: an ordered sequence of pairs\n              (`Variable`, `Operation`) representing each assignment\n              of the SSA program.\n\n        ::\n\n                >>> from arxpy.primitives.chaskey import ChaskeyPi\n                >>> ChaskeyPi.set_rounds(1)\n                >>> ChaskeyPi.ssa([\"v0\", \"v1\", \"v2\", \"v3\"], \"x\")  # doctest: +NORMALIZE_WHITESPACE\n                {'input_vars': (v0, v1, v2, v3),\n                'output_vars': (x7, x12, x13, x9),\n                'assignments': ((x0, v0 + v1), (x1, v1 <<< 5), (x2, x0 ^ x1), (x3, x0 <<< 16), (x4, v2 + v3),\n                (x5, v3 <<< 8), (x6, x4 ^ x5), (x7, x3 + x6), (x8, x6 <<< 13), (x9, x7 ^ x8), (x10, x2 + x4),\n                (x11, x2 <<< 7), (x12, x10 ^ x11), (x13, x10 <<< 16))}\n\n        \"\"\"\n        input_vars = []\n        for name, width in zip(input_names, cls.input_widths):\n            input_vars.append(core.Variable(name, width))\n        input_vars = tuple(input_vars)\n\n        table = context.MemoizationTable(id_prefix=id_prefix)\n\n        with context.Memoization(table):\n            # noinspection PyArgumentList\n            output_vars = cls(*input_vars, symbolic_inputs=True)\n\n        ssa_dict = {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assignments\": tuple(table.items())\n        }\n\n        for var, expr in ssa_dict[\"assignments\"]:\n            for arg in expr.args:\n                if isinstance(arg, operation.Operation):\n                    raise ValueError(\"assignment {} <- {} was not decomposed\".format(var, expr))\n\n        to_delete = []\n        vars_needed = set()\n        for var in output_vars:\n            vars_needed.add(var)\n        for var, expr in reversed(ssa_dict[\"assignments\"]):\n            if var in vars_needed:\n                for arg in expr.atoms(core.Variable):\n                    vars_needed.add(arg)\n            else:\n                to_delete.append((var, expr))\n                # raise ValueError(\"assignment {} <- {} is redundant in \\n{}\".format(var, expr, ssa_dict))\n\n        if len(to_delete) > 0:\n            import warnings\n            warnings.warn(\"removing redundant assignments {} in \\n{}\".format(to_delete, ssa_dict))\n            ssa_dict[\"assignments\"] = list(ssa_dict[\"assignments\"])\n            for assignment in to_delete:\n                ssa_dict[\"assignments\"].remove(assignment)\n            ssa_dict[\"assignments\"] = tuple(ssa_dict[\"assignments\"])\n\n        return ssa_dict\narxpy/primitives/primitives.py\nclass KeySchedule(BvFunction):\n    \"\"\"Represent key schedule functions.\n\n    A key schedule function is a `BvFunction` that takes\n    the masterkey as input and returns the round keys.\n    See `BvFunction` for more information.\n    \"\"\"\narxpy/primitives/primitives.py\nclass Cipher(object):\n    \"\"\"Represent (iterated) block ciphers.\n\n    A (iterated) block cipher consists of `KeySchedule` function\n    that computes round keys from a master key and an `Encryption`\n    function that computes a ciphertext from a given plaintext\n    and the round keys.\n\n    Given a ``cipher``, it can be evaluated with the operator ``()``\n    by passing it as arguments the plaintext and the master key,\n    that is, ``cipher(plaintext, masterkey)`` returns the ciphertext.\n\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> plaintext = [0, 0]\n        >>> masterkey = [0, 0, 0, 0]\n        >>> Speck32(plaintext, masterkey)\n        (0x2bb9, 0xc642)\n\n    Attributes:\n        key_schedule: the `KeySchedule` function of the cipher\n        encryption: the `Encryption` function of the cipher\n\n    \"\"\"\n    key_schedule = None\n    encryption = None\n    rounds = None\n\n    _minimum_rounds = 1  # for testing\n\n    def __new__(cls, plaintext, masterkey, **options):\n        assert isinstance(plaintext, collections.abc.Sequence)\n        assert isinstance(masterkey, collections.abc.Sequence)\n        assert cls.rounds >= cls._minimum_rounds\n\n        previous_round_keys = cls.encryption.round_keys\n\n        round_keys = cls.key_schedule(*masterkey, **options)\n        cls.encryption.round_keys = round_keys\n        result = cls.encryption(*plaintext, **options)\n\n        cls.encryption.round_keys = previous_round_keys\n\n        return result\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\nimport doctest\nimport unittest\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\nfrom arxpy.bitvector.core import Variable, Constant\nfrom arxpy.bitvector.operation import RotateLeft, RotateRight\nfrom arxpy.primitives.primitives import BvFunction, KeySchedule, Encryption, Cipher\nfrom arxpy.differential.difference import XorDiff, RXDiff\nfrom arxpy.differential import characteristic\nfrom arxpy.differential.characteristic import BvCharacteristic, SingleKeyCh, RelatedKeyCh\n\"\"\"Tests for the Characteristic module.\"\"\"\n\n\n\n\n\n\nVERBOSE = False\n\n\n# 1st cipher: linear key schedule and encryption with modular addition (no ctes)\n\nclass MyFunction(BvFunction):  # noqa: D101\n    input_widths = [8, 8]\n    output_widths = [8]\n    rounds = 1\n\n    @classmethod\n    def eval(cls, x, y):\n        x = RotateLeft(x ^ Constant(1, 8), 1)\n        y = ~y\n        return tuple([x + y])\n\n\nclass KeySchedule1(KeySchedule):  # noqa: D101\n    input_widths = [8]\n    output_widths = [8, 8]\n\n    @classmethod\n    def eval(cls, mk):\n        return tuple([mk, mk ^ Constant(1, 8)])\n\n\nNext line of code:\n", "input": "import doctest\nimport unittest\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\nfrom arxpy.bitvector.core import Variable, Constant\nfrom arxpy.bitvector.operation import RotateLeft, RotateRight\nfrom arxpy.primitives.primitives import BvFunction, KeySchedule, Encryption, Cipher\nfrom arxpy.differential.difference import XorDiff, RXDiff\nfrom arxpy.differential import characteristic\nfrom arxpy.differential.characteristic import BvCharacteristic, SingleKeyCh, RelatedKeyCh\n\"\"\"Tests for the Characteristic module.\"\"\"\n\n\n\n\n\n\nVERBOSE = False\n\n\n# 1st cipher: linear key schedule and encryption with modular addition (no ctes)\n\nclass MyFunction(BvFunction):  # noqa: D101\n    input_widths = [8, 8]\n    output_widths = [8]\n    rounds = 1\n\n    @classmethod\n    def eval(cls, x, y):\n        x = RotateLeft(x ^ Constant(1, 8), 1)\n        y = ~y\n        return tuple([x + y])\n\n\nclass KeySchedule1(KeySchedule):  # noqa: D101\n    input_widths = [8]\n    output_widths = [8, 8]\n\n    @classmethod\n    def eval(cls, mk):\n        return tuple([mk, mk ^ Constant(1, 8)])\n\n\n", "context": "arxpy/differential/characteristic.py\nclass RelatedKeyCh(object):\n    \"\"\"Represent related-key characteristics of block ciphers.\n\n    A related-key characteristic of a `Cipher` is a pair `BvCharacteristic`,\n    one over the `KeySchedule` of the cipher, and another one over the\n    the `Encryption` function of the cipher, where the output differences\n    of the key schedule characteristic are used as round key differences\n    in the encryption characteristic.\n\n    The master key differences start with the prefix ``\"dmk\"``,\n    the round key differences start with the prefix ``\"dk\"``,\n    the plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import RelatedKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives.lea import LeaCipher\n        >>> issubclass(LeaCipher, Cipher)\n        True\n        >>> LeaCipher.set_rounds(1)\n        >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n        >>> rkch .key_schedule_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dmk0, dmk1, dmk2, dmk3),\n        'output_vars': (dk1, dk3, dk5, dk3, dk7, dk3),\n        'assignments': ((dk0, 0xc3efe9db + dmk0), (dk1, dk0 <<< 1), (dk2, 0x87dfd3b7 + dmk1), (dk3, dk2 <<< 3),\n        (dk4, 0x0fbfa76f + dmk2), (dk5, dk4 <<< 6), (dk6, 0x1f7f4ede + dmk3), (dk7, dk6 <<< 11))}\n        >>> rkch.key_schedule_ch.input_diff\n        (XorDiff(dmk0), XorDiff(dmk1), XorDiff(dmk2), XorDiff(dmk3))\n        >>> rkch.key_schedule_ch.output_diff  # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dk1), XorDiff(dk0 <<< 1)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk5), XorDiff(dk4 <<< 6)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk7), XorDiff(dk6 <<< 11)], [XorDiff(dk3), XorDiff(dk2 <<< 3)]]\n        >>> rkch.key_schedule_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dk0), XDCA_0xc3efe9db(XorDiff(dmk0))),\n        (XorDiff(dk2), XDCA_0x87dfd3b7(XorDiff(dmk1))),\n        (XorDiff(dk4), XDCA_0x0fbfa76f(XorDiff(dmk2))),\n        (XorDiff(dk6), XDCA_0x1f7f4ede(XorDiff(dmk3)))])\n        >>> rkch.encryption_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1, dp2, dp3),\n        'output_vars': (dx3, dx7, dx11, dp0),\n        'assignments': ((dx0, dk1 ^ dp0), (dx1, dk3 ^ dp1), (dx2, dx0 + dx1), (dx3, dx2 <<< 9),\n        (dx4, dk5 ^ dp1), (dx5, dk3 ^ dp2), (dx6, dx4 + dx5), (dx7, dx6 >>> 5), (dx8, dk7 ^ dp2),\n        (dx9, dk3 ^ dp3), (dx10, dx8 + dx9), (dx11, dx10 >>> 3))}\n        >>> rkch.encryption_ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1), XorDiff(dp2), XorDiff(dp3))\n        >>> rkch.encryption_ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dx3), XorDiff(dx2 <<< 9)], [XorDiff(dx7), XorDiff(dx6 >>> 5)],\n        [XorDiff(dx11), XorDiff(dx10 >>> 3)], [XorDiff(dp0), XorDiff(dp0)]]\n        >>> rkch.encryption_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dx2), XDA(XorDiff(dp0 ^ (dk0 <<< 1)), XorDiff(dp1 ^ (dk2 <<< 3)))),\n        (XorDiff(dx6), XDA(XorDiff(dp1 ^ (dk4 <<< 6)), XorDiff(dp2 ^ (dk2 <<< 3)))),\n        (XorDiff(dx10), XDA(XorDiff(dp2 ^ (dk6 <<< 11)), XorDiff(dp3 ^ (dk2 <<< 3))))])\n\n    Attributes:\n        key_schedule_ch: the `BvCharacteristic` over the key schedule\n        encryption_ch: the `BvCharacteristic` over the encryption function\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        func = bv_cipher.key_schedule\n        prefix = \"dk\"\n        input_diff_names = tuple([\"dmk\" + str(i) for i in range(len(func.input_widths))])\n        ks_ch = BvCharacteristic(func, diff_type, input_diff_names, prefix)\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = ks_ch.ssa[\"output_vars\"]\n\n        func = Encryption\n        prefix = \"dx\"\n        input_diff_names = [\"dp\" + str(i) for i in range(len(func.input_widths))]\n        round_key_diff = {}\n        for var, diff in ks_ch.output_diff:\n            round_key_diff[var.val] = diff\n        encryption_ch = BvCharacteristic(func, diff_type, input_diff_names,\n                                         prefix, round_key_diff)\n\n        self.diff_type = diff_type\n        self.key_schedule_ch = ks_ch\n        self.encryption_ch = encryption_ch\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n        \"\"\"Return the empirical weight of a given differential for multiple keys.\n\n        This method returns the differential probability weight for the\n        key schedule characteristic (see `BvCharacteristic.empirical_weight`)\n        and the `collections.Counter` storing the distribution of weights for the encryption\n        characteristic (see `SingleKeyCh.empirical_weight`).\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> kid, kod = [zero]*4, [zero]*6\n            >>> eid, eod = [zero]*4, [zero]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (0.0, Counter({0.0: 10}))\n            >>> kid, kod = [zero]*4, [one]*6\n            >>> eid, eod = [zero]*4, [one]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (inf, Counter({inf: 10}))\n\n        \"\"\"\n        key_weight = self.key_schedule_ch.empirical_weight(key_input_diff, key_output_diff, key_samples)\n        # noinspection PyProtectedMember\n        enc_counter = self.encryption_ch._empirical_weight_distribution(self._cipher,\n                                                                        enc_input_diff, enc_output_diff, enc_samples,\n                                                                        key_samples, precision, key_output_diff)\n        return key_weight, enc_counter\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the related-key characteristic.\n\n        The signature of a related-key characteristic is the\n        concatenation of the key schedule and encryption signatures.\n\n        See also `BvCharacteristic.signature`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh, ChSignatureType\n            >>> from arxpy.primitives.primitives import Cipher\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> rkch.signature(ChSignatureType.Full)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk0, dk2, dk4, dk6, dp0, dp1, dp2, dp3, dx2, dx6, dx10]\n            >>> rkch.signature(ChSignatureType.InputOutput)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk1, dk3, dk5, dk3, dk7, dk3, dp0, dp1, dp2, dp3, dx3, dx7, dx11]\n\n        \"\"\"\n        return self.key_schedule_ch.signature(ch_signature_type) + self.encryption_ch.signature(ch_signature_type)\n\n    def _to_dict(self):\n        dict_ch = {\n            \"key_schedule_ch\": self.key_schedule_ch._to_dict(),\n            \"encryption_ch\": self.encryption_ch._to_dict(),\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/differential/difference.py\nclass XorDiff(Difference):\n    \"\"\"Represent XOR differences.\n\n    The XOR difference of two `Term` is given by the XOR\n    of the terms. In other words, the *difference operation*\n    of `XorDiff` is the `BvXor` (see `Difference`).\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b010, 3), Constant(0b101, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b111)\n        >>> alpha.get_pair_element(x)\n        0b101\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = XorDiff.from_pair(k, k)\n        >>> alpha\n        XorDiff(0x00)\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = operation.BvXor\n    inv_diff_op = operation.BvXor\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft, BvSub\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import XorDiff\n            >>> d1, d2 = XorDiff(Variable(\"d1\", 8)), XorDiff(Variable(\"d2\", 8))\n            >>> XorDiff.derivative(BvXor, [d1, d2])\n            XorDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(Xor1, d1)\n            XorDiff(d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> XorDiff.derivative(Rotate1, d1)\n            XorDiff(d1 <<< 1)\n            >>> XorDiff.derivative(BvAdd, [d1, d2])\n            XDA(XorDiff(d1), XorDiff(d2))\n            >>> XorDiff.derivative(BvSub, [d1, d2])\n            XDS(XorDiff(d1), XorDiff(d2))\n            >>> CteAdd1 = make_partial_operation(BvAdd, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(CteAdd1, d1)\n            XDCA_0x01(XorDiff(d1))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.Concat:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.XDA(input_diff)\n\n        if op == operation.BvSub:\n            from arxpy.differential import derivative\n            return derivative.XDS(input_diff)\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAnd:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                if isinstance(val, core.Constant):\n                    return cls(op.base_op(d1.val, val))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op in [operation.BvShl, operation.BvLshr]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Extract:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None and op.fixed_args[2] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1], op.fixed_args[2]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Concat:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                if op.fixed_args[0] is not None:\n                    val = op.fixed_args[0]\n                    input_diff = [cls.from_pair(val, val), d1]\n                else:\n                    val = op.fixed_args[1]\n                    input_diff = [d1, cls.from_pair(val, val)]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAdd:\n                assert len(input_diff) == 1\n                d = input_diff[0]\n                cte = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                from arxpy.differential import derivative\n                return derivative.XDCA(d, cte)\n            else:\n                raise ValueError(msg)\n\n        if hasattr(op, \"xor_derivative\"):\n            return op.xor_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\narxpy/differential/characteristic.py\nclass BvCharacteristic(object):\n    \"\"\"Represent characteristics of bit-vector functions.\n\n    Given a bit-vector function `BvFunction` :math:`f`,\n    a characteristic is a trail of differences obtained by\n    propagating an input difference over :math:`f`.\n\n    In particular, a characteristic is composed of the\n    input difference and the output difference of each\n    non-linear operation.\n\n    This class manages symbolic characteristics,\n    where the input difference is given symbolically\n    and the intermediate differences are `Term`\n    that depend on the input difference.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff, RXDiff\n        >>> from arxpy.differential.characteristic import BvCharacteristic\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi.set_rounds(1)\n        >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dv0, dv1, dv2, dv3),\n        'output_vars': (d7, d12, d13, d9),\n        'assignments': ((d0, dv0 + dv1), (d1, dv1 <<< 5), (d2, d0 ^ d1), (d3, d0 <<< 16), (d4, dv2 + dv3),\n        (d5, dv3 <<< 8), (d6, d4 ^ d5), (d7, d3 + d6), (d8, d6 <<< 13), (d9, d7 ^ d8), (d10, d2 + d4),\n        (d11, d2 <<< 7), (d12, d10 ^ d11), (d13, d10 <<< 16))}\n        >>> ch.input_diff\n        (XorDiff(dv0), XorDiff(dv1), XorDiff(dv2), XorDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(d0), XDA(XorDiff(dv0), XorDiff(dv1))),\n        (XorDiff(d4), XDA(XorDiff(dv2), XorDiff(dv3))),\n        (XorDiff(d7), XDA(XorDiff(d0 <<< 16), XorDiff(d4 ^ (dv3 <<< 8)))),\n        (XorDiff(d10), XDA(XorDiff(d0 ^ (dv1 <<< 5)), XorDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(d7), XorDiff(d7)],\n        [XorDiff(d12), XorDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [XorDiff(d13), XorDiff(d10 <<< 16)],\n        [XorDiff(d9), XorDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n        >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.input_diff\n        (RXDiff(dv0), RXDiff(dv1), RXDiff(dv2), RXDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(RXDiff(d0), RXDA(RXDiff(dv0), RXDiff(dv1))),\n        (RXDiff(d4), RXDA(RXDiff(dv2), RXDiff(dv3))),\n        (RXDiff(d7), RXDA(RXDiff(d0 <<< 16), RXDiff(d4 ^ (dv3 <<< 8)))),\n        (RXDiff(d10), RXDA(RXDiff(d0 ^ (dv1 <<< 5)), RXDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[RXDiff(d7), RXDiff(d7)],\n        [RXDiff(d12), RXDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [RXDiff(d13), RXDiff(d10 <<< 16)],\n        [RXDiff(d9), RXDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n\n    Attributes:\n        func: the `BvFunction`\n        diff_type: the `Difference` of the characteristic\n        input_diff: a list containing the input symbolic differences\n        nonlinear_diffs: an `collections.OrderedDict` mapping non-linear symbolic differences\n            to their corresponding `Derivative`\n        output_diff: a list, where the i-th element is a pair containing\n            the i-th output symbolic difference and its value\n    \"\"\"\n\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n        assert issubclass(func, primitives.BvFunction)\n        assert issubclass(diff_type, difference.Difference)\n\n        assert len(input_diff_names) == len(func.input_widths)\n        input_diff = []\n        for name, width in zip(input_diff_names, func.input_widths):\n            input_diff.append(diff_type(core.Variable(name, width)))\n        input_diff = tuple(input_diff)\n\n        self.func = func\n        self.diff_type = diff_type\n        self.input_diff = input_diff\n\n        # Propagate the input difference through the function\n\n        names = [d.val.name for d in self.input_diff]\n        ssa = self.func.ssa(names, id_prefix=prefix)\n        self.ssa = ssa\n        self._prefix = prefix\n        self._input_diff_names = input_diff_names\n\n        for var in ssa[\"output_vars\"]:\n            if isinstance(var, core.Constant):\n                raise ValueError(\"constant outputs (independent of the inputs) are not supported\")\n\n        var2diff = {}  # Variable to Difference\n        for var, diff in zip(ssa[\"input_vars\"], self.input_diff):\n            var2diff[var] = diff\n\n        if initial_var2diff is not None:\n            for var in initial_var2diff:\n                if str(var) in names:\n                    raise ValueError(\"the input differences cannot be replaced by initial_var2diff\")\n            var2diff.update(initial_var2diff)\n\n        self.nonlinear_diffs = collections.OrderedDict()\n        for var, expr in ssa[\"assignments\"]:\n            expr_args = []\n            for arg in expr.args:\n                if isinstance(arg, int):\n                    expr_args.append(arg)  # 'int' object has no attribute 'xreplace'\n                else:\n                    expr_args.append(arg.xreplace(var2diff))\n\n            if all(not isinstance(arg, diff_type) for arg in expr_args):\n                # symbolic computations with the key\n                var2diff[var] = expr\n                continue\n\n            if all(isinstance(arg, diff_type) for arg in expr_args):\n                der = self.diff_type.derivative(type(expr), expr_args)\n            else:\n                def contains_key_var(term):\n                    from sympy import basic\n                    for sub in basic.preorder_traversal(term):\n                        if sub in func.round_keys:\n                            return True\n                    else:\n                        return False\n\n                if type(expr) == operation.BvAdd and hasattr(func, 'round_keys') and \\\n                        all(isinstance(r, core.Variable) for r in func.round_keys) and \\\n                        any(contains_key_var(a) for a in expr_args):\n                    # temporary solution to Derivative(BvAddCte_k(x)) != Derivative(x + k)\n                    # with x a Diff and k a key variable\n                    keyed_indices = []\n                    for i, a in enumerate(expr_args):\n                        if contains_key_var(a):\n                            keyed_indices.append(i)\n                    if len(keyed_indices) != 1 or expr_args[keyed_indices[0]] not in func.round_keys:\n                        raise NotImplementedError(\"invalid expression: op={}, args={}\".format(\n                            type(expr).__name__, expr_args))\n                    # expr_args[keyed_indices[0]] replaced to the zero diff\n                    zero_diff = diff_type(core.Constant(0, expr_args[keyed_indices[0]].width))\n                    der = self.diff_type.derivative(type(expr), [expr_args[(keyed_indices[0] + 1) % 2], zero_diff])\n                elif hasattr(expr, \"xor_derivative\"):\n                    # temporary solution to operations containing a custom derivative\n                    input_diff_expr = []\n                    for i, arg in enumerate(expr_args):\n                        if isinstance(arg, diff_type):\n                            input_diff_expr.append(arg)\n                        else:\n                            assert isinstance(arg, core.Term)  # int arguments currently not supported\n                            input_diff_expr.append(diff_type.from_pair(arg, arg))\n                    der = self.diff_type.derivative(type(expr), input_diff_expr)\n                else:\n                    fixed_args = []\n                    for i, arg in enumerate(expr_args):\n                        if not isinstance(arg, diff_type):\n                            fixed_args.append(arg)\n                        else:\n                            fixed_args.append(None)\n                    new_op = extraop.make_partial_operation(type(expr), tuple(fixed_args))\n                    der = self.diff_type.derivative(new_op, [arg for arg in expr_args if isinstance(arg, diff_type)])\n\n            if isinstance(der, derivative.Derivative):\n                diff = self.diff_type(var)\n                var2diff[var] = diff\n                self.nonlinear_diffs[diff] = der\n            else:\n                var2diff[var] = der\n\n        self._var2diff = var2diff\n\n        self.output_diff = []\n        for var in ssa[\"output_vars\"]:\n            self.output_diff.append([self.diff_type(var), var2diff[var]])\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n        \"\"\"Return the empirical weight of a given differential.\n\n        Given a differential (a pair of input and output differences),\n        the differential probability is the fraction of input pairs\n        with the given input difference leading to output pairs\n        with the given output difference.\n\n        This method returns an approximation of the weight of the\n        differential probability by sampling a given number\n        of input pairs.\n\n        If no correct output pairs are found, `math.inf` is returned.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff, RXDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> ch.empirical_weight([zero, zero, zero, zero], [zero, zero, zero, zero], 100)\n            0.0\n            >>> ch.empirical_weight([zero, zero, zero, zero], [one, one, one, one], 100)\n            inf\n            >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = RXDiff(Constant(0, 32)), RXDiff(Constant(1, 32))\n            >>> 4 - 1 <= ch.empirical_weight([zero]*4, [zero]*4, 3 * 2**6) <= 8\n            True\n            >>> ch.empirical_weight([zero]*4, [one]*4, 3 * 2**6)\n            inf\n\n        \"\"\"\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            correct_pairs = 0\n\n            for index_input in range(pair_samples):\n                pt, other_pt = list_pairs[index_input]\n                ct = self.func(*pt)\n                other_ct = self.func(*other_pt)\n\n                assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                for i, diff in enumerate(output_diff):\n                    # noinspection PyUnresolvedReferences\n                    if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                        break\n                else:\n                    correct_pairs += 1\n\n            if correct_pairs == 0:\n                weight = math.inf\n            else:\n                weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n\n        return weight\n\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n        # this function is not part of SingleKeyCh since it must be accessible\n        # for the encryption characteristic of RelatedKeyCh (which is a\n        # plain BvCharacteristic)\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        old_round_keys = self.func.round_keys\n\n        empirical_weights = collections.Counter()\n\n        if rk_output_diff is not None:\n            class RelatedFunc(self.func):\n                pass\n        else:\n            RelatedFunc = self.func\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            for _ in range(key_samples):\n                master_key = []\n                for width in cipher.key_schedule.input_widths:\n                    master_key.append(core.Constant(random.randrange(2 ** width), width))\n                self.func.round_keys = cipher.key_schedule(*master_key)\n                assert all(isinstance(rk, core.Constant) for rk in self.func.round_keys), str(self.func.round_keys)\n\n                if rk_output_diff is not None:\n                    RelatedFunc.round_keys = [d.get_pair_element(r) for r, d in zip(self.func.round_keys, rk_output_diff)]\n                    assert all(isinstance(rk, core.Constant) for rk in RelatedFunc.round_keys), str(RelatedFunc.round_keys)\n\n                correct_pairs = 0\n\n                for index_input in range(pair_samples):\n                    pt, other_pt = list_pairs[index_input]\n                    ct = self.func(*pt)\n                    other_ct = RelatedFunc(*other_pt)\n\n                    assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                    assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                    for i, diff in enumerate(output_diff):\n                        # noinspection PyUnresolvedReferences\n                        if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                            break\n                    else:\n                        correct_pairs += 1\n\n                if correct_pairs == 0:\n                    weight = math.inf\n                else:\n                    weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n                # weight = float((\"{0:.\"+str(precision)+\"f}\").format(weight))\n                weight = round(weight, precision)\n                empirical_weights[weight] += 1\n\n        self.func.round_keys = old_round_keys\n\n        return empirical_weights\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the characteristic.\n\n        The signature is a \"hash\" of the characteristic used for comparing.\n\n        For the type of the signature, see `ChSignatureType`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic, ChSignatureType\n            >>> from arxpy.primitives.primitives import BvFunction\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> issubclass(ChaskeyPi, BvFunction)\n            True\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n            >>> ch.signature(ChSignatureType.Full)\n            [dv0, dv1, dv2, dv3, d0, d4, d7, d10]\n            >>> ch.signature(ChSignatureType.InputOutput)\n            [dv0, dv1, dv2, dv3, d7, d12, d13, d9]\n\n        \"\"\"\n        if ch_signature_type == ChSignatureType.Full:\n            return [d.val for d in self.input_diff] + [d.val for d in self.nonlinear_diffs]\n        elif ch_signature_type == ChSignatureType.InputOutput:\n            # sig = [d for d in self.input_diff]\n            sig_var = [d.val for d in self.input_diff]\n\n            for out_diff, _ in self.output_diff:\n                for aux_var in self._var2diff[out_diff.val].val.atoms(core.Variable):\n                    if aux_var not in sig_var:\n                        # sig.append(out_diff)\n                        sig_var.append(out_diff.val)\n                        break\n\n            return sig_var\n        else:\n            raise ValueError(\"invalid ch_signature_type: {}\".format(ch_signature_type))\n\n    def _to_dict(self):\n        dict_ch = {\n            \"ssa\": self.ssa,\n            \"input_diff\": self.input_diff,\n            \"output_diff\": self.output_diff,\n            \"nonlinear_diffs\": self.nonlinear_diffs,\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/primitives/primitives.py\nclass Encryption(BvFunction):\n    \"\"\"Represent encryption functions.\n\n    An encryption function is a `BvFunction` that takes\n    the plaintext as input and returns the ciphertext\n    for some fixed key.\n    See `BvFunction` for more information.\n\n    Attributes:\n        round_keys: a list of `Term` representing the round keys\n\n    \"\"\"\n    round_keys = None\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/differential/characteristic.py\nclass SingleKeyCh(BvCharacteristic):\n    \"\"\"Represent single-key characteristics of block ciphers.\n\n    A single-key characteristic of a `Cipher` is a `BvCharacteristic`\n    over the `Encryption` function of the cipher.\n\n    The plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import SingleKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> Speck32.set_rounds(1)\n        >>> ch = SingleKeyCh(Speck32, XorDiff)\n        >>> ch .ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1), 'output_vars': (dx2, dx4),\n        'assignments': ((dx0, dp0 >>> 7), (dx1, dp1 + dx0), (dx2, dx1 ^ k0), (dx3, dp1 <<< 2), (dx4, dx2 ^ dx3))}\n        >>> ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1))\n        >>> ch.nonlinear_diffs\n        OrderedDict([(XorDiff(dx1), XDA(XorDiff(dp1), XorDiff(dp0 >>> 7)))])\n        >>> ch.output_diff\n        [[XorDiff(dx2), XorDiff(dx1)], [XorDiff(dx4), XorDiff(dx1 ^ (dp1 <<< 2))]]\n\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        rk = []\n        for i, width in enumerate(bv_cipher.key_schedule.output_widths):\n            rk.append(core.Variable(\"k\" + str(i), width))\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = tuple(rk)\n\n        func = Encryption\n        num_inputs = len(func.input_widths)\n        input_diff_names = [\"dp\" + str(i) for i in range(num_inputs)]\n        prefix = \"dx\"\n        super().__init__(func, diff_type, input_diff_names, prefix)\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n        \"\"\"Return the empirical weight distribution of a given differential.\n\n        This method returns a `collections.Counter` storing the distribution of\n        differential probability weights over the given number of keys.\n\n        The weights are rounded to the given number of precision\n        digits after the decimal point.\n\n        See also `BvCharacteristic.empirical_weight`.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import SingleKeyCh\n            >>> from arxpy.primitives import speck\n            >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n            >>> Speck32.set_rounds(1)\n            >>> ch = SingleKeyCh(Speck32, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 16)), XorDiff(Constant(1, 16))\n            >>> ch.empirical_weight([zero, zero], [zero, zero], 100, 10)\n            Counter({0.0: 10})\n            >>> ch.empirical_weight([zero, zero], [one, one], 100, 10)\n            Counter({inf: 10})\n\n        \"\"\"\n        return self._empirical_weight_distribution(self._cipher, input_diff, output_diff, pair_samples, key_samples,\n                                                   precision, rk_diffs)\narxpy/differential/characteristic.py\nclass ChSignatureType(enum.Enum):\nclass BvCharacteristic(object):\n            class RelatedFunc(self.func):\nclass SingleKeyCh(BvCharacteristic):\n        class Encryption(bv_cipher.encryption):\nclass RelatedKeyCh(object):\n        class Encryption(bv_cipher.encryption):\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n                def contains_key_var(term):\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\narxpy/differential/difference.py\nclass RXDiff(Difference):\n    \"\"\"Represent rotational-XOR (RX) differences.\n\n    The pair ``(x, (x <<< 1) ^ d)`` has RX difference ``d``.\n    In other words,  the RX difference of two `Term` ``x`` and ``y``\n    is defined as ``(x <<< 1) ^ y``.\n\n    See `Difference` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import RXDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b000, 3), Constant(0b001, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b001)\n        >>> alpha.get_pair_element(x)\n        0b001\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = RXDiff.from_pair(k, k)\n        >>> alpha\n        RXDiff(k ^ (k <<< 1))\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = RXOp\n    inv_diff_op = RXInvOp\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import RXDiff\n            >>> d1, d2 = RXDiff(Variable(\"d1\", 8)), RXDiff(Variable(\"d2\", 8))\n            >>> RXDiff.derivative(BvXor, [d1, d2])\n            RXDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> RXDiff.derivative(Xor1, d1)\n            RXDiff(0x03 ^ d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> RXDiff.derivative(Rotate1, d1)\n            RXDiff(d1 <<< 1)\n            >>> RXDiff.derivative(BvAdd, [d1, d2])\n            RXDA(RXDiff(d1), RXDiff(d2))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.RXDA(input_diff)\n\n        # Concact, BvSub\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            # BvShl, Extract\n\n        if hasattr(op, \"rx_derivative\"):\n            return op.rx_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/primitives/primitives.py\nclass BvFunction(object):\n    \"\"\"Represent (iterated) fixed-width bit-vector functions.\n\n    A `BvFunction` takes fixed-width `Constant` operands and return a\n    tuple of fixed-width `Constant`. An iterated bit-vector function\n    contains a subroutine that is iterated a certain number of *rounds*,\n    which can be changed using `set_rounds`.\n\n    Similar to `Operation`, `BvFunction` is evaluated\n    using the operator ``()`` and provides *Automatic Constant Conversion*.\n    Note that `BvFunction` only accepts `Constant` operands and\n    always return a tuple, as opposed to `Operation` that accepts\n    `Term` and scalar operands and returns a single `Term`.\n\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi(0, 0, 0, 0)  # automatic conversion from int to Constant\n        (0x00000000, 0x00000000, 0x00000000, 0x00000000)\n\n    Attributes:\n        input_widths: a list containing the widths of the inputs\n        output_widths: a list containing the widths of the outputs\n        rounds: the number of iterations\n\n    \"\"\"\n    input_widths = None\n    output_widths = None\n    rounds = None\n\n    def __new__(cls, *args, **options):\n        if len(cls.input_widths) != len(args):\n            raise ValueError(\"{} requires {} inputs but {} were given: {}\".format(\n                cls.__name__, len(cls.input_widths), len(args), args))\n        newargs = []\n        for arg, width in zip(args, cls.input_widths):\n            newargs.append(core.bitvectify(arg, width))\n        args = newargs\n\n        if all(isinstance(arg, core.Constant) for arg in args) or \\\n                options.pop(\"symbolic_inputs\", False):\n            result = cls.eval(*args)\n        else:\n            raise TypeError(\"expected bit-vector constant arguments\")\n\n        assert isinstance(result, collections.abc.Sequence)\n        assert len(cls.output_widths) == len(result)\n\n        output = []\n        for r, width in zip(result, cls.output_widths):\n            output.append(core.bitvectify(r, width))\n\n        return tuple(output)\n\n    @classmethod\n    def eval(cls, *args):\n        \"\"\"Evaluate the function (internal method).\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    # noinspection PyArgumentList\n    @classmethod\n    def ssa(cls, input_names, id_prefix):\n        \"\"\"Return a static single assignment program representing the function.\n\n        Args:\n            input_names: the names  for the input variables\n            id_prefix: the prefix to denote the intermediate variables\n\n        Return:\n            : a dictionary with three keys\n\n            - *input_vars*: a list of `Variable` representing the inputs\n            - *output_vars*: a list of `Variable` representing the outputs\n            - *assignments*: an ordered sequence of pairs\n              (`Variable`, `Operation`) representing each assignment\n              of the SSA program.\n\n        ::\n\n                >>> from arxpy.primitives.chaskey import ChaskeyPi\n                >>> ChaskeyPi.set_rounds(1)\n                >>> ChaskeyPi.ssa([\"v0\", \"v1\", \"v2\", \"v3\"], \"x\")  # doctest: +NORMALIZE_WHITESPACE\n                {'input_vars': (v0, v1, v2, v3),\n                'output_vars': (x7, x12, x13, x9),\n                'assignments': ((x0, v0 + v1), (x1, v1 <<< 5), (x2, x0 ^ x1), (x3, x0 <<< 16), (x4, v2 + v3),\n                (x5, v3 <<< 8), (x6, x4 ^ x5), (x7, x3 + x6), (x8, x6 <<< 13), (x9, x7 ^ x8), (x10, x2 + x4),\n                (x11, x2 <<< 7), (x12, x10 ^ x11), (x13, x10 <<< 16))}\n\n        \"\"\"\n        input_vars = []\n        for name, width in zip(input_names, cls.input_widths):\n            input_vars.append(core.Variable(name, width))\n        input_vars = tuple(input_vars)\n\n        table = context.MemoizationTable(id_prefix=id_prefix)\n\n        with context.Memoization(table):\n            # noinspection PyArgumentList\n            output_vars = cls(*input_vars, symbolic_inputs=True)\n\n        ssa_dict = {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assignments\": tuple(table.items())\n        }\n\n        for var, expr in ssa_dict[\"assignments\"]:\n            for arg in expr.args:\n                if isinstance(arg, operation.Operation):\n                    raise ValueError(\"assignment {} <- {} was not decomposed\".format(var, expr))\n\n        to_delete = []\n        vars_needed = set()\n        for var in output_vars:\n            vars_needed.add(var)\n        for var, expr in reversed(ssa_dict[\"assignments\"]):\n            if var in vars_needed:\n                for arg in expr.atoms(core.Variable):\n                    vars_needed.add(arg)\n            else:\n                to_delete.append((var, expr))\n                # raise ValueError(\"assignment {} <- {} is redundant in \\n{}\".format(var, expr, ssa_dict))\n\n        if len(to_delete) > 0:\n            import warnings\n            warnings.warn(\"removing redundant assignments {} in \\n{}\".format(to_delete, ssa_dict))\n            ssa_dict[\"assignments\"] = list(ssa_dict[\"assignments\"])\n            for assignment in to_delete:\n                ssa_dict[\"assignments\"].remove(assignment)\n            ssa_dict[\"assignments\"] = tuple(ssa_dict[\"assignments\"])\n\n        return ssa_dict\narxpy/primitives/primitives.py\nclass KeySchedule(BvFunction):\n    \"\"\"Represent key schedule functions.\n\n    A key schedule function is a `BvFunction` that takes\n    the masterkey as input and returns the round keys.\n    See `BvFunction` for more information.\n    \"\"\"\narxpy/primitives/primitives.py\nclass Cipher(object):\n    \"\"\"Represent (iterated) block ciphers.\n\n    A (iterated) block cipher consists of `KeySchedule` function\n    that computes round keys from a master key and an `Encryption`\n    function that computes a ciphertext from a given plaintext\n    and the round keys.\n\n    Given a ``cipher``, it can be evaluated with the operator ``()``\n    by passing it as arguments the plaintext and the master key,\n    that is, ``cipher(plaintext, masterkey)`` returns the ciphertext.\n\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> plaintext = [0, 0]\n        >>> masterkey = [0, 0, 0, 0]\n        >>> Speck32(plaintext, masterkey)\n        (0x2bb9, 0xc642)\n\n    Attributes:\n        key_schedule: the `KeySchedule` function of the cipher\n        encryption: the `Encryption` function of the cipher\n\n    \"\"\"\n    key_schedule = None\n    encryption = None\n    rounds = None\n\n    _minimum_rounds = 1  # for testing\n\n    def __new__(cls, plaintext, masterkey, **options):\n        assert isinstance(plaintext, collections.abc.Sequence)\n        assert isinstance(masterkey, collections.abc.Sequence)\n        assert cls.rounds >= cls._minimum_rounds\n\n        previous_round_keys = cls.encryption.round_keys\n\n        round_keys = cls.key_schedule(*masterkey, **options)\n        cls.encryption.round_keys = round_keys\n        result = cls.encryption(*plaintext, **options)\n\n        cls.encryption.round_keys = previous_round_keys\n\n        return result\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n", "answers": ["class Encryption1(Encryption):  # noqa: D101"], "pred": "  Code: 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, ", "length": 5302, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "348e33db9dd7512c0d821c5d1fc6a5b74a412a1e9be012f7"}
{"prompt": "Please complete the code given below. \nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nimport android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;Next line of code:\n", "input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;", "context": "Spectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\n", "answers": ["    private ImmersiveTouchNavigation mImmersiveTouchNavigation;"], "pred": "  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m:  m: ", "length": 8166, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cf3d37ae2215d5f5123fcc3ad041ba23b56d19a3abad67e6"}
{"prompt": "Please complete the code given below. \nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusCommand.java\n@JsonTypeName(\"SetStatus\")\npublic final class SetStatusCommand extends Command {\n    private final Status status;\n\n    public SetStatusCommand(Status status) {\n        super();\n        this.status = status;\n    }\n\n    @JsonCreator\n    private SetStatusCommand(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\") Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetUpdateFrequencyCommand.java\n@JsonTypeName(\"SetUpdateFrequency\")\npublic final class SetUpdateFrequencyCommand extends Command {\n    private final int updateFrequency;\n\n    public SetUpdateFrequencyCommand(int updateFrequency) {\n        super();\n        this.updateFrequency = updateFrequency;\n    }\n\n    @JsonCreator\n    private SetUpdateFrequencyCommand(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusMessageCommand.java\n@JsonTypeName(\"SetStatusMessage\")\npublic class SetStatusMessageCommand extends Command {\n    private final String message;\n\n    public SetStatusMessageCommand(String message) {\n        super();\n        this.message = message;\n    }\n\n    public SetStatusMessageCommand(Instant time, String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @JsonCreator\n    private SetStatusMessageCommand(@JsonProperty(\"commandId\") String commandId,\n                                    @JsonProperty(\"time\") Instant time,\n                                    @JsonProperty(\"message\") String message) {\n        super(commandId, time);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusReporter.java\npublic final class StatusReporter {\n    private static final Logger LOG = LogManager.getLogger(StatusReporter.class);\n    \n    private final Jedis jedis;\n    private final String statusChannel;\n\n    /**\n     * Create a new status reporter for the given Redis URI and status channel.\n     *\n     * @param redisURI\n     *        The URI for the Redis instance to report the status on. This should\n     *        be the \"own\" Redis instance.\n     * @param statusChannel\n     *        The channel to broadcast the status messages to. This channel is\n     *        made specific to the database, so if the `redisUri`\n     *        contains database `N`, and the channel is `status`,\n     *        then messages will be broadcast on channel `status:N`.\n     * @see org.ulyssis.ipp.utils.JedisHelper#dbLocalChannel(String, java.net.URI)\n     */\n    public StatusReporter(URI redisURI, String statusChannel) {\n        this.jedis = JedisHelper.get(redisURI);\n        this.statusChannel = JedisHelper.dbLocalChannel(statusChannel, redisURI);\n    }\n\n    /**\n     * Broadcast a status message.\n     *\n     * @param message\n     *        The message to broadcast\n     * @return True if the broadcast was successful, false if the broadcast was unsuccessful.\n     *         Failure to broadcast will be logged.\n     */\n    public synchronized boolean broadcast(StatusMessage message) {\n        if (jedis == null)\n            return false;\n        try {\n            jedis.publish(statusChannel.getBytes(), Serialization.getJsonMapper().writeValueAsBytes(message));\n            return true;\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error processing message {}\", message.getDetails(), e);\n            return false;\n        } catch (JedisConnectionException e) {\n            LOG.error(\"Couldn't connect to Redis when sending: {}\", message.getDetails(), e);\n            return false;\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/handlers/PingHandler.java\npublic final class PingHandler implements CommandHandler {\n\n    /**\n     * Handles the given command, which should be a PingCommand.\n     *\n     * @param command\n     *        The ping command to handle.\n     * @param callback\n     *        The ping callback, which is always invoked with true.\n     */\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        callback.accept(true);\n    }\n\n    /**\n     * Returns PingCommand.class\n     *\n     * @return PingCommand.class\n     */\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return PingCommand.class;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/ReaderConfig.java\npublic class ReaderConfig {\n    private URI uri;\n    private Type type = Type.LLRP;\n    private double position;\n    private List<SimulatedTeam> simulatedTeams = new ArrayList<>();\n\n    public static class SimulatedTeam {\n        private final TagId tag;\n        private final long lapTime;\n\n        @JsonCreator\n        public SimulatedTeam(\n                @JsonProperty(\"tag\") TagId tag,\n                @JsonProperty(\"lapTime\") long lapTime) {\n            this.tag = tag;\n            this.lapTime = lapTime;\n        }\n\n        public TagId getTag() {\n            return tag;\n        }\n\n        public long getLapTime() {\n            return lapTime;\n        }\n    }\n\n    public enum Type {\n        LLRP,\n        SIMULATOR\n    }\n\n    /**\n     * Private constructor used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private ReaderConfig() {\n    }\n\n    public URI getURI() {\n        return uri;\n    }\n    \n    /**\n     * Private setter used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private void setURI(URI uri) {\n        this.uri = uri;\n    }\n\n    public double getPosition() {\n        return position;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setPosition(double position) {\n        this.position = position;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setType(Type type) {\n        this.type = type;\n    }\n\n    public List<SimulatedTeam> getSimulatedTeams() {\n        return Collections.unmodifiableList(simulatedTeams);\n    }\n\n    public SimulatedTeam getSimulatedTeam(int id) {\n        return simulatedTeams.get(id);\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSimulatedTeams(List<SimulatedTeam> simulatedTeams) {\n        this.simulatedTeams = simulatedTeams;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/RemoveTagCommand.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagCommand extends TagCommand {\n    public RemoveTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    public RemoveTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @JsonCreator\n    private RemoveTagCommand(@JsonProperty(\"commandId\") String commandId,\n                             @JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"tag\") TagId tag,\n                             @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StartEvent.java\n@JsonTypeName(\"Start\")\npublic final class StartEvent extends Event {\n    /**\n     * Private constructor for Jackson\n     */\n    private StartEvent() {\n        super(Instant.MIN);\n    }\n\n    public StartEvent(Instant time) {\n        super(time);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withStartTime(getTime()).build();\n    }\n\n    public static StartEvent fromCommand(Command command) {\n        assert(command instanceof SetStartTimeCommand);\n        SetStartTimeCommand cmd = (SetStartTimeCommand) command;\n        return new StartEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/JedisHelper.java\npublic final class JedisHelper {\n\n    // Static methods only! No instances!\n    private JedisHelper() {\n    }\n\n    /**\n     * Get a new Jedis instance from the given URI\n     *\n     * The URI is formed as such:\n     * `new URI(\"redis://:password@host:port/database\")`\n     * for example:\n     * `new URI(\"redis://:hunter2@10.0.0.1:6379/0\")}`.\n     * The port, password and path can be omitted. If no path is\n     * supplied, database +0+ is selected. If no user\n     * info is supplied, then no authorization is performed.\n     * If no port is supplied, the default port +6379+\n     * is used.\n     *\n     * Use this instead of `new Jedis(uri)`, because\n     * that method does not allow to omit anything.\n     *\n     * @param uri\n     *        The URI for the Jedis instance.\n     * @return A new Jedis instance.\n     */\n    // TODO: Exceptions for wrong password, failing to parse database,...\n    public static Jedis get(URI uri) throws IllegalArgumentException {\n        int port = uri.getPort() != -1 ? uri.getPort() : 6379;\n        String host = uri.getHost();\n        Jedis result = new Jedis(host, port);\n        if (uri.getUserInfo() != null) {\n            String password = uri.getUserInfo().split(\":\")[1];\n            result.auth(password);\n        }\n        result.select(getDb(uri));\n        return result;\n    }\n\n    /**\n     * Extract the database number from the given Redis URI\n     *\n     * If the URI has the path +/N+, then +N+\n     * is returned. If the path is empty, +0+ is returned.\n     *\n     * @param uri\n     *        The URI\n     * @throws java.lang.IllegalArgumentException\n     *         The supplied path could not be parsed as an int\n     * @return The database number (+0+ for no path, +N+\n     *         if the path is +/N+)\n     */\n    public static int getDb(URI uri) throws IllegalArgumentException {\n        if (!Objects.equals(uri.getPath(), \"\")) {\n            try {\n                return Integer.parseInt(uri.getPath().split(\"/\", 2)[1]);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"The supplied path could not be parsed as an int\", e);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Generates a channel name that is local to a database.\n     *\n     * Redis channels are not tied to a single database, but are\n     * global to the instance of Redis. We, however, want to tie\n     * these to a certain database, so we have to add some information\n     * that does that. For this reason, if the channel name is\n     * +channel+, the database number +N+ is added to it\n     * to form +channel:N+. The database number is extracted\n     * using `getDb(uri)`.\n     *\n     * @param channel\n     *        The base channel name\n     * @param uri\n     *        The URI containing the database info\n     * @return +channel:N+, where +N+ is the database number\n     * @see org.ulyssis.ipp.utils.JedisHelper#getDb(java.net.URI)\n     */\n    public static String dbLocalChannel(String channel, URI uri) {\n        return channel + \":\" + getDb(uri);\n    }\n\n    /**\n     * A helper class that implements +BinaryJedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class BinaryCallBackPubSub extends BinaryJedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(byte[] pattern, byte[] channel, byte[] message);\n        }\n\n        private final List<BiConsumer<byte[],byte[]>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(byte[] channel, byte[] message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onMessage(byte[], byte[])\n         */\n        public void addOnMessageListener(BiConsumer<byte[],byte[]> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPMessage(byte[], byte[], byte[])\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(byte[] channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onSubscribe(byte[], int)\n         */\n        public void addOnSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(byte[] channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onUnsubscribe(byte[], int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(byte[] pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPSubscribe(byte[], int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPUnsubscribe(byte[], int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * A helper class that implements +JedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class CallBackPubSub extends JedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(String pattern, String channel, String message);\n        }\n\n        private final List<BiConsumer<String,String>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(String channel, String message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onMessage(String, String)\n         */\n        public void addOnMessageListener(BiConsumer<String, String> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(String pattern, String channel, String message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPMessage(String, String, String)\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onSubscribe(String, int)\n         */\n        public void addOnSubscribeListener(BiConsumer<String, Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onUnsubscribe(String, int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(String pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPSubscribe(String, int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<String, Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(String pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPUnsubscribe(String, int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Snapshot.java\npublic final class Snapshot {\n    private static final Logger LOG = LogManager.getLogger(Snapshot.class);\n\n    public static class Builder {\n        private Snapshot snapshot;\n\n        private Builder(Instant time, Snapshot other) {\n            snapshot = new Snapshot(time);\n            if (other != null) {\n                snapshot.teamTagMap = other.teamTagMap;\n                snapshot.startTime = other.startTime;\n                snapshot.endTime = other.endTime;\n                snapshot.teamStates = other.teamStates;\n                snapshot.publicTeamStates = other.publicTeamStates;\n                snapshot.statusMessage = other.statusMessage;\n                snapshot.status = other.status;\n                snapshot.updateFrequency = other.updateFrequency;\n            }\n        }\n\n        public Builder withTeamTagMap(TeamTagMap teamTagMap) {\n            this.snapshot.teamTagMap = teamTagMap;\n            return this;\n        }\n\n        public Builder withStartTime(Instant time) {\n            this.snapshot.startTime = time;\n            return this;\n        }\n\n        public Builder withEndTime(Instant time) {\n            this.snapshot.endTime = time;\n            return this;\n        }\n\n        public Builder withTeamStates(TeamStates teamStates) {\n            this.snapshot.teamStates = teamStates;\n            return this;\n        }\n\n        public Builder withPublicTeamStates(TeamStates teamStates) {\n            this.snapshot.publicTeamStates = teamStates;\n            return this;\n        }\n\n        public Builder withStatusMessage(String message) {\n            this.snapshot.statusMessage = message;\n            return this;\n        }\n\n        public Builder withStatus(Status status) {\n            this.snapshot.status = status;\n            return this;\n        }\n\n        public Builder withUpdateFrequency(int updateFrequency) {\n            this.snapshot.updateFrequency = updateFrequency;\n            return this;\n        }\n\n        public Snapshot build() {\n            return snapshot;\n        }\n    }\n\n    @JsonIgnore\n    private long id = -1;\n\n    @JsonIgnore\n    long eventId = -1;\n\n    public Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    public Optional<Long> getEventId() {\n        if (eventId != -1) return Optional.of(eventId);\n        else return Optional.empty();\n    }\n\n    /**\n     * Default constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private Snapshot() {\n    }\n\n    public Snapshot(Instant time) {\n        snapshotTime = time;\n    }\n\n    public Instant getSnapshotTime() {\n        return snapshotTime;\n    }\n\n    public TeamTagMap getTeamTagMap() {\n        return teamTagMap;\n    }\n\n    public Instant getStartTime() {\n        return startTime;\n    }\n\n    public Instant getEndTime() {\n        return endTime;\n    }\n\n    public TeamStates getTeamStates() {\n        return teamStates;\n    }\n\n    public TeamStates getPublicTeamStates() {\n        return publicTeamStates;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    private Instant snapshotTime = Instant.MIN;\n    private Instant startTime = Instant.MAX;\n    private Instant endTime = Instant.MAX;\n    private TeamTagMap teamTagMap = new TeamTagMap();\n    private TeamStates teamStates;\n    private TeamStates publicTeamStates;\n    {\n        teamStates = new TeamStates();\n        publicTeamStates = teamStates;\n    }\n    private String statusMessage = \"\";\n    private Status status = Status.NoResults;\n    private int updateFrequency = 3;\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"snapshots\\\" WHERE \\\"event\\\" = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setLong(1, event.getId().get());\n            LOG.debug(\"executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = event.getId().get();\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadLatest(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" ORDER BY \\\"time\\\" DESC FETCH FIRST ROW ONLY\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(statement)) {\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" \" +\n                \"WHERE \\\"time\\\" < ? ORDER BY \\\"time\\\" DESC, \\\"event\\\" DESC FETCH FIRST ROW ONLY\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                \"INSERT INTO \\\"snapshots\\\" (\\\"time\\\",\\\"data\\\",\\\"event\\\") VALUES (?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(snapshotTime));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false; // TODO(Roel): Programming error\n                return;\n            }\n            statement.setString(2, serialized);\n            statement.setLong(3, eventId);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public static void deleteAfter(Connection connection, Snapshot snapshot) throws SQLException {\n        String statement =\n                \"DELETE FROM \\\"snapshots\\\" WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"event\\\" > ?)\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            Timestamp timestamp = Timestamp.from(snapshot.getSnapshotTime());\n            stmt.setTimestamp(1, timestamp);\n            stmt.setTimestamp(2, timestamp);\n            stmt.setLong(3, snapshot.getEventId().orElse(-1L));\n            LOG.debug(\"Executing query: {}\", stmt);\n            int affectedRows = stmt.executeUpdate();\n            LOG.debug(\"deleteAfter affected {} rows\", affectedRows);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/MessageEvent.java\n@JsonTypeName(\"Message\")\npublic final class MessageEvent extends Event {\n    private final String message;\n\n    @JsonCreator\n    public MessageEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"message\") String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withStatusMessage(message).build();\n    }\n\n    public static MessageEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusMessageCommand);\n        SetStatusMessageCommand cmd = (SetStatusMessageCommand) command;\n        return new MessageEvent(cmd.getTime(), cmd.getMessage());\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/CorrectionEvent.java\n@JsonTypeName(\"Correction\")\npublic final class CorrectionEvent extends Event {\n    private int teamNb;\n    private int correction;\n\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private CorrectionEvent() {\n        super(Instant.MIN);\n    }\n\n    /**\n     * Create an event representing a correction of score.\n     *\n     * @param time\n     *        The time at which the corection is performed.\n     * @param teamNb\n     *        The number of the team to correct the score of.\n     * @param correction\n     *        The number of laps that should be added (positive)\n     *        or removed (negative)\n     */\n    public CorrectionEvent(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getCorrection() {\n        return correction;\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamStates oldTeamStates = snapshot.getTeamStates();\n        Optional<TeamState> oldTeamState = oldTeamStates.getStateForTeam(teamNb);\n        TeamState newTeamState;\n        if (oldTeamState.isPresent()) {\n            newTeamState = oldTeamState.get().addCorrection(correction);\n        } else {\n            newTeamState = new TeamState().addCorrection(correction);\n        }\n        return Snapshot.builder(getTime(), snapshot)\n                .withTeamStates(snapshot.getTeamStates().setStateForTeam(teamNb, newTeamState))\n                .build();\n    }\n\n    public static CorrectionEvent fromCommand(Command command) {\n        assert(command instanceof CorrectionCommand);\n        CorrectionCommand cmd = (CorrectionCommand) command;\n        return new CorrectionEvent(cmd.getTime(), cmd.getTeamNb(), cmd.getCorrection());\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Event.java\n@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n@JsonSubTypes({ @JsonSubTypes.Type(value=StartEvent.class),\n                @JsonSubTypes.Type(value=EndEvent.class),\n                @JsonSubTypes.Type(value=AddTagEvent.class),\n                @JsonSubTypes.Type(value=RemoveTagEvent.class),\n                @JsonSubTypes.Type(value=CorrectionEvent.class),\n                @JsonSubTypes.Type(value=TagSeenEvent.class),\n                @JsonSubTypes.Type(value=IdentityEvent.class),\n                @JsonSubTypes.Type(value=MessageEvent.class),\n                @JsonSubTypes.Type(value=StatusChangeEvent.class)})\npublic abstract class Event {\n    private static final Logger LOG = LogManager.getLogger(Event.class);\n\n    @JsonIgnore\n    private long id = -1;\n    @JsonIgnore\n    private boolean removed = false;\n\n    private Instant time;\n\n    protected Event(Instant time) {\n        this.time = time;\n    }\n\n    @JsonIgnore\n    public final Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    @JsonIgnore\n    public final boolean isRemoved() {\n        if (id == -1) throw new IllegalStateException(\"Trying to request removed state of event not in db\");\n        return removed;\n    }\n\n    public final Instant getTime() {\n        return time;\n    }\n\n    /**\n     * Determines whether this event should be isUnique, defaults to false\n     *\n     * @return whether this event should be isUnique (default implementation = false)\n     */\n    @JsonIgnore\n    public boolean isUnique() {\n        return false;\n    }\n\n    /**\n     * Determines whether this event can be removed or undone.\n     *\n     * @return whether this event can be removed or undone (default implementation = isUnique())\n     */\n    @JsonIgnore\n    public boolean isRemovable() {\n        return isUnique();\n    }\n\n    /**\n     * Apply this event to a snapshot, yielding the new snapshot\n     */\n    protected abstract Snapshot doApply(Snapshot before);\n\n    public final Snapshot apply(Snapshot before) {\n        assert !removed;\n        Snapshot result = doApply(before);\n        if (result == before && before.getEventId().isPresent()) {\n            // We need to copy it anyway\n            result = Snapshot.builder(getTime(), before).build();\n        }\n        result.eventId = this.id;\n        return result;\n    }\n\n    // TODO: How to deal with deserialization problem?\n    public static List<Event> loadAll(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"removed\\\" FROM \\\"events\\\" ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet result = stmt.executeQuery(statement)) {\n            while (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = result.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static Optional<Event> loadUnique(Connection connection, Class<? extends Event> eventType) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"events\\\" WHERE \\\"type\\\" = ? AND \\\"removed\\\" = false\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setString(1, eventType.getSimpleName());\n            ResultSet result = stmt.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = false;\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Event> load(Connection connection, long id) throws SQLException, IOException {\n        try (PreparedStatement statement =\n                connection.prepareStatement(\n                        \"SELECT \\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" WHERE \\\"id\\\"=?\")) {\n            statement.setLong(1, id);\n            ResultSet result = statement.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = id;\n                event.removed = result.getBoolean(\"removed\");\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static List<Event> loadFrom(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" >= ? ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static List<Event> loadAfter(Connection connection, Instant time, long id) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"id\\\" > ?) ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            stmt.setTimestamp(2, Timestamp.from(time));\n            stmt.setLong(3, id);\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        LOG.debug(\"Loaded {} events\", events.size());\n        return events;\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                    \"INSERT INTO \\\"events\\\" (\\\"time\\\",\\\"type\\\",\\\"data\\\",\\\"removed\\\") \" +\n                            \"VALUES (?,?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(time));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false;\n                throw new IllegalStateException(e); // TODO(Roel): is this appropriate?\n            }\n            statement.setString(2, this.getClass().getSimpleName());\n            statement.setString(3, serialized);\n            statement.setBoolean(4, removed);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public void setRemoved(Connection connection, boolean removed) throws SQLException {\n        if (!isRemovable()) {\n            assert false; // This is a programming error\n            return;\n        }\n        PreparedStatement statement =\n                connection.prepareStatement(\n                        \"UPDATE \\\"events\\\" SET \\\"removed\\\"=? WHERE \\\"id\\\"=?\");\n        statement.setBoolean(1, removed);\n        statement.setLong(2, id);\n        boolean result = statement.execute();\n        assert(!result);\n        this.removed = true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/UpdateFrequencyChangeEvent.java\n@JsonTypeName(\"UpdateFrequencyChange\")\npublic final class UpdateFrequencyChangeEvent extends Event {\n    private final int updateFrequency;\n\n    @JsonCreator\n    public UpdateFrequencyChangeEvent(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withUpdateFrequency(updateFrequency).build();\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    public static UpdateFrequencyChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetUpdateFrequencyCommand);\n        SetUpdateFrequencyCommand cmd = (SetUpdateFrequencyCommand) command;\n        return new UpdateFrequencyChangeEvent(cmd.getTime(), cmd.getUpdateFrequency());\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/Serialization.java\npublic final class Serialization {\n    private static final ObjectMapper jsonMapper;\n\n    static {\n        jsonMapper = new ObjectMapper();\n        jsonMapper.findAndRegisterModules();\n    }\n\n    // Static methods only! No instances!\n    private Serialization() {\n    }\n\n    /**\n     * Get a JSON mapper, with all modules registered.\n     *\n     * This is equivalent to:\n     *\n     * [source,java]\n     * --\n     * jsonMapper = new ObjectMapper();\n     * jsonMapper.findAndRegisterModules();\n     * --\n     *\n     * @return A JSON ObjectMapper\n     */\n    public static ObjectMapper getJsonMapper() {\n        return jsonMapper;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Team.java\npublic final class Team {\n    private static final Logger LOG = LogManager.getLogger(Team.class);\n\n    private int teamNb;\n    private String name;\n    private ImmutableList<TagId> tags;\n\n    @SuppressWarnings(\"unused\")\n    private Team() {\n        this.teamNb = 0;\n        this.name = \"\";\n        tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name, ImmutableList<TagId> tags) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = tags;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public ImmutableList<TagId> getTags() {\n        return tags;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/EndEvent.java\n@JsonTypeName(\"End\")\npublic final class EndEvent extends Event {\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private EndEvent() {\n        super(Instant.MIN);\n    }\n\n    public EndEvent(Instant time) {\n        super(time);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withEndTime(getTime()).build();\n    }\n\n    public static EndEvent fromCommand(Command command) {\n        assert(command instanceof SetEndTimeCommand);\n        SetEndTimeCommand cmd = (SetEndTimeCommand) command;\n        return new EndEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/AddTagEvent.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagEvent extends TagEvent {\n    @JsonCreator\n    public AddTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().addTagToTeam(getTag(), getTeamNb());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static AddTagEvent fromCommand(Command command) {\n        assert(command instanceof AddTagCommand);\n        AddTagCommand addTagCommand = (AddTagCommand) command;\n        return new AddTagEvent(\n            addTagCommand.getTime(),\n            addTagCommand.getTag(),\n            addTagCommand.getTeamNb()\n        );\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/CommandProcessor.java\npublic final class CommandProcessor implements Runnable {\n    private static final Logger LOG = LogManager.getLogger(CommandProcessor.class);\n\n    private final Map<Class<? extends Command>, CommandHandler> commandHandlers = new HashMap<>();\n    private final Jedis jedis;\n    private final StatusReporter reporter;\n    private final String channel;\n\n    private BinaryJedisPubSub listener;\n\n    public CommandProcessor(URI redisUri, String commandChannel, String statusChannel) {\n        this(redisUri, JedisHelper.dbLocalChannel(commandChannel, redisUri),\n                new StatusReporter(redisUri, statusChannel));\n    }\n\n    public CommandProcessor(URI redisUri, String channel, StatusReporter statusReporter) {\n        this.jedis = JedisHelper.get(redisUri);\n        this.channel = JedisHelper.dbLocalChannel(channel, redisUri);\n        this.reporter = statusReporter;\n    }\n\n    public void run() {\n        jedis.subscribe(createCommandListener(), channel.getBytes());\n    }\n\n    private BinaryJedisPubSub createCommandListener() {\n        JedisHelper.BinaryCallBackPubSub pubSub = new JedisHelper.BinaryCallBackPubSub();\n        listener = pubSub;\n        pubSub.addOnMessageListener(this::onCommandMessage);\n        return pubSub;\n    }\n\n    private void onCommandMessage(byte[] channel, byte[] message) {\n        assert (Arrays.equals(channel, this.channel.getBytes()));\n        try {\n            Command command = Serialization.getJsonMapper().readValue(message, Command.class);\n            handleCommand(command);\n        } catch (IOException e) {\n            LOG.error(\"Couldn't parse command: {}\", new String(message), e);\n        }\n    }\n\n    public void addHandler(CommandHandler handler) {\n        commandHandlers.put(handler.getCommandClass(), handler);\n    }\n\n    private void handleCommand(Command command) {\n        LOG.debug(\"Handing command {}: {}\", command.getCommandId(), command.getClass().toString());\n        if (commandHandlers.containsKey(command.getClass())) {\n            commandHandlers.get(command.getClass()).handle(command, notifyCommandExecuted(command));\n        } else {\n            notifyCommandUnsupported(command);\n        }\n    }\n\n    private Consumer<Boolean> notifyCommandExecuted(Command command) {\n        return (result) -> {\n            if (result) {\n                notifySuccess(command);\n            } else {\n                notifyFailure(command);\n            }\n        };\n    }\n\n    private void notifySuccess(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_COMPLETE, command.getCommandId()));\n    }\n\n    private void notifyFailure(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_FAILED, command.getCommandId()));\n    }\n\n    private void notifyCommandUnsupported(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_UNSUPPORTED, command.getCommandId()));\n    }\n\n    public void stop() {\n        try {\n            listener.unsubscribe();\n        } catch (JedisConnectionException ignored) {\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusMessage.java\npublic final class StatusMessage {\n    private MessageType type;\n    private String details;\n\n    public enum MessageType {\n        /**\n         * The reader sends this message when no updates have been received for a while\n         */\n        NO_UPDATES,\n        /**\n         * Notifies that the system has started up\n         */\n        STARTED_UP,\n        /**\n         * Notifies that the startup has failed\n         */\n        STARTUP_FAILURE,\n        /**\n         * Notifies that the system is being shut down\n         */\n        SHUTDOWN,\n        /**\n         * Signals that the command given executed successfully.\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_COMPLETE,\n        /**\n         * Signals that no command handler is installed for the given command\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_UNSUPPORTED,\n        /**\n         * Signals that the command failed to execute\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_FAILED,\n        /**\n         * Signals that the processor's snapshot has been updated\n         */\n        NEW_SNAPSHOT,\n        /**\n         * Signals a miscellaneous error. The details field will contain more information\n         * about the error.\n         */\n        MISC_ERROR\n    }\n\n    /**\n     * Create a new status message with the given type and details.\n     *\n     * This message is to be broadcast by a StatusReporter to the\n     * status channel.\n     *\n     * @param type\n     *        The type of the status\n     * @param details\n     *        The details. The form of this field depends\n     *        on the type of message.\n     * @see org.ulyssis.ipp.status.StatusReporter\n     */\n    @JsonCreator\n    public StatusMessage(@JsonProperty(\"type\") MessageType type,\n                         @JsonProperty(\"details\") String details) {\n        this.type = type;\n        this.details = details;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/AddTagCommand.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagCommand extends TagCommand {\n\n    /**\n     * Create an AddTagCommand for the given tag and team number.\n     *\n     * The time is set to be the current time.\n     *\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    /**\n     * Create an AddTagCommand for the given tag and team number at the given time.\n     *\n     * @param time\n     *        The time when to add the tag, this can be in the future for\n     *        an anticipated adding of a tag, or in the past, to add a tag\n     *        afterwards (e.g. as a correction)\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    /*\n     * Only for deserialization.\n     */\n    @JsonCreator\n    private AddTagCommand(@JsonProperty(\"commandId\") String commandId,\n                          @JsonProperty(\"time\") Instant time,\n                          @JsonProperty(\"tag\") TagId tag,\n                          @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetEndTimeCommand.java\n@JsonTypeName(\"SetEndTime\")\npublic final class SetEndTimeCommand extends Command {\n    public SetEndTimeCommand() {\n        super();\n    }\n\n    public SetEndTimeCommand(Instant endTime) {\n        super(endTime);\n    }\n\n    @JsonCreator\n    private SetEndTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/RemoveTagEvent.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagEvent extends TagEvent {\n    @JsonCreator\n    public RemoveTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().removeTag(getTag());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static RemoveTagEvent fromCommand(Command command) {\n        assert(command instanceof RemoveTagCommand);\n        RemoveTagCommand cmd = (RemoveTagCommand) command;\n        return new RemoveTagEvent(cmd.getTime(), cmd.getTag(), cmd.getTeamNb());\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/control/handlers/EventCommandHandler.java\npublic final class EventCommandHandler<EventT extends Event> implements CommandHandler {\n    private final Class<? extends Command> clazz;\n    private final Function<Command, EventT> toEvent;\n    private final BiConsumer<Event, Consumer<Boolean>> processCallback;\n\n    public EventCommandHandler(Class<? extends Command> clazz,\n                               Function<Command, EventT> toEvent,\n                               BiConsumer<Event, Consumer<Boolean>> processCallback) {\n        this.clazz = clazz;\n        this.toEvent = toEvent;\n        this.processCallback = processCallback;\n    }\n\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        Event event = toEvent.apply(command);\n        processCallback.accept(event, callback);\n    }\n\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return clazz;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/CorrectionCommand.java\n@JsonTypeName(\"Correction\")\npublic class CorrectionCommand extends Command {\n    private final int teamNb;\n    private final int correction;\n\n    /**\n     * Create a CorrectionCommand\n     * @param teamNb\n     *        The team number to correct\n     * @param correction\n     *        The correction in nb. of laps. Positive adds laps,\n     *        negative removes laps.\n     */\n    public CorrectionCommand(int teamNb, int correction) {\n        super();\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public CorrectionCommand(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @JsonCreator\n    private CorrectionCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time,\n                              @JsonProperty(\"teamNb\") int teamNb,\n                              @JsonProperty(\"correction\") int correction) {\n        super(commandId, time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public int getCorrection() {\n        return correction;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/TagId.java\n@JsonSerialize(using=TagId.Serializer.class)\n@JsonDeserialize(using=TagId.Deserializer.class)\npublic final class TagId {\n    private final String id;\n    private final String lowerCaseId;\n    private final int hashCode;\n\n    static class Serializer extends JsonSerializer<TagId> {\n        @Override\n        public void serialize(TagId value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n            jgen.writeString(value.toString());\n        }\n    }\n\n    static class Deserializer extends JsonDeserializer<TagId> {\n        @Override\n        public TagId deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return new TagId(jp.getValueAsString());\n        }\n    }\n\n    /**\n     * = Create a new TagId from the given byte array.\n     *\n     * @param id\n     *        The tag id in byte array form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(byte[] id) {\n        this(BaseEncoding.base16().lowerCase().encode(id));\n    }\n\n    /**\n     * = Create a new TagId from the given byte list.\n     *\n     * @param id\n     *        The tag id in byte list form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(List<Byte> id) {\n        this(BaseEncoding.base16().lowerCase().encode(Bytes.toArray(id)));\n    }\n\n    /**\n     * = Create a new TagId\n     *\n     * @param id\n     *        A string that uniquely identifies the tag\n     * @throws java.lang.NullPointerException\n     *         A NullPointerException will be thrown if the given id is null.\n     */\n    public TagId(String id) throws NullPointerException {\n        if (id == null) throw new NullPointerException(\"The tag id is not allowed to be null!\");\n        this.id = id;\n        this.lowerCaseId = id.toLowerCase();\n        this.hashCode = this.lowerCaseId.hashCode();\n    }\n\n    /**\n     * = Get the tag id as a string\n     *\n     * @return This tag id as a string\n     */\n    @Override\n    public String toString() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (!(other instanceof TagId)) return false;\n        return this.lowerCaseId.equals(((TagId) other).lowerCaseId);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hashCode;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStartTimeCommand.java\n@JsonTypeName(\"SetStartTime\")\npublic final class SetStartTimeCommand extends Command {\n    public SetStartTimeCommand() {\n        super();\n    }\n\n    public SetStartTimeCommand(Instant startTime) {\n        super(startTime);\n    }\n\n    @JsonCreator\n    private SetStartTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                                @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Config.java\npublic class Config {\n    private static final Logger LOG = LogManager.getLogger(Config.class);\n\n    private double trackLength;\n    private ImmutableList<ReaderConfig> readers = ImmutableList.of();\n    private ImmutableList<URI> speedwayURIs = ImmutableList.of();\n    private ImmutableList<Team> teams = ImmutableList.of();\n    private long retryInterval = 5000L;\n    private long minUpdateInterval = 5000L;\n    private long maxUpdateInterval = 30000L;\n    private String statusChannel = \"status\";\n    private String updateChannel = \"update\";\n    private String updatesList = \"updates\";\n    private String updatesSet = \"updates\";\n    private String controlChannel = \"control\";\n\n    /**\n     * Private constructor used by Jackson\n     */\n    private Config() {\n    }\n    \n    /**\n     * Create a configuration from the given configuration file.\n     * \n     * Expects the configuration file to be UTF-8 formatted.\n     */\n    public static Optional<Config> fromConfigurationFile(Path configFile) {\n        try {\n            byte[] config = Files.readAllBytes(configFile);\n            Charset charset = Charset.forName(\"utf-8\");\n            String configString = charset.decode(ByteBuffer.wrap(config)).toString();\n            return fromConfigurationString(configString);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration file: {}\", configFile, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Create a configuration from the given JSON configuration string.\n     */\n    public static Optional<Config> fromConfigurationString(String configuration) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.findAndRegisterModules();\n        try {\n            Config result = mapper.readValue(configuration, Config.class);\n            return Optional.of(result);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration\", e);\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Get the track length in meters.\n     */\n    public double getTrackLength() {\n        return trackLength;\n    }\n\n    public ImmutableList<ReaderConfig> getReaders() {\n        return readers;\n    }\n    public ReaderConfig getReader(int readerId) {\n        return this.readers.get(readerId);\n    }\n    public int getNbReaders() {\n        return readers.size();\n    }\n\n    public ImmutableList<URI> getSpeedwayURIs() {\n        return speedwayURIs;\n    }\n    /**\n     * Get the URI of the Impinj Speedway corresponding\n     * to the reader with the given id. This id ranges from 0 to\n     * getSpeedwayURIs.size() - 1\n     */\n    public URI getSpeedwayURI(int readerId) {\n        return speedwayURIs.get(readerId);\n    }\n    public int getNbSpeedways() {\n        return speedwayURIs.size();\n    }\n\n    /**\n     * The retry interval for connections in ms.\n     */\n    public long getRetryInterval() {\n        return retryInterval;\n    }\n    \n    /**\n     * The minimum amount of time in ms between two updates, any\n     * update within this amount of time is ignored.\n     */\n    public long getMinUpdateInterval() {\n        return minUpdateInterval;\n    }\n    \n    /**\n     * The maximum time in ms to wait for an update before issuing a warning.\n     */\n    public long getMaxUpdateInterval() {\n        return maxUpdateInterval;\n    }\n    \n    /**\n     * Gets the Redis channel name on which status updates are posted.\n     *\n     * Defaults to \"status\".\n     *\n     * Generally, the db id will be added to the prefix, because\n     * pubsub channels are not database-specific in Redis.\n     */\n    public String getStatusChannel() {\n        return statusChannel;\n    }\n    \n    /**\n     * The prefix of the channel where the reader announces new updates.\n     *\n     * This prefix defaults to \"update\". Generally, the db id will be added\n     * to the prefix, because if multiple readers would use the same Redis\n     * instance (e.g. for testing purposes), these would collide, because\n     * pubsub channels are not database-specific.\n     */\n    public String getUpdateChannel() {\n        return updateChannel;\n    }\n\n    /**\n     * The prefix of the channel where an entity in the system receives control messages.\n     *\n     * This defaults to \"control\". Generally, the db id will be added to this prefix,\n     * because pubsub channels are not database-specific in Redis.\n     */\n    public String getControlChannel() {\n        return controlChannel;\n    }\n\n    /**\n     * The name of the list where readers push their updates on.\n     *\n     * Defaults to \"updates\".\n     */\n    public String getUpdatesList() {\n        return updatesList;\n    }\n\n    /**\n     * The name of the set in which updates are stored in the processor.\n     */\n    public String getUpdatesSet() {\n        return updatesSet;\n    }\n\n    /**\n     * The teams, with team number and name.\n     */\n    public ImmutableList<Team> getTeams() {\n        return teams;\n    }\n\n    // TODO: Maybe find some other solution?\n    private static Config currentConfig;\n\n    public static void setCurrentConfig(Config config) {\n        currentConfig = config;\n    }\n\n    public static Config getCurrentConfig() {\n        return currentConfig;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StatusChangeEvent.java\n@JsonTypeName(\"StatusChange\")\npublic final class StatusChangeEvent extends Event {\n    private final Status status;\n\n    @JsonCreator\n    public StatusChangeEvent(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\")Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public static StatusChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusCommand);\n        SetStatusCommand cmd = (SetStatusCommand) command;\n        return new StatusChangeEvent(cmd.getTime(), cmd.getStatus());\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        Snapshot.Builder builder = Snapshot.builder(getTime(), before).withStatus(status);\n        if (!before.getStatus().isPublic() && status.isPublic()) {\n            builder.withPublicTeamStates(before.getTeamStates());\n        }\n        return builder.build();\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.ulyssis.ipp.config.Config;\nimport org.ulyssis.ipp.config.ReaderConfig;\nimport org.ulyssis.ipp.config.Team;\nimport org.ulyssis.ipp.control.CommandProcessor;\nimport org.ulyssis.ipp.control.commands.AddTagCommand;\nimport org.ulyssis.ipp.control.commands.CorrectionCommand;\nimport org.ulyssis.ipp.control.commands.RemoveTagCommand;\nimport org.ulyssis.ipp.control.commands.SetEndTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStartTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusMessageCommand;\nimport org.ulyssis.ipp.control.commands.SetUpdateFrequencyCommand;\nimport org.ulyssis.ipp.control.handlers.EventCommandHandler;\nimport org.ulyssis.ipp.control.handlers.PingHandler;\nimport org.ulyssis.ipp.snapshot.Snapshot;\nimport org.ulyssis.ipp.snapshot.AddTagEvent;\nimport org.ulyssis.ipp.snapshot.CorrectionEvent;\nimport org.ulyssis.ipp.snapshot.EndEvent;\nimport org.ulyssis.ipp.snapshot.Event;\nimport org.ulyssis.ipp.snapshot.MessageEvent;\nimport org.ulyssis.ipp.snapshot.RemoveTagEvent;\nimport org.ulyssis.ipp.snapshot.StartEvent;\nimport org.ulyssis.ipp.snapshot.StatusChangeEvent;\nimport org.ulyssis.ipp.snapshot.UpdateFrequencyChangeEvent;\nimport org.ulyssis.ipp.status.StatusMessage;\nimport org.ulyssis.ipp.status.StatusReporter;\nimport org.ulyssis.ipp.utils.JedisHelper;\nimport org.ulyssis.ipp.utils.Serialization;\nimport org.ulyssis.ipp.TagId;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.sql.*;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_ONLY;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_WRITE;\n        }\n        URI uri = options.getRedisUri();\n        this.eventQueue = new LinkedBlockingQueue<>();\n        this.eventCallbacks  = new ConcurrentHashMap<>();\n        this.onStartedCallbacks = new CopyOnWriteArrayList<>();\n        this.readerListeners = new ArrayList<>();\n        this.threads = new ArrayList<>();\n        // TODO: Move status reporting and processing of commands to ZeroMQ?\n        // Also: post some stuff to a log in the db?\n        this.statusReporter = new StatusReporter(uri, Config.getCurrentConfig().getStatusChannel());\n        this.commandProcessor = new CommandProcessor(uri, Config.getCurrentConfig().getControlChannel(), statusReporter);\n        initCommandProcessor();\n        snapshot = new Snapshot(Instant.EPOCH);\n        if (!restoreFromDb()) {\n            registerInitialTags();\n        }\n    }\n\n    /**\n     * Restore the state from the database\n     *\n     * @return Whether we could restore from db, if false, we're starting from a clean slate\n     */\n    private boolean restoreFromDb() {\n        Connection connection = null;\n        Snapshot oldSnapshot = this.snapshot;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            Optional<Snapshot> snapshot = Snapshot.loadLatest(connection);\n            if (snapshot.isPresent()) {\n                this.snapshot = snapshot.get();\n                connection.commit();\n                return true;\n            } else {\n                List<Event> events = Event.loadAll(connection);\n                Snapshot snapshotBefore = this.snapshot;\n                // Instant now = Instant.now(); // TODO: Handle future events later!\n                for (Event event : events) {\n                    if (!event.isRemoved()/* && event.getTime().isBefore(now)*/) { // TODO: Future events later!\n                        this.snapshot = event.apply(this.snapshot);\n                        this.snapshot.save(connection);\n                    }\n                }\n                connection.commit();\n                return !Objects.equals(this.snapshot, snapshotBefore);\n            }\n        } catch (SQLException | IOException e) {\n            LOG.error(\"An error occurred when restoring from database!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void registerInitialTags() {\n        Snapshot oldSnapshot = this.snapshot;\n        Connection connection = null;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            for (Team team : Config.getCurrentConfig().getTeams()) {\n                for (TagId tag : team.getTags()) {\n                    AddTagEvent e = new AddTagEvent(Instant.EPOCH, tag, team.getTeamNb());\n                    e.save(connection);\n                    this.snapshot = e.apply(this.snapshot);\n                    this.snapshot.save(connection);\n                }\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            LOG.error(\"An error occurred when registering initial tags!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void initCommandProcessor() {\n        commandProcessor.addHandler(new PingHandler());\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(AddTagCommand.class, AddTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(RemoveTagCommand.class, RemoveTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(CorrectionCommand.class, CorrectionEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStartTimeCommand.class, StartEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetEndTimeCommand.class, EndEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusCommand.class, StatusChangeEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusMessageCommand.class, MessageEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(Next line of code:\n", "input": "import com.fasterxml.jackson.core.JsonProcessingException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.ulyssis.ipp.config.Config;\nimport org.ulyssis.ipp.config.ReaderConfig;\nimport org.ulyssis.ipp.config.Team;\nimport org.ulyssis.ipp.control.CommandProcessor;\nimport org.ulyssis.ipp.control.commands.AddTagCommand;\nimport org.ulyssis.ipp.control.commands.CorrectionCommand;\nimport org.ulyssis.ipp.control.commands.RemoveTagCommand;\nimport org.ulyssis.ipp.control.commands.SetEndTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStartTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusMessageCommand;\nimport org.ulyssis.ipp.control.commands.SetUpdateFrequencyCommand;\nimport org.ulyssis.ipp.control.handlers.EventCommandHandler;\nimport org.ulyssis.ipp.control.handlers.PingHandler;\nimport org.ulyssis.ipp.snapshot.Snapshot;\nimport org.ulyssis.ipp.snapshot.AddTagEvent;\nimport org.ulyssis.ipp.snapshot.CorrectionEvent;\nimport org.ulyssis.ipp.snapshot.EndEvent;\nimport org.ulyssis.ipp.snapshot.Event;\nimport org.ulyssis.ipp.snapshot.MessageEvent;\nimport org.ulyssis.ipp.snapshot.RemoveTagEvent;\nimport org.ulyssis.ipp.snapshot.StartEvent;\nimport org.ulyssis.ipp.snapshot.StatusChangeEvent;\nimport org.ulyssis.ipp.snapshot.UpdateFrequencyChangeEvent;\nimport org.ulyssis.ipp.status.StatusMessage;\nimport org.ulyssis.ipp.status.StatusReporter;\nimport org.ulyssis.ipp.utils.JedisHelper;\nimport org.ulyssis.ipp.utils.Serialization;\nimport org.ulyssis.ipp.TagId;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.sql.*;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_ONLY;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_WRITE;\n        }\n        URI uri = options.getRedisUri();\n        this.eventQueue = new LinkedBlockingQueue<>();\n        this.eventCallbacks  = new ConcurrentHashMap<>();\n        this.onStartedCallbacks = new CopyOnWriteArrayList<>();\n        this.readerListeners = new ArrayList<>();\n        this.threads = new ArrayList<>();\n        // TODO: Move status reporting and processing of commands to ZeroMQ?\n        // Also: post some stuff to a log in the db?\n        this.statusReporter = new StatusReporter(uri, Config.getCurrentConfig().getStatusChannel());\n        this.commandProcessor = new CommandProcessor(uri, Config.getCurrentConfig().getControlChannel(), statusReporter);\n        initCommandProcessor();\n        snapshot = new Snapshot(Instant.EPOCH);\n        if (!restoreFromDb()) {\n            registerInitialTags();\n        }\n    }\n\n    /**\n     * Restore the state from the database\n     *\n     * @return Whether we could restore from db, if false, we're starting from a clean slate\n     */\n    private boolean restoreFromDb() {\n        Connection connection = null;\n        Snapshot oldSnapshot = this.snapshot;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            Optional<Snapshot> snapshot = Snapshot.loadLatest(connection);\n            if (snapshot.isPresent()) {\n                this.snapshot = snapshot.get();\n                connection.commit();\n                return true;\n            } else {\n                List<Event> events = Event.loadAll(connection);\n                Snapshot snapshotBefore = this.snapshot;\n                // Instant now = Instant.now(); // TODO: Handle future events later!\n                for (Event event : events) {\n                    if (!event.isRemoved()/* && event.getTime().isBefore(now)*/) { // TODO: Future events later!\n                        this.snapshot = event.apply(this.snapshot);\n                        this.snapshot.save(connection);\n                    }\n                }\n                connection.commit();\n                return !Objects.equals(this.snapshot, snapshotBefore);\n            }\n        } catch (SQLException | IOException e) {\n            LOG.error(\"An error occurred when restoring from database!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void registerInitialTags() {\n        Snapshot oldSnapshot = this.snapshot;\n        Connection connection = null;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            for (Team team : Config.getCurrentConfig().getTeams()) {\n                for (TagId tag : team.getTags()) {\n                    AddTagEvent e = new AddTagEvent(Instant.EPOCH, tag, team.getTeamNb());\n                    e.save(connection);\n                    this.snapshot = e.apply(this.snapshot);\n                    this.snapshot.save(connection);\n                }\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            LOG.error(\"An error occurred when registering initial tags!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void initCommandProcessor() {\n        commandProcessor.addHandler(new PingHandler());\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(AddTagCommand.class, AddTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(RemoveTagCommand.class, RemoveTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(CorrectionCommand.class, CorrectionEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStartTimeCommand.class, StartEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetEndTimeCommand.class, EndEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusCommand.class, StatusChangeEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusMessageCommand.class, MessageEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(", "context": "shared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusCommand.java\n@JsonTypeName(\"SetStatus\")\npublic final class SetStatusCommand extends Command {\n    private final Status status;\n\n    public SetStatusCommand(Status status) {\n        super();\n        this.status = status;\n    }\n\n    @JsonCreator\n    private SetStatusCommand(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\") Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetUpdateFrequencyCommand.java\n@JsonTypeName(\"SetUpdateFrequency\")\npublic final class SetUpdateFrequencyCommand extends Command {\n    private final int updateFrequency;\n\n    public SetUpdateFrequencyCommand(int updateFrequency) {\n        super();\n        this.updateFrequency = updateFrequency;\n    }\n\n    @JsonCreator\n    private SetUpdateFrequencyCommand(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusMessageCommand.java\n@JsonTypeName(\"SetStatusMessage\")\npublic class SetStatusMessageCommand extends Command {\n    private final String message;\n\n    public SetStatusMessageCommand(String message) {\n        super();\n        this.message = message;\n    }\n\n    public SetStatusMessageCommand(Instant time, String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @JsonCreator\n    private SetStatusMessageCommand(@JsonProperty(\"commandId\") String commandId,\n                                    @JsonProperty(\"time\") Instant time,\n                                    @JsonProperty(\"message\") String message) {\n        super(commandId, time);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusReporter.java\npublic final class StatusReporter {\n    private static final Logger LOG = LogManager.getLogger(StatusReporter.class);\n    \n    private final Jedis jedis;\n    private final String statusChannel;\n\n    /**\n     * Create a new status reporter for the given Redis URI and status channel.\n     *\n     * @param redisURI\n     *        The URI for the Redis instance to report the status on. This should\n     *        be the \"own\" Redis instance.\n     * @param statusChannel\n     *        The channel to broadcast the status messages to. This channel is\n     *        made specific to the database, so if the `redisUri`\n     *        contains database `N`, and the channel is `status`,\n     *        then messages will be broadcast on channel `status:N`.\n     * @see org.ulyssis.ipp.utils.JedisHelper#dbLocalChannel(String, java.net.URI)\n     */\n    public StatusReporter(URI redisURI, String statusChannel) {\n        this.jedis = JedisHelper.get(redisURI);\n        this.statusChannel = JedisHelper.dbLocalChannel(statusChannel, redisURI);\n    }\n\n    /**\n     * Broadcast a status message.\n     *\n     * @param message\n     *        The message to broadcast\n     * @return True if the broadcast was successful, false if the broadcast was unsuccessful.\n     *         Failure to broadcast will be logged.\n     */\n    public synchronized boolean broadcast(StatusMessage message) {\n        if (jedis == null)\n            return false;\n        try {\n            jedis.publish(statusChannel.getBytes(), Serialization.getJsonMapper().writeValueAsBytes(message));\n            return true;\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error processing message {}\", message.getDetails(), e);\n            return false;\n        } catch (JedisConnectionException e) {\n            LOG.error(\"Couldn't connect to Redis when sending: {}\", message.getDetails(), e);\n            return false;\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/handlers/PingHandler.java\npublic final class PingHandler implements CommandHandler {\n\n    /**\n     * Handles the given command, which should be a PingCommand.\n     *\n     * @param command\n     *        The ping command to handle.\n     * @param callback\n     *        The ping callback, which is always invoked with true.\n     */\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        callback.accept(true);\n    }\n\n    /**\n     * Returns PingCommand.class\n     *\n     * @return PingCommand.class\n     */\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return PingCommand.class;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/ReaderConfig.java\npublic class ReaderConfig {\n    private URI uri;\n    private Type type = Type.LLRP;\n    private double position;\n    private List<SimulatedTeam> simulatedTeams = new ArrayList<>();\n\n    public static class SimulatedTeam {\n        private final TagId tag;\n        private final long lapTime;\n\n        @JsonCreator\n        public SimulatedTeam(\n                @JsonProperty(\"tag\") TagId tag,\n                @JsonProperty(\"lapTime\") long lapTime) {\n            this.tag = tag;\n            this.lapTime = lapTime;\n        }\n\n        public TagId getTag() {\n            return tag;\n        }\n\n        public long getLapTime() {\n            return lapTime;\n        }\n    }\n\n    public enum Type {\n        LLRP,\n        SIMULATOR\n    }\n\n    /**\n     * Private constructor used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private ReaderConfig() {\n    }\n\n    public URI getURI() {\n        return uri;\n    }\n    \n    /**\n     * Private setter used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private void setURI(URI uri) {\n        this.uri = uri;\n    }\n\n    public double getPosition() {\n        return position;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setPosition(double position) {\n        this.position = position;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setType(Type type) {\n        this.type = type;\n    }\n\n    public List<SimulatedTeam> getSimulatedTeams() {\n        return Collections.unmodifiableList(simulatedTeams);\n    }\n\n    public SimulatedTeam getSimulatedTeam(int id) {\n        return simulatedTeams.get(id);\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSimulatedTeams(List<SimulatedTeam> simulatedTeams) {\n        this.simulatedTeams = simulatedTeams;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/RemoveTagCommand.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagCommand extends TagCommand {\n    public RemoveTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    public RemoveTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @JsonCreator\n    private RemoveTagCommand(@JsonProperty(\"commandId\") String commandId,\n                             @JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"tag\") TagId tag,\n                             @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StartEvent.java\n@JsonTypeName(\"Start\")\npublic final class StartEvent extends Event {\n    /**\n     * Private constructor for Jackson\n     */\n    private StartEvent() {\n        super(Instant.MIN);\n    }\n\n    public StartEvent(Instant time) {\n        super(time);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withStartTime(getTime()).build();\n    }\n\n    public static StartEvent fromCommand(Command command) {\n        assert(command instanceof SetStartTimeCommand);\n        SetStartTimeCommand cmd = (SetStartTimeCommand) command;\n        return new StartEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/JedisHelper.java\npublic final class JedisHelper {\n\n    // Static methods only! No instances!\n    private JedisHelper() {\n    }\n\n    /**\n     * Get a new Jedis instance from the given URI\n     *\n     * The URI is formed as such:\n     * `new URI(\"redis://:password@host:port/database\")`\n     * for example:\n     * `new URI(\"redis://:hunter2@10.0.0.1:6379/0\")}`.\n     * The port, password and path can be omitted. If no path is\n     * supplied, database +0+ is selected. If no user\n     * info is supplied, then no authorization is performed.\n     * If no port is supplied, the default port +6379+\n     * is used.\n     *\n     * Use this instead of `new Jedis(uri)`, because\n     * that method does not allow to omit anything.\n     *\n     * @param uri\n     *        The URI for the Jedis instance.\n     * @return A new Jedis instance.\n     */\n    // TODO: Exceptions for wrong password, failing to parse database,...\n    public static Jedis get(URI uri) throws IllegalArgumentException {\n        int port = uri.getPort() != -1 ? uri.getPort() : 6379;\n        String host = uri.getHost();\n        Jedis result = new Jedis(host, port);\n        if (uri.getUserInfo() != null) {\n            String password = uri.getUserInfo().split(\":\")[1];\n            result.auth(password);\n        }\n        result.select(getDb(uri));\n        return result;\n    }\n\n    /**\n     * Extract the database number from the given Redis URI\n     *\n     * If the URI has the path +/N+, then +N+\n     * is returned. If the path is empty, +0+ is returned.\n     *\n     * @param uri\n     *        The URI\n     * @throws java.lang.IllegalArgumentException\n     *         The supplied path could not be parsed as an int\n     * @return The database number (+0+ for no path, +N+\n     *         if the path is +/N+)\n     */\n    public static int getDb(URI uri) throws IllegalArgumentException {\n        if (!Objects.equals(uri.getPath(), \"\")) {\n            try {\n                return Integer.parseInt(uri.getPath().split(\"/\", 2)[1]);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"The supplied path could not be parsed as an int\", e);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Generates a channel name that is local to a database.\n     *\n     * Redis channels are not tied to a single database, but are\n     * global to the instance of Redis. We, however, want to tie\n     * these to a certain database, so we have to add some information\n     * that does that. For this reason, if the channel name is\n     * +channel+, the database number +N+ is added to it\n     * to form +channel:N+. The database number is extracted\n     * using `getDb(uri)`.\n     *\n     * @param channel\n     *        The base channel name\n     * @param uri\n     *        The URI containing the database info\n     * @return +channel:N+, where +N+ is the database number\n     * @see org.ulyssis.ipp.utils.JedisHelper#getDb(java.net.URI)\n     */\n    public static String dbLocalChannel(String channel, URI uri) {\n        return channel + \":\" + getDb(uri);\n    }\n\n    /**\n     * A helper class that implements +BinaryJedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class BinaryCallBackPubSub extends BinaryJedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(byte[] pattern, byte[] channel, byte[] message);\n        }\n\n        private final List<BiConsumer<byte[],byte[]>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(byte[] channel, byte[] message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onMessage(byte[], byte[])\n         */\n        public void addOnMessageListener(BiConsumer<byte[],byte[]> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPMessage(byte[], byte[], byte[])\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(byte[] channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onSubscribe(byte[], int)\n         */\n        public void addOnSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(byte[] channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onUnsubscribe(byte[], int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(byte[] pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPSubscribe(byte[], int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPUnsubscribe(byte[], int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * A helper class that implements +JedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class CallBackPubSub extends JedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(String pattern, String channel, String message);\n        }\n\n        private final List<BiConsumer<String,String>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(String channel, String message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onMessage(String, String)\n         */\n        public void addOnMessageListener(BiConsumer<String, String> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(String pattern, String channel, String message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPMessage(String, String, String)\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onSubscribe(String, int)\n         */\n        public void addOnSubscribeListener(BiConsumer<String, Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onUnsubscribe(String, int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(String pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPSubscribe(String, int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<String, Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(String pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPUnsubscribe(String, int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Snapshot.java\npublic final class Snapshot {\n    private static final Logger LOG = LogManager.getLogger(Snapshot.class);\n\n    public static class Builder {\n        private Snapshot snapshot;\n\n        private Builder(Instant time, Snapshot other) {\n            snapshot = new Snapshot(time);\n            if (other != null) {\n                snapshot.teamTagMap = other.teamTagMap;\n                snapshot.startTime = other.startTime;\n                snapshot.endTime = other.endTime;\n                snapshot.teamStates = other.teamStates;\n                snapshot.publicTeamStates = other.publicTeamStates;\n                snapshot.statusMessage = other.statusMessage;\n                snapshot.status = other.status;\n                snapshot.updateFrequency = other.updateFrequency;\n            }\n        }\n\n        public Builder withTeamTagMap(TeamTagMap teamTagMap) {\n            this.snapshot.teamTagMap = teamTagMap;\n            return this;\n        }\n\n        public Builder withStartTime(Instant time) {\n            this.snapshot.startTime = time;\n            return this;\n        }\n\n        public Builder withEndTime(Instant time) {\n            this.snapshot.endTime = time;\n            return this;\n        }\n\n        public Builder withTeamStates(TeamStates teamStates) {\n            this.snapshot.teamStates = teamStates;\n            return this;\n        }\n\n        public Builder withPublicTeamStates(TeamStates teamStates) {\n            this.snapshot.publicTeamStates = teamStates;\n            return this;\n        }\n\n        public Builder withStatusMessage(String message) {\n            this.snapshot.statusMessage = message;\n            return this;\n        }\n\n        public Builder withStatus(Status status) {\n            this.snapshot.status = status;\n            return this;\n        }\n\n        public Builder withUpdateFrequency(int updateFrequency) {\n            this.snapshot.updateFrequency = updateFrequency;\n            return this;\n        }\n\n        public Snapshot build() {\n            return snapshot;\n        }\n    }\n\n    @JsonIgnore\n    private long id = -1;\n\n    @JsonIgnore\n    long eventId = -1;\n\n    public Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    public Optional<Long> getEventId() {\n        if (eventId != -1) return Optional.of(eventId);\n        else return Optional.empty();\n    }\n\n    /**\n     * Default constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private Snapshot() {\n    }\n\n    public Snapshot(Instant time) {\n        snapshotTime = time;\n    }\n\n    public Instant getSnapshotTime() {\n        return snapshotTime;\n    }\n\n    public TeamTagMap getTeamTagMap() {\n        return teamTagMap;\n    }\n\n    public Instant getStartTime() {\n        return startTime;\n    }\n\n    public Instant getEndTime() {\n        return endTime;\n    }\n\n    public TeamStates getTeamStates() {\n        return teamStates;\n    }\n\n    public TeamStates getPublicTeamStates() {\n        return publicTeamStates;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    private Instant snapshotTime = Instant.MIN;\n    private Instant startTime = Instant.MAX;\n    private Instant endTime = Instant.MAX;\n    private TeamTagMap teamTagMap = new TeamTagMap();\n    private TeamStates teamStates;\n    private TeamStates publicTeamStates;\n    {\n        teamStates = new TeamStates();\n        publicTeamStates = teamStates;\n    }\n    private String statusMessage = \"\";\n    private Status status = Status.NoResults;\n    private int updateFrequency = 3;\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"snapshots\\\" WHERE \\\"event\\\" = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setLong(1, event.getId().get());\n            LOG.debug(\"executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = event.getId().get();\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadLatest(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" ORDER BY \\\"time\\\" DESC FETCH FIRST ROW ONLY\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(statement)) {\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" \" +\n                \"WHERE \\\"time\\\" < ? ORDER BY \\\"time\\\" DESC, \\\"event\\\" DESC FETCH FIRST ROW ONLY\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                \"INSERT INTO \\\"snapshots\\\" (\\\"time\\\",\\\"data\\\",\\\"event\\\") VALUES (?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(snapshotTime));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false; // TODO(Roel): Programming error\n                return;\n            }\n            statement.setString(2, serialized);\n            statement.setLong(3, eventId);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public static void deleteAfter(Connection connection, Snapshot snapshot) throws SQLException {\n        String statement =\n                \"DELETE FROM \\\"snapshots\\\" WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"event\\\" > ?)\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            Timestamp timestamp = Timestamp.from(snapshot.getSnapshotTime());\n            stmt.setTimestamp(1, timestamp);\n            stmt.setTimestamp(2, timestamp);\n            stmt.setLong(3, snapshot.getEventId().orElse(-1L));\n            LOG.debug(\"Executing query: {}\", stmt);\n            int affectedRows = stmt.executeUpdate();\n            LOG.debug(\"deleteAfter affected {} rows\", affectedRows);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/MessageEvent.java\n@JsonTypeName(\"Message\")\npublic final class MessageEvent extends Event {\n    private final String message;\n\n    @JsonCreator\n    public MessageEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"message\") String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withStatusMessage(message).build();\n    }\n\n    public static MessageEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusMessageCommand);\n        SetStatusMessageCommand cmd = (SetStatusMessageCommand) command;\n        return new MessageEvent(cmd.getTime(), cmd.getMessage());\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/CorrectionEvent.java\n@JsonTypeName(\"Correction\")\npublic final class CorrectionEvent extends Event {\n    private int teamNb;\n    private int correction;\n\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private CorrectionEvent() {\n        super(Instant.MIN);\n    }\n\n    /**\n     * Create an event representing a correction of score.\n     *\n     * @param time\n     *        The time at which the corection is performed.\n     * @param teamNb\n     *        The number of the team to correct the score of.\n     * @param correction\n     *        The number of laps that should be added (positive)\n     *        or removed (negative)\n     */\n    public CorrectionEvent(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getCorrection() {\n        return correction;\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamStates oldTeamStates = snapshot.getTeamStates();\n        Optional<TeamState> oldTeamState = oldTeamStates.getStateForTeam(teamNb);\n        TeamState newTeamState;\n        if (oldTeamState.isPresent()) {\n            newTeamState = oldTeamState.get().addCorrection(correction);\n        } else {\n            newTeamState = new TeamState().addCorrection(correction);\n        }\n        return Snapshot.builder(getTime(), snapshot)\n                .withTeamStates(snapshot.getTeamStates().setStateForTeam(teamNb, newTeamState))\n                .build();\n    }\n\n    public static CorrectionEvent fromCommand(Command command) {\n        assert(command instanceof CorrectionCommand);\n        CorrectionCommand cmd = (CorrectionCommand) command;\n        return new CorrectionEvent(cmd.getTime(), cmd.getTeamNb(), cmd.getCorrection());\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Event.java\n@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n@JsonSubTypes({ @JsonSubTypes.Type(value=StartEvent.class),\n                @JsonSubTypes.Type(value=EndEvent.class),\n                @JsonSubTypes.Type(value=AddTagEvent.class),\n                @JsonSubTypes.Type(value=RemoveTagEvent.class),\n                @JsonSubTypes.Type(value=CorrectionEvent.class),\n                @JsonSubTypes.Type(value=TagSeenEvent.class),\n                @JsonSubTypes.Type(value=IdentityEvent.class),\n                @JsonSubTypes.Type(value=MessageEvent.class),\n                @JsonSubTypes.Type(value=StatusChangeEvent.class)})\npublic abstract class Event {\n    private static final Logger LOG = LogManager.getLogger(Event.class);\n\n    @JsonIgnore\n    private long id = -1;\n    @JsonIgnore\n    private boolean removed = false;\n\n    private Instant time;\n\n    protected Event(Instant time) {\n        this.time = time;\n    }\n\n    @JsonIgnore\n    public final Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    @JsonIgnore\n    public final boolean isRemoved() {\n        if (id == -1) throw new IllegalStateException(\"Trying to request removed state of event not in db\");\n        return removed;\n    }\n\n    public final Instant getTime() {\n        return time;\n    }\n\n    /**\n     * Determines whether this event should be isUnique, defaults to false\n     *\n     * @return whether this event should be isUnique (default implementation = false)\n     */\n    @JsonIgnore\n    public boolean isUnique() {\n        return false;\n    }\n\n    /**\n     * Determines whether this event can be removed or undone.\n     *\n     * @return whether this event can be removed or undone (default implementation = isUnique())\n     */\n    @JsonIgnore\n    public boolean isRemovable() {\n        return isUnique();\n    }\n\n    /**\n     * Apply this event to a snapshot, yielding the new snapshot\n     */\n    protected abstract Snapshot doApply(Snapshot before);\n\n    public final Snapshot apply(Snapshot before) {\n        assert !removed;\n        Snapshot result = doApply(before);\n        if (result == before && before.getEventId().isPresent()) {\n            // We need to copy it anyway\n            result = Snapshot.builder(getTime(), before).build();\n        }\n        result.eventId = this.id;\n        return result;\n    }\n\n    // TODO: How to deal with deserialization problem?\n    public static List<Event> loadAll(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"removed\\\" FROM \\\"events\\\" ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet result = stmt.executeQuery(statement)) {\n            while (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = result.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static Optional<Event> loadUnique(Connection connection, Class<? extends Event> eventType) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"events\\\" WHERE \\\"type\\\" = ? AND \\\"removed\\\" = false\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setString(1, eventType.getSimpleName());\n            ResultSet result = stmt.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = false;\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Event> load(Connection connection, long id) throws SQLException, IOException {\n        try (PreparedStatement statement =\n                connection.prepareStatement(\n                        \"SELECT \\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" WHERE \\\"id\\\"=?\")) {\n            statement.setLong(1, id);\n            ResultSet result = statement.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = id;\n                event.removed = result.getBoolean(\"removed\");\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static List<Event> loadFrom(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" >= ? ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static List<Event> loadAfter(Connection connection, Instant time, long id) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"id\\\" > ?) ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            stmt.setTimestamp(2, Timestamp.from(time));\n            stmt.setLong(3, id);\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        LOG.debug(\"Loaded {} events\", events.size());\n        return events;\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                    \"INSERT INTO \\\"events\\\" (\\\"time\\\",\\\"type\\\",\\\"data\\\",\\\"removed\\\") \" +\n                            \"VALUES (?,?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(time));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false;\n                throw new IllegalStateException(e); // TODO(Roel): is this appropriate?\n            }\n            statement.setString(2, this.getClass().getSimpleName());\n            statement.setString(3, serialized);\n            statement.setBoolean(4, removed);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public void setRemoved(Connection connection, boolean removed) throws SQLException {\n        if (!isRemovable()) {\n            assert false; // This is a programming error\n            return;\n        }\n        PreparedStatement statement =\n                connection.prepareStatement(\n                        \"UPDATE \\\"events\\\" SET \\\"removed\\\"=? WHERE \\\"id\\\"=?\");\n        statement.setBoolean(1, removed);\n        statement.setLong(2, id);\n        boolean result = statement.execute();\n        assert(!result);\n        this.removed = true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/UpdateFrequencyChangeEvent.java\n@JsonTypeName(\"UpdateFrequencyChange\")\npublic final class UpdateFrequencyChangeEvent extends Event {\n    private final int updateFrequency;\n\n    @JsonCreator\n    public UpdateFrequencyChangeEvent(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withUpdateFrequency(updateFrequency).build();\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    public static UpdateFrequencyChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetUpdateFrequencyCommand);\n        SetUpdateFrequencyCommand cmd = (SetUpdateFrequencyCommand) command;\n        return new UpdateFrequencyChangeEvent(cmd.getTime(), cmd.getUpdateFrequency());\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/Serialization.java\npublic final class Serialization {\n    private static final ObjectMapper jsonMapper;\n\n    static {\n        jsonMapper = new ObjectMapper();\n        jsonMapper.findAndRegisterModules();\n    }\n\n    // Static methods only! No instances!\n    private Serialization() {\n    }\n\n    /**\n     * Get a JSON mapper, with all modules registered.\n     *\n     * This is equivalent to:\n     *\n     * [source,java]\n     * --\n     * jsonMapper = new ObjectMapper();\n     * jsonMapper.findAndRegisterModules();\n     * --\n     *\n     * @return A JSON ObjectMapper\n     */\n    public static ObjectMapper getJsonMapper() {\n        return jsonMapper;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Team.java\npublic final class Team {\n    private static final Logger LOG = LogManager.getLogger(Team.class);\n\n    private int teamNb;\n    private String name;\n    private ImmutableList<TagId> tags;\n\n    @SuppressWarnings(\"unused\")\n    private Team() {\n        this.teamNb = 0;\n        this.name = \"\";\n        tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name, ImmutableList<TagId> tags) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = tags;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public ImmutableList<TagId> getTags() {\n        return tags;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/EndEvent.java\n@JsonTypeName(\"End\")\npublic final class EndEvent extends Event {\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private EndEvent() {\n        super(Instant.MIN);\n    }\n\n    public EndEvent(Instant time) {\n        super(time);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withEndTime(getTime()).build();\n    }\n\n    public static EndEvent fromCommand(Command command) {\n        assert(command instanceof SetEndTimeCommand);\n        SetEndTimeCommand cmd = (SetEndTimeCommand) command;\n        return new EndEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/AddTagEvent.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagEvent extends TagEvent {\n    @JsonCreator\n    public AddTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().addTagToTeam(getTag(), getTeamNb());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static AddTagEvent fromCommand(Command command) {\n        assert(command instanceof AddTagCommand);\n        AddTagCommand addTagCommand = (AddTagCommand) command;\n        return new AddTagEvent(\n            addTagCommand.getTime(),\n            addTagCommand.getTag(),\n            addTagCommand.getTeamNb()\n        );\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/CommandProcessor.java\npublic final class CommandProcessor implements Runnable {\n    private static final Logger LOG = LogManager.getLogger(CommandProcessor.class);\n\n    private final Map<Class<? extends Command>, CommandHandler> commandHandlers = new HashMap<>();\n    private final Jedis jedis;\n    private final StatusReporter reporter;\n    private final String channel;\n\n    private BinaryJedisPubSub listener;\n\n    public CommandProcessor(URI redisUri, String commandChannel, String statusChannel) {\n        this(redisUri, JedisHelper.dbLocalChannel(commandChannel, redisUri),\n                new StatusReporter(redisUri, statusChannel));\n    }\n\n    public CommandProcessor(URI redisUri, String channel, StatusReporter statusReporter) {\n        this.jedis = JedisHelper.get(redisUri);\n        this.channel = JedisHelper.dbLocalChannel(channel, redisUri);\n        this.reporter = statusReporter;\n    }\n\n    public void run() {\n        jedis.subscribe(createCommandListener(), channel.getBytes());\n    }\n\n    private BinaryJedisPubSub createCommandListener() {\n        JedisHelper.BinaryCallBackPubSub pubSub = new JedisHelper.BinaryCallBackPubSub();\n        listener = pubSub;\n        pubSub.addOnMessageListener(this::onCommandMessage);\n        return pubSub;\n    }\n\n    private void onCommandMessage(byte[] channel, byte[] message) {\n        assert (Arrays.equals(channel, this.channel.getBytes()));\n        try {\n            Command command = Serialization.getJsonMapper().readValue(message, Command.class);\n            handleCommand(command);\n        } catch (IOException e) {\n            LOG.error(\"Couldn't parse command: {}\", new String(message), e);\n        }\n    }\n\n    public void addHandler(CommandHandler handler) {\n        commandHandlers.put(handler.getCommandClass(), handler);\n    }\n\n    private void handleCommand(Command command) {\n        LOG.debug(\"Handing command {}: {}\", command.getCommandId(), command.getClass().toString());\n        if (commandHandlers.containsKey(command.getClass())) {\n            commandHandlers.get(command.getClass()).handle(command, notifyCommandExecuted(command));\n        } else {\n            notifyCommandUnsupported(command);\n        }\n    }\n\n    private Consumer<Boolean> notifyCommandExecuted(Command command) {\n        return (result) -> {\n            if (result) {\n                notifySuccess(command);\n            } else {\n                notifyFailure(command);\n            }\n        };\n    }\n\n    private void notifySuccess(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_COMPLETE, command.getCommandId()));\n    }\n\n    private void notifyFailure(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_FAILED, command.getCommandId()));\n    }\n\n    private void notifyCommandUnsupported(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_UNSUPPORTED, command.getCommandId()));\n    }\n\n    public void stop() {\n        try {\n            listener.unsubscribe();\n        } catch (JedisConnectionException ignored) {\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusMessage.java\npublic final class StatusMessage {\n    private MessageType type;\n    private String details;\n\n    public enum MessageType {\n        /**\n         * The reader sends this message when no updates have been received for a while\n         */\n        NO_UPDATES,\n        /**\n         * Notifies that the system has started up\n         */\n        STARTED_UP,\n        /**\n         * Notifies that the startup has failed\n         */\n        STARTUP_FAILURE,\n        /**\n         * Notifies that the system is being shut down\n         */\n        SHUTDOWN,\n        /**\n         * Signals that the command given executed successfully.\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_COMPLETE,\n        /**\n         * Signals that no command handler is installed for the given command\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_UNSUPPORTED,\n        /**\n         * Signals that the command failed to execute\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_FAILED,\n        /**\n         * Signals that the processor's snapshot has been updated\n         */\n        NEW_SNAPSHOT,\n        /**\n         * Signals a miscellaneous error. The details field will contain more information\n         * about the error.\n         */\n        MISC_ERROR\n    }\n\n    /**\n     * Create a new status message with the given type and details.\n     *\n     * This message is to be broadcast by a StatusReporter to the\n     * status channel.\n     *\n     * @param type\n     *        The type of the status\n     * @param details\n     *        The details. The form of this field depends\n     *        on the type of message.\n     * @see org.ulyssis.ipp.status.StatusReporter\n     */\n    @JsonCreator\n    public StatusMessage(@JsonProperty(\"type\") MessageType type,\n                         @JsonProperty(\"details\") String details) {\n        this.type = type;\n        this.details = details;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/AddTagCommand.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagCommand extends TagCommand {\n\n    /**\n     * Create an AddTagCommand for the given tag and team number.\n     *\n     * The time is set to be the current time.\n     *\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    /**\n     * Create an AddTagCommand for the given tag and team number at the given time.\n     *\n     * @param time\n     *        The time when to add the tag, this can be in the future for\n     *        an anticipated adding of a tag, or in the past, to add a tag\n     *        afterwards (e.g. as a correction)\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    /*\n     * Only for deserialization.\n     */\n    @JsonCreator\n    private AddTagCommand(@JsonProperty(\"commandId\") String commandId,\n                          @JsonProperty(\"time\") Instant time,\n                          @JsonProperty(\"tag\") TagId tag,\n                          @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetEndTimeCommand.java\n@JsonTypeName(\"SetEndTime\")\npublic final class SetEndTimeCommand extends Command {\n    public SetEndTimeCommand() {\n        super();\n    }\n\n    public SetEndTimeCommand(Instant endTime) {\n        super(endTime);\n    }\n\n    @JsonCreator\n    private SetEndTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/RemoveTagEvent.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagEvent extends TagEvent {\n    @JsonCreator\n    public RemoveTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().removeTag(getTag());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static RemoveTagEvent fromCommand(Command command) {\n        assert(command instanceof RemoveTagCommand);\n        RemoveTagCommand cmd = (RemoveTagCommand) command;\n        return new RemoveTagEvent(cmd.getTime(), cmd.getTag(), cmd.getTeamNb());\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/control/handlers/EventCommandHandler.java\npublic final class EventCommandHandler<EventT extends Event> implements CommandHandler {\n    private final Class<? extends Command> clazz;\n    private final Function<Command, EventT> toEvent;\n    private final BiConsumer<Event, Consumer<Boolean>> processCallback;\n\n    public EventCommandHandler(Class<? extends Command> clazz,\n                               Function<Command, EventT> toEvent,\n                               BiConsumer<Event, Consumer<Boolean>> processCallback) {\n        this.clazz = clazz;\n        this.toEvent = toEvent;\n        this.processCallback = processCallback;\n    }\n\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        Event event = toEvent.apply(command);\n        processCallback.accept(event, callback);\n    }\n\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return clazz;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/CorrectionCommand.java\n@JsonTypeName(\"Correction\")\npublic class CorrectionCommand extends Command {\n    private final int teamNb;\n    private final int correction;\n\n    /**\n     * Create a CorrectionCommand\n     * @param teamNb\n     *        The team number to correct\n     * @param correction\n     *        The correction in nb. of laps. Positive adds laps,\n     *        negative removes laps.\n     */\n    public CorrectionCommand(int teamNb, int correction) {\n        super();\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public CorrectionCommand(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @JsonCreator\n    private CorrectionCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time,\n                              @JsonProperty(\"teamNb\") int teamNb,\n                              @JsonProperty(\"correction\") int correction) {\n        super(commandId, time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public int getCorrection() {\n        return correction;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/TagId.java\n@JsonSerialize(using=TagId.Serializer.class)\n@JsonDeserialize(using=TagId.Deserializer.class)\npublic final class TagId {\n    private final String id;\n    private final String lowerCaseId;\n    private final int hashCode;\n\n    static class Serializer extends JsonSerializer<TagId> {\n        @Override\n        public void serialize(TagId value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n            jgen.writeString(value.toString());\n        }\n    }\n\n    static class Deserializer extends JsonDeserializer<TagId> {\n        @Override\n        public TagId deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return new TagId(jp.getValueAsString());\n        }\n    }\n\n    /**\n     * = Create a new TagId from the given byte array.\n     *\n     * @param id\n     *        The tag id in byte array form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(byte[] id) {\n        this(BaseEncoding.base16().lowerCase().encode(id));\n    }\n\n    /**\n     * = Create a new TagId from the given byte list.\n     *\n     * @param id\n     *        The tag id in byte list form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(List<Byte> id) {\n        this(BaseEncoding.base16().lowerCase().encode(Bytes.toArray(id)));\n    }\n\n    /**\n     * = Create a new TagId\n     *\n     * @param id\n     *        A string that uniquely identifies the tag\n     * @throws java.lang.NullPointerException\n     *         A NullPointerException will be thrown if the given id is null.\n     */\n    public TagId(String id) throws NullPointerException {\n        if (id == null) throw new NullPointerException(\"The tag id is not allowed to be null!\");\n        this.id = id;\n        this.lowerCaseId = id.toLowerCase();\n        this.hashCode = this.lowerCaseId.hashCode();\n    }\n\n    /**\n     * = Get the tag id as a string\n     *\n     * @return This tag id as a string\n     */\n    @Override\n    public String toString() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (!(other instanceof TagId)) return false;\n        return this.lowerCaseId.equals(((TagId) other).lowerCaseId);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hashCode;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStartTimeCommand.java\n@JsonTypeName(\"SetStartTime\")\npublic final class SetStartTimeCommand extends Command {\n    public SetStartTimeCommand() {\n        super();\n    }\n\n    public SetStartTimeCommand(Instant startTime) {\n        super(startTime);\n    }\n\n    @JsonCreator\n    private SetStartTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                                @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Config.java\npublic class Config {\n    private static final Logger LOG = LogManager.getLogger(Config.class);\n\n    private double trackLength;\n    private ImmutableList<ReaderConfig> readers = ImmutableList.of();\n    private ImmutableList<URI> speedwayURIs = ImmutableList.of();\n    private ImmutableList<Team> teams = ImmutableList.of();\n    private long retryInterval = 5000L;\n    private long minUpdateInterval = 5000L;\n    private long maxUpdateInterval = 30000L;\n    private String statusChannel = \"status\";\n    private String updateChannel = \"update\";\n    private String updatesList = \"updates\";\n    private String updatesSet = \"updates\";\n    private String controlChannel = \"control\";\n\n    /**\n     * Private constructor used by Jackson\n     */\n    private Config() {\n    }\n    \n    /**\n     * Create a configuration from the given configuration file.\n     * \n     * Expects the configuration file to be UTF-8 formatted.\n     */\n    public static Optional<Config> fromConfigurationFile(Path configFile) {\n        try {\n            byte[] config = Files.readAllBytes(configFile);\n            Charset charset = Charset.forName(\"utf-8\");\n            String configString = charset.decode(ByteBuffer.wrap(config)).toString();\n            return fromConfigurationString(configString);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration file: {}\", configFile, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Create a configuration from the given JSON configuration string.\n     */\n    public static Optional<Config> fromConfigurationString(String configuration) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.findAndRegisterModules();\n        try {\n            Config result = mapper.readValue(configuration, Config.class);\n            return Optional.of(result);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration\", e);\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Get the track length in meters.\n     */\n    public double getTrackLength() {\n        return trackLength;\n    }\n\n    public ImmutableList<ReaderConfig> getReaders() {\n        return readers;\n    }\n    public ReaderConfig getReader(int readerId) {\n        return this.readers.get(readerId);\n    }\n    public int getNbReaders() {\n        return readers.size();\n    }\n\n    public ImmutableList<URI> getSpeedwayURIs() {\n        return speedwayURIs;\n    }\n    /**\n     * Get the URI of the Impinj Speedway corresponding\n     * to the reader with the given id. This id ranges from 0 to\n     * getSpeedwayURIs.size() - 1\n     */\n    public URI getSpeedwayURI(int readerId) {\n        return speedwayURIs.get(readerId);\n    }\n    public int getNbSpeedways() {\n        return speedwayURIs.size();\n    }\n\n    /**\n     * The retry interval for connections in ms.\n     */\n    public long getRetryInterval() {\n        return retryInterval;\n    }\n    \n    /**\n     * The minimum amount of time in ms between two updates, any\n     * update within this amount of time is ignored.\n     */\n    public long getMinUpdateInterval() {\n        return minUpdateInterval;\n    }\n    \n    /**\n     * The maximum time in ms to wait for an update before issuing a warning.\n     */\n    public long getMaxUpdateInterval() {\n        return maxUpdateInterval;\n    }\n    \n    /**\n     * Gets the Redis channel name on which status updates are posted.\n     *\n     * Defaults to \"status\".\n     *\n     * Generally, the db id will be added to the prefix, because\n     * pubsub channels are not database-specific in Redis.\n     */\n    public String getStatusChannel() {\n        return statusChannel;\n    }\n    \n    /**\n     * The prefix of the channel where the reader announces new updates.\n     *\n     * This prefix defaults to \"update\". Generally, the db id will be added\n     * to the prefix, because if multiple readers would use the same Redis\n     * instance (e.g. for testing purposes), these would collide, because\n     * pubsub channels are not database-specific.\n     */\n    public String getUpdateChannel() {\n        return updateChannel;\n    }\n\n    /**\n     * The prefix of the channel where an entity in the system receives control messages.\n     *\n     * This defaults to \"control\". Generally, the db id will be added to this prefix,\n     * because pubsub channels are not database-specific in Redis.\n     */\n    public String getControlChannel() {\n        return controlChannel;\n    }\n\n    /**\n     * The name of the list where readers push their updates on.\n     *\n     * Defaults to \"updates\".\n     */\n    public String getUpdatesList() {\n        return updatesList;\n    }\n\n    /**\n     * The name of the set in which updates are stored in the processor.\n     */\n    public String getUpdatesSet() {\n        return updatesSet;\n    }\n\n    /**\n     * The teams, with team number and name.\n     */\n    public ImmutableList<Team> getTeams() {\n        return teams;\n    }\n\n    // TODO: Maybe find some other solution?\n    private static Config currentConfig;\n\n    public static void setCurrentConfig(Config config) {\n        currentConfig = config;\n    }\n\n    public static Config getCurrentConfig() {\n        return currentConfig;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StatusChangeEvent.java\n@JsonTypeName(\"StatusChange\")\npublic final class StatusChangeEvent extends Event {\n    private final Status status;\n\n    @JsonCreator\n    public StatusChangeEvent(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\")Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public static StatusChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusCommand);\n        SetStatusCommand cmd = (SetStatusCommand) command;\n        return new StatusChangeEvent(cmd.getTime(), cmd.getStatus());\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        Snapshot.Builder builder = Snapshot.builder(getTime(), before).withStatus(status);\n        if (!before.getStatus().isPublic() && status.isPublic()) {\n            builder.withPublicTeamStates(before.getTeamStates());\n        }\n        return builder.build();\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\n", "answers": ["                new EventCommandHandler<>(SetUpdateFrequencyCommand.class, UpdateFrequencyChangeEvent::fromCommand, this::queueEvent));"], "pred": "  queueEvent::                                                            ", "length": 6872, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "2c164c959e45cbd40c80a8618dfe2fbe7d12a613e0ce71c4"}
{"prompt": "Please complete the code given below. \nsrc/main/java/uw/task/util/LocalRateLimiter.java\npublic class LocalRateLimiter {\r\n\r\n    private ConcurrentHashMap<String, RateLimiter> map = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u83b7\u5f97\u9650\u5236\u5141\u8bb8\u72b6\u6001\u3002\r\n     *\r\n     * @param name\r\n     * @return\r\n     */\r\n    public boolean tryAcquire(String name, int requests, int seconds, long waitTime, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return true;\r\n        }\r\n        final double rate = (double) requests / (double) seconds;\r\n        RateLimiter limiter = map.computeIfAbsent(name, key -> RateLimiter.create(rate));\r\n        if (limiter != null) {\r\n            //\u68c0\u67e5\u5e76\u4fee\u6539\r\n            if (limiter.getRate() != rate) {\r\n                limiter.setRate(rate);\r\n            }\r\n            return limiter.tryAcquire(permits, waitTime, TimeUnit.SECONDS);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskFactory.java\npublic class TaskFactory {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskFactory.class);\n\n    /**\n     * rabbitTemplate\u6a21\u677f.\n     */\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * \u5168\u5c40sequence\u5e8f\u5217\uff0c\u4e3b\u8981\u7528\u4e8etaskLog\u65e5\u5fd7\u3002\n     */\n    private GlobalSequenceManager globalSequenceManager;\n\n    /**\n     * \u7528\u4e8e\u672c\u5730\u6267\u884c\u4efb\u52a1\u7684taskConsumer\u3002\n     */\n    private TaskRunnerContainer taskRunnerContainer;\n\n    /**\n     * rpc\u5f02\u6b65\u8c03\u7528\u7ebf\u7a0b\u6c60\n     */\n    private ExecutorService taskRpcService = null;\n\n    /**\n     * \u6700\u5927\u91cd\u8bd5\u6b21\u6570\u3002\n     */\n    private static final int MAX_RETRY_TIMES = 10;\n\n\n    public TaskFactory(TaskProperties taskProperties, RabbitTemplate rabbitTemplate,\n                       TaskRunnerContainer taskRunnerContainer, GlobalSequenceManager globalSequenceManager) {\n        this.rabbitTemplate = rabbitTemplate;\n        this.taskRunnerContainer = taskRunnerContainer;\n        this.globalSequenceManager = globalSequenceManager;\n        taskRpcService = new ThreadPoolExecutor(taskProperties.getTaskRpcMinThreadNum(),\n                taskProperties.getTaskRpcMaxThreadNum(), 20L, TimeUnit.SECONDS, new SynchronousQueue<>(),\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"TaskRpc-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    }\n\n    /**\n     * \u628a\u4efb\u52a1\u53d1\u9001\u5230\u961f\u5217\u4e2d\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     */\n    public void sendToQueue(final TaskData<?, ?> taskData) {\n        Message message = buildTaskQueueMessage(taskData);\n        String queue = message.getMessageProperties().getConsumerQueue();\n        //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n        for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n            try {\n                if (i > 0) {\n                    Thread.sleep(i * 500);\n                }\n                rabbitTemplate.send(queue, queue, message);\n                return;\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n        throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n    }\n\n    /**\n     * \u6784\u9020Task\u6d88\u606f\u5bf9\u8c61\uff0c\u6b64\u65b9\u6cd5\u7528\u4e8e\u63d0\u524d\u6784\u9020TaskData\u3002\n     *\n     * @param taskData\n     * @return\n     */\n    private Message buildTaskQueueMessage(final TaskData taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        taskData.setRunType(TaskData.RUN_TYPE_GLOBAL);\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setConsumerQueue(TaskMetaInfoManager.getFitQueue(taskData));\n        Message msg = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n        return msg;\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTask(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n            for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                try {\n                    if (i > 0) {\n                        Thread.sleep(i * 500);\n                    }\n                    Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                    return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n            throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n        }\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTaskLocal(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            throw new TaskRuntimeException(taskData.getClass().getName() + \" is not a local task! \");\n        }\n    }\n\n    /**\n     * \u8fdc\u7a0b\u8fd0\u884c\u4efb\u52a1\uff0c\u5e76\u8fd4\u56defuture<TaskData<?,?>>\u3002 \u5982\u679c\u9700\u8981\u83b7\u5f97\u6570\u636e\uff0c\u53ef\u4ee5\u4f7f\u7528futrue.get()\u6765\u83b7\u5f97\u3002\n     * \u6b64\u65b9\u6cd5\u8981\u8c28\u614e\u4f7f\u7528\uff0c\u56e0\u4e3atask\u5b58\u5728\u9650\u901f\uff0c\u5927\u5e76\u53d1\u4e0b\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7ebf\u7a0b\u6570\u8d85\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> Future<TaskData<TP, RD>> runTaskAsync(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            return taskRpcService.submit(() -> {\n                taskRunnerContainer.process(taskData);\n                return taskData;\n            });\n        } else {\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            return taskRpcService.submit(() -> {\n                //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n                for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                    try {\n                        if (i > 0) {\n                            Thread.sleep(i * 500);\n                        }\n                        Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                        return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                    } catch (Exception e) {\n                        log.error(e.getMessage(), e);\n                    }\n                }\n                throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n            });\n        }\n    }\n\n    /**\n     * \u83b7\u5f97\u961f\u5217\u4fe1\u606f\u3002\n     *\n     * @param queueName\n     * @return 0 \u662f\u6d88\u606f\u6570\u91cf 1 \u662f\u6d88\u8d39\u8005\u6570\u91cf\n     */\n    public int[] getQueueInfo(String queueName) {\n        AMQP.Queue.DeclareOk declareOk = this.rabbitTemplate.execute(new ChannelCallback<AMQP.Queue.DeclareOk>() {\n            public AMQP.Queue.DeclareOk doInRabbit(Channel channel) throws Exception {\n                return channel.queueDeclarePassive(queueName);\n            }\n        });\n        return new int[]{declareOk.getMessageCount(), declareOk.getConsumerCount()};\n    }\n\n    /**\n     * \u6e05\u9664\u961f\u5217\u3002\n     *\n     * @param queueName\n     * @return \u88ab\u6e05\u9664\u7684\u961f\u5217\u6570\n     */\n    public int purgeQueue(String queueName) {\n        return this.rabbitTemplate.execute(channel -> {\n            AMQP.Queue.PurgeOk queuePurged = channel.queuePurge(queueName);\n            return queuePurged.getMessageCount();\n        });\n    }\n\n}\nsrc/main/java/uw/task/listener/RunnerTaskListener.java\npublic interface RunnerTaskListener {\r\n\r\n    /**\r\n     * \u6267\u884c\u524d\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPreExecute(TaskData data);\r\n\r\n    /**\r\n     * \u6267\u884c\u540e\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPostExecute(TaskData data);\r\n\r\n}\r\nsrc/main/java/uw/task/util/GlobalRateLimiter.java\npublic class GlobalRateLimiter {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(GlobalRateLimiter.class);\r\n\r\n    private static final String REDIS_PREFIX = \"TaskRateLimit:\";\r\n\r\n    private final RedisTemplate<String, Long> redisTemplate;\r\n\r\n    /**\r\n     * LUA\u811a\u672c\u3002\r\n     * \u8fd4\u56de\u503c\u4e3a\uff1a\u53ef\u7528\u8bf7\u6c42\u6570,\u7b49\u5f85\u6beb\u79d2\u6570\u3002\r\n     */\r\n    private static final RedisScript<Long> LUA_RATE_LIMIT = RedisScript.of(\r\n            \"local key = KEYS[1];\\n\" +\r\n                    \"local requests = tonumber(ARGV[1]);\\n\" +\r\n                    \"local millis = tonumber(ARGV[2])*1000;\\n\" +\r\n                    \"local permits = tonumber(ARGV[3]);\\n\" +\r\n                    \"local remainRequests=0;\\n\" +\r\n                    \"local waitMillis=0;\\n\" +\r\n                    \"local nowRate= redis.call('INCRBY', key,permits);\\n\" +\r\n                    \"if (nowRate==permits) then \\n\" +//\u5982\u679c\u662f\u7b2c\u4e00\u6b21\u6267\u884c\uff0c\u8bbe\u7f6e\u6709\u6548\u671f\u4fdd\u62a4\u3002\r\n                    \"    redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"end\\n\" +\r\n                    \"remainRequests = requests-nowRate;\\n\" +\r\n                    \"if (remainRequests<1) then \\n\" +//\u8bf7\u6c42\u6570\u8d85\u8fc7\u9650\u5236\r\n                    \"    waitMillis = redis.call('PTTL',key);\\n\" +\r\n                    \"    if (waitMillis == -1) then \\n\" +\r\n                    \"        redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"        waitMillis = millis;\\n\" +\r\n                    \"    end\\n\" +\r\n                    \"end \\n\" +\r\n                    \"return waitMillis\", Long.class);\r\n\r\n\r\n    public GlobalRateLimiter(final RedisConnectionFactory redisConnectionFactory) {\r\n        redisTemplate = new RedisTemplate<String, Long>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericToStringSerializer<Long>(Long.class));\r\n        redisTemplate.setExposeConnection(true);\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.afterPropertiesSet();\r\n    }\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u53ef\u5426\u83b7\u5f97\u6388\u6743\u3002\r\n     *\r\n     * @param permits       \u7533\u8bf7\u8bbf\u95ee\u6b21\u6570\r\n     * @return \u5982\u679c\u672a\u8d85\u9650\u5219\u8fd4\u56de0\uff0c-1\u4e3a\u4e0d\u786e\u5b9a\u65f6\u95f4\uff0c\u5176\u4ed6\u4e3a\u9700\u8981\u7b49\u5f85\u7684\u6beb\u79d2\u6570\r\n     */\r\n    public long tryAcquire(String name, int requests, int seconds, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return 0;\r\n        }\r\n        Long waitLimit = redisTemplate.execute(LUA_RATE_LIMIT, Collections.singletonList(REDIS_PREFIX + name), requests,seconds, permits);\r\n        if (waitLimit==null)\r\n            return 0;\r\n        else\r\n            return waitLimit;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/exception/TaskPartnerException.java\npublic class TaskPartnerException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskPartnerException() {\r\n        super();\r\n    }\r\n\r\n    public TaskPartnerException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskPartnerException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskPartnerException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/TaskData.java\npublic class TaskData<TP, RD> implements Serializable {\n\n    /**\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 1333167065535557828L;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u672a\u8bbe\u7f6e\n     */\n    public static final int STATE_UNKNOWN = 0;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6210\u529f\n     */\n    public static final int STATE_SUCCESS = 1;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7a0b\u5e8f\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PROGRAM = 2;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u914d\u7f6e\u9519\u8bef\uff0c\u5982\u8d85\u8fc7\u6d41\u91cf\u9650\u5236\n     */\n    public static final int STATE_FAIL_CONFIG = 3;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7b2c\u4e09\u65b9\u63a5\u53e3\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PARTNER = 4;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6570\u636e\u9519\u8bef\n     */\n    public static final int STATE_FAIL_DATA = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u672c\u5730\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_LOCAL = 1;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_GLOBAL = 3;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\n     */\n    public static final int RUN_TYPE_GLOBAL_RPC = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u81ea\u52a8\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\uff0c\u4f7f\u7528\u6b64\u6a21\u5f0f\uff0c\u4f1a\u81ea\u52a8\u9009\u62e9\u672c\u5730\u8fd8\u8fdc\u7a0b\u8fd0\u884c\u6a21\u5f0f\u3002\n     */\n    public static final int RUN_TYPE_AUTO_RPC = 6;\n\n    /**\n     * \u81ea\u52a8\u91cd\u8bd5[\u4e3a\u4e86\u517c\u5bb9,\u9ed8\u8ba4\u5f00\u542f\u91cd\u8bd5]\n     */\n    public static final int RETRY_TYPE_AUTO = 0;\n\n    /**\n     * \u7528\u6237\u624b\u5de5\u91cd\u8bd5\n     */\n    public static final int RETRY_TYPE_MANUAL = 1;\n\n    /**\n     * id\uff0c\u6b64\u5e8f\u5217\u503c\u7531\u6846\u67b6\u81ea\u52a8\u751f\u6210\uff0c\u65e0\u9700\u624b\u5de5\u8bbe\u7f6e\u3002\n     */\n    private long id;\n\n    /**\n     * \u5173\u8054TAG\uff0c\u7531\u8c03\u7528\u65b9\u8bbe\u5b9a\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private String refTag;\n\n    /**\n     * \u5173\u8054id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refId;\n\n    /**\n     * \u5173\u8054\u5b50id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refSubId;\n\n    /**\n     * \u5173\u8054\u5bf9\u8c61\uff0c\u6b64\u5bf9\u8c61\u4e0d\u5b58\u5165\u6570\u636e\u5e93\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7Listener\u6765\u8bbf\u95ee\u3002\n     */\n    @JsonIgnore\n    private Object refObject;\n\n    /**\n     * \u6d41\u91cf\u9650\u5236TAG\u3002\n     */\n    private String rateLimitTag;\n\n    /**\n     * \u9700\u8981\u6267\u884c\u7684\u7c7b\u540d\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u7531\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private String taskClass = \"\";\n\n    /**\n     * \u4efb\u52a1\u6807\u7b7e\uff0c\u7528\u4e8e\u7ec6\u5206\u4efb\u52a1\u961f\u5217\uff0c\u652f\u6301\u591a\u5b9e\u4f8b\u8fd0\u884c\u3002\n     */\n    private String taskTag = \"\";\n\n    /**\n     * \u4efb\u52a1\u5ef6\u8fdf\u6beb\u79d2\u6570\u3002\u4e00\u822c\u8fd9\u4e2a\u65f6\u95f4\u4e0d\u5b9c\u592a\u957f\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4e0d\u8981\u8d85\u8fc760\u79d2\u3002\n     */\n    private long taskDelay;\n\n    /**\n     * \u6267\u884c\u53c2\u6570\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u6709\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private TP taskParam;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u7c7b\u578b\uff0c\u9ed8\u8ba4\u4e3a\u81ea\u52a8RPC\uff0c\u6839\u636e\u60c5\u51b5\u9009\u62e9\u672c\u5730\u8fd8\u662f\u8fdc\u7a0b\u8fd0\u884c\u3002\n     */\n    private int runType = RUN_TYPE_AUTO_RPC;\n\n    /**\n     * \u91cd\u8bd5\u7c7b\u578b\n     */\n    private int retryType;\n\n    /**\n     * \u6307\u5b9a\u8fd0\u884c\u76ee\u6807\u3002\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aIP\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostIp;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aID\uff08\u53ef\u80fd\u4e3adocker\u7684ContainerID\uff09\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostId;\n\n    /**\n     * \u8fdb\u5165\u961f\u5217\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date queueDate;\n\n    /**\n     * \u5f00\u59cb\u6d88\u8d39\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date consumeDate;\n\n    /**\n     * \u5f00\u59cb\u8fd0\u884c\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date runDate;\n\n    /**\n     * \u8fd0\u884c\u7ed3\u675f\u65e5\u671f\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date finishDate;\n\n    /**\n     * \u6267\u884c\u4fe1\u606f\uff0c\u7528\u4e8e\u5b58\u50a8\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private RD resultData;\n\n    /**\n     * \u51fa\u9519\u4fe1\u606f\n     */\n    private String errorInfo;\n\n    /**\n     * \u5df2\u7ecf\u6267\u884c\u7684\u6b21\u6570\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int ranTimes;\n\n    /**\n     * \u6267\u884c\u72b6\u6001\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u6839\u636e\u5f02\u5e38\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int state;\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * @param id the id to set\n     */\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return refId;\n    }\n\n    /**\n     * @param refId the refId to set\n     */\n    public void setRefId(long refId) {\n        this.refId = refId;\n    }\n\n    /**\n\t * @return the refSubId\n\t */\n\tpublic long getRefSubId() {\n\t\treturn refSubId;\n\t}\n\n\t/**\n\t * @param refSubId the refSubId to set\n\t */\n\tpublic void setRefSubId(long refSubId) {\n\t\tthis.refSubId = refSubId;\n\t}\n\n\t/**\n\t * @return the refTag\n\t */\n\tpublic String getRefTag() {\n\t\treturn refTag;\n\t}\n\n\t/**\n\t * @param refTag the refTag to set\n\t */\n\tpublic void setRefTag(String refTag) {\n\t\tthis.refTag = refTag;\n\t}\n\n\t/**\n\t * @return the rateLimitTag\n\t */\n\tpublic String getRateLimitTag() {\n\t\treturn rateLimitTag;\n\t}\n\n\t/**\n\t * @param rateLimitTag the rateLimitTag to set\n\t */\n\tpublic void setRateLimitTag(String rateLimitTag) {\n\t\tthis.rateLimitTag = rateLimitTag;\n\t}\n\n\t/**\n\t * @return the refObject\n\t */\n\tpublic Object getRefObject() {\n\t\treturn refObject;\n\t}\n\n    /**\n     * @param refObject the refObject to set\n     */\n    public void setRefObject(Object refObject) {\n        this.refObject = refObject;\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    /**\n     * @param taskClass the taskClass to set\n     */\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    /**\n\t * @return the taskTag\n\t */\n\tpublic String getTaskTag() {\n\t\treturn taskTag;\n\t}\n\n\tpublic long getTaskDelay() {\n\t\treturn taskDelay;\n\t}\n\n\tpublic void setTaskDelay(long taskDelay) {\n\t\tthis.taskDelay = taskDelay;\n\t}\n\n\t/**\n\t * @param taskTag the taskTag to set\n\t */\n\tpublic void setTaskTag(String taskTag) {\n\t\tthis.taskTag = taskTag;\n\t}\n\n\t/**\n     * @return the taskParam\n     */\n    public TP getTaskParam() {\n        return taskParam;\n    }\n\n    /**\n     * @param taskParam the taskParam to set\n     */\n    public void setTaskParam(TP taskParam) {\n        this.taskParam = taskParam;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return runType;\n    }\n\n    /**\n     * @param runType the runType to set\n     */\n    public void setRunType(int runType) {\n        this.runType = runType;\n    }\n\n    public int getRetryType() {\n        return retryType;\n    }\n\n    public void setRetryType(int retryType) {\n        this.retryType = retryType;\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    /**\n     * @param runTarget the runTarget to set\n     */\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * @param hostIp the hostIp to set\n     */\n    public void setHostIp(String hostIp) {\n        this.hostIp = hostIp;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return queueDate;\n    }\n\n    /**\n     * @param queueDate the queueDate to set\n     */\n    public void setQueueDate(Date queueDate) {\n        this.queueDate = queueDate;\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return consumeDate;\n    }\n\n    /**\n     * @param consumeDate the consumeDate to set\n     */\n    public void setConsumeDate(Date consumeDate) {\n        this.consumeDate = consumeDate;\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return runDate;\n    }\n\n    /**\n     * @param runDate the runDate to set\n     */\n    public void setRunDate(Date runDate) {\n        this.runDate = runDate;\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return finishDate;\n    }\n\n    /**\n     * @param finishDate the finishDate to set\n     */\n    public void setFinishDate(Date finishDate) {\n        this.finishDate = finishDate;\n    }\n\n    /**\n     * @return the resultData\n     */\n    public RD getResultData() {\n        return resultData;\n    }\n\n    /**\n     * @param resultData the resultData to set\n     */\n    public void setResultData(RD resultData) {\n        this.resultData = resultData;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return errorInfo;\n    }\n\n    /**\n     * @param errorInfo the errorInfo to set\n     */\n    public void setErrorInfo(String errorInfo) {\n        this.errorInfo = errorInfo;\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return ranTimes;\n    }\n\n    /**\n     * @param ranTimes the ranTimes to set\n     */\n    public void setRanTimes(int ranTimes) {\n        this.ranTimes = ranTimes;\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * @param status the status to set\n     */\n    public void setState(int status) {\n        this.state = status;\n    }\n\n}\nsrc/main/java/uw/task/TaskRunner.java\npublic abstract class TaskRunner<TP, RD> {\r\n\r\n    /**\r\n     * \u6267\u884c\u4efb\u52a1\u3002\r\n     * \u4e1a\u52a1\u5c42\u9762\u7684\u5f02\u5e38\u8bf7\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u624b\u52a8Throw TaskException:\r\n     * \u76ee\u524d\u652f\u6301\u7684\u5f02\u5e38:\r\n     * 1. TaskDataException \u4efb\u52a1\u6570\u636e\u5f02\u5e38\r\n     * 2. TaskPartnerException \u4efb\u52a1\u5408\u4f5c\u65b9\u5f02\u5e38\r\n     *\r\n     * @param taskData \u6570\u636e\r\n     * @throws Exception \u5f02\u5e38\r\n     * @return \u6307\u5b9a\u7684\u8fd4\u56de\u5bf9\u8c61\r\n     */\r\n    public abstract RD runTask(TaskData<TP, RD> taskData) throws Exception;\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u914d\u7f6e\u4fe1\u606f\r\n     *\r\n     * @return TaskRunnerConfig\u914d\u7f6e\r\n     */\r\n    public abstract TaskRunnerConfig initConfig();\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     *\r\n     * @return TaskContact\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     */\r\n    public abstract TaskContact initContact();\r\n}\nsrc/main/java/uw/task/conf/TaskMetaInfoManager.java\npublic class TaskMetaInfoManager {\r\n\r\n\t/**\r\n\t * \u8fd0\u884c\u4e3b\u673a\u914d\u7f6e\r\n\t */\r\n\tstatic List<String> targetConfig = null;\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tstatic Map<String, TaskRunner> runnerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic Map<String, TaskCroner> cronerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskRunnerConfig> runnerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskCronerConfig> cronerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u8fd0\u884c\u5b9e\u4f8b\u3002\r\n\t *\r\n\t * @param taskClass\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunner<?, ?> getRunner(String taskClass) {\r\n\t\treturn runnerMap.get(taskClass);\r\n\t}\r\n\r\n\t/**\r\n\t * \u68c0\u67e5\u4e00\u4e2arunner\u662f\u5426\u53ef\u4ee5\u5728\u672c\u5730\u8fd0\u884c\u3002\r\n\t * \r\n\t * @param taskData\r\n\t * @return\r\n\t */\r\n\tpublic static boolean checkRunnerRunLocal(TaskData<?, ?> taskData) {\r\n\t\treturn runnerMap.containsKey(taskData.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u6839\u636e\u670d\u52a1\u5668\u7aefQueue\u5217\u8868\uff0c\u8fd4\u56de\u5408\u9002\u7684key\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getFitQueue(TaskData<?, ?> data) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tif (runnerConfigMap.containsKey(all)) {\r\n\t\t\treturn all;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            if (runnerConfigMap.containsKey(test)) {\r\n                return test;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u6700\u540e\u90fd\u6ca1\u5339\u914d\u5230\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e\r\n\t\treturn all;\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u914d\u7f6e\r\n\t *\r\n\t * @param data\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunnerConfig getRunnerConfig(TaskData<?, ?> data) {\r\n\t\tTaskRunnerConfig config = null;\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tconfig = runnerConfigMap.get(all);\r\n\t\tif (config != null) {\r\n\t\t\treturn config;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            config = runnerConfigMap.get(test);\r\n            if (config != null) {\r\n                return config;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new RuntimeException(\"\u627e\u4e0d\u5230\u4efb\u52a1\u914d\u7f6e: taskClass = \" + data.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u66f4\u65b0\u7cfb\u7edf\u961f\u5217\u8868\u3002\r\n\t * \r\n\t * @param config\r\n\t */\r\n\tstatic void updateSysQueue(final TaskRunnerConfig config) {\r\n\t\tString key = getRunnerConfigKey(config);\r\n\t\t// \u68c0\u6d4b\u662f\u5426\u8001\u7684TaskRunnerConfig\u662f\u5426\u662f\u672c\u5730\u7684\u5b8c\u6574\u914d\u7f6e\uff0c\u5982\u679c\u662f\uff0c\u5219\u4e0d\u7ba1\u3002\r\n\t\tTaskRunnerConfig old = runnerConfigMap.get(key);\r\n\t\tif (old == null || (old != null && old.getCreateDate() == null)) {\r\n\t\t\tif (config.getState() < 1) {\r\n\t\t\t\trunnerConfigMap.remove(key);\r\n\t\t\t} else {\r\n\t\t\t\trunnerConfigMap.put(key, config);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97croner\u914d\u7f6e\u952e\u3002 \u4f7f\u7528taskClass#Id$target\u6765\u914d\u7f6e\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getCronerConfigKey(TaskCronerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskParam() != null && config.getTaskParam().length() > 0) {\r\n\t\t\tsb.append(config.getId());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97Runner\u914d\u7f6e\u7ed3\u5408Host\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getRunnerConfigKey(TaskRunnerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskTag() != null && config.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(config.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n    /**\r\n     * \u83b7\u5f97RunnerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getRunnerLogKey(TaskData<?,?> log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskTag() != null && log.getTaskTag().length() > 0) {\r\n            sb.append(log.getTaskTag());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97CronerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getCronerLogKey(TaskCronerLog log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskParam() != null && log.getTaskParam().length()>0){\r\n            sb.append(log.getTaskParam());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\nsrc/main/java/uw/task/api/TaskAPI.java\npublic class TaskAPI {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskAPI.class);\n\n    /**\n     * Task\u914d\u7f6e\u6587\u4ef6\n     */\n    private TaskProperties taskProperties;\n\n    /**\n     * Rest\u6a21\u677f\u7c7b\n     */\n    private RestTemplate restTemplate;\n\n    /**\n     * \u65e5\u5fd7\u5ba2\u6237\u7aef\u3002\n     */\n    private LogClient logClient = null;\n\n    /**\n     * \u672c\u673a\u7684\u5916\u7f51IP\n     */\n    private String hostIp = \"\";\n\n    public TaskAPI(final TaskProperties taskProperties, final RestTemplate restTemplate,\n                   final LogClient logClient) {\n        this.taskProperties = taskProperties;\n        this.restTemplate = restTemplate;\n        this.logClient = logClient;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u76ee\u6807\u914d\u7f6e\u3002\n     *\n     * @return\n     */\n    public List<String> getServerTargetConfig() {\n        List<String> targetConfig = null;\n        // \u5224\u65ad\u662f\u5426\u662f\u79c1\u6709\u6a21\u5f0f\u3002\n        boolean privacyMode = taskProperties.isPrivacyMode();\n        try {\n            String[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/target/config?targetType={targetType}\", String[].class,\n                    privacyMode ? 1 : 0);\n            targetConfig = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getHostConfig()\u670d\u52a1\u7aefTarget\u914d\u7f6e\u62c9\u53d6\u5f02\u5e38:{}\", e.getMessage());\n        }\n        if (targetConfig == null || targetConfig.size() == 0) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"\u83b7\u5f97\u4e3b\u673aTarget\u670d\u52a1\u7aef\u914d\u7f6e\u5931\u8d25\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e\u9879!\");\n            }\n            targetConfig = new ArrayList<>();\n            if (!privacyMode) {\n                targetConfig.add(\"\");\n            }\n        }\n        return targetConfig;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u72b6\u6001\uff0c\u8fd4\u56de\u4e3b\u673aIP\u5730\u5740\u3002\n     *\n     * @return \u4e3b\u673aIP\u5730\u5740\n     */\n    public String updateHostStatus() {\n        String ip = \"\";\n        TaskHostStatus taskHostStatus = new TaskHostStatus();\n        taskHostStatus.setHostId(taskProperties.getHostId());\n        taskHostStatus.setTaskProject(taskProperties.getProject());\n        try {\n            ip = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/host/status\", taskHostStatus,\n                    String.class);\n            hostIp = ip;\n        } catch (Exception e) {\n            log.error(\"TaskAPI.updateHostStatus()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return ip;\n    }\n\n    /**\n     * \u521d\u59cb\u5316CronerConfig\u3002\n     *\n     * @param config\n     */\n    public TaskCronerConfig initTaskCronerConfig(TaskCronerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/croner/config\", config,\n                    TaskCronerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskCronerConfig\u4e0a\u4f20Croner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n    }\n\n    /**\n     * \u521d\u59cb\u5316RunnerConfig\n     *\n     * @param config\n     */\n    public TaskRunnerConfig initTaskRunnerConfig(TaskRunnerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/runner/config\", config,\n                    TaskRunnerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskRunnerConfig\u4e0a\u4f20Runner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n\n    }\n\n    /**\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\u3002\n     *\n     * @param contact\n     */\n    public void initTaskContact(TaskContact contact) {\n        try {\n            restTemplate.postForLocation(taskProperties.getTaskCenterHost() + \"/taskapi/contact\", contact);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskContact\u4e0a\u4f20\u8054\u7cfb\u4eba\u4fe1\u606f\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n    }\n\n    /**\n     * \u6839\u636e\u66f4\u65b0\u65f6\u95f4\u83b7\u5f97\u53d8\u5316\u7684TaskRunner\u961f\u5217\u5217\u8868\u3002\n     *\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerQueueList(long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/runner/queue?lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerQueueList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskRunner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/runner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskCroner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskCronerConfig> getTaskCronerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskCronerConfig> list = null;\n        try {\n            TaskCronerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskCronerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskCronerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u53d1\u9001Runner\u4efb\u52a1\u65e5\u5fd7\u3002\n     *\n     * @param log\n     */\n    public void sendTaskRunnerLog(TaskRunnerLog log) {\n        logClient.log(log);\n    }\n\n    /**\n     * \u53d1\u9001CronLog\u65e5\u5fd7\n     *\n     * @param configId      \u914d\u7f6eId,\u65b9\u4fbf\u66f4\u65b0\u4e0b\u4e00\u6b21\u6267\u884c\u65f6\u95f4\n     * @param taskCronerLog \u65e5\u5fd7\u5bf9\u8c61\n     */\n    public void sendTaskCronerLog(long configId, TaskCronerLog taskCronerLog) {\n        try {\n            restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/tick?id={id}&nextDate={nextDate}\",\n                    Integer.class, configId, taskCronerLog.getNextDate().getTime());\n        } catch (Exception e) {\n            log.error(\"TaskAPI.cornerTick()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38: \" + e.getMessage(), e);\n        }\n\n        int logLevel = taskCronerLog.getLogLevel();\n        int logLimitSize = taskCronerLog.getLogLimitSize();\n        if (logLevel > TaskCronerConfig.TASK_LOG_TYPE_NONE) {\n            switch (logLevel) {\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD: {\n                    taskCronerLog.setTaskParam(null);\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM: {\n                    String taskParam = taskCronerLog.getTaskParam();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                        taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA: {\n                    String resultData = taskCronerLog.getResultData();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                        taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setTaskParam(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_ALL: {\n                    if (logLimitSize > 0) {\n                        String taskParam = taskCronerLog.getTaskParam();\n                        String resultData = taskCronerLog.getResultData();\n                        if (StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                            taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                        }\n                        if (StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                            taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                        }\n                    }\n                }\n                break;\n            }\n            logClient.log(taskCronerLog);\n        }\n    }\n}\nsrc/main/java/uw/task/exception/TaskDataException.java\npublic class TaskDataException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskDataException() {\r\n        super();\r\n    }\r\n\r\n    public TaskDataException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskDataException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskDataException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/entity/TaskRunnerConfig.java\npublic class TaskRunnerConfig implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u4e0d\u9650\u901f\n     */\n    public static final int RATE_LIMIT_NONE = 0;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730\u8fdb\u7a0b\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL = 1;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK = 2;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK_TAG = 3;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40\u4e3b\u673aHOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_HOST = 4;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG = 5;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK = 6;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG+HOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG_HOST = 7;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_HOST = 8;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG = 9;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG_HOST = 10;\n\n    /**\n     * \u4ec0\u4e48\u90fd\u4e0d\u8bb0\u5f55\n     */\n    public static final int TASK_LOG_TYPE_NONE = -1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD = 0;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8bf7\u6c42\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_TASK_PARAM = 1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8fd4\u56de\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_RESULT_DATA = 2;\n\n    /**\n     * \u8bb0\u5f55\u5168\u90e8\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD_ALL = 3;\n\n    private long id;\n\n    /**\n     * \u4efb\u52a1\u540d\u79f0\n     */\n    private String taskName;\n\n    /**\n     * \u4efb\u52a1\u63cf\u8ff0\n     */\n    private String taskDesc;\n\n    /**\n     * \u6267\u884c\u7c7b\u4fe1\u606f\n     */\n    private String taskClass;\n\n    /**\n     * \u6267\u884c\u7c7bTAG\uff0c\u53ef\u80fd\u7528\u4e8e\u533a\u5206\u5b50\u4efb\u52a1\n     */\n    private String taskTag;\n\n    /**\n     * \u6d88\u8d39\u8005\u7684\u6570\u91cf\n     */\n    private int consumerNum = 1;\n\n    /**\n     * \u9884\u53d6\u4efb\u52a1\u6570\u3002\n     */\n    private int prefetchNum = 1;\n\n    /**\n     * \u8be6\u89c1\u6d41\u91cf\u9650\u5236\u7c7b\u578b\u8bf4\u660e\u3002\n     */\n    private int rateLimitType = RATE_LIMIT_NONE;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u6570\u503c\uff0c\u9ed8\u8ba4\u4e3a10\u6b21\n     */\n    private int rateLimitValue = 10;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u65f6\u95f4(S)\uff0c\u9ed8\u8ba4\u4e3a1\u79d2\n     */\n    private int rateLimitTime = 1;\n\n    /**\n     * \u5f53\u53d1\u751f\u6d41\u91cf\u9650\u5236\u65f6\uff0c\u7b49\u5f85\u7684\u79d2\u6570\uff0c\u9ed8\u8ba4300\u79d2\n     */\n    private int rateLimitWait = 30;\n\n    /**\n     * \u8d85\u8fc7\u6d41\u91cf\u9650\u5236\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u5728\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByOverrated = 0;\n\n    /**\n     * \u5bf9\u65b9\u63a5\u53e3\u9519\u8bef\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u518d\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByPartner = 0;\n\n    /**\n     * \u8fd0\u884c\u76ee\u6807\uff0c\u9ed8\u8ba4\u4e0d\u6307\u5b9a\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u5931\u8d25\u7387\n     */\n    private int failRate;\n\n    /**\n     * \u63a5\u53e3\u5931\u8d25\u7387\n     */\n    private int failPartnerRate;\n\n    /**\n     * \u7a0b\u5e8f\u5931\u8d25\u7387\n     */\n    private int failProgramRate;\n\n    /**\n     * \u914d\u7f6e\u5931\u8d25\u7387\n     */\n    private int failConfigRate;\n\n    /**\n     * \u6570\u636e\u5931\u8d25\u7387\n     */\n    private int failDataRate;\n\n    /**\n     * \u961f\u5217\u7b49\u5f85\u8d85\u65f6\n     */\n    private int queueTimeout;\n\n    /**\n     * \u7b49\u5f85\u8d85\u65f6\n     */\n    private int waitTimeout;\n\n    /**\n     * \u8fd0\u884c\u8d85\u65f6\n     */\n    private int runTimeout;\n\n    /**\n     * \u521b\u5efa\u65e5\u671f\u3002\n     */\n    private Date createDate;\n\n    /**\n     * \u4fee\u6539\u65e5\u671f\u3002\n     */\n    private Date modifyDate;\n\n    /**\n     * \u72b6\u6001\u503c\n     */\n    private int state = 1;\n\n    /**\n     * \u8be6\u89c1\u65e5\u5fd7\u7c7b\u578b\u8bf4\u660e\n     */\n    private int logLevel = TASK_LOG_TYPE_RECORD;\n\n    /**\n     * \u65e5\u5fd7\u5b57\u7b26\u4e32\u5b57\u6bb5\u5927\u5c0f\u9650\u5236: 0 \u8868\u793a\u65e0\u9650\u5236\n     */\n    private int logLimitSize = 0;\n\n    public TaskRunnerConfig() {\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getTaskName() {\n        return taskName;\n    }\n\n    public void setTaskName(String taskName) {\n        this.taskName = taskName;\n    }\n\n    public String getTaskDesc() {\n        return taskDesc;\n    }\n\n    public void setTaskDesc(String taskDesc) {\n        this.taskDesc = taskDesc;\n    }\n\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    public String getTaskTag() {\n        return taskTag;\n    }\n\n    public void setTaskTag(String taskTag) {\n        this.taskTag = taskTag;\n    }\n\n    public int getConsumerNum() {\n        return consumerNum;\n    }\n\n    public void setConsumerNum(int consumerNum) {\n        this.consumerNum = consumerNum;\n    }\n\n    public int getPrefetchNum() {\n        return prefetchNum;\n    }\n\n    public void setPrefetchNum(int prefetchNum) {\n        this.prefetchNum = prefetchNum;\n    }\n\n    public int getRateLimitType() {\n        return rateLimitType;\n    }\n\n    public void setRateLimitType(int rateLimitType) {\n        this.rateLimitType = rateLimitType;\n    }\n\n    public int getRateLimitValue() {\n        return rateLimitValue;\n    }\n\n    public void setRateLimitValue(int rateLimitValue) {\n        this.rateLimitValue = rateLimitValue;\n    }\n\n    public int getRateLimitTime() {\n        return rateLimitTime;\n    }\n\n    public void setRateLimitTime(int rateLimitTime) {\n        this.rateLimitTime = rateLimitTime;\n    }\n\n    public int getRateLimitWait() {\n        return rateLimitWait;\n    }\n\n    public void setRateLimitWait(int rateLimitWait) {\n        this.rateLimitWait = rateLimitWait;\n    }\n\n    public int getRetryTimesByOverrated() {\n        return retryTimesByOverrated;\n    }\n\n    public void setRetryTimesByOverrated(int retryTimesByOverrated) {\n        this.retryTimesByOverrated = retryTimesByOverrated;\n    }\n\n    public int getRetryTimesByPartner() {\n        return retryTimesByPartner;\n    }\n\n    public void setRetryTimesByPartner(int retryTimesByPartner) {\n        this.retryTimesByPartner = retryTimesByPartner;\n    }\n\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    public int getFailRate() {\n        return failRate;\n    }\n\n    public void setFailRate(int failRate) {\n        this.failRate = failRate;\n    }\n\n    public int getFailPartnerRate() {\n        return failPartnerRate;\n    }\n\n    public void setFailPartnerRate(int failPartnerRate) {\n        this.failPartnerRate = failPartnerRate;\n    }\n\n    public int getFailProgramRate() {\n        return failProgramRate;\n    }\n\n    public void setFailProgramRate(int failProgramRate) {\n        this.failProgramRate = failProgramRate;\n    }\n\n    public int getFailConfigRate() {\n        return failConfigRate;\n    }\n\n    public void setFailConfigRate(int failConfigRate) {\n        this.failConfigRate = failConfigRate;\n    }\n\n    public int getFailDataRate() {\n        return failDataRate;\n    }\n\n    public void setFailDataRate(int failDataRate) {\n        this.failDataRate = failDataRate;\n    }\n\n    public int getQueueTimeout() {\n        return queueTimeout;\n    }\n\n    public void setQueueTimeout(int queueTimeout) {\n        this.queueTimeout = queueTimeout;\n    }\n\n    public int getWaitTimeout() {\n        return waitTimeout;\n    }\n\n    public void setWaitTimeout(int waitTimeout) {\n        this.waitTimeout = waitTimeout;\n    }\n\n    public int getRunTimeout() {\n        return runTimeout;\n    }\n\n    public void setRunTimeout(int runTimeout) {\n        this.runTimeout = runTimeout;\n    }\n\n    public Date getCreateDate() {\n        return createDate;\n    }\n\n    public void setCreateDate(Date createDate) {\n        this.createDate = createDate;\n    }\n\n    public Date getModifyDate() {\n        return modifyDate;\n    }\n\n    public void setModifyDate(Date modifyDate) {\n        this.modifyDate = modifyDate;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n    }\n\n    public int getLogLevel() {\n        return logLevel;\n    }\n\n    public void setLogLevel(int logLevel) {\n        this.logLevel = logLevel;\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/util/MiscUtils.java\npublic class MiscUtils {\r\n\r\n    /**\r\n     * taskData\u7684copy\u5668\u3002\r\n     */\r\n    private static BeanCopier beanCopier = BeanCopier.create(TaskData.class, TaskData.class, false);\r\n\r\n    /**\r\n     * copy taskData\u5bf9\u8c61\u3002\r\n     *\r\n     * @param srcData\r\n     * @param dstData\r\n     */\r\n    public static void copyTaskData(TaskData srcData, TaskData dstData) {\r\n        beanCopier.copy(srcData, dstData, null);\r\n    }\r\n\r\n    /**\r\n     * \u6253\u5370\u5f02\u5e38\u4fe1\u606f\uff0c\u5c4f\u853d\u6389spring\u81ea\u5df1\u7684\u5806\u6808\u8f93\u51fa\u3002\r\n     *\r\n     * @param e \u9700\u8981\u6253\u5370\u7684\u5f02\u5e38\u4fe1\u606f\r\n     * @return\r\n     */\r\n    public static String exceptionToString(Throwable e) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(e.toString()).append(\"\\n\");\r\n\r\n        StackTraceElement[] trace = e.getStackTrace();\r\n        for (StackTraceElement traceElement : trace) {\r\n            if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                continue;\r\n            }\r\n            if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                continue;\r\n            }\r\n            sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n        }\r\n        Throwable ourCause = e.getCause();\r\n        if (ourCause != null) {\r\n            sb.append(\"CAUSE BY\").append(ourCause.toString()).append(\"\\n\");\r\n            trace = ourCause.getStackTrace();\r\n            for (StackTraceElement traceElement : trace) {\r\n                if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                    continue;\r\n                }\r\n                if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                    continue;\r\n                }\r\n                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskListenerManager.java\npublic class TaskListenerManager {\r\n\r\n\t/**\r\n\t * runner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n\t */\r\n    private ArrayList<RunnerTaskListener> runnerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * croner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n     */\r\n    private ArrayList<CronerTaskListener> cronerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener\u3002\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addRunnerListener(RunnerTaskListener listener) {\r\n        runnerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener.\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addCronerListener(CronerTaskListener listener) {\r\n        cronerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearRunnerListener() {\r\n        runnerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearCronerListener() {\r\n        cronerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Runner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<RunnerTaskListener> getRunnerListenerList() {\r\n        return runnerListenerList;\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Croner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<CronerTaskListener> getCronerListenerList() {\r\n        return cronerListenerList;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/entity/TaskRunnerLog.java\n@JsonIgnoreProperties({\"taskData\"})\npublic class TaskRunnerLog extends LogBaseVo {\n\n    private static final Logger logger = LoggerFactory.getLogger(TaskRunnerLog.class);\n\n    private TaskData taskData;\n\n    /**\n     * logLimitSize\u3002\n     */\n    private int logLimitSize;\n\n    public TaskRunnerLog(TaskData taskData) {\n        this.taskData = taskData;\n    }\n\n    public TaskData getTaskData() {\n        return taskData;\n    }\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return taskData.getId();\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return taskData.getRefId();\n    }\n\n    /**\n     * @return the refSubId\n     */\n    public long getRefSubId() {\n        return taskData.getRefSubId();\n    }\n\n    /**\n     * @return the refTag\n     */\n    public String getRefTag() {\n        return taskData.getRefTag();\n    }\n\n    /**\n     * @return the rateLimitTag\n     */\n    public String getRateLimitTag() {\n        return taskData.getRateLimitTag();\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskData.getTaskClass();\n    }\n\n    /**\n     * @return the taskTag\n     */\n    public String getTaskTag() {\n        return taskData.getTaskTag();\n    }\n\n    public long getTaskDelay() {\n        return taskData.getTaskDelay();\n    }\n\n    /**\n     * @return the taskParam\n     */\n    public String getTaskParam() {\n        Object value = taskData.getTaskParam();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return taskData.getRunType();\n    }\n\n    /**\n     * @return the retryType\n     */\n    public int getRetryType() {\n        return taskData.getRetryType();\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return taskData.getRunTarget();\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return taskData.getHostIp();\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return taskData.getHostId();\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return taskData.getQueueDate();\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return taskData.getConsumeDate();\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return taskData.getRunDate();\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return taskData.getFinishDate();\n    }\n\n    /**\n     * @return the resultData\n     */\n    public String getResultData() {\n        Object value = taskData.getResultData();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return taskData.getErrorInfo();\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return taskData.getRanTimes();\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return taskData.getState();\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/conf/TaskProperties.java\n@ConfigurationProperties(prefix = \"uw.task\")\npublic class TaskProperties {\n\n    /**\n     * \u662f\u5426\u542f\u7528uw-task\u670d\u52a1\u6ce8\u518c\u548c\u4e3b\u673a\u6ce8\u518c\uff0c\u9ed8\u8ba4\u4e0d\u542f\u7528\u3002\n     *\n     */\n    private boolean enableTaskRegistry = false;\n    /**\n     * \u4efb\u52a1\u540d\uff0c\u5fc5\u987b\u8bbe\u7f6e\u4e3a\u57fa\u7840\u5305\u540d\u3002\n     */\n    private String project;\n\n    /**\n     * \u79c1\u6709\u6a21\u5f0f\u3002\u4e0d\u8fd0\u884c\u5168\u5c40target\u4efb\u52a1\u3002\n     */\n    private boolean privacyMode = false;\n\n    /**\n     * croner\u7ebf\u7a0b\u6570\uff0c\u9ed8\u8ba4\u57283\u4e2a\uff0c\u5efa\u8bae\u6309\u7167\u5b9e\u9645croner\u4efb\u52a1\u6570\u91cf*70%\u3002\n     */\n    private int cronerThreadNum = 5;\n\n    /**\n     * RPC\u6700\u5c0f\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u5982\u4e0d\u4f7f\u7528rpc\uff0c\u5efa\u8bae\u8bbe\u7f6e\u4e3a1\uff0c\u5426\u5219\u6309\u7167\u6700\u5927\u5e76\u53d1\u91cf*10%\u8bbe\u7f6e\u3002\n     */\n    private int taskRpcMinThreadNum = 1;\n\n    /**\n     * RPC\u6700\u5927\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u8d85\u8fc7\u6b64\u7ebf\u7a0b\u6570\uff0c\u5c06\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     */\n    private int taskRpcMaxThreadNum = 100;\n\n    /**\n     * \u961f\u5217\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba42\u79d2\n     */\n    private long taskQueueRetryDelay = 2000;\n\n    /**\n     *  rpc\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba4100\u6beb\u79d2\n     */\n    private long taskRpcRetryDelay = 100;\n\n    /**\n     * \u8fd0\u884c\u4e3b\u673aID\n     */\n    private String hostId = ManagementFactory.getRuntimeMXBean().getName();\n\n    /**\n     * \u4efb\u52a1\u670d\u52a1\u5668\n     */\n    private String taskCenterHost = \"127.0.0.1\";\n\n    /**\n     * Redis\u914d\u7f6e\n     */\n    private RedisProperties redis = new RedisProperties();\n\n    /**\n     * Rabbit MQ\u914d\u7f6e\n     */\n    private RabbitProperties rabbitmq = new RabbitProperties();\n\n    public static class RedisProperties extends org.springframework.boot.autoconfigure.data.redis.RedisProperties {\n\n    }\n\n    public static class RabbitProperties extends org.springframework.boot.autoconfigure.amqp.RabbitProperties {\n\n    }\n\n    public boolean isEnableTaskRegistry() {\n        return enableTaskRegistry;\n    }\n\n    public void setEnableTaskRegistry(boolean enableTaskRegistry) {\n        this.enableTaskRegistry = enableTaskRegistry;\n    }\n\n    /**\n\t * @return the privacyMode\n\t */\n\tpublic boolean isPrivacyMode() {\n\t\treturn privacyMode;\n\t}\n\n\t/**\n\t * @param privacyMode the privacyMode to set\n\t */\n\tpublic void setPrivacyMode(boolean privacyMode) {\n\t\tthis.privacyMode = privacyMode;\n\t}\n\n\tpublic int getTaskRpcMinThreadNum() {\n\t\treturn taskRpcMinThreadNum;\n\t}\n\n\tpublic void setTaskRpcMinThreadNum(int taskRpcMinThreadNum) {\n\t\tthis.taskRpcMinThreadNum = taskRpcMinThreadNum;\n\t}\n\n\tpublic int getTaskRpcMaxThreadNum() {\n\t\treturn taskRpcMaxThreadNum;\n\t}\n\n\tpublic void setTaskRpcMaxThreadNum(int taskRpcMaxThreadNum) {\n\t\tthis.taskRpcMaxThreadNum = taskRpcMaxThreadNum;\n\t}\n\n\t/**\n     * @return the project\n     */\n    public String getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(String project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n\t * @return the cronerThreadNum\n\t */\n\tpublic int getCronerThreadNum() {\n\t\treturn cronerThreadNum;\n\t}\n\n\t/**\n\t * @param cronerThreadNum the cronerThreadNum to set\n\t */\n\tpublic void setCronerThreadNum(int cronerThreadNum) {\n\t\tthis.cronerThreadNum = cronerThreadNum;\n\t}\n\n\t/**\n     * @return the taskCenterHost\n     */\n    public String getTaskCenterHost() {\n        return taskCenterHost;\n    }\n\n    /**\n     * @param taskCenterHost the taskCenterHost to set\n     */\n    public void setTaskCenterHost(String taskCenterHost) {\n        this.taskCenterHost = taskCenterHost;\n    }\n\n    public RedisProperties getRedis() {\n        return redis;\n    }\n\n    public void setRedis(RedisProperties redis) {\n        this.redis = redis;\n    }\n\n    public RabbitProperties getRabbitmq() {\n        return rabbitmq;\n    }\n\n    public void setRabbitmq(RabbitProperties rabbitmq) {\n        this.rabbitmq = rabbitmq;\n    }\n\n    public long getTaskQueueRetryDelay() {\n        return taskQueueRetryDelay;\n    }\n\n    public void setTaskQueueRetryDelay(long taskQueueRetryDelay) {\n        this.taskQueueRetryDelay = taskQueueRetryDelay;\n    }\n\n    public long getTaskRpcRetryDelay() {\n        return taskRpcRetryDelay;\n    }\n\n    public void setTaskRpcRetryDelay(long taskRpcRetryDelay) {\n        this.taskRpcRetryDelay = taskRpcRetryDelay;\n    }\n}\npackage uw.task.container;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport uw.task.TaskData;\nimport uw.task.TaskFactory;\nimport uw.task.TaskListenerManager;\nimport uw.task.TaskRunner;\nimport uw.task.api.TaskAPI;\nimport uw.task.conf.TaskMetaInfoManager;\nimport uw.task.conf.TaskProperties;\nimport uw.task.entity.TaskRunnerConfig;\nimport uw.task.entity.TaskRunnerLog;\nimport uw.task.exception.TaskDataException;\nimport uw.task.exception.TaskPartnerException;\nimport uw.task.listener.RunnerTaskListener;\nimport uw.task.util.GlobalRateLimiter;\nimport uw.task.util.LocalRateLimiter;\nimport uw.task.util.MiscUtils;\n\n\n\n\n/**\n * \u5728\u6b64\u5904\u63a5\u53d7MQ\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c\u5904\u7406\u3002\n *\n * @author axeon\n */\npublic class TaskRunnerContainer {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskRunnerContainer.class);\n\n    /**\n     * TaskFactory\n     */\n    private TaskFactory taskFactory;\n\n    /**\n     * \u670d\u52a1\u7aef\u4efb\u52a1API\n     */\n    private TaskAPI taskAPI;\n\n    /**\n     * \u5168\u5c40\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */\n    private GlobalRateLimiter globalRateLimiter;\n\n    /**\n     * \u672c\u5730\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */Next line of code:\n", "input": "package uw.task.container;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport uw.task.TaskData;\nimport uw.task.TaskFactory;\nimport uw.task.TaskListenerManager;\nimport uw.task.TaskRunner;\nimport uw.task.api.TaskAPI;\nimport uw.task.conf.TaskMetaInfoManager;\nimport uw.task.conf.TaskProperties;\nimport uw.task.entity.TaskRunnerConfig;\nimport uw.task.entity.TaskRunnerLog;\nimport uw.task.exception.TaskDataException;\nimport uw.task.exception.TaskPartnerException;\nimport uw.task.listener.RunnerTaskListener;\nimport uw.task.util.GlobalRateLimiter;\nimport uw.task.util.LocalRateLimiter;\nimport uw.task.util.MiscUtils;\n\n\n\n\n/**\n * \u5728\u6b64\u5904\u63a5\u53d7MQ\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c\u5904\u7406\u3002\n *\n * @author axeon\n */\npublic class TaskRunnerContainer {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskRunnerContainer.class);\n\n    /**\n     * TaskFactory\n     */\n    private TaskFactory taskFactory;\n\n    /**\n     * \u670d\u52a1\u7aef\u4efb\u52a1API\n     */\n    private TaskAPI taskAPI;\n\n    /**\n     * \u5168\u5c40\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */\n    private GlobalRateLimiter globalRateLimiter;\n\n    /**\n     * \u672c\u5730\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */", "context": "src/main/java/uw/task/util/LocalRateLimiter.java\npublic class LocalRateLimiter {\r\n\r\n    private ConcurrentHashMap<String, RateLimiter> map = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u83b7\u5f97\u9650\u5236\u5141\u8bb8\u72b6\u6001\u3002\r\n     *\r\n     * @param name\r\n     * @return\r\n     */\r\n    public boolean tryAcquire(String name, int requests, int seconds, long waitTime, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return true;\r\n        }\r\n        final double rate = (double) requests / (double) seconds;\r\n        RateLimiter limiter = map.computeIfAbsent(name, key -> RateLimiter.create(rate));\r\n        if (limiter != null) {\r\n            //\u68c0\u67e5\u5e76\u4fee\u6539\r\n            if (limiter.getRate() != rate) {\r\n                limiter.setRate(rate);\r\n            }\r\n            return limiter.tryAcquire(permits, waitTime, TimeUnit.SECONDS);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskFactory.java\npublic class TaskFactory {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskFactory.class);\n\n    /**\n     * rabbitTemplate\u6a21\u677f.\n     */\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * \u5168\u5c40sequence\u5e8f\u5217\uff0c\u4e3b\u8981\u7528\u4e8etaskLog\u65e5\u5fd7\u3002\n     */\n    private GlobalSequenceManager globalSequenceManager;\n\n    /**\n     * \u7528\u4e8e\u672c\u5730\u6267\u884c\u4efb\u52a1\u7684taskConsumer\u3002\n     */\n    private TaskRunnerContainer taskRunnerContainer;\n\n    /**\n     * rpc\u5f02\u6b65\u8c03\u7528\u7ebf\u7a0b\u6c60\n     */\n    private ExecutorService taskRpcService = null;\n\n    /**\n     * \u6700\u5927\u91cd\u8bd5\u6b21\u6570\u3002\n     */\n    private static final int MAX_RETRY_TIMES = 10;\n\n\n    public TaskFactory(TaskProperties taskProperties, RabbitTemplate rabbitTemplate,\n                       TaskRunnerContainer taskRunnerContainer, GlobalSequenceManager globalSequenceManager) {\n        this.rabbitTemplate = rabbitTemplate;\n        this.taskRunnerContainer = taskRunnerContainer;\n        this.globalSequenceManager = globalSequenceManager;\n        taskRpcService = new ThreadPoolExecutor(taskProperties.getTaskRpcMinThreadNum(),\n                taskProperties.getTaskRpcMaxThreadNum(), 20L, TimeUnit.SECONDS, new SynchronousQueue<>(),\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"TaskRpc-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    }\n\n    /**\n     * \u628a\u4efb\u52a1\u53d1\u9001\u5230\u961f\u5217\u4e2d\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     */\n    public void sendToQueue(final TaskData<?, ?> taskData) {\n        Message message = buildTaskQueueMessage(taskData);\n        String queue = message.getMessageProperties().getConsumerQueue();\n        //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n        for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n            try {\n                if (i > 0) {\n                    Thread.sleep(i * 500);\n                }\n                rabbitTemplate.send(queue, queue, message);\n                return;\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n        throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n    }\n\n    /**\n     * \u6784\u9020Task\u6d88\u606f\u5bf9\u8c61\uff0c\u6b64\u65b9\u6cd5\u7528\u4e8e\u63d0\u524d\u6784\u9020TaskData\u3002\n     *\n     * @param taskData\n     * @return\n     */\n    private Message buildTaskQueueMessage(final TaskData taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        taskData.setRunType(TaskData.RUN_TYPE_GLOBAL);\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setConsumerQueue(TaskMetaInfoManager.getFitQueue(taskData));\n        Message msg = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n        return msg;\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTask(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n            for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                try {\n                    if (i > 0) {\n                        Thread.sleep(i * 500);\n                    }\n                    Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                    return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n            throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n        }\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTaskLocal(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            throw new TaskRuntimeException(taskData.getClass().getName() + \" is not a local task! \");\n        }\n    }\n\n    /**\n     * \u8fdc\u7a0b\u8fd0\u884c\u4efb\u52a1\uff0c\u5e76\u8fd4\u56defuture<TaskData<?,?>>\u3002 \u5982\u679c\u9700\u8981\u83b7\u5f97\u6570\u636e\uff0c\u53ef\u4ee5\u4f7f\u7528futrue.get()\u6765\u83b7\u5f97\u3002\n     * \u6b64\u65b9\u6cd5\u8981\u8c28\u614e\u4f7f\u7528\uff0c\u56e0\u4e3atask\u5b58\u5728\u9650\u901f\uff0c\u5927\u5e76\u53d1\u4e0b\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7ebf\u7a0b\u6570\u8d85\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> Future<TaskData<TP, RD>> runTaskAsync(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            return taskRpcService.submit(() -> {\n                taskRunnerContainer.process(taskData);\n                return taskData;\n            });\n        } else {\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            return taskRpcService.submit(() -> {\n                //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n                for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                    try {\n                        if (i > 0) {\n                            Thread.sleep(i * 500);\n                        }\n                        Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                        return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                    } catch (Exception e) {\n                        log.error(e.getMessage(), e);\n                    }\n                }\n                throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n            });\n        }\n    }\n\n    /**\n     * \u83b7\u5f97\u961f\u5217\u4fe1\u606f\u3002\n     *\n     * @param queueName\n     * @return 0 \u662f\u6d88\u606f\u6570\u91cf 1 \u662f\u6d88\u8d39\u8005\u6570\u91cf\n     */\n    public int[] getQueueInfo(String queueName) {\n        AMQP.Queue.DeclareOk declareOk = this.rabbitTemplate.execute(new ChannelCallback<AMQP.Queue.DeclareOk>() {\n            public AMQP.Queue.DeclareOk doInRabbit(Channel channel) throws Exception {\n                return channel.queueDeclarePassive(queueName);\n            }\n        });\n        return new int[]{declareOk.getMessageCount(), declareOk.getConsumerCount()};\n    }\n\n    /**\n     * \u6e05\u9664\u961f\u5217\u3002\n     *\n     * @param queueName\n     * @return \u88ab\u6e05\u9664\u7684\u961f\u5217\u6570\n     */\n    public int purgeQueue(String queueName) {\n        return this.rabbitTemplate.execute(channel -> {\n            AMQP.Queue.PurgeOk queuePurged = channel.queuePurge(queueName);\n            return queuePurged.getMessageCount();\n        });\n    }\n\n}\nsrc/main/java/uw/task/listener/RunnerTaskListener.java\npublic interface RunnerTaskListener {\r\n\r\n    /**\r\n     * \u6267\u884c\u524d\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPreExecute(TaskData data);\r\n\r\n    /**\r\n     * \u6267\u884c\u540e\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPostExecute(TaskData data);\r\n\r\n}\r\nsrc/main/java/uw/task/util/GlobalRateLimiter.java\npublic class GlobalRateLimiter {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(GlobalRateLimiter.class);\r\n\r\n    private static final String REDIS_PREFIX = \"TaskRateLimit:\";\r\n\r\n    private final RedisTemplate<String, Long> redisTemplate;\r\n\r\n    /**\r\n     * LUA\u811a\u672c\u3002\r\n     * \u8fd4\u56de\u503c\u4e3a\uff1a\u53ef\u7528\u8bf7\u6c42\u6570,\u7b49\u5f85\u6beb\u79d2\u6570\u3002\r\n     */\r\n    private static final RedisScript<Long> LUA_RATE_LIMIT = RedisScript.of(\r\n            \"local key = KEYS[1];\\n\" +\r\n                    \"local requests = tonumber(ARGV[1]);\\n\" +\r\n                    \"local millis = tonumber(ARGV[2])*1000;\\n\" +\r\n                    \"local permits = tonumber(ARGV[3]);\\n\" +\r\n                    \"local remainRequests=0;\\n\" +\r\n                    \"local waitMillis=0;\\n\" +\r\n                    \"local nowRate= redis.call('INCRBY', key,permits);\\n\" +\r\n                    \"if (nowRate==permits) then \\n\" +//\u5982\u679c\u662f\u7b2c\u4e00\u6b21\u6267\u884c\uff0c\u8bbe\u7f6e\u6709\u6548\u671f\u4fdd\u62a4\u3002\r\n                    \"    redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"end\\n\" +\r\n                    \"remainRequests = requests-nowRate;\\n\" +\r\n                    \"if (remainRequests<1) then \\n\" +//\u8bf7\u6c42\u6570\u8d85\u8fc7\u9650\u5236\r\n                    \"    waitMillis = redis.call('PTTL',key);\\n\" +\r\n                    \"    if (waitMillis == -1) then \\n\" +\r\n                    \"        redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"        waitMillis = millis;\\n\" +\r\n                    \"    end\\n\" +\r\n                    \"end \\n\" +\r\n                    \"return waitMillis\", Long.class);\r\n\r\n\r\n    public GlobalRateLimiter(final RedisConnectionFactory redisConnectionFactory) {\r\n        redisTemplate = new RedisTemplate<String, Long>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericToStringSerializer<Long>(Long.class));\r\n        redisTemplate.setExposeConnection(true);\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.afterPropertiesSet();\r\n    }\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u53ef\u5426\u83b7\u5f97\u6388\u6743\u3002\r\n     *\r\n     * @param permits       \u7533\u8bf7\u8bbf\u95ee\u6b21\u6570\r\n     * @return \u5982\u679c\u672a\u8d85\u9650\u5219\u8fd4\u56de0\uff0c-1\u4e3a\u4e0d\u786e\u5b9a\u65f6\u95f4\uff0c\u5176\u4ed6\u4e3a\u9700\u8981\u7b49\u5f85\u7684\u6beb\u79d2\u6570\r\n     */\r\n    public long tryAcquire(String name, int requests, int seconds, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return 0;\r\n        }\r\n        Long waitLimit = redisTemplate.execute(LUA_RATE_LIMIT, Collections.singletonList(REDIS_PREFIX + name), requests,seconds, permits);\r\n        if (waitLimit==null)\r\n            return 0;\r\n        else\r\n            return waitLimit;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/exception/TaskPartnerException.java\npublic class TaskPartnerException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskPartnerException() {\r\n        super();\r\n    }\r\n\r\n    public TaskPartnerException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskPartnerException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskPartnerException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/TaskData.java\npublic class TaskData<TP, RD> implements Serializable {\n\n    /**\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 1333167065535557828L;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u672a\u8bbe\u7f6e\n     */\n    public static final int STATE_UNKNOWN = 0;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6210\u529f\n     */\n    public static final int STATE_SUCCESS = 1;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7a0b\u5e8f\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PROGRAM = 2;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u914d\u7f6e\u9519\u8bef\uff0c\u5982\u8d85\u8fc7\u6d41\u91cf\u9650\u5236\n     */\n    public static final int STATE_FAIL_CONFIG = 3;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7b2c\u4e09\u65b9\u63a5\u53e3\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PARTNER = 4;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6570\u636e\u9519\u8bef\n     */\n    public static final int STATE_FAIL_DATA = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u672c\u5730\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_LOCAL = 1;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_GLOBAL = 3;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\n     */\n    public static final int RUN_TYPE_GLOBAL_RPC = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u81ea\u52a8\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\uff0c\u4f7f\u7528\u6b64\u6a21\u5f0f\uff0c\u4f1a\u81ea\u52a8\u9009\u62e9\u672c\u5730\u8fd8\u8fdc\u7a0b\u8fd0\u884c\u6a21\u5f0f\u3002\n     */\n    public static final int RUN_TYPE_AUTO_RPC = 6;\n\n    /**\n     * \u81ea\u52a8\u91cd\u8bd5[\u4e3a\u4e86\u517c\u5bb9,\u9ed8\u8ba4\u5f00\u542f\u91cd\u8bd5]\n     */\n    public static final int RETRY_TYPE_AUTO = 0;\n\n    /**\n     * \u7528\u6237\u624b\u5de5\u91cd\u8bd5\n     */\n    public static final int RETRY_TYPE_MANUAL = 1;\n\n    /**\n     * id\uff0c\u6b64\u5e8f\u5217\u503c\u7531\u6846\u67b6\u81ea\u52a8\u751f\u6210\uff0c\u65e0\u9700\u624b\u5de5\u8bbe\u7f6e\u3002\n     */\n    private long id;\n\n    /**\n     * \u5173\u8054TAG\uff0c\u7531\u8c03\u7528\u65b9\u8bbe\u5b9a\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private String refTag;\n\n    /**\n     * \u5173\u8054id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refId;\n\n    /**\n     * \u5173\u8054\u5b50id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refSubId;\n\n    /**\n     * \u5173\u8054\u5bf9\u8c61\uff0c\u6b64\u5bf9\u8c61\u4e0d\u5b58\u5165\u6570\u636e\u5e93\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7Listener\u6765\u8bbf\u95ee\u3002\n     */\n    @JsonIgnore\n    private Object refObject;\n\n    /**\n     * \u6d41\u91cf\u9650\u5236TAG\u3002\n     */\n    private String rateLimitTag;\n\n    /**\n     * \u9700\u8981\u6267\u884c\u7684\u7c7b\u540d\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u7531\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private String taskClass = \"\";\n\n    /**\n     * \u4efb\u52a1\u6807\u7b7e\uff0c\u7528\u4e8e\u7ec6\u5206\u4efb\u52a1\u961f\u5217\uff0c\u652f\u6301\u591a\u5b9e\u4f8b\u8fd0\u884c\u3002\n     */\n    private String taskTag = \"\";\n\n    /**\n     * \u4efb\u52a1\u5ef6\u8fdf\u6beb\u79d2\u6570\u3002\u4e00\u822c\u8fd9\u4e2a\u65f6\u95f4\u4e0d\u5b9c\u592a\u957f\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4e0d\u8981\u8d85\u8fc760\u79d2\u3002\n     */\n    private long taskDelay;\n\n    /**\n     * \u6267\u884c\u53c2\u6570\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u6709\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private TP taskParam;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u7c7b\u578b\uff0c\u9ed8\u8ba4\u4e3a\u81ea\u52a8RPC\uff0c\u6839\u636e\u60c5\u51b5\u9009\u62e9\u672c\u5730\u8fd8\u662f\u8fdc\u7a0b\u8fd0\u884c\u3002\n     */\n    private int runType = RUN_TYPE_AUTO_RPC;\n\n    /**\n     * \u91cd\u8bd5\u7c7b\u578b\n     */\n    private int retryType;\n\n    /**\n     * \u6307\u5b9a\u8fd0\u884c\u76ee\u6807\u3002\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aIP\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostIp;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aID\uff08\u53ef\u80fd\u4e3adocker\u7684ContainerID\uff09\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostId;\n\n    /**\n     * \u8fdb\u5165\u961f\u5217\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date queueDate;\n\n    /**\n     * \u5f00\u59cb\u6d88\u8d39\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date consumeDate;\n\n    /**\n     * \u5f00\u59cb\u8fd0\u884c\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date runDate;\n\n    /**\n     * \u8fd0\u884c\u7ed3\u675f\u65e5\u671f\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date finishDate;\n\n    /**\n     * \u6267\u884c\u4fe1\u606f\uff0c\u7528\u4e8e\u5b58\u50a8\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private RD resultData;\n\n    /**\n     * \u51fa\u9519\u4fe1\u606f\n     */\n    private String errorInfo;\n\n    /**\n     * \u5df2\u7ecf\u6267\u884c\u7684\u6b21\u6570\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int ranTimes;\n\n    /**\n     * \u6267\u884c\u72b6\u6001\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u6839\u636e\u5f02\u5e38\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int state;\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * @param id the id to set\n     */\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return refId;\n    }\n\n    /**\n     * @param refId the refId to set\n     */\n    public void setRefId(long refId) {\n        this.refId = refId;\n    }\n\n    /**\n\t * @return the refSubId\n\t */\n\tpublic long getRefSubId() {\n\t\treturn refSubId;\n\t}\n\n\t/**\n\t * @param refSubId the refSubId to set\n\t */\n\tpublic void setRefSubId(long refSubId) {\n\t\tthis.refSubId = refSubId;\n\t}\n\n\t/**\n\t * @return the refTag\n\t */\n\tpublic String getRefTag() {\n\t\treturn refTag;\n\t}\n\n\t/**\n\t * @param refTag the refTag to set\n\t */\n\tpublic void setRefTag(String refTag) {\n\t\tthis.refTag = refTag;\n\t}\n\n\t/**\n\t * @return the rateLimitTag\n\t */\n\tpublic String getRateLimitTag() {\n\t\treturn rateLimitTag;\n\t}\n\n\t/**\n\t * @param rateLimitTag the rateLimitTag to set\n\t */\n\tpublic void setRateLimitTag(String rateLimitTag) {\n\t\tthis.rateLimitTag = rateLimitTag;\n\t}\n\n\t/**\n\t * @return the refObject\n\t */\n\tpublic Object getRefObject() {\n\t\treturn refObject;\n\t}\n\n    /**\n     * @param refObject the refObject to set\n     */\n    public void setRefObject(Object refObject) {\n        this.refObject = refObject;\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    /**\n     * @param taskClass the taskClass to set\n     */\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    /**\n\t * @return the taskTag\n\t */\n\tpublic String getTaskTag() {\n\t\treturn taskTag;\n\t}\n\n\tpublic long getTaskDelay() {\n\t\treturn taskDelay;\n\t}\n\n\tpublic void setTaskDelay(long taskDelay) {\n\t\tthis.taskDelay = taskDelay;\n\t}\n\n\t/**\n\t * @param taskTag the taskTag to set\n\t */\n\tpublic void setTaskTag(String taskTag) {\n\t\tthis.taskTag = taskTag;\n\t}\n\n\t/**\n     * @return the taskParam\n     */\n    public TP getTaskParam() {\n        return taskParam;\n    }\n\n    /**\n     * @param taskParam the taskParam to set\n     */\n    public void setTaskParam(TP taskParam) {\n        this.taskParam = taskParam;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return runType;\n    }\n\n    /**\n     * @param runType the runType to set\n     */\n    public void setRunType(int runType) {\n        this.runType = runType;\n    }\n\n    public int getRetryType() {\n        return retryType;\n    }\n\n    public void setRetryType(int retryType) {\n        this.retryType = retryType;\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    /**\n     * @param runTarget the runTarget to set\n     */\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * @param hostIp the hostIp to set\n     */\n    public void setHostIp(String hostIp) {\n        this.hostIp = hostIp;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return queueDate;\n    }\n\n    /**\n     * @param queueDate the queueDate to set\n     */\n    public void setQueueDate(Date queueDate) {\n        this.queueDate = queueDate;\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return consumeDate;\n    }\n\n    /**\n     * @param consumeDate the consumeDate to set\n     */\n    public void setConsumeDate(Date consumeDate) {\n        this.consumeDate = consumeDate;\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return runDate;\n    }\n\n    /**\n     * @param runDate the runDate to set\n     */\n    public void setRunDate(Date runDate) {\n        this.runDate = runDate;\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return finishDate;\n    }\n\n    /**\n     * @param finishDate the finishDate to set\n     */\n    public void setFinishDate(Date finishDate) {\n        this.finishDate = finishDate;\n    }\n\n    /**\n     * @return the resultData\n     */\n    public RD getResultData() {\n        return resultData;\n    }\n\n    /**\n     * @param resultData the resultData to set\n     */\n    public void setResultData(RD resultData) {\n        this.resultData = resultData;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return errorInfo;\n    }\n\n    /**\n     * @param errorInfo the errorInfo to set\n     */\n    public void setErrorInfo(String errorInfo) {\n        this.errorInfo = errorInfo;\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return ranTimes;\n    }\n\n    /**\n     * @param ranTimes the ranTimes to set\n     */\n    public void setRanTimes(int ranTimes) {\n        this.ranTimes = ranTimes;\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * @param status the status to set\n     */\n    public void setState(int status) {\n        this.state = status;\n    }\n\n}\nsrc/main/java/uw/task/TaskRunner.java\npublic abstract class TaskRunner<TP, RD> {\r\n\r\n    /**\r\n     * \u6267\u884c\u4efb\u52a1\u3002\r\n     * \u4e1a\u52a1\u5c42\u9762\u7684\u5f02\u5e38\u8bf7\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u624b\u52a8Throw TaskException:\r\n     * \u76ee\u524d\u652f\u6301\u7684\u5f02\u5e38:\r\n     * 1. TaskDataException \u4efb\u52a1\u6570\u636e\u5f02\u5e38\r\n     * 2. TaskPartnerException \u4efb\u52a1\u5408\u4f5c\u65b9\u5f02\u5e38\r\n     *\r\n     * @param taskData \u6570\u636e\r\n     * @throws Exception \u5f02\u5e38\r\n     * @return \u6307\u5b9a\u7684\u8fd4\u56de\u5bf9\u8c61\r\n     */\r\n    public abstract RD runTask(TaskData<TP, RD> taskData) throws Exception;\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u914d\u7f6e\u4fe1\u606f\r\n     *\r\n     * @return TaskRunnerConfig\u914d\u7f6e\r\n     */\r\n    public abstract TaskRunnerConfig initConfig();\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     *\r\n     * @return TaskContact\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     */\r\n    public abstract TaskContact initContact();\r\n}\nsrc/main/java/uw/task/conf/TaskMetaInfoManager.java\npublic class TaskMetaInfoManager {\r\n\r\n\t/**\r\n\t * \u8fd0\u884c\u4e3b\u673a\u914d\u7f6e\r\n\t */\r\n\tstatic List<String> targetConfig = null;\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tstatic Map<String, TaskRunner> runnerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic Map<String, TaskCroner> cronerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskRunnerConfig> runnerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskCronerConfig> cronerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u8fd0\u884c\u5b9e\u4f8b\u3002\r\n\t *\r\n\t * @param taskClass\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunner<?, ?> getRunner(String taskClass) {\r\n\t\treturn runnerMap.get(taskClass);\r\n\t}\r\n\r\n\t/**\r\n\t * \u68c0\u67e5\u4e00\u4e2arunner\u662f\u5426\u53ef\u4ee5\u5728\u672c\u5730\u8fd0\u884c\u3002\r\n\t * \r\n\t * @param taskData\r\n\t * @return\r\n\t */\r\n\tpublic static boolean checkRunnerRunLocal(TaskData<?, ?> taskData) {\r\n\t\treturn runnerMap.containsKey(taskData.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u6839\u636e\u670d\u52a1\u5668\u7aefQueue\u5217\u8868\uff0c\u8fd4\u56de\u5408\u9002\u7684key\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getFitQueue(TaskData<?, ?> data) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tif (runnerConfigMap.containsKey(all)) {\r\n\t\t\treturn all;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            if (runnerConfigMap.containsKey(test)) {\r\n                return test;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u6700\u540e\u90fd\u6ca1\u5339\u914d\u5230\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e\r\n\t\treturn all;\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u914d\u7f6e\r\n\t *\r\n\t * @param data\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunnerConfig getRunnerConfig(TaskData<?, ?> data) {\r\n\t\tTaskRunnerConfig config = null;\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tconfig = runnerConfigMap.get(all);\r\n\t\tif (config != null) {\r\n\t\t\treturn config;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            config = runnerConfigMap.get(test);\r\n            if (config != null) {\r\n                return config;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new RuntimeException(\"\u627e\u4e0d\u5230\u4efb\u52a1\u914d\u7f6e: taskClass = \" + data.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u66f4\u65b0\u7cfb\u7edf\u961f\u5217\u8868\u3002\r\n\t * \r\n\t * @param config\r\n\t */\r\n\tstatic void updateSysQueue(final TaskRunnerConfig config) {\r\n\t\tString key = getRunnerConfigKey(config);\r\n\t\t// \u68c0\u6d4b\u662f\u5426\u8001\u7684TaskRunnerConfig\u662f\u5426\u662f\u672c\u5730\u7684\u5b8c\u6574\u914d\u7f6e\uff0c\u5982\u679c\u662f\uff0c\u5219\u4e0d\u7ba1\u3002\r\n\t\tTaskRunnerConfig old = runnerConfigMap.get(key);\r\n\t\tif (old == null || (old != null && old.getCreateDate() == null)) {\r\n\t\t\tif (config.getState() < 1) {\r\n\t\t\t\trunnerConfigMap.remove(key);\r\n\t\t\t} else {\r\n\t\t\t\trunnerConfigMap.put(key, config);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97croner\u914d\u7f6e\u952e\u3002 \u4f7f\u7528taskClass#Id$target\u6765\u914d\u7f6e\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getCronerConfigKey(TaskCronerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskParam() != null && config.getTaskParam().length() > 0) {\r\n\t\t\tsb.append(config.getId());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97Runner\u914d\u7f6e\u7ed3\u5408Host\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getRunnerConfigKey(TaskRunnerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskTag() != null && config.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(config.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n    /**\r\n     * \u83b7\u5f97RunnerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getRunnerLogKey(TaskData<?,?> log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskTag() != null && log.getTaskTag().length() > 0) {\r\n            sb.append(log.getTaskTag());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97CronerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getCronerLogKey(TaskCronerLog log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskParam() != null && log.getTaskParam().length()>0){\r\n            sb.append(log.getTaskParam());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\nsrc/main/java/uw/task/api/TaskAPI.java\npublic class TaskAPI {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskAPI.class);\n\n    /**\n     * Task\u914d\u7f6e\u6587\u4ef6\n     */\n    private TaskProperties taskProperties;\n\n    /**\n     * Rest\u6a21\u677f\u7c7b\n     */\n    private RestTemplate restTemplate;\n\n    /**\n     * \u65e5\u5fd7\u5ba2\u6237\u7aef\u3002\n     */\n    private LogClient logClient = null;\n\n    /**\n     * \u672c\u673a\u7684\u5916\u7f51IP\n     */\n    private String hostIp = \"\";\n\n    public TaskAPI(final TaskProperties taskProperties, final RestTemplate restTemplate,\n                   final LogClient logClient) {\n        this.taskProperties = taskProperties;\n        this.restTemplate = restTemplate;\n        this.logClient = logClient;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u76ee\u6807\u914d\u7f6e\u3002\n     *\n     * @return\n     */\n    public List<String> getServerTargetConfig() {\n        List<String> targetConfig = null;\n        // \u5224\u65ad\u662f\u5426\u662f\u79c1\u6709\u6a21\u5f0f\u3002\n        boolean privacyMode = taskProperties.isPrivacyMode();\n        try {\n            String[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/target/config?targetType={targetType}\", String[].class,\n                    privacyMode ? 1 : 0);\n            targetConfig = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getHostConfig()\u670d\u52a1\u7aefTarget\u914d\u7f6e\u62c9\u53d6\u5f02\u5e38:{}\", e.getMessage());\n        }\n        if (targetConfig == null || targetConfig.size() == 0) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"\u83b7\u5f97\u4e3b\u673aTarget\u670d\u52a1\u7aef\u914d\u7f6e\u5931\u8d25\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e\u9879!\");\n            }\n            targetConfig = new ArrayList<>();\n            if (!privacyMode) {\n                targetConfig.add(\"\");\n            }\n        }\n        return targetConfig;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u72b6\u6001\uff0c\u8fd4\u56de\u4e3b\u673aIP\u5730\u5740\u3002\n     *\n     * @return \u4e3b\u673aIP\u5730\u5740\n     */\n    public String updateHostStatus() {\n        String ip = \"\";\n        TaskHostStatus taskHostStatus = new TaskHostStatus();\n        taskHostStatus.setHostId(taskProperties.getHostId());\n        taskHostStatus.setTaskProject(taskProperties.getProject());\n        try {\n            ip = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/host/status\", taskHostStatus,\n                    String.class);\n            hostIp = ip;\n        } catch (Exception e) {\n            log.error(\"TaskAPI.updateHostStatus()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return ip;\n    }\n\n    /**\n     * \u521d\u59cb\u5316CronerConfig\u3002\n     *\n     * @param config\n     */\n    public TaskCronerConfig initTaskCronerConfig(TaskCronerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/croner/config\", config,\n                    TaskCronerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskCronerConfig\u4e0a\u4f20Croner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n    }\n\n    /**\n     * \u521d\u59cb\u5316RunnerConfig\n     *\n     * @param config\n     */\n    public TaskRunnerConfig initTaskRunnerConfig(TaskRunnerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/runner/config\", config,\n                    TaskRunnerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskRunnerConfig\u4e0a\u4f20Runner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n\n    }\n\n    /**\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\u3002\n     *\n     * @param contact\n     */\n    public void initTaskContact(TaskContact contact) {\n        try {\n            restTemplate.postForLocation(taskProperties.getTaskCenterHost() + \"/taskapi/contact\", contact);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskContact\u4e0a\u4f20\u8054\u7cfb\u4eba\u4fe1\u606f\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n    }\n\n    /**\n     * \u6839\u636e\u66f4\u65b0\u65f6\u95f4\u83b7\u5f97\u53d8\u5316\u7684TaskRunner\u961f\u5217\u5217\u8868\u3002\n     *\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerQueueList(long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/runner/queue?lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerQueueList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskRunner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/runner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskCroner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskCronerConfig> getTaskCronerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskCronerConfig> list = null;\n        try {\n            TaskCronerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskCronerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskCronerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u53d1\u9001Runner\u4efb\u52a1\u65e5\u5fd7\u3002\n     *\n     * @param log\n     */\n    public void sendTaskRunnerLog(TaskRunnerLog log) {\n        logClient.log(log);\n    }\n\n    /**\n     * \u53d1\u9001CronLog\u65e5\u5fd7\n     *\n     * @param configId      \u914d\u7f6eId,\u65b9\u4fbf\u66f4\u65b0\u4e0b\u4e00\u6b21\u6267\u884c\u65f6\u95f4\n     * @param taskCronerLog \u65e5\u5fd7\u5bf9\u8c61\n     */\n    public void sendTaskCronerLog(long configId, TaskCronerLog taskCronerLog) {\n        try {\n            restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/tick?id={id}&nextDate={nextDate}\",\n                    Integer.class, configId, taskCronerLog.getNextDate().getTime());\n        } catch (Exception e) {\n            log.error(\"TaskAPI.cornerTick()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38: \" + e.getMessage(), e);\n        }\n\n        int logLevel = taskCronerLog.getLogLevel();\n        int logLimitSize = taskCronerLog.getLogLimitSize();\n        if (logLevel > TaskCronerConfig.TASK_LOG_TYPE_NONE) {\n            switch (logLevel) {\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD: {\n                    taskCronerLog.setTaskParam(null);\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM: {\n                    String taskParam = taskCronerLog.getTaskParam();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                        taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA: {\n                    String resultData = taskCronerLog.getResultData();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                        taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setTaskParam(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_ALL: {\n                    if (logLimitSize > 0) {\n                        String taskParam = taskCronerLog.getTaskParam();\n                        String resultData = taskCronerLog.getResultData();\n                        if (StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                            taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                        }\n                        if (StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                            taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                        }\n                    }\n                }\n                break;\n            }\n            logClient.log(taskCronerLog);\n        }\n    }\n}\nsrc/main/java/uw/task/exception/TaskDataException.java\npublic class TaskDataException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskDataException() {\r\n        super();\r\n    }\r\n\r\n    public TaskDataException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskDataException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskDataException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/entity/TaskRunnerConfig.java\npublic class TaskRunnerConfig implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u4e0d\u9650\u901f\n     */\n    public static final int RATE_LIMIT_NONE = 0;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730\u8fdb\u7a0b\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL = 1;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK = 2;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK_TAG = 3;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40\u4e3b\u673aHOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_HOST = 4;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG = 5;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK = 6;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG+HOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG_HOST = 7;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_HOST = 8;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG = 9;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG_HOST = 10;\n\n    /**\n     * \u4ec0\u4e48\u90fd\u4e0d\u8bb0\u5f55\n     */\n    public static final int TASK_LOG_TYPE_NONE = -1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD = 0;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8bf7\u6c42\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_TASK_PARAM = 1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8fd4\u56de\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_RESULT_DATA = 2;\n\n    /**\n     * \u8bb0\u5f55\u5168\u90e8\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD_ALL = 3;\n\n    private long id;\n\n    /**\n     * \u4efb\u52a1\u540d\u79f0\n     */\n    private String taskName;\n\n    /**\n     * \u4efb\u52a1\u63cf\u8ff0\n     */\n    private String taskDesc;\n\n    /**\n     * \u6267\u884c\u7c7b\u4fe1\u606f\n     */\n    private String taskClass;\n\n    /**\n     * \u6267\u884c\u7c7bTAG\uff0c\u53ef\u80fd\u7528\u4e8e\u533a\u5206\u5b50\u4efb\u52a1\n     */\n    private String taskTag;\n\n    /**\n     * \u6d88\u8d39\u8005\u7684\u6570\u91cf\n     */\n    private int consumerNum = 1;\n\n    /**\n     * \u9884\u53d6\u4efb\u52a1\u6570\u3002\n     */\n    private int prefetchNum = 1;\n\n    /**\n     * \u8be6\u89c1\u6d41\u91cf\u9650\u5236\u7c7b\u578b\u8bf4\u660e\u3002\n     */\n    private int rateLimitType = RATE_LIMIT_NONE;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u6570\u503c\uff0c\u9ed8\u8ba4\u4e3a10\u6b21\n     */\n    private int rateLimitValue = 10;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u65f6\u95f4(S)\uff0c\u9ed8\u8ba4\u4e3a1\u79d2\n     */\n    private int rateLimitTime = 1;\n\n    /**\n     * \u5f53\u53d1\u751f\u6d41\u91cf\u9650\u5236\u65f6\uff0c\u7b49\u5f85\u7684\u79d2\u6570\uff0c\u9ed8\u8ba4300\u79d2\n     */\n    private int rateLimitWait = 30;\n\n    /**\n     * \u8d85\u8fc7\u6d41\u91cf\u9650\u5236\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u5728\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByOverrated = 0;\n\n    /**\n     * \u5bf9\u65b9\u63a5\u53e3\u9519\u8bef\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u518d\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByPartner = 0;\n\n    /**\n     * \u8fd0\u884c\u76ee\u6807\uff0c\u9ed8\u8ba4\u4e0d\u6307\u5b9a\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u5931\u8d25\u7387\n     */\n    private int failRate;\n\n    /**\n     * \u63a5\u53e3\u5931\u8d25\u7387\n     */\n    private int failPartnerRate;\n\n    /**\n     * \u7a0b\u5e8f\u5931\u8d25\u7387\n     */\n    private int failProgramRate;\n\n    /**\n     * \u914d\u7f6e\u5931\u8d25\u7387\n     */\n    private int failConfigRate;\n\n    /**\n     * \u6570\u636e\u5931\u8d25\u7387\n     */\n    private int failDataRate;\n\n    /**\n     * \u961f\u5217\u7b49\u5f85\u8d85\u65f6\n     */\n    private int queueTimeout;\n\n    /**\n     * \u7b49\u5f85\u8d85\u65f6\n     */\n    private int waitTimeout;\n\n    /**\n     * \u8fd0\u884c\u8d85\u65f6\n     */\n    private int runTimeout;\n\n    /**\n     * \u521b\u5efa\u65e5\u671f\u3002\n     */\n    private Date createDate;\n\n    /**\n     * \u4fee\u6539\u65e5\u671f\u3002\n     */\n    private Date modifyDate;\n\n    /**\n     * \u72b6\u6001\u503c\n     */\n    private int state = 1;\n\n    /**\n     * \u8be6\u89c1\u65e5\u5fd7\u7c7b\u578b\u8bf4\u660e\n     */\n    private int logLevel = TASK_LOG_TYPE_RECORD;\n\n    /**\n     * \u65e5\u5fd7\u5b57\u7b26\u4e32\u5b57\u6bb5\u5927\u5c0f\u9650\u5236: 0 \u8868\u793a\u65e0\u9650\u5236\n     */\n    private int logLimitSize = 0;\n\n    public TaskRunnerConfig() {\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getTaskName() {\n        return taskName;\n    }\n\n    public void setTaskName(String taskName) {\n        this.taskName = taskName;\n    }\n\n    public String getTaskDesc() {\n        return taskDesc;\n    }\n\n    public void setTaskDesc(String taskDesc) {\n        this.taskDesc = taskDesc;\n    }\n\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    public String getTaskTag() {\n        return taskTag;\n    }\n\n    public void setTaskTag(String taskTag) {\n        this.taskTag = taskTag;\n    }\n\n    public int getConsumerNum() {\n        return consumerNum;\n    }\n\n    public void setConsumerNum(int consumerNum) {\n        this.consumerNum = consumerNum;\n    }\n\n    public int getPrefetchNum() {\n        return prefetchNum;\n    }\n\n    public void setPrefetchNum(int prefetchNum) {\n        this.prefetchNum = prefetchNum;\n    }\n\n    public int getRateLimitType() {\n        return rateLimitType;\n    }\n\n    public void setRateLimitType(int rateLimitType) {\n        this.rateLimitType = rateLimitType;\n    }\n\n    public int getRateLimitValue() {\n        return rateLimitValue;\n    }\n\n    public void setRateLimitValue(int rateLimitValue) {\n        this.rateLimitValue = rateLimitValue;\n    }\n\n    public int getRateLimitTime() {\n        return rateLimitTime;\n    }\n\n    public void setRateLimitTime(int rateLimitTime) {\n        this.rateLimitTime = rateLimitTime;\n    }\n\n    public int getRateLimitWait() {\n        return rateLimitWait;\n    }\n\n    public void setRateLimitWait(int rateLimitWait) {\n        this.rateLimitWait = rateLimitWait;\n    }\n\n    public int getRetryTimesByOverrated() {\n        return retryTimesByOverrated;\n    }\n\n    public void setRetryTimesByOverrated(int retryTimesByOverrated) {\n        this.retryTimesByOverrated = retryTimesByOverrated;\n    }\n\n    public int getRetryTimesByPartner() {\n        return retryTimesByPartner;\n    }\n\n    public void setRetryTimesByPartner(int retryTimesByPartner) {\n        this.retryTimesByPartner = retryTimesByPartner;\n    }\n\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    public int getFailRate() {\n        return failRate;\n    }\n\n    public void setFailRate(int failRate) {\n        this.failRate = failRate;\n    }\n\n    public int getFailPartnerRate() {\n        return failPartnerRate;\n    }\n\n    public void setFailPartnerRate(int failPartnerRate) {\n        this.failPartnerRate = failPartnerRate;\n    }\n\n    public int getFailProgramRate() {\n        return failProgramRate;\n    }\n\n    public void setFailProgramRate(int failProgramRate) {\n        this.failProgramRate = failProgramRate;\n    }\n\n    public int getFailConfigRate() {\n        return failConfigRate;\n    }\n\n    public void setFailConfigRate(int failConfigRate) {\n        this.failConfigRate = failConfigRate;\n    }\n\n    public int getFailDataRate() {\n        return failDataRate;\n    }\n\n    public void setFailDataRate(int failDataRate) {\n        this.failDataRate = failDataRate;\n    }\n\n    public int getQueueTimeout() {\n        return queueTimeout;\n    }\n\n    public void setQueueTimeout(int queueTimeout) {\n        this.queueTimeout = queueTimeout;\n    }\n\n    public int getWaitTimeout() {\n        return waitTimeout;\n    }\n\n    public void setWaitTimeout(int waitTimeout) {\n        this.waitTimeout = waitTimeout;\n    }\n\n    public int getRunTimeout() {\n        return runTimeout;\n    }\n\n    public void setRunTimeout(int runTimeout) {\n        this.runTimeout = runTimeout;\n    }\n\n    public Date getCreateDate() {\n        return createDate;\n    }\n\n    public void setCreateDate(Date createDate) {\n        this.createDate = createDate;\n    }\n\n    public Date getModifyDate() {\n        return modifyDate;\n    }\n\n    public void setModifyDate(Date modifyDate) {\n        this.modifyDate = modifyDate;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n    }\n\n    public int getLogLevel() {\n        return logLevel;\n    }\n\n    public void setLogLevel(int logLevel) {\n        this.logLevel = logLevel;\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/util/MiscUtils.java\npublic class MiscUtils {\r\n\r\n    /**\r\n     * taskData\u7684copy\u5668\u3002\r\n     */\r\n    private static BeanCopier beanCopier = BeanCopier.create(TaskData.class, TaskData.class, false);\r\n\r\n    /**\r\n     * copy taskData\u5bf9\u8c61\u3002\r\n     *\r\n     * @param srcData\r\n     * @param dstData\r\n     */\r\n    public static void copyTaskData(TaskData srcData, TaskData dstData) {\r\n        beanCopier.copy(srcData, dstData, null);\r\n    }\r\n\r\n    /**\r\n     * \u6253\u5370\u5f02\u5e38\u4fe1\u606f\uff0c\u5c4f\u853d\u6389spring\u81ea\u5df1\u7684\u5806\u6808\u8f93\u51fa\u3002\r\n     *\r\n     * @param e \u9700\u8981\u6253\u5370\u7684\u5f02\u5e38\u4fe1\u606f\r\n     * @return\r\n     */\r\n    public static String exceptionToString(Throwable e) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(e.toString()).append(\"\\n\");\r\n\r\n        StackTraceElement[] trace = e.getStackTrace();\r\n        for (StackTraceElement traceElement : trace) {\r\n            if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                continue;\r\n            }\r\n            if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                continue;\r\n            }\r\n            sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n        }\r\n        Throwable ourCause = e.getCause();\r\n        if (ourCause != null) {\r\n            sb.append(\"CAUSE BY\").append(ourCause.toString()).append(\"\\n\");\r\n            trace = ourCause.getStackTrace();\r\n            for (StackTraceElement traceElement : trace) {\r\n                if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                    continue;\r\n                }\r\n                if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                    continue;\r\n                }\r\n                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskListenerManager.java\npublic class TaskListenerManager {\r\n\r\n\t/**\r\n\t * runner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n\t */\r\n    private ArrayList<RunnerTaskListener> runnerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * croner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n     */\r\n    private ArrayList<CronerTaskListener> cronerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener\u3002\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addRunnerListener(RunnerTaskListener listener) {\r\n        runnerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener.\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addCronerListener(CronerTaskListener listener) {\r\n        cronerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearRunnerListener() {\r\n        runnerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearCronerListener() {\r\n        cronerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Runner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<RunnerTaskListener> getRunnerListenerList() {\r\n        return runnerListenerList;\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Croner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<CronerTaskListener> getCronerListenerList() {\r\n        return cronerListenerList;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/entity/TaskRunnerLog.java\n@JsonIgnoreProperties({\"taskData\"})\npublic class TaskRunnerLog extends LogBaseVo {\n\n    private static final Logger logger = LoggerFactory.getLogger(TaskRunnerLog.class);\n\n    private TaskData taskData;\n\n    /**\n     * logLimitSize\u3002\n     */\n    private int logLimitSize;\n\n    public TaskRunnerLog(TaskData taskData) {\n        this.taskData = taskData;\n    }\n\n    public TaskData getTaskData() {\n        return taskData;\n    }\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return taskData.getId();\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return taskData.getRefId();\n    }\n\n    /**\n     * @return the refSubId\n     */\n    public long getRefSubId() {\n        return taskData.getRefSubId();\n    }\n\n    /**\n     * @return the refTag\n     */\n    public String getRefTag() {\n        return taskData.getRefTag();\n    }\n\n    /**\n     * @return the rateLimitTag\n     */\n    public String getRateLimitTag() {\n        return taskData.getRateLimitTag();\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskData.getTaskClass();\n    }\n\n    /**\n     * @return the taskTag\n     */\n    public String getTaskTag() {\n        return taskData.getTaskTag();\n    }\n\n    public long getTaskDelay() {\n        return taskData.getTaskDelay();\n    }\n\n    /**\n     * @return the taskParam\n     */\n    public String getTaskParam() {\n        Object value = taskData.getTaskParam();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return taskData.getRunType();\n    }\n\n    /**\n     * @return the retryType\n     */\n    public int getRetryType() {\n        return taskData.getRetryType();\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return taskData.getRunTarget();\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return taskData.getHostIp();\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return taskData.getHostId();\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return taskData.getQueueDate();\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return taskData.getConsumeDate();\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return taskData.getRunDate();\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return taskData.getFinishDate();\n    }\n\n    /**\n     * @return the resultData\n     */\n    public String getResultData() {\n        Object value = taskData.getResultData();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return taskData.getErrorInfo();\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return taskData.getRanTimes();\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return taskData.getState();\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/conf/TaskProperties.java\n@ConfigurationProperties(prefix = \"uw.task\")\npublic class TaskProperties {\n\n    /**\n     * \u662f\u5426\u542f\u7528uw-task\u670d\u52a1\u6ce8\u518c\u548c\u4e3b\u673a\u6ce8\u518c\uff0c\u9ed8\u8ba4\u4e0d\u542f\u7528\u3002\n     *\n     */\n    private boolean enableTaskRegistry = false;\n    /**\n     * \u4efb\u52a1\u540d\uff0c\u5fc5\u987b\u8bbe\u7f6e\u4e3a\u57fa\u7840\u5305\u540d\u3002\n     */\n    private String project;\n\n    /**\n     * \u79c1\u6709\u6a21\u5f0f\u3002\u4e0d\u8fd0\u884c\u5168\u5c40target\u4efb\u52a1\u3002\n     */\n    private boolean privacyMode = false;\n\n    /**\n     * croner\u7ebf\u7a0b\u6570\uff0c\u9ed8\u8ba4\u57283\u4e2a\uff0c\u5efa\u8bae\u6309\u7167\u5b9e\u9645croner\u4efb\u52a1\u6570\u91cf*70%\u3002\n     */\n    private int cronerThreadNum = 5;\n\n    /**\n     * RPC\u6700\u5c0f\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u5982\u4e0d\u4f7f\u7528rpc\uff0c\u5efa\u8bae\u8bbe\u7f6e\u4e3a1\uff0c\u5426\u5219\u6309\u7167\u6700\u5927\u5e76\u53d1\u91cf*10%\u8bbe\u7f6e\u3002\n     */\n    private int taskRpcMinThreadNum = 1;\n\n    /**\n     * RPC\u6700\u5927\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u8d85\u8fc7\u6b64\u7ebf\u7a0b\u6570\uff0c\u5c06\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     */\n    private int taskRpcMaxThreadNum = 100;\n\n    /**\n     * \u961f\u5217\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba42\u79d2\n     */\n    private long taskQueueRetryDelay = 2000;\n\n    /**\n     *  rpc\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba4100\u6beb\u79d2\n     */\n    private long taskRpcRetryDelay = 100;\n\n    /**\n     * \u8fd0\u884c\u4e3b\u673aID\n     */\n    private String hostId = ManagementFactory.getRuntimeMXBean().getName();\n\n    /**\n     * \u4efb\u52a1\u670d\u52a1\u5668\n     */\n    private String taskCenterHost = \"127.0.0.1\";\n\n    /**\n     * Redis\u914d\u7f6e\n     */\n    private RedisProperties redis = new RedisProperties();\n\n    /**\n     * Rabbit MQ\u914d\u7f6e\n     */\n    private RabbitProperties rabbitmq = new RabbitProperties();\n\n    public static class RedisProperties extends org.springframework.boot.autoconfigure.data.redis.RedisProperties {\n\n    }\n\n    public static class RabbitProperties extends org.springframework.boot.autoconfigure.amqp.RabbitProperties {\n\n    }\n\n    public boolean isEnableTaskRegistry() {\n        return enableTaskRegistry;\n    }\n\n    public void setEnableTaskRegistry(boolean enableTaskRegistry) {\n        this.enableTaskRegistry = enableTaskRegistry;\n    }\n\n    /**\n\t * @return the privacyMode\n\t */\n\tpublic boolean isPrivacyMode() {\n\t\treturn privacyMode;\n\t}\n\n\t/**\n\t * @param privacyMode the privacyMode to set\n\t */\n\tpublic void setPrivacyMode(boolean privacyMode) {\n\t\tthis.privacyMode = privacyMode;\n\t}\n\n\tpublic int getTaskRpcMinThreadNum() {\n\t\treturn taskRpcMinThreadNum;\n\t}\n\n\tpublic void setTaskRpcMinThreadNum(int taskRpcMinThreadNum) {\n\t\tthis.taskRpcMinThreadNum = taskRpcMinThreadNum;\n\t}\n\n\tpublic int getTaskRpcMaxThreadNum() {\n\t\treturn taskRpcMaxThreadNum;\n\t}\n\n\tpublic void setTaskRpcMaxThreadNum(int taskRpcMaxThreadNum) {\n\t\tthis.taskRpcMaxThreadNum = taskRpcMaxThreadNum;\n\t}\n\n\t/**\n     * @return the project\n     */\n    public String getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(String project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n\t * @return the cronerThreadNum\n\t */\n\tpublic int getCronerThreadNum() {\n\t\treturn cronerThreadNum;\n\t}\n\n\t/**\n\t * @param cronerThreadNum the cronerThreadNum to set\n\t */\n\tpublic void setCronerThreadNum(int cronerThreadNum) {\n\t\tthis.cronerThreadNum = cronerThreadNum;\n\t}\n\n\t/**\n     * @return the taskCenterHost\n     */\n    public String getTaskCenterHost() {\n        return taskCenterHost;\n    }\n\n    /**\n     * @param taskCenterHost the taskCenterHost to set\n     */\n    public void setTaskCenterHost(String taskCenterHost) {\n        this.taskCenterHost = taskCenterHost;\n    }\n\n    public RedisProperties getRedis() {\n        return redis;\n    }\n\n    public void setRedis(RedisProperties redis) {\n        this.redis = redis;\n    }\n\n    public RabbitProperties getRabbitmq() {\n        return rabbitmq;\n    }\n\n    public void setRabbitmq(RabbitProperties rabbitmq) {\n        this.rabbitmq = rabbitmq;\n    }\n\n    public long getTaskQueueRetryDelay() {\n        return taskQueueRetryDelay;\n    }\n\n    public void setTaskQueueRetryDelay(long taskQueueRetryDelay) {\n        this.taskQueueRetryDelay = taskQueueRetryDelay;\n    }\n\n    public long getTaskRpcRetryDelay() {\n        return taskRpcRetryDelay;\n    }\n\n    public void setTaskRpcRetryDelay(long taskRpcRetryDelay) {\n        this.taskRpcRetryDelay = taskRpcRetryDelay;\n    }\n}\n", "answers": ["    private LocalRateLimiter localRateLimiter;"], "pred": "  code: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: 1: ", "length": 5298, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "fbea06f3c6f93b8aaf69f52783041ff4c6ce262cc8922060"}
{"prompt": "Please complete the code given below. \nsrc/main/java/org/cryptomator/sanitizer/Passphrase.java\npublic class Passphrase implements CharSequence, AutoCloseable {\n\n\tprivate final char[] chars;\n\n\tpublic Passphrase(char[] chars) {\n\t\tthis.chars = chars;\n\t}\n\n\tpublic Passphrase(CharBuffer chars) {\n\t\tthis.chars = new char[chars.remaining()];\n\t\tchars.get(this.chars);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tArrays.fill(chars, ' ');\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn chars.length;\n\t}\n\n\t@Override\n\tpublic char charAt(int index) {\n\t\treturn chars[index];\n\t}\n\n\t@Override\n\tpublic Passphrase subSequence(int start, int end) {\n\t\tint len = end - start;\n\t\tchar[] result = new char[len];\n\t\tSystem.arraycopy(chars, start, result, 0, len);\n\t\treturn new Passphrase(result);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new String(chars);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/IntegrityCheck.java\npublic class IntegrityCheck {\n\n\tprivate final CryptorHolder cryptorHolder;\n\n\tpublic IntegrityCheck(CryptorHolder cryptorHolder) {\n\t\tthis.cryptorHolder = cryptorHolder;\n\t}\n\n\tpublic Set<Problem> check(Path path, CharSequence passphrase, boolean checkFileIntegrity) throws AbortCheckException {\n\t\tProblems problems = new Problems(path);\n\t\ttry {\n\t\t\tcryptorHolder.createCryptor(problems, path, passphrase).ifPresent(cryptor -> {\n\t\t\t\ttry {\n\t\t\t\t\tvaultFormatChecks(cryptor, path, checkFileIntegrity).check(problems, path);\n\t\t\t\t} finally {\n\t\t\t\t\tcryptor.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (AbortCheckException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tproblems.reportException(e);\n\t\t}\n\t\treturn problems.asSet();\n\t}\n\n\tprivate Check vaultFormatChecks(Cryptor cryptor, Path pathToVault, boolean checkContentIntegrity) {\n\t\tCheck referencedDirectoryExists = referencedDirectoryExists(cryptor, pathToVault);\n\t\tHasCorrespondingDirectoryFileCheck hasCorrespondingDirectoryFileCheck = hasCorrespondingDirectoryFile(cryptor, pathToVault);\n\t\tCheck decryptedNameCheckForRegularFiles = decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck);\n\t\tHasCorrespondingDFileCheck hasCorrespondingDFile = hasCorrespondingDFileIn(pathToVault);\n\t\tCheck decryptedNameCheckForLongFiles = Checks.decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck, hasCorrespondingDFile);\n\t\tCheck emptyEncryptedFileIfEmpty = emptyEncryptedFileIfEmpty();\n\t\treturn dir().containing( //\n\t\t\t\tdir().that(hasName(\"d\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{30}\")) //\n\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()).validate(hasCorrespondingDirectoryFileCheck) //\n\t\t\t\t\t\t\t\t\t\t.reportAs(rootDirectoryIfMachting(cryptor)) //\n\t\t\t\t\t\t\t\t\t\t.containing( //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidDirectoryFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0?([A-Z2-7]{8})*[A-Z2-7=]{1,7}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aFileWithMissingEqualsSign()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tdir().that(hasName(\"m\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName()))\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles), //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName())) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles)\n\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator\")).validate(nameDoesNotContainUppercaseChars()), // do not validate contents because this already happened when creating the Cryptor\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator.bkup\")).validate(isMasterkeyBackupFile()));\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/SolutionContext.java\npublic interface SolutionContext {\n\n\tpublic static SolutionContext simulatePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, true);\n\t}\n\n\tpublic static SolutionContext executePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, false);\n\t}\n\n\tvoid start(String format, Object... args);\n\n\tvoid finish();\n\n\tvoid fail(String format, Object... args);\n\n\tvoid fail(Throwable reason);\n\n\tboolean dryRun();\n\n\tPath vaultLocation();\n\n\tCryptor cryptor();\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void printNoNewline(String line) {\n\tprintNoNewline(line, System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Severity.java\npublic enum Severity {\n\n\t/**\n\t * Issues which prevent the integrity check from operating correctly.\n\t */\n\tFATAL,\n\n\t/**\n\t * Issues which are guaranteed to cause problems while using the vault.\n\t */\n\tERROR,\n\n\t/**\n\t * Issues which are not guaranteed to cause problems while using the vault.\n\t */\n\tWARN,\n\n\t/**\n\t * Issues which occur during normal operation of the vault.\n\t */\n\tINFO\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Problem.java\npublic interface Problem {\n\n\tSeverity severity();\n\n\tdefault Optional<Solution> solution() {\n\t\treturn Optional.empty();\n\t}\n\n\tdefault String name() {\n\t\treturn \"notSolvable\";\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/CryptorHolder.java\npublic class CryptorHolder implements AutoCloseable {\n\n\tprivate static final int VAULT_VERSION = 6;\n\n\tprivate static final int VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION = 6;\n\n\tprivate Optional<Cryptor> cryptor = Optional.empty();\n\n\tpublic Optional<Cryptor> optionalCryptor() {\n\t\treturn cryptor;\n\t}\n\n\tpublic Optional<Cryptor> createCryptor(Problems problems, Path path, CharSequence passphrase) throws IOException, AbortCheckException {\n\t\tdestroyCryptor();\n\t\tPath masterkeyFile = path.resolve(\"masterkey.cryptomator\");\n\t\ttry {\n\t\t\tif (!isRegularFile(masterkeyFile)) {\n\t\t\t\tproblems.reportMissingMasterkeyFile(masterkeyFile);\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tKeyFile keyFile = KeyFile.parse(readAllBytes(masterkeyFile));\n\t\t\tif (keyFile.getVersion() != VAULT_VERSION) {\n\t\t\t\tthrow new AbortCheckException(format(\"Vault version mismatch. Expected: %d Actual: %d\", VAULT_VERSION, keyFile.getVersion()));\n\t\t\t}\n\t\t\tcryptor = Optional.of(bestGuessCryptorProvider(keyFile).createFromKeyFile(keyFile, normalizePassphrase(keyFile, passphrase), keyFile.getVersion()));\n\t\t\treturn cryptor;\n\t\t} catch (InvalidPassphraseException e) {\n\t\t\tthrow new AbortCheckException(\"Invalid passphrase\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (e.getCause() instanceof InvalidKeyException) {\n\t\t\t\tthrow new AbortCheckException(\"JCE files seem to be missing. Download from \\n\" //\n\t\t\t\t\t\t+ \"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html.\\n\" //\n\t\t\t\t\t\t+ \"and install according to instructions in README.txt\");\n\t\t\t} else {\n\t\t\t\tproblems.reportInvalidMasterkeyFile(masterkeyFile);\n\t\t\t}\n\t\t}\n\t\tcryptor = Optional.empty();\n\t\treturn cryptor;\n\t}\n\n\tpublic void destroyCryptor() {\n\t\tcryptor.ifPresent(Cryptor::destroy);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tdestroyCryptor();\n\t}\n\n\tpublic static CharSequence normalizePassphrase(KeyFile keyFile, CharSequence passphrase) {\n\t\tif (keyFile.getVersion() < VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION) {\n\t\t\treturn passphrase;\n\t\t}\n\t\treturn Normalizer.normalize(passphrase, Form.NFC);\n\t}\n\n\tpublic static CryptorProvider bestGuessCryptorProvider(KeyFile keyFile) {\n\t\tswitch (keyFile.getVersion()) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\treturn Cryptors.version1(strongSecureRandom());\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unsupported vault version \" + keyFile.getVersion());\n\t\t}\n\t}\n\n\tprivate static SecureRandom strongSecureRandom() {\n\t\ttry {\n\t\t\treturn SecureRandom.getInstanceStrong();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(\"Java platform is required to support a strong SecureRandom.\", e);\n\t\t}\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/AbortCheckException.java\npublic class AbortCheckException extends Exception {\n\n\tpublic AbortCheckException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void print() {\n\tprint(System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/utils/Counter.java\npublic class Counter {\n\n\tprivate long count = 0;\n\n\tpublic void increment() {\n\t\tcount++;\n\t}\n\n\tpublic long get() {\n\t\treturn count;\n\t}\n\n}\npackage org.cryptomator.sanitizer.commands;\nimport static java.lang.String.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.isDirectory;\nimport static java.nio.file.Files.isRegularFile;\nimport static java.nio.file.Files.newBufferedWriter;\nimport static java.nio.file.Files.size;\nimport static java.nio.file.Files.walk;\nimport static java.nio.file.StandardOpenOption.CREATE_NEW;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.util.Collections.sort;\nimport static java.util.stream.Collectors.toList;\nimport static org.cryptomator.sanitizer.Sanitizer.print;\nimport static org.cryptomator.sanitizer.Sanitizer.printNoNewline;\nimport static org.cryptomator.sanitizer.integrity.problems.Severity.INFO;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.cryptomator.sanitizer.CryptorHolder;\nimport org.cryptomator.sanitizer.Passphrase;\nimport org.cryptomator.sanitizer.integrity.AbortCheckException;\nimport org.cryptomator.sanitizer.integrity.IntegrityCheck;\nimport org.cryptomator.sanitizer.integrity.problems.Problem;\nimport org.cryptomator.sanitizer.integrity.problems.Severity;\nimport org.cryptomator.sanitizer.integrity.problems.SolutionContext;\nimport org.cryptomator.sanitizer.utils.Counter;\n\n\n\n\nclass CheckRunner implements Runnable {\n\n\tprivate static final long KIBI = 1024;\n\tprivate static final String[] KIBI_POWERS = {\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"};\n\n\tprivate final CheckCommand args;\n\n\tpublic CheckRunner(CheckCommand args) {\n\t\tthis.args = args;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry (CryptorHolder cryptorHolder = new CryptorHolder(); //\n\t\t\t\tPassphrase passphrase = args.passphrase()) {\n\t\t\tIntegrityCheck integrityCheck = new IntegrityCheck(cryptorHolder);Next line of code:\n", "input": "package org.cryptomator.sanitizer.commands;\nimport static java.lang.String.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.isDirectory;\nimport static java.nio.file.Files.isRegularFile;\nimport static java.nio.file.Files.newBufferedWriter;\nimport static java.nio.file.Files.size;\nimport static java.nio.file.Files.walk;\nimport static java.nio.file.StandardOpenOption.CREATE_NEW;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.util.Collections.sort;\nimport static java.util.stream.Collectors.toList;\nimport static org.cryptomator.sanitizer.Sanitizer.print;\nimport static org.cryptomator.sanitizer.Sanitizer.printNoNewline;\nimport static org.cryptomator.sanitizer.integrity.problems.Severity.INFO;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.cryptomator.sanitizer.CryptorHolder;\nimport org.cryptomator.sanitizer.Passphrase;\nimport org.cryptomator.sanitizer.integrity.AbortCheckException;\nimport org.cryptomator.sanitizer.integrity.IntegrityCheck;\nimport org.cryptomator.sanitizer.integrity.problems.Problem;\nimport org.cryptomator.sanitizer.integrity.problems.Severity;\nimport org.cryptomator.sanitizer.integrity.problems.SolutionContext;\nimport org.cryptomator.sanitizer.utils.Counter;\n\n\n\n\nclass CheckRunner implements Runnable {\n\n\tprivate static final long KIBI = 1024;\n\tprivate static final String[] KIBI_POWERS = {\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"};\n\n\tprivate final CheckCommand args;\n\n\tpublic CheckRunner(CheckCommand args) {\n\t\tthis.args = args;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry (CryptorHolder cryptorHolder = new CryptorHolder(); //\n\t\t\t\tPassphrase passphrase = args.passphrase()) {\n\t\t\tIntegrityCheck integrityCheck = new IntegrityCheck(cryptorHolder);", "context": "src/main/java/org/cryptomator/sanitizer/Passphrase.java\npublic class Passphrase implements CharSequence, AutoCloseable {\n\n\tprivate final char[] chars;\n\n\tpublic Passphrase(char[] chars) {\n\t\tthis.chars = chars;\n\t}\n\n\tpublic Passphrase(CharBuffer chars) {\n\t\tthis.chars = new char[chars.remaining()];\n\t\tchars.get(this.chars);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tArrays.fill(chars, ' ');\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn chars.length;\n\t}\n\n\t@Override\n\tpublic char charAt(int index) {\n\t\treturn chars[index];\n\t}\n\n\t@Override\n\tpublic Passphrase subSequence(int start, int end) {\n\t\tint len = end - start;\n\t\tchar[] result = new char[len];\n\t\tSystem.arraycopy(chars, start, result, 0, len);\n\t\treturn new Passphrase(result);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new String(chars);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/IntegrityCheck.java\npublic class IntegrityCheck {\n\n\tprivate final CryptorHolder cryptorHolder;\n\n\tpublic IntegrityCheck(CryptorHolder cryptorHolder) {\n\t\tthis.cryptorHolder = cryptorHolder;\n\t}\n\n\tpublic Set<Problem> check(Path path, CharSequence passphrase, boolean checkFileIntegrity) throws AbortCheckException {\n\t\tProblems problems = new Problems(path);\n\t\ttry {\n\t\t\tcryptorHolder.createCryptor(problems, path, passphrase).ifPresent(cryptor -> {\n\t\t\t\ttry {\n\t\t\t\t\tvaultFormatChecks(cryptor, path, checkFileIntegrity).check(problems, path);\n\t\t\t\t} finally {\n\t\t\t\t\tcryptor.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (AbortCheckException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tproblems.reportException(e);\n\t\t}\n\t\treturn problems.asSet();\n\t}\n\n\tprivate Check vaultFormatChecks(Cryptor cryptor, Path pathToVault, boolean checkContentIntegrity) {\n\t\tCheck referencedDirectoryExists = referencedDirectoryExists(cryptor, pathToVault);\n\t\tHasCorrespondingDirectoryFileCheck hasCorrespondingDirectoryFileCheck = hasCorrespondingDirectoryFile(cryptor, pathToVault);\n\t\tCheck decryptedNameCheckForRegularFiles = decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck);\n\t\tHasCorrespondingDFileCheck hasCorrespondingDFile = hasCorrespondingDFileIn(pathToVault);\n\t\tCheck decryptedNameCheckForLongFiles = Checks.decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck, hasCorrespondingDFile);\n\t\tCheck emptyEncryptedFileIfEmpty = emptyEncryptedFileIfEmpty();\n\t\treturn dir().containing( //\n\t\t\t\tdir().that(hasName(\"d\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{30}\")) //\n\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()).validate(hasCorrespondingDirectoryFileCheck) //\n\t\t\t\t\t\t\t\t\t\t.reportAs(rootDirectoryIfMachting(cryptor)) //\n\t\t\t\t\t\t\t\t\t\t.containing( //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidDirectoryFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0?([A-Z2-7]{8})*[A-Z2-7=]{1,7}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aFileWithMissingEqualsSign()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tdir().that(hasName(\"m\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName()))\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles), //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName())) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles)\n\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator\")).validate(nameDoesNotContainUppercaseChars()), // do not validate contents because this already happened when creating the Cryptor\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator.bkup\")).validate(isMasterkeyBackupFile()));\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/SolutionContext.java\npublic interface SolutionContext {\n\n\tpublic static SolutionContext simulatePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, true);\n\t}\n\n\tpublic static SolutionContext executePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, false);\n\t}\n\n\tvoid start(String format, Object... args);\n\n\tvoid finish();\n\n\tvoid fail(String format, Object... args);\n\n\tvoid fail(Throwable reason);\n\n\tboolean dryRun();\n\n\tPath vaultLocation();\n\n\tCryptor cryptor();\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void printNoNewline(String line) {\n\tprintNoNewline(line, System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Severity.java\npublic enum Severity {\n\n\t/**\n\t * Issues which prevent the integrity check from operating correctly.\n\t */\n\tFATAL,\n\n\t/**\n\t * Issues which are guaranteed to cause problems while using the vault.\n\t */\n\tERROR,\n\n\t/**\n\t * Issues which are not guaranteed to cause problems while using the vault.\n\t */\n\tWARN,\n\n\t/**\n\t * Issues which occur during normal operation of the vault.\n\t */\n\tINFO\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Problem.java\npublic interface Problem {\n\n\tSeverity severity();\n\n\tdefault Optional<Solution> solution() {\n\t\treturn Optional.empty();\n\t}\n\n\tdefault String name() {\n\t\treturn \"notSolvable\";\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/CryptorHolder.java\npublic class CryptorHolder implements AutoCloseable {\n\n\tprivate static final int VAULT_VERSION = 6;\n\n\tprivate static final int VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION = 6;\n\n\tprivate Optional<Cryptor> cryptor = Optional.empty();\n\n\tpublic Optional<Cryptor> optionalCryptor() {\n\t\treturn cryptor;\n\t}\n\n\tpublic Optional<Cryptor> createCryptor(Problems problems, Path path, CharSequence passphrase) throws IOException, AbortCheckException {\n\t\tdestroyCryptor();\n\t\tPath masterkeyFile = path.resolve(\"masterkey.cryptomator\");\n\t\ttry {\n\t\t\tif (!isRegularFile(masterkeyFile)) {\n\t\t\t\tproblems.reportMissingMasterkeyFile(masterkeyFile);\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tKeyFile keyFile = KeyFile.parse(readAllBytes(masterkeyFile));\n\t\t\tif (keyFile.getVersion() != VAULT_VERSION) {\n\t\t\t\tthrow new AbortCheckException(format(\"Vault version mismatch. Expected: %d Actual: %d\", VAULT_VERSION, keyFile.getVersion()));\n\t\t\t}\n\t\t\tcryptor = Optional.of(bestGuessCryptorProvider(keyFile).createFromKeyFile(keyFile, normalizePassphrase(keyFile, passphrase), keyFile.getVersion()));\n\t\t\treturn cryptor;\n\t\t} catch (InvalidPassphraseException e) {\n\t\t\tthrow new AbortCheckException(\"Invalid passphrase\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (e.getCause() instanceof InvalidKeyException) {\n\t\t\t\tthrow new AbortCheckException(\"JCE files seem to be missing. Download from \\n\" //\n\t\t\t\t\t\t+ \"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html.\\n\" //\n\t\t\t\t\t\t+ \"and install according to instructions in README.txt\");\n\t\t\t} else {\n\t\t\t\tproblems.reportInvalidMasterkeyFile(masterkeyFile);\n\t\t\t}\n\t\t}\n\t\tcryptor = Optional.empty();\n\t\treturn cryptor;\n\t}\n\n\tpublic void destroyCryptor() {\n\t\tcryptor.ifPresent(Cryptor::destroy);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tdestroyCryptor();\n\t}\n\n\tpublic static CharSequence normalizePassphrase(KeyFile keyFile, CharSequence passphrase) {\n\t\tif (keyFile.getVersion() < VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION) {\n\t\t\treturn passphrase;\n\t\t}\n\t\treturn Normalizer.normalize(passphrase, Form.NFC);\n\t}\n\n\tpublic static CryptorProvider bestGuessCryptorProvider(KeyFile keyFile) {\n\t\tswitch (keyFile.getVersion()) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\treturn Cryptors.version1(strongSecureRandom());\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unsupported vault version \" + keyFile.getVersion());\n\t\t}\n\t}\n\n\tprivate static SecureRandom strongSecureRandom() {\n\t\ttry {\n\t\t\treturn SecureRandom.getInstanceStrong();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(\"Java platform is required to support a strong SecureRandom.\", e);\n\t\t}\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/AbortCheckException.java\npublic class AbortCheckException extends Exception {\n\n\tpublic AbortCheckException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void print() {\n\tprint(System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/utils/Counter.java\npublic class Counter {\n\n\tprivate long count = 0;\n\n\tpublic void increment() {\n\t\tcount++;\n\t}\n\n\tpublic long get() {\n\t\treturn count;\n\t}\n\n}\n", "answers": ["\t\t\tprint(\"Scanning vault structure may take some time. Be patient...\");"], "pred": "  (Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity Check Code: Integrity", "length": 924, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "47573702c5f1ad33b86b8645ddc49617af39e584b4303008"}
{"prompt": "Please complete the code given below. \nyasme/src/main/java/de/fau/cs/mad/yasme/android/encryption/KeyEncryption.java\npublic class KeyEncryption {\r\n\r\n    public static final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n    public static final String PRIVATEKEY = \"privateKey\";\r\n    public static final String PUBLICKEY = \"publicKey\";\r\n    private final byte CREATOR = 0;\r\n    private final byte RECIPIENT = 1;\r\n    private RSAEncryption rsa;\r\n    private DatabaseManager db = DatabaseManager.INSTANCE;\r\n\r\n    public KeyEncryption() {\r\n        this.rsa = new RSAEncryption();\r\n    }\r\n\r\n    /**\r\n     * generate a random RSA-KeyPair (Private and Public Key)\r\n     */\r\n    public void generateRSAKeys(){\r\n        rsa.generateKeyPair();\r\n    }\r\n\r\n    /**\r\n     * encode generated RSA-KeyPair to base64 and store it to local storage (SharedPreferences)\r\n     * there is a own SharedPreference for every user on the device\r\n     *\r\n     * @param deviceId deviceId from the user logged in currently\r\n     * @return true/false\r\n     */\r\n    public boolean saveRSAKeys(long deviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + deviceId;\r\n\r\n        try {\r\n\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            //delete existing keys\r\n            if (privKeyStorage.getString(PRIVATEKEY, \"\") != \"\"){\r\n                keyeditor.remove(PRIVATEKEY);\r\n            }\r\n            if (privKeyStorage.getString(PUBLICKEY, \"\") != \"\"){\r\n                keyeditor.remove(PUBLICKEY);\r\n            }\r\n\r\n            keyeditor.putString(PRIVATEKEY, rsa.getPrivKeyinBase64());\r\n            keyeditor.putString(PUBLICKEY, rsa.getPubKeyinBase64());\r\n\r\n            keyeditor.commit();\r\n\r\n            // For Developer-Devices only\r\n            if (DebugManager.INSTANCE.isDebugMode()) {\r\n                Log.d(getClass().getSimpleName(), \"Store keys to external storage\");\r\n                DebugManager.INSTANCE.storePrivatePublicKeyToExternalStorage(rsa.getPrivKeyinBase64(),rsa.getPubKeyinBase64());\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"RSA Keys generated and saved\");\r\n\r\n\r\n            return true;\r\n        } catch (Exception e){\r\n            Log.e(this.getClass().getSimpleName(), \"saving rsa keys failed\");\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the generated RSA Public Key in Base64\r\n     * method is needed in registration when the Public Key needs to be sent to the server\r\n     *\r\n     * @return base64 encoded string\r\n     */\r\n    public String getGeneratedPubKeyInBase64(){\r\n        return rsa.getPubKeyinBase64();\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the RSA PublicKey from the recipient\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be encrypted\r\n     * @return messageKey containing the RSA-encrypted AES-Key\r\n     */\r\n    public MessageKey encrypt(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, RECIPIENT);\r\n\r\n        if (pubKey != null){\r\n            String keyEncrypted = rsa.encrypt(messageKey.getMessageKey(), pubKey);\r\n            messageKey.setKey(keyEncrypted);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the encrypted AES-Key that should be decrypted\r\n     * @return messageKey containing the decrypted AES-Key\r\n     */\r\n    public MessageKey decrypt(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getRecipientDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String key = rsa.decrypt(messageKey.getMessageKey(), privKey);\r\n            if (key == null) {\r\n                return null;\r\n            }\r\n            messageKey.setKey(key);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sign an AES-Key using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be signed\r\n     * @return  messageKey containing the signature\r\n     */\r\n    public MessageKey sign(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getCreatorDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String keySigned = rsa.sign(messageKey.getMessageKey(), privKey);\r\n            messageKey.setSign(keySigned);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * verify the signature from given messageKey using the RSA Public Key from the creatorDevice\r\n     *\r\n     * @param messageKey messageKey containing the signature\r\n     * @return true/false\r\n     */\r\n    public boolean verify(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, CREATOR);\r\n\r\n        if (pubKey != null) {\r\n            Log.d(getClass().getSimpleName(), \"Verify key\");\r\n            return rsa.verify(messageKey.getSign(), messageKey.getMessageKey(), pubKey);\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"PubKey is null\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * load own RSA Private Key from local storage\r\n     *\r\n     * @param selfDeviceId deviceId from the user logged in currently\r\n     * @return PrivateKey\r\n     */\r\n    public PrivateKey getPrivateRSAKeyFromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String privKeyInBase64 = privKeyStorage.getString(PRIVATEKEY, \"\");\r\n\r\n        Log.d(this.getClass().getSimpleName(),\"Load private Key from storage: \" + RSAKEY_STORAGE_USER);\r\n\r\n        //if Key is available\r\n        if (privKeyInBase64 != \"\") {\r\n\r\n            PrivateKey privKey = rsa.convertBase64toPrivKey(privKeyInBase64);\r\n\r\n            if (privKey != null){\r\n                Log.d(this.getClass().getSimpleName(),\"Private Key was successfully loaded from storage\");\r\n                return privKey;\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Getting private key from storage failed\");\r\n            return null;\r\n        }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Private Key could not be found.\");\r\n            return null;\r\n\r\n    }\r\n\r\n    /**\r\n     * load the needed RSA Public Key from local storage/Device-Object\r\n     *\r\n     * @param messageKey messageKey containing the information about creatorDevice and recipientDevice\r\n     * @param type define, the RSA Public Key from the recipient or the creator is needed\r\n     * @return PublicKey\r\n     */\r\n    public PublicKey getPubKeyFromUser(MessageKey messageKey, byte type) {\r\n\r\n        String pubKeyInBase64 = null;\r\n\r\n        //try to extract Public Key from MessageKey\r\n        if (type == CREATOR){\r\n                pubKeyInBase64 = messageKey.getCreatorDevice().getPublicKey();\r\n        }\r\n        else if (type == RECIPIENT){\r\n                pubKeyInBase64 = messageKey.getRecipientDevice().getPublicKey();\r\n        }\r\n        else{\r\n            Log.d(this.getClass().getSimpleName(), \"Wrong use of function: getPubKeyFromUser()\");\r\n            return null;\r\n        }\r\n\r\n        //convert Base64toPublicKey\r\n        if (pubKeyInBase64 != null) {\r\n            PublicKey pubKey = rsa.convertBase64toPubKey(pubKeyInBase64);\r\n            if (pubKey != null) return pubKey;\r\n        }\r\n\r\n        Log.d(this.getClass().getSimpleName(), \"Getting public key from storage failed\");\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    //get own PublicKey in Base64\r\n    public String getPublicRSAKeyInBase64FromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String pubKeyInBase64 = privKeyStorage.getString(PUBLICKEY, \"\");\r\n\r\n        return pubKeyInBase64;\r\n    }\r\n    */\r\n\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/LoginFragment.java\npublic class LoginFragment extends Fragment implements NotifiableFragment<LoginFragment.LoginParam> {\n\n    //Keep track of the login task to ensure we can cancel it if requested.\n    private UserLoginTask authTask = null;\n\n    // UI references.\n    private EditText emailView;\n    private EditText passwordView;\n    private TextView loginStatusMessageView;\n    private View mProgressView;\n    private View mLoginFormView;\n    // values for devices yasme server\n    private String deviceProduct;\n    // Values for name, email and password at the time of the login attempt.\n    private String emailTmp;\n    private String passwordTmp;\n    // focusView for validate()\n    private View focusView = null;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        // In debug app, show @yasme.net\n        String defaultEmail = (BuildConfig.DEBUG) ? \"@yasme.net\" : \"\";\n\n        // Restore preferences\n        emailTmp = DatabaseManager.INSTANCE.getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, defaultEmail);\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_login, container,\n                false);\n\n        // Set up the login form.\n        emailView = (EditText) rootView.findViewById(R.id.email);\n        emailView.setText(emailTmp);\n\n        passwordView = (EditText) rootView.findViewById(R.id.password);\n        if (BuildConfig.DEBUG) {\n            passwordView.setText(R.string.default_password);\n        }\n        passwordView\n                .setOnEditorActionListener(new TextView.OnEditorActionListener() {\n                    @Override\n                    public boolean onEditorAction(TextView textView, int id,\n                                                  KeyEvent keyEvent) {\n                        if (id == R.id.login || id == EditorInfo.IME_NULL) {\n                            attemptLogin();\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        loginStatusMessageView = (TextView) rootView.findViewById(R.id.login_status_message);\n\n        rootView.findViewById(R.id.sign_in_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"SignIn-Button pushed\");\n                        attemptLogin();\n                    }\n                }\n        );\n\n        rootView.findViewById(R.id.register_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Register-Button pushed\");\n                        registerDialog();\n                    }\n                }\n        );\n\n        TextView tv = (TextView) rootView.findViewById(R.id.forgot_password);\n\n        Pattern pattern = Pattern.compile(getString(R.string.forgot_password));\n        /*\n        Linkify.addLinks(tv, pattern, \"\", null, new Linkify.TransformFilter() {\n            @Override\n            public String transformUrl(Matcher matcher, String s) {\n                return \"\";\n            }\n        });\n        */\n        tv.setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Forgot Password-Button pushed\");\n                        requestMail();\n                    }\n                }\n        );\n\n        return rootView;\n    }\n\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(this.getClass().getSimpleName(), \"Try to get LoginObservableInstance\");\n        FragmentObservable<LoginFragment, LoginParam> obs = ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"... successful\");\n\n        obs.register(this);\n        mProgressView = getActivity().findViewById(R.id.login_status);\n        mLoginFormView = getActivity().findViewById(R.id.login);\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        FragmentObservable<LoginFragment, LoginParam> obs =\n                ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"Remove from observer\");\n        obs.remove(this);\n    }\n\n    private void registerDialog() {\n        getFragmentManager().beginTransaction()\n                .add(R.id.singleFragmentContainer, new RegisterFragment()).commit();\n    }\n\n    /**\n     * Attempts to sign in or register the account specified by the login form.\n     * If there are form errors (missing fields, etc.), the errors are presented\n     * and no actual login attempt is made.\n     */\n    public void attemptLogin() {\n        if (authTask == null) {\n            authTask = new UserLoginTask(true, this.getClass());\n            Log.d(this.getClass().getSimpleName(), \"AuthTask is null\");\n        }\n\n        // Reset errors.\n        emailView.setError(null);\n        passwordView.setError(null);\n\n        // Store values at the time of the login attempt.\n        emailTmp = emailView.getText().toString();\n        passwordTmp = passwordView.getText().toString();\n\n        boolean cancel = false;\n\n        // Check for a valid password.\n        if (TextUtils.isEmpty(passwordTmp)) {\n            passwordView.setError(getString(R.string.error_field_required));\n            focusView = passwordView;\n            cancel = true;\n        } else if (passwordTmp.length() < 8) {\n            passwordView.setError(getString(R.string.error_invalid_password));\n            focusView = passwordView;\n            cancel = true;\n        }\n\n        // Check for a valid mail.\n        if (TextUtils.isEmpty(emailTmp)) {\n            emailView.setError(getString(R.string.error_field_required));\n            focusView = emailView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            // Show a progress spinner, and kick off a background task to\n            // perform the user login attempt.\n            loginStatusMessageView.setText(R.string.login_progress_signing_in);\n            showProgress(true);\n\n            // Hide the virtual keyboard\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            View focus = activity.getCurrentFocus();\n            if (null == focus) {\n                focus = focusView;\n            }\n            if (null == focus) {\n                focus = passwordView;\n            }\n            if (null == focus) {\n                focus = emailView;\n            }\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (null != imm && null != focus)\n                imm.hideSoftInputFromWindow(focus.getWindowToken(), 0);\n\n            // Start the asynctask\n            authTask.execute(emailTmp, passwordTmp);\n            authTask = null;\n        }\n    }\n\n    public void onPostLoginExecute(Boolean success, long userId) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        activity.getSelfUser().setId(userId);\n\n        if (success) {\n            //Initialize database (once in application)\n            if (!DatabaseManager.INSTANCE.isInitialized()) {\n                Log.e(getClass().getSimpleName(), \"DB-Manger hasn't been initialized\");\n            }\n            DatabaseManager.INSTANCE.setUserId(userId);\n\n            // check if there is a device in the Database\n            if (yasmeDeviceCheck()) {\n                Log.d(this.getClass().getSimpleName(), \"Device exists in Database\");\n\n                long deviceId = DatabaseManager.INSTANCE.getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n                if (deviceId < 0) {\n                    // Error ocurred\n                    Log.e(this.getClass().getSimpleName(), \"Could not load registered device's id from shared prefs\");\n                    showProgress(false);\n                    return;\n                }\n\n                DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n                showProgress(false);\n                Intent intent = new Intent(activity, ChatListActivity.class);\n                startActivity(intent);\n                getActivity().finish();\n            } else {\n                // register device\n                Log.d(this.getClass().getSimpleName(), \"Device does not exist in Database\");\n                Log.d(this.getClass().getSimpleName(), \"Starting task to register device at yasme server\");\n\n                new DeviceRegistrationTask(activity, this.getClass())\n                        .execute(Long.toString(userId), this.deviceProduct, this.getClass().getName());\n\n            }\n        } else {\n            Log.d(getClass().getSimpleName(), \"Login failed\");\n            ServerInfo serverInfo = DatabaseManager.INSTANCE.getServerInfo();\n            if (serverInfo != null && !serverInfo.getLoginAllowed() && serverInfo.hasMessage()) {\n                passwordView.setError(DatabaseManager.INSTANCE.getServerInfo().getMessage());\n            } else {\n                passwordView.setError(getString(R.string.error_incorrect_user_or_password));\n            }\n            passwordView.requestFocus();\n            showProgress(false);\n        }\n    }\n\n    public void onPostYasmeDeviceRegExecute(Boolean success, long deviceId) {\n        if (!success) {\n            Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n        } else {\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            // Initialize the session a second time because the deviceId was missing\n            /*SharedPreferences devicePrefs = activity.getSharedPreferences(\n                    AbstractYasmeActivity.DEVICE_PREFS,\n                    AbstractYasmeActivity.MODE_PRIVATE);\n            long userId = devicePrefs.getLong(AbstractYasmeActivity.USER_ID, -1);\n            if (userId < 0) {\n                // Error ocurred\n                Log.e(this.getClass().getSimpleName(), \"Did not find user id in shared prefs\");\n                Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n                showProgress(false);\n                return;\n            }*/\n\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n            Log.d(this.getClass().getSimpleName(), \"Login after device registration at yasme server\");\n            showProgress(false);\n            Intent intent = new Intent(activity, ChatListActivity.class);\n            startActivity(intent);\n            getActivity().finish();\n        }\n    }\n\n    /**\n     * This method checks if there is a device in the DB\n     */\n    public boolean yasmeDeviceCheck() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        //set the deviceProduct\n        this.deviceProduct = Build.MANUFACTURER + \" \" + Build.MODEL;\n        Log.d(this.getClass().getSimpleName(), \"MODEL is \" + Build.MODEL);\n        Log.d(this.getClass().getSimpleName(), \"DEVICE is \" + Build.DEVICE);\n        Log.d(this.getClass().getSimpleName(), \"PRODUCT is \" + Build.PRODUCT);\n        Log.d(this.getClass().getSimpleName(), \"MANUFACTURER is \" + Build.MANUFACTURER);\n        Log.d(this.getClass().getSimpleName(), \"BRAND is \" + Build.BRAND);\n        Log.d(this.getClass().getSimpleName(), \"NOW is \" + this.deviceProduct);\n        //try to load device from shared preferences\n        SharedPreferences devicePrefs = activity.getSharedPreferences(\n                AbstractYasmeActivity.DEVICE_PREFS,\n                AbstractYasmeActivity.MODE_PRIVATE);\n        long deviceId = devicePrefs.getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n\n        // load regId\n        SharedPreferences pushPrefs = activity.\n                getSharedPreferences(AbstractYasmeActivity.PUSH_PREFS,\n                        AbstractYasmeActivity.MODE_PRIVATE);\n\n        String googleRegId = pushPrefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, null);\n        // TODO proper check\n\n        if (deviceId == -1) {\n            if (DebugManager.INSTANCE.isDebugMode()) {\n                return DebugManager.INSTANCE.restoreData();\n            }\n            return false;\n        }\n        // TODO devices from server\n        // TODO use case : plain app + old user + old device\n\n        Log.d(this.getClass().getSimpleName(), \"deviceId is \" + deviceId);\n        return true;\n    }\n\n    public void requestMail() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.request_email_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final TextView requestEmailText = new TextView(activity);\n        requestEmailText.setText(R.string.request_email_body);\n\n        final EditText mail = new EditTextWithX(activity).getEditText();\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n        mail.setText(emailTmp);\n\n        list.addView(mail);\n        list.addView(requestEmailText, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        // Grab the EditText's input\n                        emailTmp = mail.getText().toString();\n                        Log.d(this.getClass().getSimpleName(), \"Mail to send token at: \" + emailTmp);\n                        User user = new User();\n                        user.setEmail(emailTmp);\n                        new ChangePasswordTask(user).execute(\"1\");\n                        forgotPasswordDialog(emailTmp);\n                    }\n                }\n        );\n\n        // Skip, email was already sent\n        alert.setNeutralButton(R.string.skip,\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        forgotPasswordDialog(null);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    public void forgotPasswordDialog(final String inputMail) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.password_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final EditText token = new EditText(activity);\n        token.setInputType(InputType.TYPE_CLASS_TEXT);\n        token.setHint(R.string.hint_mail_token);\n\n        final TextView tokenExplanation = new TextView(activity);\n        tokenExplanation.setText(R.string.explanation_mail_token);\n\n        final EditText password = new EditText(activity);\n        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        password.setHint(R.string.hint_new_password);\n\n        final EditText passwordCheck = new EditText(activity);\n        passwordCheck.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        passwordCheck.setHint(R.string.hint_repeat_new_password);\n\n        final EditText mail = new EditText(activity);\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n\n        if (inputMail == null || inputMail.isEmpty()) {\n            list.addView(mail);\n        }\n        list.addView(token, layoutParams);\n        list.addView(tokenExplanation, layoutParams);\n        list.addView(password, layoutParams);\n        list.addView(passwordCheck, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n\n                        // Grab the EditText's input\n                        String email;\n                        if (inputMail == null || inputMail.isEmpty()) {\n                            email = mail.getText().toString();\n                        } else {\n                            email = inputMail;\n                        }\n                        String mailToken = token.getText().toString();\n                        String inputPassword = password.getText().toString();\n                        String inputPasswordCheck = passwordCheck.getText()\n                                .toString();\n\n                        if (password.getText().length() < 8) {\n                            Toaster.getInstance().toast(R.string.password_too_short,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        if (!inputPassword.equals(inputPasswordCheck)) {\n                            Toaster.getInstance().toast(R.string.passwords_do_not_match,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        User user = new User(email, inputPassword);\n                        PasswordEncryption pwEnc = new PasswordEncryption(user);\n                        User secured = pwEnc.securePassword();\n                        new ChangePasswordTask(secured).execute(\"0\", mailToken);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    /**\n     * Shows the progress UI and hides the login form.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(final boolean show) {\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n                }\n            });\n\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n                }\n            });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply show\n            // and hide the relevant UI components.\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void notifyFragment(LoginParam param) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified. Yeeha!\");\n        if (param instanceof LoginProcessParam) {\n            notifyFragment((LoginProcessParam) param);\n        } else if (param instanceof DeviceRegistrationParam) {\n            notifyFragment((DeviceRegistrationParam) param);\n        }\n    }\n\n    public void notifyFragment(LoginProcessParam loginParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with loginParam\");\n\n        onPostLoginExecute(loginParam.getSuccess(), loginParam.getUserId());\n        Log.d(super.getClass().getSimpleName(), \"Login-Status: \" + loginParam.getSuccess());\n    }\n\n    public void notifyFragment(DeviceRegistrationParam deviceRegistrationParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with deviceRegistrationParam\");\n\n        onPostYasmeDeviceRegExecute(deviceRegistrationParam.getSuccess(),\n                deviceRegistrationParam.getDeviceId());\n\n    }\n\n    public static class LoginParam {\n        protected Boolean success;\n\n        public Boolean getSuccess() {\n            return success;\n        }\n    }\n\n    public static class LoginProcessParam extends LoginParam {\n        private Long userId;\n\n        public LoginProcessParam(Boolean success) {\n            this.success = success;\n            this.userId = DatabaseManager.INSTANCE.getUserId();\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n    }\n\n    public static class DeviceRegistrationParam extends LoginParam {\n        private Long deviceId;\n\n        public DeviceRegistrationParam(Boolean success) {\n            this.success = success;\n            this.deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        }\n\n        public Long getDeviceId() {\n            return deviceId;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/gcm/CloudMessaging.java\npublic class CloudMessaging {\n\n    private static CloudMessaging instance;\n\n    private Activity activity;\n    private GoogleCloudMessaging gcm;\n    private Context context;\n    private String regid;\n\n\n    public static CloudMessaging getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CloudMessaging(activity);\n        }\n        return instance;\n    }\n\n    private CloudMessaging(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.gcm = GoogleCloudMessaging.getInstance(activity);\n    }\n\n    public boolean checkPlayServices() {\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                GooglePlayServicesUtil.getErrorDialog(resultCode, activity,\n                        AbstractYasmeActivity.PLAY_SERVICES_RESOLUTION_REQUEST).show();\n            } else {\n                Log.i(AbstractYasmeActivity.TAG, \"This device is not supported.\");\n                activity.finish();\n            }\n            return false;\n        }\n        return true;\n    }\n\n    public String getRegistrationId() {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        String registrationId = prefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, \"\");\n        Log.i(AbstractYasmeActivity.TAG + \"WOOOOOLOOOLOOOO\", \"this is my id: [\" + AbstractYasmeActivity.PROPERTY_REG_ID + \"]\");\n        if (registrationId.isEmpty()) {\n            Log.i(AbstractYasmeActivity.TAG, \"Registration not found.\");\n            return \"\";\n        }\n        // Check if app was updated; if so, it must clear the registration ID\n        // since the existing regID is not guaranteed to work with the new\n        // app version.\n        int registeredVersion = prefs.getInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, Integer.MIN_VALUE);\n        int currentVersion = getAppVersion(context);\n        if (registeredVersion != currentVersion) {\n            Log.i(AbstractYasmeActivity.TAG, \"App version changed.\");\n            return \"\";\n        }\n        return registrationId;\n    }\n\n    public SharedPreferences getGCMPreferences(Context context) {\n        return context.getSharedPreferences(LoginActivity.class.getSimpleName(),\n                Context.MODE_PRIVATE);\n    }\n\n    public int getAppVersion(Context context) {\n        try {\n            PackageInfo packageInfo = context.getPackageManager()\n                    .getPackageInfo(context.getPackageName(), 0);\n            return packageInfo.versionCode;\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new RuntimeException(\"Could not get package name: \" + e);\n        }\n    }\n\n    public String registerInBackground() {\n        try {\n            if (gcm == null) {\n                gcm = GoogleCloudMessaging.getInstance(context);\n            }\n            regid = gcm.register(AbstractYasmeActivity.SENDER_ID);\n\n            Log.d(this.getClass().getSimpleName(), \"Device registered, registration ID=\" + regid);\n\n            // Persist the regID - no need to register again.\n            storeRegistrationId(context, regid);\n            return regid;\n        } catch (IOException e) {\n            // If there is an error, don't just keep trying to register.\n            // Require the user to click a button again, or perform\n            // exponential back-off.\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    private void storeRegistrationId(Context context, String regId) {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        int appVersion = getAppVersion(context);\n        Log.i(AbstractYasmeActivity.TAG, \"Saving regId on app version \" + appVersion);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(AbstractYasmeActivity.PROPERTY_REG_ID, regId);\n        editor.putInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, appVersion);\n        editor.commit();\n\n        // For Developer-Devices only\n        if (DebugManager.INSTANCE.isDebugMode()) {\n            Log.d(getClass().getSimpleName(), \"Store gcmId to external storage\");\n            DebugManager.INSTANCE.storePushId(regId);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DebugManager.java\npublic enum DebugManager {\r\n    INSTANCE;\r\n\r\n    private final String OWNDEVICE = \"owndevice\";\r\n    private final String MESSAGEKEYS = \"messagekeys\";\r\n\r\n    private boolean debugMode = false;\r\n    private OwnDevice ownDevice = new OwnDevice();\r\n\r\n    public boolean isDebugMode() {\r\n        return debugMode;\r\n    }\r\n\r\n    public boolean storeDeviceId(long deviceId) {\r\n        ownDevice.setId(deviceId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n\r\n    public boolean storePrivatePublicKeyToExternalStorage(String privateKey, String publicKey) {\r\n        ownDevice.setPrivateKey(privateKey);\r\n        ownDevice.setPublicKey(publicKey);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    public boolean storePushId(String pushId) {\r\n        ownDevice.setPushId(pushId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    private boolean storeOwnDeviceToExternalStorage() {\r\n        return storeToExternalStorage(OWNDEVICE, ownDevice, false);\r\n    }\r\n\r\n    public boolean storeMessageKeyToExternalStorage(MessageKey data) {\r\n        return storeToExternalStorage(MESSAGEKEYS, data, true);\r\n    }\r\n\r\n    private boolean storeToExternalStorage(String name, Object data, boolean append) {\r\n        try {\r\n            String state = Environment.getExternalStorageState();\r\n            Log.d(getClass().getSimpleName(), \"Check state\");\r\n            if (!Environment.MEDIA_MOUNTED.equals(state)) {\r\n                return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            Log.d(getClass().getSimpleName(), \"Mkdir\");\r\n            if (!dir.exists() && !dir.mkdirs()) {\r\n                Log.d(getClass().getSimpleName(), \"... failed\");\r\n               return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            File file = new File(dir,name + \".txt\");\r\n            Log.d(getClass().getSimpleName(), \"Write file\");\r\n\r\n            ObjectWriter objectWriter = new ObjectMapper().writer();\r\n            String json = objectWriter.writeValueAsString(data);\r\n            Log.d(getClass().getSimpleName(),\"Generated JSON: \" + json);\r\n\r\n            FileOutputStream f = new FileOutputStream(file,append);\r\n            PrintWriter pw = new PrintWriter(f);\r\n            if (append) {\r\n                pw.println(json + \",\");\r\n            } else {\r\n                pw.println(json);\r\n            }\r\n            pw.flush();\r\n            pw.close();\r\n            f.close();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean restoreData() {\r\n        Log.d(getClass().getSimpleName(),\"Restoring data\");\r\n        if (!restoreOwnDeviceFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring OwnDevice failed\");\r\n            return false;\r\n        }\r\n        if (!restoreMessageKeysFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring MessageKeys failed\");\r\n            return false;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Restoring successful\");\r\n        Toaster.getInstance().toast(\"Restoring Debug-Data successful\", Toast.LENGTH_LONG);\r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean restoreOwnDeviceFromExternalStorage() {\r\n         final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n         final String PRIVATEKEY = \"privateKey\";\r\n         final String PUBLICKEY = \"publicKey\";\r\n\r\n        try {\r\n            OwnDevice device = getOwnDeviceFromExternalStorage();\r\n            if (device == null) {\r\n                Log.d(getClass().getSimpleName(), \"Device is null\");\r\n                return false;\r\n            }\r\n\r\n            // Restore devId\r\n            Log.d(getClass().getSimpleName(), \"Restore devId\");\r\n            SharedPreferences.Editor editor1 = DatabaseManager.INSTANCE.getSharedPreferences().edit();\r\n            editor1.putLong(AbstractYasmeActivity.DEVICE_ID, ownDevice.getId());\r\n            editor1.commit();\r\n\r\n            // Restore pushId and app version\r\n            Log.d(getClass().getSimpleName(), \"Restore pushId\");\r\n            SharedPreferences prefs = DatabaseManager.INSTANCE.getContext().getSharedPreferences(LoginActivity.class.getSimpleName(), Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor2 = prefs.edit();\r\n            editor2.putString(AbstractYasmeActivity.PROPERTY_REG_ID, ownDevice.getPushId());\r\n            editor2.commit();\r\n\r\n            // Restore PrivatePublicKey\r\n            Log.d(getClass().getSimpleName(), \"Restore PrivPubKeys\");\r\n            String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + ownDevice.getId();\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            keyeditor.putString(PRIVATEKEY, device.getPrivateKey());\r\n            keyeditor.putString(PUBLICKEY,device.getPublicKey());\r\n            keyeditor.commit();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private OwnDevice getOwnDeviceFromExternalStorage() {\r\n        String text = readText(OWNDEVICE);\r\n        if (text == null || text == \"\") {\r\n            return null;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Device-Text: \" + text);\r\n        try {\r\n            OwnDevice device = new ObjectMapper().readValue(text, OwnDevice.class);\r\n            Log.d(getClass().getSimpleName(), \"PubKey: \" + device.getPublicKey());\r\n            return device;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private boolean restoreMessageKeysFromExternalStorage() {\r\n        String text = readText(MESSAGEKEYS);\r\n        if (text == null) {\r\n            return false;\r\n        }\r\n        if (text == \"\") {\r\n            // No messageKey stored yet\r\n            return true;\r\n        }\r\n        String json = \"[\" + text + \"{}]\";\r\n        Log.d(getClass().getSimpleName(), \"MessageKeys-Text: \" + text);\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"JSON: \" + json);\r\n            JSONArray jsonArray = new JSONArray(json);\r\n\r\n            for (int i = 0; i < jsonArray.length() - 1; i++) {\r\n                MessageKey messageKey = new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\r\n                        toString(), MessageKey.class);\r\n                messageKey.setAuthenticity(true);\r\n                DatabaseManager.INSTANCE.getMessageKeyDAO().addOrUpdate(messageKey);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private String readText(String name) {\r\n        String filename = \"\";\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            if (!dir.exists()) {\r\n                return null;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            filename = dir.getAbsolutePath() + \"/\" + name + \".txt\";\r\n\r\n\r\n            BufferedReader br = new BufferedReader(new FileReader(filename));\r\n            StringBuilder sb = new StringBuilder();\r\n            String line = br.readLine();\r\n\r\n            while (line != null) {\r\n                sb.append(line);\r\n                line = br.readLine();\r\n            }\r\n            br.close();\r\n            return sb.toString();\r\n        } catch (FileNotFoundException e) {\r\n            Log.e(getClass().getSimpleName(), \"File \" + filename + \" not found.\");\r\n            return \"\";\r\n        }\r\n        catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private File getDir() {\r\n        return new File(Environment.getExternalStoragePublicDirectory(\"yasme\"), String.valueOf(DatabaseManager.INSTANCE.getUserId()));\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/DeviceTask.java\npublic class DeviceTask extends ConnectionTask {\n\n    private static DeviceTask instance;\n\n    public static DeviceTask getInstance() {\n        if (instance == null) {\n            synchronized (DeviceTask.class) {\n                if (null == instance) {\n                    instance = new DeviceTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private DeviceTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/device\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n    }\n\n    public Long registerDevice(OwnDevice device) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", device);\n\n            //Log.d(this.getClass().getSimpleName(), \"Device registration was successful\");\n\n            long deviceId = (new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent())\n            )).readLine())).getLong(\"id\");\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n            return deviceId;\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n        return null;\n    }\n\n    public Device getDevice(long devId) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(devId));\n            return new ObjectMapper().readValue(new BufferedReader(new InputStreamReader(httpResponse.getEntity()\n                    .getContent())).readLine(), Device.class);\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public ArrayList<Device> getAllDevices(Long userId) throws RestServiceException {\n\n        ArrayList<Device> devices = new ArrayList<Device>();\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"all/\" + userId);\n\n            JSONArray jsonArray = new JSONArray(new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent())).readLine());\n\n            for (int i = 0; i < jsonArray.length(); i++)\n                devices.add(new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\n                        toString(), Device.class));\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n\n        //Log.d(this.getClass().getSimpleName(), \"No.Devices: \" + devices.size());\n        return devices;\n    }\n\n    public void deleteDevice(long deviceId) throws RestServiceException {\n        executeRequest(Request.DELETE, Long.toString(deviceId));\n        //Log.d(this.getClass().getSimpleName(), \"Device removed!\");\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/contacts/QR.java\npublic class QR {\n    private static final int SIZE = 1024;\n    private static Bitmap qrCode;\n    private static boolean isRunning = false;\n\n    public static void init(boolean force) {\n        if (force) {\n            qrCode = null;\n            isRunning = false;\n        }\n        if (qrCode == null && !isRunning) {\n            isRunning = true;\n            new QRTask().execute();\n        }\n    }\n\n    public static void finished() {\n        isRunning = false;\n    }\n\n    public Bitmap generateQRCode() {\n        if (qrCode != null) {\n            return qrCode;\n        }\n        QRData qrdata = new QRData();\n        DatabaseManager db = DatabaseManager.INSTANCE;\n        qrdata.setDeviceId(db.getDeviceId());\n\n        Context context = db.getContext();\n        String RSAKEY_STORAGE_USER = KeyEncryption.RSAKEY_STORAGE + \"_\" + db.getDeviceId();\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\n        String pubKeyInBase64 = privKeyStorage.getString(KeyEncryption.PUBLICKEY, \"\");\n        qrdata.setPublicKey(pubKeyInBase64);\n\n        //ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();\n        ObjectWriter objectWriter = new ObjectMapper().writer();\n        try {\n            String data = objectWriter.writeValueAsString(qrdata);\n            qrCode = generateQRCode(data);\n            return qrCode;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Bitmap generateQRCode(String data) {\n        Log.d(getClass().getName(), \"Generate QR for \" + data);\n        com.google.zxing.Writer writer = new QRCodeWriter();\n        BitMatrix bm;\n        try {\n            bm = writer.encode(data, BarcodeFormat.QR_CODE,SIZE, SIZE);\n        } catch (Exception e) {\n            return null;\n        }\n\n        Bitmap imageBitmap = Bitmap.createBitmap(SIZE, SIZE, Bitmap.Config.ARGB_8888);\n\n        for (int i = 0; i < SIZE; i++) {//width\n            for (int j = 0; j < SIZE; j++) {//height\n                imageBitmap.setPixel(i, j, bm.get(i, j) ? Color.BLACK: Color.WHITE);\n            }\n        }\n        return imageBitmap;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/OwnDevice.java\npublic class OwnDevice {\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        WINDOWSPHONE;\n    }\n\n    private long id;\n    private Platform platform; // android, ios or windowsmobile\n    private String type;    // mobilephone, tablet or desktop\n    private User user;\n    private String number;  // optional\n    private String publicKey;\n    private String privateKey;\n    private String product; // product name e.g. Google Nexux 5\n    private String pushId;\n\n    private Date created;\n\n    private Date lastModified;\n\n    public OwnDevice(User user, Platform platform, String publicKey, String type, String number, String product, String pushId) {\n        this.user = user;\n        this.platform = platform;\n        this.type = type;\n        this.number = number;\n        this.product = product;\n        this.pushId = pushId;\n        this.publicKey = publicKey;\n    }\n\n    public OwnDevice() {\n    }\n\n    public OwnDevice(long id) {\n        this.id = id;\n    }\n\n    @JsonIgnoreProperties({ \"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\" })\n    public User getUser() {\n        return this.user;\n    }\n\n    public String getPushId(){return this.pushId;}\n\n    public String getProduct(){return this.product;}\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setProduct(String product){this.product = product;}\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Platform getPlatform() {\n        return platform;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setPlatform(Platform platform) {\n        this.platform = platform;\n    }\n\n    public void setPushId(String pushId){this.pushId = pushId;}\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPublicKey() {\n        return publicKey;\n    }\n\n    public void setPublicKey(String publicKey) {\n        this.publicKey = publicKey;\n    }\n\n    public Date getCreated() {\n        return this.created;\n    }\n\n    public Date getLastModified() {\n        return this.lastModified;\n    }\n\n    public String getPrivateKey() {\n        return privateKey;\n    }\n\n    public void setPrivateKey(String privateKey) {\n        this.privateKey = privateKey;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\npackage de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.app.Activity;\nimport android.os.AsyncTask;\nimport de.fau.cs.mad.yasme.android.connection.DeviceTask;\nimport de.fau.cs.mad.yasme.android.contacts.QR;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.encryption.KeyEncryption;\nimport de.fau.cs.mad.yasme.android.entities.OwnDevice;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.gcm.CloudMessaging;\nimport de.fau.cs.mad.yasme.android.storage.DebugManager;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.fragments.LoginFragment;\n\n\n\n/**\n * Created by Cuong Bui <cuong.bui@fau.de> on 21/06/14.\n */\npublic class DeviceRegistrationTask extends AsyncTask<String, Void, Boolean> {\n\n    private long deviceId;\n    private Activity activity;\n    private String regId;\n    private Class classToNotify;\n\n    public DeviceRegistrationTask(Activity activity, Class classToNotify) {\n        this.activity = activity;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @params params[0] is userId\n     * @params params[1] is product\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        long userId = Long.parseLong(params[0]);\n\n        // the product : e.g Google Nexus\n        String product = params[1];\n\n        // Register for Google Cloud Messaging at Google Server\n        if (!registerGCM()) {\n            return false;\n        }\n\n        // Register at YASME server\n        return registerDeviceAtYASME(userId, product, regId);\n    }\n\n\n    private boolean registerGCM() {\n        CloudMessaging cloudMessaging = CloudMessaging.getInstance(this.activity);\n\n        if (cloudMessaging.checkPlayServices()) {\n            String regid = cloudMessaging.getRegistrationId();\n            Log.d(this.getClass().getSimpleName(), \"Google reg id is empty? \" + regid.isEmpty());\n            if (regid.isEmpty()) {\n                regId = cloudMessaging.registerInBackground();\n                if (null == regId || regId.isEmpty()) {\n                    Log.e(this.getClass().getSimpleName(), \"reg id for GCM is empty\");\n                    return false;\n                }\n            }\n        } else {\n            Log.i(AbstractYasmeActivity.TAG, \"No valid Google Play Services APK found.\");\n        }\n\n        return true;\n    }\n\n\n    private boolean registerDeviceAtYASME(long userId, String product, String regId) {\n        long deviceIdFromServer;\n\n        //register device through REST-Call\n        // create a new device to be registered\n\n        // user which want to register the device\n        // ignore the name user, the server will set the right values according to the userId\n        User user = new User(\"user\", userId);\n\n        // indicates if its a smartphone or a tablet\n        // currently unused\n        String type = \"device\";\n\n        // phone number, currently unused\n        String number = null;\n\n        KeyEncryption rsa = new KeyEncryption();\n        //generate private and public Key\n        rsa.generateRSAKeys();\n        String pubKeyInBase64 = rsa.getGeneratedPubKeyInBase64();\n\n        OwnDevice deviceToBeRegistered = new OwnDevice(user, OwnDevice.Platform.ANDROID, pubKeyInBase64, type, number, product, regId);\n\n        // make the REST-Call\n        try {\n            deviceIdFromServer = DeviceTask.getInstance().registerDevice(deviceToBeRegistered);\n            deviceId = deviceIdFromServer;\n            //save private and public Key to storage\n            rsa.saveRSAKeys(deviceId);Next line of code:\n", "input": "package de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.app.Activity;\nimport android.os.AsyncTask;\nimport de.fau.cs.mad.yasme.android.connection.DeviceTask;\nimport de.fau.cs.mad.yasme.android.contacts.QR;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.encryption.KeyEncryption;\nimport de.fau.cs.mad.yasme.android.entities.OwnDevice;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.gcm.CloudMessaging;\nimport de.fau.cs.mad.yasme.android.storage.DebugManager;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.fragments.LoginFragment;\n\n\n\n/**\n * Created by Cuong Bui <cuong.bui@fau.de> on 21/06/14.\n */\npublic class DeviceRegistrationTask extends AsyncTask<String, Void, Boolean> {\n\n    private long deviceId;\n    private Activity activity;\n    private String regId;\n    private Class classToNotify;\n\n    public DeviceRegistrationTask(Activity activity, Class classToNotify) {\n        this.activity = activity;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @params params[0] is userId\n     * @params params[1] is product\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        long userId = Long.parseLong(params[0]);\n\n        // the product : e.g Google Nexus\n        String product = params[1];\n\n        // Register for Google Cloud Messaging at Google Server\n        if (!registerGCM()) {\n            return false;\n        }\n\n        // Register at YASME server\n        return registerDeviceAtYASME(userId, product, regId);\n    }\n\n\n    private boolean registerGCM() {\n        CloudMessaging cloudMessaging = CloudMessaging.getInstance(this.activity);\n\n        if (cloudMessaging.checkPlayServices()) {\n            String regid = cloudMessaging.getRegistrationId();\n            Log.d(this.getClass().getSimpleName(), \"Google reg id is empty? \" + regid.isEmpty());\n            if (regid.isEmpty()) {\n                regId = cloudMessaging.registerInBackground();\n                if (null == regId || regId.isEmpty()) {\n                    Log.e(this.getClass().getSimpleName(), \"reg id for GCM is empty\");\n                    return false;\n                }\n            }\n        } else {\n            Log.i(AbstractYasmeActivity.TAG, \"No valid Google Play Services APK found.\");\n        }\n\n        return true;\n    }\n\n\n    private boolean registerDeviceAtYASME(long userId, String product, String regId) {\n        long deviceIdFromServer;\n\n        //register device through REST-Call\n        // create a new device to be registered\n\n        // user which want to register the device\n        // ignore the name user, the server will set the right values according to the userId\n        User user = new User(\"user\", userId);\n\n        // indicates if its a smartphone or a tablet\n        // currently unused\n        String type = \"device\";\n\n        // phone number, currently unused\n        String number = null;\n\n        KeyEncryption rsa = new KeyEncryption();\n        //generate private and public Key\n        rsa.generateRSAKeys();\n        String pubKeyInBase64 = rsa.getGeneratedPubKeyInBase64();\n\n        OwnDevice deviceToBeRegistered = new OwnDevice(user, OwnDevice.Platform.ANDROID, pubKeyInBase64, type, number, product, regId);\n\n        // make the REST-Call\n        try {\n            deviceIdFromServer = DeviceTask.getInstance().registerDevice(deviceToBeRegistered);\n            deviceId = deviceIdFromServer;\n            //save private and public Key to storage\n            rsa.saveRSAKeys(deviceId);", "context": "yasme/src/main/java/de/fau/cs/mad/yasme/android/encryption/KeyEncryption.java\npublic class KeyEncryption {\r\n\r\n    public static final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n    public static final String PRIVATEKEY = \"privateKey\";\r\n    public static final String PUBLICKEY = \"publicKey\";\r\n    private final byte CREATOR = 0;\r\n    private final byte RECIPIENT = 1;\r\n    private RSAEncryption rsa;\r\n    private DatabaseManager db = DatabaseManager.INSTANCE;\r\n\r\n    public KeyEncryption() {\r\n        this.rsa = new RSAEncryption();\r\n    }\r\n\r\n    /**\r\n     * generate a random RSA-KeyPair (Private and Public Key)\r\n     */\r\n    public void generateRSAKeys(){\r\n        rsa.generateKeyPair();\r\n    }\r\n\r\n    /**\r\n     * encode generated RSA-KeyPair to base64 and store it to local storage (SharedPreferences)\r\n     * there is a own SharedPreference for every user on the device\r\n     *\r\n     * @param deviceId deviceId from the user logged in currently\r\n     * @return true/false\r\n     */\r\n    public boolean saveRSAKeys(long deviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + deviceId;\r\n\r\n        try {\r\n\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            //delete existing keys\r\n            if (privKeyStorage.getString(PRIVATEKEY, \"\") != \"\"){\r\n                keyeditor.remove(PRIVATEKEY);\r\n            }\r\n            if (privKeyStorage.getString(PUBLICKEY, \"\") != \"\"){\r\n                keyeditor.remove(PUBLICKEY);\r\n            }\r\n\r\n            keyeditor.putString(PRIVATEKEY, rsa.getPrivKeyinBase64());\r\n            keyeditor.putString(PUBLICKEY, rsa.getPubKeyinBase64());\r\n\r\n            keyeditor.commit();\r\n\r\n            // For Developer-Devices only\r\n            if (DebugManager.INSTANCE.isDebugMode()) {\r\n                Log.d(getClass().getSimpleName(), \"Store keys to external storage\");\r\n                DebugManager.INSTANCE.storePrivatePublicKeyToExternalStorage(rsa.getPrivKeyinBase64(),rsa.getPubKeyinBase64());\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"RSA Keys generated and saved\");\r\n\r\n\r\n            return true;\r\n        } catch (Exception e){\r\n            Log.e(this.getClass().getSimpleName(), \"saving rsa keys failed\");\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the generated RSA Public Key in Base64\r\n     * method is needed in registration when the Public Key needs to be sent to the server\r\n     *\r\n     * @return base64 encoded string\r\n     */\r\n    public String getGeneratedPubKeyInBase64(){\r\n        return rsa.getPubKeyinBase64();\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the RSA PublicKey from the recipient\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be encrypted\r\n     * @return messageKey containing the RSA-encrypted AES-Key\r\n     */\r\n    public MessageKey encrypt(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, RECIPIENT);\r\n\r\n        if (pubKey != null){\r\n            String keyEncrypted = rsa.encrypt(messageKey.getMessageKey(), pubKey);\r\n            messageKey.setKey(keyEncrypted);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the encrypted AES-Key that should be decrypted\r\n     * @return messageKey containing the decrypted AES-Key\r\n     */\r\n    public MessageKey decrypt(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getRecipientDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String key = rsa.decrypt(messageKey.getMessageKey(), privKey);\r\n            if (key == null) {\r\n                return null;\r\n            }\r\n            messageKey.setKey(key);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sign an AES-Key using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be signed\r\n     * @return  messageKey containing the signature\r\n     */\r\n    public MessageKey sign(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getCreatorDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String keySigned = rsa.sign(messageKey.getMessageKey(), privKey);\r\n            messageKey.setSign(keySigned);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * verify the signature from given messageKey using the RSA Public Key from the creatorDevice\r\n     *\r\n     * @param messageKey messageKey containing the signature\r\n     * @return true/false\r\n     */\r\n    public boolean verify(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, CREATOR);\r\n\r\n        if (pubKey != null) {\r\n            Log.d(getClass().getSimpleName(), \"Verify key\");\r\n            return rsa.verify(messageKey.getSign(), messageKey.getMessageKey(), pubKey);\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"PubKey is null\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * load own RSA Private Key from local storage\r\n     *\r\n     * @param selfDeviceId deviceId from the user logged in currently\r\n     * @return PrivateKey\r\n     */\r\n    public PrivateKey getPrivateRSAKeyFromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String privKeyInBase64 = privKeyStorage.getString(PRIVATEKEY, \"\");\r\n\r\n        Log.d(this.getClass().getSimpleName(),\"Load private Key from storage: \" + RSAKEY_STORAGE_USER);\r\n\r\n        //if Key is available\r\n        if (privKeyInBase64 != \"\") {\r\n\r\n            PrivateKey privKey = rsa.convertBase64toPrivKey(privKeyInBase64);\r\n\r\n            if (privKey != null){\r\n                Log.d(this.getClass().getSimpleName(),\"Private Key was successfully loaded from storage\");\r\n                return privKey;\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Getting private key from storage failed\");\r\n            return null;\r\n        }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Private Key could not be found.\");\r\n            return null;\r\n\r\n    }\r\n\r\n    /**\r\n     * load the needed RSA Public Key from local storage/Device-Object\r\n     *\r\n     * @param messageKey messageKey containing the information about creatorDevice and recipientDevice\r\n     * @param type define, the RSA Public Key from the recipient or the creator is needed\r\n     * @return PublicKey\r\n     */\r\n    public PublicKey getPubKeyFromUser(MessageKey messageKey, byte type) {\r\n\r\n        String pubKeyInBase64 = null;\r\n\r\n        //try to extract Public Key from MessageKey\r\n        if (type == CREATOR){\r\n                pubKeyInBase64 = messageKey.getCreatorDevice().getPublicKey();\r\n        }\r\n        else if (type == RECIPIENT){\r\n                pubKeyInBase64 = messageKey.getRecipientDevice().getPublicKey();\r\n        }\r\n        else{\r\n            Log.d(this.getClass().getSimpleName(), \"Wrong use of function: getPubKeyFromUser()\");\r\n            return null;\r\n        }\r\n\r\n        //convert Base64toPublicKey\r\n        if (pubKeyInBase64 != null) {\r\n            PublicKey pubKey = rsa.convertBase64toPubKey(pubKeyInBase64);\r\n            if (pubKey != null) return pubKey;\r\n        }\r\n\r\n        Log.d(this.getClass().getSimpleName(), \"Getting public key from storage failed\");\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    //get own PublicKey in Base64\r\n    public String getPublicRSAKeyInBase64FromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String pubKeyInBase64 = privKeyStorage.getString(PUBLICKEY, \"\");\r\n\r\n        return pubKeyInBase64;\r\n    }\r\n    */\r\n\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/LoginFragment.java\npublic class LoginFragment extends Fragment implements NotifiableFragment<LoginFragment.LoginParam> {\n\n    //Keep track of the login task to ensure we can cancel it if requested.\n    private UserLoginTask authTask = null;\n\n    // UI references.\n    private EditText emailView;\n    private EditText passwordView;\n    private TextView loginStatusMessageView;\n    private View mProgressView;\n    private View mLoginFormView;\n    // values for devices yasme server\n    private String deviceProduct;\n    // Values for name, email and password at the time of the login attempt.\n    private String emailTmp;\n    private String passwordTmp;\n    // focusView for validate()\n    private View focusView = null;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        // In debug app, show @yasme.net\n        String defaultEmail = (BuildConfig.DEBUG) ? \"@yasme.net\" : \"\";\n\n        // Restore preferences\n        emailTmp = DatabaseManager.INSTANCE.getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, defaultEmail);\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_login, container,\n                false);\n\n        // Set up the login form.\n        emailView = (EditText) rootView.findViewById(R.id.email);\n        emailView.setText(emailTmp);\n\n        passwordView = (EditText) rootView.findViewById(R.id.password);\n        if (BuildConfig.DEBUG) {\n            passwordView.setText(R.string.default_password);\n        }\n        passwordView\n                .setOnEditorActionListener(new TextView.OnEditorActionListener() {\n                    @Override\n                    public boolean onEditorAction(TextView textView, int id,\n                                                  KeyEvent keyEvent) {\n                        if (id == R.id.login || id == EditorInfo.IME_NULL) {\n                            attemptLogin();\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        loginStatusMessageView = (TextView) rootView.findViewById(R.id.login_status_message);\n\n        rootView.findViewById(R.id.sign_in_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"SignIn-Button pushed\");\n                        attemptLogin();\n                    }\n                }\n        );\n\n        rootView.findViewById(R.id.register_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Register-Button pushed\");\n                        registerDialog();\n                    }\n                }\n        );\n\n        TextView tv = (TextView) rootView.findViewById(R.id.forgot_password);\n\n        Pattern pattern = Pattern.compile(getString(R.string.forgot_password));\n        /*\n        Linkify.addLinks(tv, pattern, \"\", null, new Linkify.TransformFilter() {\n            @Override\n            public String transformUrl(Matcher matcher, String s) {\n                return \"\";\n            }\n        });\n        */\n        tv.setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Forgot Password-Button pushed\");\n                        requestMail();\n                    }\n                }\n        );\n\n        return rootView;\n    }\n\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(this.getClass().getSimpleName(), \"Try to get LoginObservableInstance\");\n        FragmentObservable<LoginFragment, LoginParam> obs = ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"... successful\");\n\n        obs.register(this);\n        mProgressView = getActivity().findViewById(R.id.login_status);\n        mLoginFormView = getActivity().findViewById(R.id.login);\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        FragmentObservable<LoginFragment, LoginParam> obs =\n                ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"Remove from observer\");\n        obs.remove(this);\n    }\n\n    private void registerDialog() {\n        getFragmentManager().beginTransaction()\n                .add(R.id.singleFragmentContainer, new RegisterFragment()).commit();\n    }\n\n    /**\n     * Attempts to sign in or register the account specified by the login form.\n     * If there are form errors (missing fields, etc.), the errors are presented\n     * and no actual login attempt is made.\n     */\n    public void attemptLogin() {\n        if (authTask == null) {\n            authTask = new UserLoginTask(true, this.getClass());\n            Log.d(this.getClass().getSimpleName(), \"AuthTask is null\");\n        }\n\n        // Reset errors.\n        emailView.setError(null);\n        passwordView.setError(null);\n\n        // Store values at the time of the login attempt.\n        emailTmp = emailView.getText().toString();\n        passwordTmp = passwordView.getText().toString();\n\n        boolean cancel = false;\n\n        // Check for a valid password.\n        if (TextUtils.isEmpty(passwordTmp)) {\n            passwordView.setError(getString(R.string.error_field_required));\n            focusView = passwordView;\n            cancel = true;\n        } else if (passwordTmp.length() < 8) {\n            passwordView.setError(getString(R.string.error_invalid_password));\n            focusView = passwordView;\n            cancel = true;\n        }\n\n        // Check for a valid mail.\n        if (TextUtils.isEmpty(emailTmp)) {\n            emailView.setError(getString(R.string.error_field_required));\n            focusView = emailView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            // Show a progress spinner, and kick off a background task to\n            // perform the user login attempt.\n            loginStatusMessageView.setText(R.string.login_progress_signing_in);\n            showProgress(true);\n\n            // Hide the virtual keyboard\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            View focus = activity.getCurrentFocus();\n            if (null == focus) {\n                focus = focusView;\n            }\n            if (null == focus) {\n                focus = passwordView;\n            }\n            if (null == focus) {\n                focus = emailView;\n            }\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (null != imm && null != focus)\n                imm.hideSoftInputFromWindow(focus.getWindowToken(), 0);\n\n            // Start the asynctask\n            authTask.execute(emailTmp, passwordTmp);\n            authTask = null;\n        }\n    }\n\n    public void onPostLoginExecute(Boolean success, long userId) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        activity.getSelfUser().setId(userId);\n\n        if (success) {\n            //Initialize database (once in application)\n            if (!DatabaseManager.INSTANCE.isInitialized()) {\n                Log.e(getClass().getSimpleName(), \"DB-Manger hasn't been initialized\");\n            }\n            DatabaseManager.INSTANCE.setUserId(userId);\n\n            // check if there is a device in the Database\n            if (yasmeDeviceCheck()) {\n                Log.d(this.getClass().getSimpleName(), \"Device exists in Database\");\n\n                long deviceId = DatabaseManager.INSTANCE.getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n                if (deviceId < 0) {\n                    // Error ocurred\n                    Log.e(this.getClass().getSimpleName(), \"Could not load registered device's id from shared prefs\");\n                    showProgress(false);\n                    return;\n                }\n\n                DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n                showProgress(false);\n                Intent intent = new Intent(activity, ChatListActivity.class);\n                startActivity(intent);\n                getActivity().finish();\n            } else {\n                // register device\n                Log.d(this.getClass().getSimpleName(), \"Device does not exist in Database\");\n                Log.d(this.getClass().getSimpleName(), \"Starting task to register device at yasme server\");\n\n                new DeviceRegistrationTask(activity, this.getClass())\n                        .execute(Long.toString(userId), this.deviceProduct, this.getClass().getName());\n\n            }\n        } else {\n            Log.d(getClass().getSimpleName(), \"Login failed\");\n            ServerInfo serverInfo = DatabaseManager.INSTANCE.getServerInfo();\n            if (serverInfo != null && !serverInfo.getLoginAllowed() && serverInfo.hasMessage()) {\n                passwordView.setError(DatabaseManager.INSTANCE.getServerInfo().getMessage());\n            } else {\n                passwordView.setError(getString(R.string.error_incorrect_user_or_password));\n            }\n            passwordView.requestFocus();\n            showProgress(false);\n        }\n    }\n\n    public void onPostYasmeDeviceRegExecute(Boolean success, long deviceId) {\n        if (!success) {\n            Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n        } else {\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            // Initialize the session a second time because the deviceId was missing\n            /*SharedPreferences devicePrefs = activity.getSharedPreferences(\n                    AbstractYasmeActivity.DEVICE_PREFS,\n                    AbstractYasmeActivity.MODE_PRIVATE);\n            long userId = devicePrefs.getLong(AbstractYasmeActivity.USER_ID, -1);\n            if (userId < 0) {\n                // Error ocurred\n                Log.e(this.getClass().getSimpleName(), \"Did not find user id in shared prefs\");\n                Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n                showProgress(false);\n                return;\n            }*/\n\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n            Log.d(this.getClass().getSimpleName(), \"Login after device registration at yasme server\");\n            showProgress(false);\n            Intent intent = new Intent(activity, ChatListActivity.class);\n            startActivity(intent);\n            getActivity().finish();\n        }\n    }\n\n    /**\n     * This method checks if there is a device in the DB\n     */\n    public boolean yasmeDeviceCheck() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        //set the deviceProduct\n        this.deviceProduct = Build.MANUFACTURER + \" \" + Build.MODEL;\n        Log.d(this.getClass().getSimpleName(), \"MODEL is \" + Build.MODEL);\n        Log.d(this.getClass().getSimpleName(), \"DEVICE is \" + Build.DEVICE);\n        Log.d(this.getClass().getSimpleName(), \"PRODUCT is \" + Build.PRODUCT);\n        Log.d(this.getClass().getSimpleName(), \"MANUFACTURER is \" + Build.MANUFACTURER);\n        Log.d(this.getClass().getSimpleName(), \"BRAND is \" + Build.BRAND);\n        Log.d(this.getClass().getSimpleName(), \"NOW is \" + this.deviceProduct);\n        //try to load device from shared preferences\n        SharedPreferences devicePrefs = activity.getSharedPreferences(\n                AbstractYasmeActivity.DEVICE_PREFS,\n                AbstractYasmeActivity.MODE_PRIVATE);\n        long deviceId = devicePrefs.getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n\n        // load regId\n        SharedPreferences pushPrefs = activity.\n                getSharedPreferences(AbstractYasmeActivity.PUSH_PREFS,\n                        AbstractYasmeActivity.MODE_PRIVATE);\n\n        String googleRegId = pushPrefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, null);\n        // TODO proper check\n\n        if (deviceId == -1) {\n            if (DebugManager.INSTANCE.isDebugMode()) {\n                return DebugManager.INSTANCE.restoreData();\n            }\n            return false;\n        }\n        // TODO devices from server\n        // TODO use case : plain app + old user + old device\n\n        Log.d(this.getClass().getSimpleName(), \"deviceId is \" + deviceId);\n        return true;\n    }\n\n    public void requestMail() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.request_email_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final TextView requestEmailText = new TextView(activity);\n        requestEmailText.setText(R.string.request_email_body);\n\n        final EditText mail = new EditTextWithX(activity).getEditText();\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n        mail.setText(emailTmp);\n\n        list.addView(mail);\n        list.addView(requestEmailText, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        // Grab the EditText's input\n                        emailTmp = mail.getText().toString();\n                        Log.d(this.getClass().getSimpleName(), \"Mail to send token at: \" + emailTmp);\n                        User user = new User();\n                        user.setEmail(emailTmp);\n                        new ChangePasswordTask(user).execute(\"1\");\n                        forgotPasswordDialog(emailTmp);\n                    }\n                }\n        );\n\n        // Skip, email was already sent\n        alert.setNeutralButton(R.string.skip,\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        forgotPasswordDialog(null);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    public void forgotPasswordDialog(final String inputMail) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.password_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final EditText token = new EditText(activity);\n        token.setInputType(InputType.TYPE_CLASS_TEXT);\n        token.setHint(R.string.hint_mail_token);\n\n        final TextView tokenExplanation = new TextView(activity);\n        tokenExplanation.setText(R.string.explanation_mail_token);\n\n        final EditText password = new EditText(activity);\n        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        password.setHint(R.string.hint_new_password);\n\n        final EditText passwordCheck = new EditText(activity);\n        passwordCheck.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        passwordCheck.setHint(R.string.hint_repeat_new_password);\n\n        final EditText mail = new EditText(activity);\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n\n        if (inputMail == null || inputMail.isEmpty()) {\n            list.addView(mail);\n        }\n        list.addView(token, layoutParams);\n        list.addView(tokenExplanation, layoutParams);\n        list.addView(password, layoutParams);\n        list.addView(passwordCheck, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n\n                        // Grab the EditText's input\n                        String email;\n                        if (inputMail == null || inputMail.isEmpty()) {\n                            email = mail.getText().toString();\n                        } else {\n                            email = inputMail;\n                        }\n                        String mailToken = token.getText().toString();\n                        String inputPassword = password.getText().toString();\n                        String inputPasswordCheck = passwordCheck.getText()\n                                .toString();\n\n                        if (password.getText().length() < 8) {\n                            Toaster.getInstance().toast(R.string.password_too_short,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        if (!inputPassword.equals(inputPasswordCheck)) {\n                            Toaster.getInstance().toast(R.string.passwords_do_not_match,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        User user = new User(email, inputPassword);\n                        PasswordEncryption pwEnc = new PasswordEncryption(user);\n                        User secured = pwEnc.securePassword();\n                        new ChangePasswordTask(secured).execute(\"0\", mailToken);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    /**\n     * Shows the progress UI and hides the login form.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(final boolean show) {\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n                }\n            });\n\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n                }\n            });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply show\n            // and hide the relevant UI components.\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void notifyFragment(LoginParam param) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified. Yeeha!\");\n        if (param instanceof LoginProcessParam) {\n            notifyFragment((LoginProcessParam) param);\n        } else if (param instanceof DeviceRegistrationParam) {\n            notifyFragment((DeviceRegistrationParam) param);\n        }\n    }\n\n    public void notifyFragment(LoginProcessParam loginParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with loginParam\");\n\n        onPostLoginExecute(loginParam.getSuccess(), loginParam.getUserId());\n        Log.d(super.getClass().getSimpleName(), \"Login-Status: \" + loginParam.getSuccess());\n    }\n\n    public void notifyFragment(DeviceRegistrationParam deviceRegistrationParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with deviceRegistrationParam\");\n\n        onPostYasmeDeviceRegExecute(deviceRegistrationParam.getSuccess(),\n                deviceRegistrationParam.getDeviceId());\n\n    }\n\n    public static class LoginParam {\n        protected Boolean success;\n\n        public Boolean getSuccess() {\n            return success;\n        }\n    }\n\n    public static class LoginProcessParam extends LoginParam {\n        private Long userId;\n\n        public LoginProcessParam(Boolean success) {\n            this.success = success;\n            this.userId = DatabaseManager.INSTANCE.getUserId();\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n    }\n\n    public static class DeviceRegistrationParam extends LoginParam {\n        private Long deviceId;\n\n        public DeviceRegistrationParam(Boolean success) {\n            this.success = success;\n            this.deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        }\n\n        public Long getDeviceId() {\n            return deviceId;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/gcm/CloudMessaging.java\npublic class CloudMessaging {\n\n    private static CloudMessaging instance;\n\n    private Activity activity;\n    private GoogleCloudMessaging gcm;\n    private Context context;\n    private String regid;\n\n\n    public static CloudMessaging getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CloudMessaging(activity);\n        }\n        return instance;\n    }\n\n    private CloudMessaging(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.gcm = GoogleCloudMessaging.getInstance(activity);\n    }\n\n    public boolean checkPlayServices() {\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                GooglePlayServicesUtil.getErrorDialog(resultCode, activity,\n                        AbstractYasmeActivity.PLAY_SERVICES_RESOLUTION_REQUEST).show();\n            } else {\n                Log.i(AbstractYasmeActivity.TAG, \"This device is not supported.\");\n                activity.finish();\n            }\n            return false;\n        }\n        return true;\n    }\n\n    public String getRegistrationId() {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        String registrationId = prefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, \"\");\n        Log.i(AbstractYasmeActivity.TAG + \"WOOOOOLOOOLOOOO\", \"this is my id: [\" + AbstractYasmeActivity.PROPERTY_REG_ID + \"]\");\n        if (registrationId.isEmpty()) {\n            Log.i(AbstractYasmeActivity.TAG, \"Registration not found.\");\n            return \"\";\n        }\n        // Check if app was updated; if so, it must clear the registration ID\n        // since the existing regID is not guaranteed to work with the new\n        // app version.\n        int registeredVersion = prefs.getInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, Integer.MIN_VALUE);\n        int currentVersion = getAppVersion(context);\n        if (registeredVersion != currentVersion) {\n            Log.i(AbstractYasmeActivity.TAG, \"App version changed.\");\n            return \"\";\n        }\n        return registrationId;\n    }\n\n    public SharedPreferences getGCMPreferences(Context context) {\n        return context.getSharedPreferences(LoginActivity.class.getSimpleName(),\n                Context.MODE_PRIVATE);\n    }\n\n    public int getAppVersion(Context context) {\n        try {\n            PackageInfo packageInfo = context.getPackageManager()\n                    .getPackageInfo(context.getPackageName(), 0);\n            return packageInfo.versionCode;\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new RuntimeException(\"Could not get package name: \" + e);\n        }\n    }\n\n    public String registerInBackground() {\n        try {\n            if (gcm == null) {\n                gcm = GoogleCloudMessaging.getInstance(context);\n            }\n            regid = gcm.register(AbstractYasmeActivity.SENDER_ID);\n\n            Log.d(this.getClass().getSimpleName(), \"Device registered, registration ID=\" + regid);\n\n            // Persist the regID - no need to register again.\n            storeRegistrationId(context, regid);\n            return regid;\n        } catch (IOException e) {\n            // If there is an error, don't just keep trying to register.\n            // Require the user to click a button again, or perform\n            // exponential back-off.\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    private void storeRegistrationId(Context context, String regId) {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        int appVersion = getAppVersion(context);\n        Log.i(AbstractYasmeActivity.TAG, \"Saving regId on app version \" + appVersion);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(AbstractYasmeActivity.PROPERTY_REG_ID, regId);\n        editor.putInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, appVersion);\n        editor.commit();\n\n        // For Developer-Devices only\n        if (DebugManager.INSTANCE.isDebugMode()) {\n            Log.d(getClass().getSimpleName(), \"Store gcmId to external storage\");\n            DebugManager.INSTANCE.storePushId(regId);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DebugManager.java\npublic enum DebugManager {\r\n    INSTANCE;\r\n\r\n    private final String OWNDEVICE = \"owndevice\";\r\n    private final String MESSAGEKEYS = \"messagekeys\";\r\n\r\n    private boolean debugMode = false;\r\n    private OwnDevice ownDevice = new OwnDevice();\r\n\r\n    public boolean isDebugMode() {\r\n        return debugMode;\r\n    }\r\n\r\n    public boolean storeDeviceId(long deviceId) {\r\n        ownDevice.setId(deviceId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n\r\n    public boolean storePrivatePublicKeyToExternalStorage(String privateKey, String publicKey) {\r\n        ownDevice.setPrivateKey(privateKey);\r\n        ownDevice.setPublicKey(publicKey);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    public boolean storePushId(String pushId) {\r\n        ownDevice.setPushId(pushId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    private boolean storeOwnDeviceToExternalStorage() {\r\n        return storeToExternalStorage(OWNDEVICE, ownDevice, false);\r\n    }\r\n\r\n    public boolean storeMessageKeyToExternalStorage(MessageKey data) {\r\n        return storeToExternalStorage(MESSAGEKEYS, data, true);\r\n    }\r\n\r\n    private boolean storeToExternalStorage(String name, Object data, boolean append) {\r\n        try {\r\n            String state = Environment.getExternalStorageState();\r\n            Log.d(getClass().getSimpleName(), \"Check state\");\r\n            if (!Environment.MEDIA_MOUNTED.equals(state)) {\r\n                return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            Log.d(getClass().getSimpleName(), \"Mkdir\");\r\n            if (!dir.exists() && !dir.mkdirs()) {\r\n                Log.d(getClass().getSimpleName(), \"... failed\");\r\n               return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            File file = new File(dir,name + \".txt\");\r\n            Log.d(getClass().getSimpleName(), \"Write file\");\r\n\r\n            ObjectWriter objectWriter = new ObjectMapper().writer();\r\n            String json = objectWriter.writeValueAsString(data);\r\n            Log.d(getClass().getSimpleName(),\"Generated JSON: \" + json);\r\n\r\n            FileOutputStream f = new FileOutputStream(file,append);\r\n            PrintWriter pw = new PrintWriter(f);\r\n            if (append) {\r\n                pw.println(json + \",\");\r\n            } else {\r\n                pw.println(json);\r\n            }\r\n            pw.flush();\r\n            pw.close();\r\n            f.close();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean restoreData() {\r\n        Log.d(getClass().getSimpleName(),\"Restoring data\");\r\n        if (!restoreOwnDeviceFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring OwnDevice failed\");\r\n            return false;\r\n        }\r\n        if (!restoreMessageKeysFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring MessageKeys failed\");\r\n            return false;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Restoring successful\");\r\n        Toaster.getInstance().toast(\"Restoring Debug-Data successful\", Toast.LENGTH_LONG);\r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean restoreOwnDeviceFromExternalStorage() {\r\n         final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n         final String PRIVATEKEY = \"privateKey\";\r\n         final String PUBLICKEY = \"publicKey\";\r\n\r\n        try {\r\n            OwnDevice device = getOwnDeviceFromExternalStorage();\r\n            if (device == null) {\r\n                Log.d(getClass().getSimpleName(), \"Device is null\");\r\n                return false;\r\n            }\r\n\r\n            // Restore devId\r\n            Log.d(getClass().getSimpleName(), \"Restore devId\");\r\n            SharedPreferences.Editor editor1 = DatabaseManager.INSTANCE.getSharedPreferences().edit();\r\n            editor1.putLong(AbstractYasmeActivity.DEVICE_ID, ownDevice.getId());\r\n            editor1.commit();\r\n\r\n            // Restore pushId and app version\r\n            Log.d(getClass().getSimpleName(), \"Restore pushId\");\r\n            SharedPreferences prefs = DatabaseManager.INSTANCE.getContext().getSharedPreferences(LoginActivity.class.getSimpleName(), Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor2 = prefs.edit();\r\n            editor2.putString(AbstractYasmeActivity.PROPERTY_REG_ID, ownDevice.getPushId());\r\n            editor2.commit();\r\n\r\n            // Restore PrivatePublicKey\r\n            Log.d(getClass().getSimpleName(), \"Restore PrivPubKeys\");\r\n            String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + ownDevice.getId();\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            keyeditor.putString(PRIVATEKEY, device.getPrivateKey());\r\n            keyeditor.putString(PUBLICKEY,device.getPublicKey());\r\n            keyeditor.commit();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private OwnDevice getOwnDeviceFromExternalStorage() {\r\n        String text = readText(OWNDEVICE);\r\n        if (text == null || text == \"\") {\r\n            return null;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Device-Text: \" + text);\r\n        try {\r\n            OwnDevice device = new ObjectMapper().readValue(text, OwnDevice.class);\r\n            Log.d(getClass().getSimpleName(), \"PubKey: \" + device.getPublicKey());\r\n            return device;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private boolean restoreMessageKeysFromExternalStorage() {\r\n        String text = readText(MESSAGEKEYS);\r\n        if (text == null) {\r\n            return false;\r\n        }\r\n        if (text == \"\") {\r\n            // No messageKey stored yet\r\n            return true;\r\n        }\r\n        String json = \"[\" + text + \"{}]\";\r\n        Log.d(getClass().getSimpleName(), \"MessageKeys-Text: \" + text);\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"JSON: \" + json);\r\n            JSONArray jsonArray = new JSONArray(json);\r\n\r\n            for (int i = 0; i < jsonArray.length() - 1; i++) {\r\n                MessageKey messageKey = new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\r\n                        toString(), MessageKey.class);\r\n                messageKey.setAuthenticity(true);\r\n                DatabaseManager.INSTANCE.getMessageKeyDAO().addOrUpdate(messageKey);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private String readText(String name) {\r\n        String filename = \"\";\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            if (!dir.exists()) {\r\n                return null;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            filename = dir.getAbsolutePath() + \"/\" + name + \".txt\";\r\n\r\n\r\n            BufferedReader br = new BufferedReader(new FileReader(filename));\r\n            StringBuilder sb = new StringBuilder();\r\n            String line = br.readLine();\r\n\r\n            while (line != null) {\r\n                sb.append(line);\r\n                line = br.readLine();\r\n            }\r\n            br.close();\r\n            return sb.toString();\r\n        } catch (FileNotFoundException e) {\r\n            Log.e(getClass().getSimpleName(), \"File \" + filename + \" not found.\");\r\n            return \"\";\r\n        }\r\n        catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private File getDir() {\r\n        return new File(Environment.getExternalStoragePublicDirectory(\"yasme\"), String.valueOf(DatabaseManager.INSTANCE.getUserId()));\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/DeviceTask.java\npublic class DeviceTask extends ConnectionTask {\n\n    private static DeviceTask instance;\n\n    public static DeviceTask getInstance() {\n        if (instance == null) {\n            synchronized (DeviceTask.class) {\n                if (null == instance) {\n                    instance = new DeviceTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private DeviceTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/device\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n    }\n\n    public Long registerDevice(OwnDevice device) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", device);\n\n            //Log.d(this.getClass().getSimpleName(), \"Device registration was successful\");\n\n            long deviceId = (new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent())\n            )).readLine())).getLong(\"id\");\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n            return deviceId;\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n        return null;\n    }\n\n    public Device getDevice(long devId) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(devId));\n            return new ObjectMapper().readValue(new BufferedReader(new InputStreamReader(httpResponse.getEntity()\n                    .getContent())).readLine(), Device.class);\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public ArrayList<Device> getAllDevices(Long userId) throws RestServiceException {\n\n        ArrayList<Device> devices = new ArrayList<Device>();\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"all/\" + userId);\n\n            JSONArray jsonArray = new JSONArray(new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent())).readLine());\n\n            for (int i = 0; i < jsonArray.length(); i++)\n                devices.add(new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\n                        toString(), Device.class));\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n\n        //Log.d(this.getClass().getSimpleName(), \"No.Devices: \" + devices.size());\n        return devices;\n    }\n\n    public void deleteDevice(long deviceId) throws RestServiceException {\n        executeRequest(Request.DELETE, Long.toString(deviceId));\n        //Log.d(this.getClass().getSimpleName(), \"Device removed!\");\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/contacts/QR.java\npublic class QR {\n    private static final int SIZE = 1024;\n    private static Bitmap qrCode;\n    private static boolean isRunning = false;\n\n    public static void init(boolean force) {\n        if (force) {\n            qrCode = null;\n            isRunning = false;\n        }\n        if (qrCode == null && !isRunning) {\n            isRunning = true;\n            new QRTask().execute();\n        }\n    }\n\n    public static void finished() {\n        isRunning = false;\n    }\n\n    public Bitmap generateQRCode() {\n        if (qrCode != null) {\n            return qrCode;\n        }\n        QRData qrdata = new QRData();\n        DatabaseManager db = DatabaseManager.INSTANCE;\n        qrdata.setDeviceId(db.getDeviceId());\n\n        Context context = db.getContext();\n        String RSAKEY_STORAGE_USER = KeyEncryption.RSAKEY_STORAGE + \"_\" + db.getDeviceId();\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\n        String pubKeyInBase64 = privKeyStorage.getString(KeyEncryption.PUBLICKEY, \"\");\n        qrdata.setPublicKey(pubKeyInBase64);\n\n        //ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();\n        ObjectWriter objectWriter = new ObjectMapper().writer();\n        try {\n            String data = objectWriter.writeValueAsString(qrdata);\n            qrCode = generateQRCode(data);\n            return qrCode;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Bitmap generateQRCode(String data) {\n        Log.d(getClass().getName(), \"Generate QR for \" + data);\n        com.google.zxing.Writer writer = new QRCodeWriter();\n        BitMatrix bm;\n        try {\n            bm = writer.encode(data, BarcodeFormat.QR_CODE,SIZE, SIZE);\n        } catch (Exception e) {\n            return null;\n        }\n\n        Bitmap imageBitmap = Bitmap.createBitmap(SIZE, SIZE, Bitmap.Config.ARGB_8888);\n\n        for (int i = 0; i < SIZE; i++) {//width\n            for (int j = 0; j < SIZE; j++) {//height\n                imageBitmap.setPixel(i, j, bm.get(i, j) ? Color.BLACK: Color.WHITE);\n            }\n        }\n        return imageBitmap;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/OwnDevice.java\npublic class OwnDevice {\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        WINDOWSPHONE;\n    }\n\n    private long id;\n    private Platform platform; // android, ios or windowsmobile\n    private String type;    // mobilephone, tablet or desktop\n    private User user;\n    private String number;  // optional\n    private String publicKey;\n    private String privateKey;\n    private String product; // product name e.g. Google Nexux 5\n    private String pushId;\n\n    private Date created;\n\n    private Date lastModified;\n\n    public OwnDevice(User user, Platform platform, String publicKey, String type, String number, String product, String pushId) {\n        this.user = user;\n        this.platform = platform;\n        this.type = type;\n        this.number = number;\n        this.product = product;\n        this.pushId = pushId;\n        this.publicKey = publicKey;\n    }\n\n    public OwnDevice() {\n    }\n\n    public OwnDevice(long id) {\n        this.id = id;\n    }\n\n    @JsonIgnoreProperties({ \"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\" })\n    public User getUser() {\n        return this.user;\n    }\n\n    public String getPushId(){return this.pushId;}\n\n    public String getProduct(){return this.product;}\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setProduct(String product){this.product = product;}\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Platform getPlatform() {\n        return platform;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setPlatform(Platform platform) {\n        this.platform = platform;\n    }\n\n    public void setPushId(String pushId){this.pushId = pushId;}\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPublicKey() {\n        return publicKey;\n    }\n\n    public void setPublicKey(String publicKey) {\n        this.publicKey = publicKey;\n    }\n\n    public Date getCreated() {\n        return this.created;\n    }\n\n    public Date getLastModified() {\n        return this.lastModified;\n    }\n\n    public String getPrivateKey() {\n        return privateKey;\n    }\n\n    public void setPrivateKey(String privateKey) {\n        this.privateKey = privateKey;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\n", "answers": ["        } catch (RestServiceException e) {"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 5741, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "6844939b4c4619bf2bb691b26c2beecaad85f0aeb4518366"}
{"prompt": "Please complete the code given below. \nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationRequest.java\npublic class RegistrationRequest {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegistrationRequest(String version, String challenge, String appId, String sessionId) {\n    this.version = version;\n    this.challenge = challenge;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(challenge, version, sessionId, appId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationRequest other = (RegistrationRequest) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(challenge, other.challenge)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic enum Transports {\n  BLUETOOTH_BREDR(\"bt\"),\n  BLUETOOTH_LOW_ENERGY(\"ble\"),\n  USB(\"usb\"),\n  NFC(\"nfc\");\n\n  private String mValue;\n\n  Transports(String value) {\n    mValue = value;\n  }\n\n  @Override\n  public String toString() {\n    return mValue;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationResponse.java\npublic class RegistrationResponse {\n  /** websafe-base64(raw registration response message) */\n  private final String registrationData;\n\n  /** websafe-base64(UTF8(stringified(client data))) */\n  private final String clientData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n  public RegistrationResponse(String registrationData, String clientData, String sessionId) {\n    this.registrationData = registrationData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getRegistrationData() {\n    return registrationData;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(registrationData, clientData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationResponse other = (RegistrationResponse) obj;\n    if (clientData == null) {\n      if (other.clientData != null)\n        return false;\n    } else if (!clientData.equals(other.clientData))\n      return false;\n    if (registrationData == null) {\n      if (other.registrationData != null)\n        return false;\n    } else if (!registrationData.equals(other.registrationData))\n      return false;\n    if (sessionId == null) {\n      if (other.sessionId != null)\n        return false;\n    } else if (!sessionId.equals(other.sessionId))\n      return false;\n    return true;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SignSessionData.java\npublic class SignSessionData extends EnrollSessionData {\n  private static final long serialVersionUID = -1374014642398686120L;\n\n  private final byte[] publicKey;\n\n  public SignSessionData(String accountName, String appId, byte[] challenge, byte[] publicKey) {\n    super(accountName, appId, challenge);\n    this.publicKey = publicKey;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/SignResponse.java\npublic class SignResponse {\n\n  /** websafe-base64 key handle from U2F device */\n  private final String keyHandle;\n\n  /** websafe-base64(client data) */\n  private final String clientData;\n\n  /** websafe-base64(raw response from U2F device) */\n  private final String signatureData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n\n  public SignResponse(String keyHandle, String signatureData, String clientData, String sessionId) {\n    this.keyHandle = keyHandle;\n    this.signatureData = signatureData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSignatureData() {\n    return signatureData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(keyHandle, clientData, signatureData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (getClass() != obj.getClass())\n      return false;\n    SignResponse other = (SignResponse) obj;\n    return Objects.equals(keyHandle, other.keyHandle)\n        && Objects.equals(clientData, other.clientData)\n        && Objects.equals(signatureData, other.signatureData)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic class SecurityKeyData {\n  public enum Transports {\n    BLUETOOTH_BREDR(\"bt\"),\n    BLUETOOTH_LOW_ENERGY(\"ble\"),\n    USB(\"usb\"),\n    NFC(\"nfc\");\n\n    private String mValue;\n\n    Transports(String value) {\n      mValue = value;\n    }\n\n    @Override\n    public String toString() {\n      return mValue;\n    }\n  }\n\n  private final long enrollmentTime;\n  private final List<Transports> transports;\n  private final byte[] keyHandle;\n  private final byte[] publicKey;\n  private final X509Certificate attestationCert;\n  private int counter;\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this(enrollmentTime, null /* transports */, keyHandle, publicKey, attestationCert, counter);\n  }\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      List<Transports> transports,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this.enrollmentTime = enrollmentTime;\n    this.transports = transports;\n    this.keyHandle = keyHandle;\n    this.publicKey = publicKey;\n    this.attestationCert = attestationCert;\n    this.counter = counter;\n  }\n\n  /**\n   * When these keys were created/enrolled with the relying party.\n   */\n  public long getEnrollmentTime() {\n    return enrollmentTime;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public byte[] getKeyHandle() {\n    return keyHandle;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n\n  public X509Certificate getAttestationCertificate() {\n    return attestationCert;\n  }\n\n  public int getCounter() {\n    return counter;\n  }\n\n  public void setCounter(int newCounterValue) {\n    counter = newCounterValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        enrollmentTime,\n        transports,\n        keyHandle,\n        publicKey,\n        attestationCert,\n        counter);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof SecurityKeyData)) {\n      return false;\n    }\n    SecurityKeyData that = (SecurityKeyData) obj;\n    return Arrays.equals(this.keyHandle, that.keyHandle)\n        && (this.enrollmentTime == that.enrollmentTime)\n        && containSameTransports(this.transports, that.transports)\n        && Arrays.equals(this.publicKey, that.publicKey)\n        && Objects.equals(this.attestationCert, that.attestationCert)\n        && Objects.equals(counter, counter);\n  }\n\n  /**\n   * Compares the two Lists of Transports and says if they are equal.\n   *\n   * @param transports1 first List of Transports\n   * @param transports2 second List of Transports\n   * @return true if both lists are null or if both lists contain the same transport values\n   */\n  public static boolean containSameTransports(List<Transports> transports1,\n      List<Transports> transports2) {\n    if (transports1 == null && transports2 == null) {\n      return true;\n    } else if (transports1 == null || transports2 == null) {\n      return false;\n    }\n    return transports1.containsAll(transports2) && transports2.containsAll(transports1);\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder()\n      .append(\"public_key: \")\n      .append(Base64.encodeBase64URLSafeString(publicKey))\n      .append(\"\\n\")\n      .append(\"key_handle: \")\n      .append(Base64.encodeBase64URLSafeString(keyHandle))\n      .append(\"\\n\")\n      .append(\"counter: \")\n      .append(counter)\n      .append(\"\\n\")\n      .append(\"attestation certificate:\\n\")\n      .append(attestationCert.toString())\n      .append(\"transports: \")\n      .append(transports)\n      .append(\"\\n\")\n      .toString();\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/U2fSignRequest.java\npublic class U2fSignRequest {\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n  /** List of registered keys */\n  private List<RegisteredKey> registeredKeys;\n\n  public U2fSignRequest(String challenge, List<RegisteredKey> registeredKeys) {\n    this.challenge = challenge;\n    this.registeredKeys = registeredKeys;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public List<RegisteredKey> getRegisteredKeys() {\n    return registeredKeys;\n  }\n\n  public JsonArray getRegisteredKeysAsJson(String defaultAppId) {\n    if (registeredKeys == null) {\n      return null;\n    }\n    JsonArray result = new JsonArray();\n    for (RegisteredKey registeredKey : registeredKeys) {\n      result.add(registeredKey.getJson(defaultAppId));\n    }\n    return result;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/U2FServer.java\npublic interface U2FServer {\n\n  // registration //\n  public RegistrationRequest getRegistrationRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processRegistrationResponse(RegistrationResponse registrationResponse,\n      long currentTimeInMillis) throws U2FException;\n\n  // authentication //\n  public U2fSignRequest getSignRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processSignResponse(SignResponse signResponse) throws U2FException;\n\n  // token management //\n  public List<SecurityKeyData> getAllSecurityKeys(String accountName);\n\n  public void removeSecurityKey(String accountName, byte[] publicKey) throws U2FException;\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/EnrollSessionData.java\npublic class EnrollSessionData implements Serializable {\n  private static final long serialVersionUID = 1750990095756334568L;\n\n  private final String accountName;\n  private final byte[] challenge;\n  private final String appId;\n\n  public EnrollSessionData(String accountName, String appId, byte[] challenge) {\n    this.accountName = accountName;\n    this.challenge = challenge;\n    this.appId = appId;\n  }\n\n  public String getAccountName() {\n    return accountName;\n  }\n\n  public byte[] getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n\treturn appId;\n  }\n}\nu2f-ref-code/java/tests/com/google/u2f/TestVectors.java\npublic class TestVectors {\n  // Test vectors from FIDO U2F: Raw Message Formats - Draft 4\n  protected static final int COUNTER_VALUE = 1;\n  protected static final String ACCOUNT_NAME = \"test@example.com\";\n  protected static final Set<String> TRUSTED_DOMAINS = ImmutableSet.of(\"http://example.com\");\n  protected static final String SESSION_ID = \"session_id\";\n  protected static final String APP_ID_ENROLL = \"http://example.com\";\n  protected static final byte[] APP_ID_ENROLL_SHA256 = computeSha256(APP_ID_ENROLL);\n  protected static final String APP_ID_SIGN = \"https://gstatic.com/securitykey/a/example.com\";\n  protected static final byte[] APP_ID_SIGN_SHA256 = computeSha256(APP_ID_SIGN);\n  protected static final String ORIGIN = \"http://example.com\";\n  protected static final String SERVER_CHALLENGE_ENROLL_BASE64 =\n      \"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\";\n  protected static final byte[] SERVER_CHALLENGE_ENROLL =\n      Base64.decodeBase64(SERVER_CHALLENGE_ENROLL_BASE64);\n  protected static final String SERVER_CHALLENGE_SIGN_BASE64 =\n      \"opsXqUifDriAAmWclinfbS0e-USY0CgyJHe_Otd7z8o\";\n  protected static final byte[] SERVER_CHALLENGE_SIGN =\n      Base64.decodeBase64(SERVER_CHALLENGE_SIGN_BASE64);\n  protected static final String VENDOR_CERTIFICATE_HEX =\n      \"3082013c3081e4a003020102020a47901280001155957352300a06082a8648ce\"\n      + \"3d0403023017311530130603550403130c476e756262792050696c6f74301e17\"\n      + \"0d3132303831343138323933325a170d3133303831343138323933325a303131\"\n      + \"2f302d0603550403132650696c6f74476e756262792d302e342e312d34373930\"\n      + \"313238303030313135353935373335323059301306072a8648ce3d020106082a\"\n      + \"8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c144668\"\n      + \"2c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23abaf02\"\n      + \"03b4b8911ba0569994e101300a06082a8648ce3d0403020347003044022060cd\"\n      + \"b6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30dfa0220\"\n      + \"631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b30410df\";\n  protected static final X509Certificate VENDOR_CERTIFICATE =\n      parseCertificate(VENDOR_CERTIFICATE_HEX);\n  protected static final PrivateKey VENDOR_CERTIFICATE_PRIVATE_KEY =\n      parsePrivateKey(\"f3fccc0d00d8031954f90864d43c247f4bf5f0665c6b50cc17749a27d1cf7664\");\n  protected static final String CHANNEL_ID_STRING =\n      \"{\"\n      + \"\\\"kty\\\":\\\"EC\\\",\"\n      + \"\\\"crv\\\":\\\"P-256\\\",\"\n      + \"\\\"x\\\":\\\"HzQwlfXX7Q4S5MtCCnZUNBw3RMzPO9tOyWjBqRl4tJ8\\\",\"\n      + \"\\\"y\\\":\\\"XVguGFLIZx1fXg3wNqfdbn75hi4-_7-BxhMljw42Ht4\\\"\"\n      + \"}\";\n  protected static final JsonObject CHANNEL_ID_JSON =\n      (JsonObject) new JsonParser().parse(CHANNEL_ID_STRING);\n  protected static final String BROWSER_DATA_ENROLL = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_ENROLL_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_ENROLL_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_ENROLL.getBytes());\n  protected static final byte[] BROWSER_DATA_ENROLL_SHA256 =\n      computeSha256(BROWSER_DATA_ENROLL.getBytes());\n  protected static final String BROWSER_DATA_SIGN = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.getAssertion\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_SIGN_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_SIGN_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_SIGN.getBytes());\n  protected static final byte[] BROWSER_DATA_SIGN_SHA256 =\n      parseHex(\"ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc57\");\n  protected static final byte[] REGISTRATION_REQUEST_DATA =\n      parseHex(\"4142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfacb\"\n          + \"f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1c4\");\n  protected static final byte[] REGISTRATION_RESPONSE_DATA =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2\"\n          + \"e3925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772\"\n          + \"d70c253082013c3081e4a003020102020a47901280001155957352300a06082a\"\n          + \"8648ce3d0403023017311530130603550403130c476e756262792050696c6f74\"\n          + \"301e170d3132303831343138323933325a170d3133303831343138323933325a\"\n          + \"3031312f302d0603550403132650696c6f74476e756262792d302e342e312d34\"\n          + \"373930313238303030313135353935373335323059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c\"\n          + \"1446682c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23\"\n          + \"abaf0203b4b8911ba0569994e101300a06082a8648ce3d040302034700304402\"\n          + \"2060cdb6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30d\"\n          + \"fa0220631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b3\"\n          + \"0410df304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80f\"\n          + \"cab017db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5\"\n          + \"ad7804a6d3d3961ef871\");\n  protected static final String REGISTRATION_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA);\n\n  // Has Bluetooth Radio transport\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc\"\n          + \"6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552d\"\n          + \"fdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab6\"\n          + \"1d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019a30820140\"\n          + \"a0030201020209012242000255962657300a06082a8648ce3d0403023045310b30090\"\n          + \"603550406130241553113301106035504080c0a536f6d652d53746174653121301f06\"\n          + \"0355040a0c18496e7465726e6574205769646769747320507479204c74643020170d3\"\n          + \"135303830353136353131325a180f32303633303630373136353131325a3045310b30\"\n          + \"090603550406130241553113301106035504080c0a536f6d652d53746174653121301\"\n          + \"f060355040a0c18496e7465726e6574205769646769747320507479204c7464305930\"\n          + \"1306072a8648ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b\"\n          + \"367eb0b8dcb4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932\"\n          + \"d3167e961eb664c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51\"\n          + \"c020101040403020780300a06082a8648ce3d040302034800304502202106e368bbe2\"\n          + \"fc9f86991826b90a51c694b90fb7c01945e7a9531e4b65315ac5022100aa8e75a071e\"\n          + \"645000376150c7faef1b8a57cb4bd41729c28d9b9bec744ebb4493045022070c1b332\"\n          + \"667853491a525850b15599cc88be0433fc673be89e991b550921c2110221008326311\"\n          + \"e0feaf1698110bed2c0737f3614298a8f265121f896db3cad459607fb\");\n  protected static final String REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6\"\n          + \"b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfd\"\n          + \"b7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1\"\n          + \"6591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019930820140a003\"\n          + \"0201020209012242000255962657300a06082a8648ce3d0403023045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643020170d31353038\"\n          + \"30353136343932345a180f32303633303630373136343932345a3045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643059301306072a86\"\n          + \"48ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb\"\n          + \"4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb6\"\n          + \"64c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51c020101040403\"\n          + \"0204d0300a06082a8648ce3d0403020347003044022058b52f205dc9772e1bef915973\"\n          + \"6098290ffb5850769efd1c37cfc97141279e5f02200c4d91c96c457d1a607a0d16b0b5\"\n          + \"47bbb2e5e2865490112e4b94607b3adcad18304402202548b5204488995f00c905d2b9\"\n          + \"25ca2f9b8c0aba76faf3461dc6778864eb5ee3022005f2d852969864577e01c71cbb10\"\n          + \"93412ef0fef518141d698cda2a45fe2bc767\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS);\n\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6b\"\n          + \"952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfdb7\"\n          + \"477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1659\"\n          + \"1659cbaf00b4950f7abfe6660e2e006f76868b772d70c25308201983082013ea0030201\"\n          + \"020209012242000255962657300a06082a8648ce3d0403023045310b300906035504061\"\n          + \"30241553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18\"\n          + \"496e7465726e6574205769646769747320507479204c74643020170d313530383036323\"\n          + \"3333532385a180f32303633303630383233333532385a3045310b300906035504061302\"\n          + \"41553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18496\"\n          + \"e7465726e6574205769646769747320507479204c74643059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb4a61d1fa336\"\n          + \"bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb664c3080347e5\"\n          + \"05626c1d5d15cfa31530133011060b2b0601040182e51c0201010402aa80300a06082a8\"\n          + \"648ce3d0403020348003045022100907f965f33d857982b39d9f4c22ccb4a63359fc10a\"\n          + \"af08a81997c0e04b73dc9b02204f45d556ae2ea71a5fdfa646b516584dada84954a5d8b\"\n          + \"9d27bdb041e89b216b6304402206b5085168e0c0e850677d3423c0f3972860bd3fbf6d2\"\n          + \"d98cd7af9e1d3f46269402201bde430c86260666bcaa23155296bd0627a8e48d98c2009\"\n          + \"212bec8a7a77f7974\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS);\n\n  protected static final byte[] KEY_HANDLE =\n      parseHex(\"2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a\"\n          + \"6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c25\");\n  protected static final String KEY_HANDLE_BASE64 = Base64.encodeBase64URLSafeString(KEY_HANDLE);\n  protected static final byte[] USER_PUBLIC_KEY_ENROLL_HEX =\n      parseHex(\"04b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b65\"\n          + \"7c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6\"\n          + \"d9\");\n  protected static final String USER_PRIVATE_KEY_ENROLL_HEX =\n      \"9a9684b127c5e3a706d618c86401c7cf6fd827fd0bc18d24b0eb842e36d16df1\";\n  protected static final PublicKey USER_PUBLIC_KEY_ENROLL =\n      parsePublicKey(USER_PUBLIC_KEY_ENROLL_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_ENROLL =\n      parsePrivateKey(USER_PRIVATE_KEY_ENROLL_HEX);\n  protected static final KeyPair USER_KEY_PAIR_ENROLL =\n      new KeyPair(USER_PUBLIC_KEY_ENROLL, USER_PRIVATE_KEY_ENROLL);\n  protected static final String USER_PRIVATE_KEY_SIGN_HEX =\n      \"ffa1e110dde5a2f8d93c4df71e2d4337b7bf5ddb60c75dc2b6b81433b54dd3c0\";\n  protected static final byte[] USER_PUBLIC_KEY_SIGN_HEX =\n      parseHex(\"04d368f1b665bade3c33a20f1e429c7750d5033660c019119d29aa4ba7abc04a\"\n          + \"a7c80a46bbe11ca8cb5674d74f31f8a903f6bad105fb6ab74aefef4db8b0025e\"\n          + \"1d\");\n  protected static final PublicKey USER_PUBLIC_KEY_SIGN = parsePublicKey(USER_PUBLIC_KEY_SIGN_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_SIGN =\n      parsePrivateKey(USER_PRIVATE_KEY_SIGN_HEX);\n  protected static final KeyPair USER_KEY_PAIR_SIGN =\n      new KeyPair(USER_PUBLIC_KEY_SIGN, USER_PRIVATE_KEY_SIGN);\n  protected static final byte[] SIGN_REQUEST_DATA =\n      parseHex(\"03ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc\"\n          + \"574b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992\"\n          + \"ca402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3\"\n          + \"925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d7\"\n          + \"0c25\");\n  protected static final byte[] SIGN_RESPONSE_DATA =\n      parseHex(\"0100000001304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030c\"\n          + \"e43d406de870b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f\"\n          + \"53c7b22272ec10047a923f\");\n  protected static final String SIGN_RESPONSE_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(SIGN_RESPONSE_DATA);\n  protected static final byte[] EXPECTED_REGISTER_SIGNED_BYTES =\n      parseHex(\"00f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1\"\n          + \"c44142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfa\"\n          + \"cb2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e392\"\n          + \"5a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c\"\n          + \"2504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9\");\n  protected static final byte[] EXPECTED_AUTHENTICATE_SIGNED_BYTES =\n      parseHex(\"4b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992ca\"\n          + \"0100000001ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c482\"\n          + \"1b3b9dbc57\");\n  protected static final byte[] SIGNATURE_ENROLL =\n      parseHex(\"304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80fcab017\"\n          + \"db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5ad7804\"\n          + \"a6d3d3961ef871\");\n  protected static final byte[] SIGNATURE_AUTHENTICATE =\n      parseHex(\"304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030ce43d406de8\"\n          + \"70b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f53c7b22272\"\n          + \"ec10047a923f\");\n\n  // Test vectors provided by Discretix\n  protected static final String APP_ID_2 = APP_ID_ENROLL;\n  protected static final String CHALLENGE_2_BASE64 = SERVER_CHALLENGE_ENROLL_BASE64;\n  protected static final String BROWSER_DATA_2_BASE64 = BROWSER_DATA_ENROLL_BASE64;\n\n  protected static final String TRUSTED_CERTIFICATE_2_HEX =\n      \"308201443081eaa0030201020209019189ffffffff5183300a06082a8648ce3d\"\n      + \"040302301b3119301706035504031310476e756262792048534d204341203030\"\n      + \"3022180f32303132303630313030303030305a180f3230363230353331323335\"\n      + \"3935395a30303119301706035504031310476f6f676c6520476e756262792076\"\n      + \"3031133011060355042d030a00019189ffffffff51833059301306072a8648ce\"\n      + \"3d020106082a8648ce3d030107034200041f1302f12173a9cbea83d06d755411\"\n      + \"e582a87fbb5850eddcf3607ec759a4a12c3cb392235e8d5b17caee1b34e5b5eb\"\n      + \"548649696257f0ea8efb90846f88ad5f72300a06082a8648ce3d040302034900\"\n      + \"3046022100b4caea5dc60fbf9f004ed84fc4f18522981c1c303155c08274e889\"\n      + \"f3f10c5b23022100faafb4f10b92f4754e3b08b5af353f78485bc903ece7ea91\"\n      + \"1264fc1673b6598f\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_2 =\n      parseCertificate(TRUSTED_CERTIFICATE_2_HEX);\n\n  // Has Bluetooth Radio transport\n  private static final String TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64 =\n      \"MIIBmjCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY1MTEyWhgPMjA2MzA2MDcxNjUxMTJaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIHgDAKBggqhkjO\"\n      + \"PQQDAgNIADBFAiAhBuNou+L8n4aZGCa5ClHGlLkPt8AZReepUx5LZTFaxQIhAKqO\"\n      + \"daBx5kUAA3YVDH+u8bilfLS9QXKcKNm5vsdE67RJ\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_ONE_TRANSPORT =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  private static final String TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64 =\n      \"MIIBmTCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY0OTI0WhgPMjA2MzA2MDcxNjQ5MjRaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIE0DAKBggqhkjO\"\n      + \"PQQDAgNHADBEAiBYtS8gXcl3LhvvkVlzYJgpD/tYUHae/Rw3z8lxQSeeXwIgDE2R\"\n      + \"yWxFfRpgeg0WsLVHu7Ll4oZUkBEuS5RgezrcrRg=\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64);\n\n  private static final String TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64 =\n      \"MIIBmDCCAT6gAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA2MjMzNTI4WhgPMjA2MzA2MDgyMzM1MjhaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxUwEzARBgsrBgEEAYLlHAIBAQQCqoAwCgYIKoZIzj0E\"\n      + \"AwIDSAAwRQIhAJB/ll8z2FeYKznZ9MIsy0pjNZ/BCq8IqBmXwOBLc9ybAiBPRdVW\"\n      + \"ri6nGl/fpka1FlhNrahJVKXYudJ72wQeibIWtg==\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64);\n\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64 =\n      \"MIIBlzCCAQCgAwIBAgICJxAwDQYJKoZIhvcNAQELBQAwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXlt\"\n      + \"YXN0ZXIwHhcNNzAwMTAxMDAwMDAwWhcNNzAwMTAxMDI0NjQwWjAaMRgwFgYDVQQDDA9BIEtleW1h\"\n      + \"c3RlciBLZXkwOjANBgkqhkiG9w0BAQEFAAMpADAmAiEAvKVptjTyP1p0L8rF/XANRuIc/TOmDiBc\"\n      + \"yb0lMri0YpkCAQOjUDBOMEwGCisGAQQB1nkCAREEPjA8MDihBgIBAgIBA4IBAYMCAQClAwIBAKYD\"\n      + \"AgEBn4FIAQOfg3gBAZ+DeQIBLJ+FPQYBUqVEtxCfhT4BADAAMA0GCSqGSIb3DQEBCwUAA4GBAHwH\"\n      + \"DZvsYbkgWAPv7QRa+cxLrFxrmv7M3HxYL7UdbpXP5/5sOp3hkhBdtAwlUW9tgGLdjheFFcz0lUSP\"\n      + \"uK5et199s1ifeNzV4fePlBAGvzKFci6adJgGDMXDodM49jhIEF1KC4xlbwBWR/brl4vZa4h1EZ9H\"\n      + \"ghyoJ3PFFZC8xYOB\";\n  protected static final X509Certificate ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION =\n      parseCertificateBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64);\n\n  /**\n   * Contains a chain where:\n   *   cert[0] = attestation certificate describing some new key\n   *   cert[1] = batch certificate\n   *\n   * Note that cert[1] is signed by another cert that should be known to RPs.\n   */\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64 =\n      \"MIIBjTCCATKgAwIBAgICJxAwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXltYXN0\"\n      + \"ZXIwIBcNNzAwMTAxMDAwMDAwWhgPMjEwNjAyMDcwNjI4MTVaMBoxGDAWBgNVBAMMD0EgS2V5bWFz\"\n      + \"dGVyIEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJiTI/rSw9N1NYV3FGxgeJSj1NWyyb61\"\n      + \"/gbdEefKuM3dYOeUZhciSigDY/u9Y3gBKm0wmXsd7DxXibDk/VvGIVWjZDBiMGAGCisGAQQB1nkC\"\n      + \"AREEUjBQAgECBAljaGFsbGVuZ2UwPqEIMQYCAQICAQOiAwIBA6MEAgIBAKUFMQMCAQS/g3gDAgEB\"\n      + \"v4N5BAICASy/hT0IAgYBUqi8MmC/hT4DAgEAMAAwCgYIKoZIzj0EAwIDSQAwRgIhANnmsSeWsnVH\"\n      + \"aF5zII50tkiA7fRhIMNeZZBcPvSV2BN5AiEAwUZm63OxMZEHTIFL50ASKVN/sCLs8+gMY6uEVZRy\"\n      + \"61QwggK2MIICH6ADAgECAgIQADANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQGEwJVUzETMBEGA1UE\"\n      + \"CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UECgwMR29vZ2xlLCBJ\"\n      + \"bmMuMRAwDgYDVQQLDAdBbmRyb2lkMB4XDTE2MDEwNDEyNDA1M1oXDTM1MTIzMDEyNDA1M1owdjEL\"\n      + \"MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFTATBgNVBAoMDEdvb2dsZSwgSW5jLjEQ\"\n      + \"MA4GA1UECwwHQW5kcm9pZDEpMCcGA1UEAwwgQW5kcm9pZCBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBL\"\n      + \"ZXkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMCDI9xWiBu4MCBp9bCFYcbuvn8F4vWoQgSK\"\n      + \"votHvnb+rvJc8psq+jIAFBYBQpmJoV/PxoFes2NYPC/S8gvkmDKD3YFLFtfhhUF65Uq8KWo6bbXA\"\n      + \"BAg7aMVWwfAjOZFkGYZNULdNQK7KSEx3NWyJWgwnWr+sSZ1dfSNi8pxeAuhxAgMBAAGjZjBkMB0G\"\n      + \"A1UdDgQWBBTUDBAb+M1jufc5UrUOE1ym15mThjAfBgNVHSMEGDAWgBQp+vGszE3STJZAJ3W2sOky\"\n      + \"5Qf+LjASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIChDANBgkqhkiG9w0BAQsFAAOB\"\n      + \"gQCeLUhfjGcz3BqFrZnXUCPqFOxDsOGd6sIjRh5ytRncYCLkpWgxbAtVxOacoi2fOk+TazGLFngW\"\n      + \"DYjL2YvMgJ2E8MIn42s48f3R5xdyMVk1fZbzxX+rnY+WYSZPsr6Buw1JBCKKzp/39UIuJUT6IQcS\"\n      + \"WoO1Va0YgvhAFJucIGMEfw==\";\n  protected static final X509Certificate[] ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN =\n      parseCertificateChainBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64);\n\n  protected static final byte[] REGISTRATION_DATA_2 =\n      parseHex(\"0504478E16BBDBBB741A660A000314A8B6BD63095196ED704C52EEBC0FA02A61\"\n          + \"8F19FF59DF18451A11CEE43DEFD9A29B5710F63DFC671F752B1B0C6CA76C8427\"\n          + \"AF2D403C2415E1760D1108105720C6069A9039C99D09F76909C36D9EFC350937\"\n          + \"31F85F55AC6D73EA69DE7D9005AE9507B95E149E19676272FC202D949A3AB151\"\n          + \"B96870308201443081EAA0030201020209019189FFFFFFFF5183300A06082A86\"\n          + \"48CE3D040302301B3119301706035504031310476E756262792048534D204341\"\n          + \"2030303022180F32303132303630313030303030305A180F3230363230353331\"\n          + \"3233353935395A30303119301706035504031310476F6F676C6520476E756262\"\n          + \"7920763031133011060355042D030A00019189FFFFFFFF51833059301306072A\"\n          + \"8648CE3D020106082A8648CE3D030107034200041F1302F12173A9CBEA83D06D\"\n          + \"755411E582A87FBB5850EDDCF3607EC759A4A12C3CB392235E8D5B17CAEE1B34\"\n          + \"E5B5EB548649696257F0EA8EFB90846F88AD5F72300A06082A8648CE3D040302\"\n          + \"0349003046022100B4CAEA5DC60FBF9F004ED84FC4F18522981C1C303155C082\"\n          + \"74E889F3F10C5B23022100FAAFB4F10B92F4754E3B08B5AF353F78485BC903EC\"\n          + \"E7EA911264FC1673B6598F3046022100F3BE1BF12CBF0BE7EAB5EA32F3664EDB\"\n          + \"18A24D4999AAC5AA40FF39CF6F34C9ED022100CE72631767367467DFE2AECF6A\"\n          + \"5A4EBA9779FAC65F5CA8A2C325B174EE4769AC\");\n  protected static final String REGISTRATION_DATA_2_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_DATA_2);\n  protected static final byte[] KEY_HANDLE_2 =\n      parseHex(\"3c2415e1760d1108105720c6069a9039c99d09f76909c36d9efc35093731f85f\"\n          + \"55ac6d73ea69de7d9005ae9507b95e149e19676272fc202d949a3ab151b96870\");\n  protected static final String KEY_HANDLE_2_BASE64 =\n      Base64.encodeBase64URLSafeString(KEY_HANDLE_2);\n  protected static final byte[] USER_PUBLIC_KEY_2 =\n      parseHex(\"04478e16bbdbbb741a660a000314a8b6bd63095196ed704c52eebc0fa02a618f\"\n          + \"19ff59df18451a11cee43defd9a29b5710f63dfc671f752b1b0c6ca76c8427af\"\n          + \"2d\");\n  protected static final byte[] SIGN_DATA_2 =\n      parseHex(\"01000000223045022100FB16D12F8EC73D93EAB43BFDF141BF94E31AD3B1C98E\"\n          + \"E4459E9E80CBBBD892F70220796DBCB8BBF57EC95A20A76D9ED3365CB688BF88\"\n          + \"2ECCEABCC8D4A674024F6ABA\");\n  protected static final String SIGN_DATA_2_BASE64 = Base64.encodeBase64URLSafeString(SIGN_DATA_2);\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegisteredKey.java\npublic class RegisteredKey {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /**\n   * websafe-base64 encoding of the key handle obtained from the U2F token\n   * during registration.\n   */\n  private final String keyHandle;\n\n  /**\n   * The transports registered for this key handle.\n   */\n  private final List<Transports> transports;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegisteredKey(String version, String keyHandle, List<Transports> transports,\n      String appId, String sessionId) {\n    super();\n    this.version = version;\n    this.keyHandle = keyHandle;\n    this.transports = transports;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(version, keyHandle, transports, appId, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegisteredKey other = (RegisteredKey) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(keyHandle, other.keyHandle)\n        && SecurityKeyData.containSameTransports(transports, other.transports)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n\n  public JsonObject getJson(String defaultAppId) {\n    JsonObject result = new JsonObject();\n    if (appId != null && !appId.equals(defaultAppId)) {\n      result.addProperty(\"appId\", appId);\n    }\n    result.addProperty(\"version\", version);\n    result.addProperty(\"keyHandle\", keyHandle);\n    result.addProperty(\"sessionId\", sessionId);\n    String transportsString = getTransportsAsString();\n    if (transportsString != null) {\n      result.addProperty(\"transports\", transportsString);\n    }\n    return result;\n  }\n\n  private String getTransportsAsString() {\n    if (this.transports == null) {\n      return null;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < transports.size(); i++) {\n      stringBuilder.append(transports.get(i));\n      if (i < transports.size() - 1) {\n        stringBuilder.append(\",\");\n      }\n    }\n    return stringBuilder.toString();\n  }\n}\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport java.security.cert.X509Certificate;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Matchers;\nimport org.mockito.Mock;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.u2f.TestVectors;\nimport com.google.u2f.U2FException;\nimport com.google.u2f.server.ChallengeGenerator;\nimport com.google.u2f.server.Crypto;\nimport com.google.u2f.server.DataStore;\nimport com.google.u2f.server.SessionIdGenerator;\nimport com.google.u2f.server.U2FServer;\nimport com.google.u2f.server.data.EnrollSessionData;\nimport com.google.u2f.server.data.SecurityKeyData;\nimport com.google.u2f.server.data.SecurityKeyData.Transports;\nimport com.google.u2f.server.data.SignSessionData;\nimport com.google.u2f.server.messages.RegisteredKey;\nimport com.google.u2f.server.messages.RegistrationRequest;\nimport com.google.u2f.server.messages.RegistrationResponse;\nimport com.google.u2f.server.messages.SignResponse;\nimport com.google.u2f.server.messages.U2fSignRequest;\n\n  @Test\n  public void testGetRegistrationRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationRequest registrationRequest = u2fServer.getRegistrationRequest(ACCOUNT_NAME, APP_ID_ENROLL);\n\n    assertEquals(new RegistrationRequest(\"U2F_V2\", SERVER_CHALLENGE_ENROLL_BASE64, APP_ID_ENROLL,\n        SESSION_ID), registrationRequest);\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_noTransports() throws U2FException {\n\t  when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX, VENDOR_CERTIFICATE, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_oneTransport() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_ONE_TRANSPORT);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_ONE_TRANSPORT, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_multipleTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    transports.add(Transports.BLUETOOTH_LOW_ENERGY);\n    transports.add(Transports.NFC);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_malformedTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse2() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(VENDOR_CERTIFICATE);\n    trustedCertificates.add(TRUSTED_CERTIFICATE_2);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_2_BASE64,\n        BROWSER_DATA_2_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE_2, USER_PUBLIC_KEY_2,\n            TRUSTED_CERTIFICATE_2, 0)));\n  }\n\n  @Test\n  public void testGetSignRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n    when(mockChallengeGenerator.generateChallenge(ACCOUNT_NAME)).thenReturn(SERVER_CHALLENGE_SIGN);\nNext line of code:\n", "input": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport java.security.cert.X509Certificate;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Matchers;\nimport org.mockito.Mock;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.u2f.TestVectors;\nimport com.google.u2f.U2FException;\nimport com.google.u2f.server.ChallengeGenerator;\nimport com.google.u2f.server.Crypto;\nimport com.google.u2f.server.DataStore;\nimport com.google.u2f.server.SessionIdGenerator;\nimport com.google.u2f.server.U2FServer;\nimport com.google.u2f.server.data.EnrollSessionData;\nimport com.google.u2f.server.data.SecurityKeyData;\nimport com.google.u2f.server.data.SecurityKeyData.Transports;\nimport com.google.u2f.server.data.SignSessionData;\nimport com.google.u2f.server.messages.RegisteredKey;\nimport com.google.u2f.server.messages.RegistrationRequest;\nimport com.google.u2f.server.messages.RegistrationResponse;\nimport com.google.u2f.server.messages.SignResponse;\nimport com.google.u2f.server.messages.U2fSignRequest;\n\n  @Test\n  public void testGetRegistrationRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationRequest registrationRequest = u2fServer.getRegistrationRequest(ACCOUNT_NAME, APP_ID_ENROLL);\n\n    assertEquals(new RegistrationRequest(\"U2F_V2\", SERVER_CHALLENGE_ENROLL_BASE64, APP_ID_ENROLL,\n        SESSION_ID), registrationRequest);\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_noTransports() throws U2FException {\n\t  when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX, VENDOR_CERTIFICATE, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_oneTransport() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_ONE_TRANSPORT);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_ONE_TRANSPORT, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_multipleTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    transports.add(Transports.BLUETOOTH_LOW_ENERGY);\n    transports.add(Transports.NFC);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_malformedTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse2() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(VENDOR_CERTIFICATE);\n    trustedCertificates.add(TRUSTED_CERTIFICATE_2);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_2_BASE64,\n        BROWSER_DATA_2_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE_2, USER_PUBLIC_KEY_2,\n            TRUSTED_CERTIFICATE_2, 0)));\n  }\n\n  @Test\n  public void testGetSignRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n    when(mockChallengeGenerator.generateChallenge(ACCOUNT_NAME)).thenReturn(SERVER_CHALLENGE_SIGN);\n", "context": "u2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationRequest.java\npublic class RegistrationRequest {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegistrationRequest(String version, String challenge, String appId, String sessionId) {\n    this.version = version;\n    this.challenge = challenge;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(challenge, version, sessionId, appId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationRequest other = (RegistrationRequest) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(challenge, other.challenge)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic enum Transports {\n  BLUETOOTH_BREDR(\"bt\"),\n  BLUETOOTH_LOW_ENERGY(\"ble\"),\n  USB(\"usb\"),\n  NFC(\"nfc\");\n\n  private String mValue;\n\n  Transports(String value) {\n    mValue = value;\n  }\n\n  @Override\n  public String toString() {\n    return mValue;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationResponse.java\npublic class RegistrationResponse {\n  /** websafe-base64(raw registration response message) */\n  private final String registrationData;\n\n  /** websafe-base64(UTF8(stringified(client data))) */\n  private final String clientData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n  public RegistrationResponse(String registrationData, String clientData, String sessionId) {\n    this.registrationData = registrationData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getRegistrationData() {\n    return registrationData;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(registrationData, clientData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationResponse other = (RegistrationResponse) obj;\n    if (clientData == null) {\n      if (other.clientData != null)\n        return false;\n    } else if (!clientData.equals(other.clientData))\n      return false;\n    if (registrationData == null) {\n      if (other.registrationData != null)\n        return false;\n    } else if (!registrationData.equals(other.registrationData))\n      return false;\n    if (sessionId == null) {\n      if (other.sessionId != null)\n        return false;\n    } else if (!sessionId.equals(other.sessionId))\n      return false;\n    return true;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SignSessionData.java\npublic class SignSessionData extends EnrollSessionData {\n  private static final long serialVersionUID = -1374014642398686120L;\n\n  private final byte[] publicKey;\n\n  public SignSessionData(String accountName, String appId, byte[] challenge, byte[] publicKey) {\n    super(accountName, appId, challenge);\n    this.publicKey = publicKey;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/SignResponse.java\npublic class SignResponse {\n\n  /** websafe-base64 key handle from U2F device */\n  private final String keyHandle;\n\n  /** websafe-base64(client data) */\n  private final String clientData;\n\n  /** websafe-base64(raw response from U2F device) */\n  private final String signatureData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n\n  public SignResponse(String keyHandle, String signatureData, String clientData, String sessionId) {\n    this.keyHandle = keyHandle;\n    this.signatureData = signatureData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSignatureData() {\n    return signatureData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(keyHandle, clientData, signatureData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (getClass() != obj.getClass())\n      return false;\n    SignResponse other = (SignResponse) obj;\n    return Objects.equals(keyHandle, other.keyHandle)\n        && Objects.equals(clientData, other.clientData)\n        && Objects.equals(signatureData, other.signatureData)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic class SecurityKeyData {\n  public enum Transports {\n    BLUETOOTH_BREDR(\"bt\"),\n    BLUETOOTH_LOW_ENERGY(\"ble\"),\n    USB(\"usb\"),\n    NFC(\"nfc\");\n\n    private String mValue;\n\n    Transports(String value) {\n      mValue = value;\n    }\n\n    @Override\n    public String toString() {\n      return mValue;\n    }\n  }\n\n  private final long enrollmentTime;\n  private final List<Transports> transports;\n  private final byte[] keyHandle;\n  private final byte[] publicKey;\n  private final X509Certificate attestationCert;\n  private int counter;\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this(enrollmentTime, null /* transports */, keyHandle, publicKey, attestationCert, counter);\n  }\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      List<Transports> transports,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this.enrollmentTime = enrollmentTime;\n    this.transports = transports;\n    this.keyHandle = keyHandle;\n    this.publicKey = publicKey;\n    this.attestationCert = attestationCert;\n    this.counter = counter;\n  }\n\n  /**\n   * When these keys were created/enrolled with the relying party.\n   */\n  public long getEnrollmentTime() {\n    return enrollmentTime;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public byte[] getKeyHandle() {\n    return keyHandle;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n\n  public X509Certificate getAttestationCertificate() {\n    return attestationCert;\n  }\n\n  public int getCounter() {\n    return counter;\n  }\n\n  public void setCounter(int newCounterValue) {\n    counter = newCounterValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        enrollmentTime,\n        transports,\n        keyHandle,\n        publicKey,\n        attestationCert,\n        counter);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof SecurityKeyData)) {\n      return false;\n    }\n    SecurityKeyData that = (SecurityKeyData) obj;\n    return Arrays.equals(this.keyHandle, that.keyHandle)\n        && (this.enrollmentTime == that.enrollmentTime)\n        && containSameTransports(this.transports, that.transports)\n        && Arrays.equals(this.publicKey, that.publicKey)\n        && Objects.equals(this.attestationCert, that.attestationCert)\n        && Objects.equals(counter, counter);\n  }\n\n  /**\n   * Compares the two Lists of Transports and says if they are equal.\n   *\n   * @param transports1 first List of Transports\n   * @param transports2 second List of Transports\n   * @return true if both lists are null or if both lists contain the same transport values\n   */\n  public static boolean containSameTransports(List<Transports> transports1,\n      List<Transports> transports2) {\n    if (transports1 == null && transports2 == null) {\n      return true;\n    } else if (transports1 == null || transports2 == null) {\n      return false;\n    }\n    return transports1.containsAll(transports2) && transports2.containsAll(transports1);\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder()\n      .append(\"public_key: \")\n      .append(Base64.encodeBase64URLSafeString(publicKey))\n      .append(\"\\n\")\n      .append(\"key_handle: \")\n      .append(Base64.encodeBase64URLSafeString(keyHandle))\n      .append(\"\\n\")\n      .append(\"counter: \")\n      .append(counter)\n      .append(\"\\n\")\n      .append(\"attestation certificate:\\n\")\n      .append(attestationCert.toString())\n      .append(\"transports: \")\n      .append(transports)\n      .append(\"\\n\")\n      .toString();\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/U2fSignRequest.java\npublic class U2fSignRequest {\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n  /** List of registered keys */\n  private List<RegisteredKey> registeredKeys;\n\n  public U2fSignRequest(String challenge, List<RegisteredKey> registeredKeys) {\n    this.challenge = challenge;\n    this.registeredKeys = registeredKeys;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public List<RegisteredKey> getRegisteredKeys() {\n    return registeredKeys;\n  }\n\n  public JsonArray getRegisteredKeysAsJson(String defaultAppId) {\n    if (registeredKeys == null) {\n      return null;\n    }\n    JsonArray result = new JsonArray();\n    for (RegisteredKey registeredKey : registeredKeys) {\n      result.add(registeredKey.getJson(defaultAppId));\n    }\n    return result;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/U2FServer.java\npublic interface U2FServer {\n\n  // registration //\n  public RegistrationRequest getRegistrationRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processRegistrationResponse(RegistrationResponse registrationResponse,\n      long currentTimeInMillis) throws U2FException;\n\n  // authentication //\n  public U2fSignRequest getSignRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processSignResponse(SignResponse signResponse) throws U2FException;\n\n  // token management //\n  public List<SecurityKeyData> getAllSecurityKeys(String accountName);\n\n  public void removeSecurityKey(String accountName, byte[] publicKey) throws U2FException;\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/EnrollSessionData.java\npublic class EnrollSessionData implements Serializable {\n  private static final long serialVersionUID = 1750990095756334568L;\n\n  private final String accountName;\n  private final byte[] challenge;\n  private final String appId;\n\n  public EnrollSessionData(String accountName, String appId, byte[] challenge) {\n    this.accountName = accountName;\n    this.challenge = challenge;\n    this.appId = appId;\n  }\n\n  public String getAccountName() {\n    return accountName;\n  }\n\n  public byte[] getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n\treturn appId;\n  }\n}\nu2f-ref-code/java/tests/com/google/u2f/TestVectors.java\npublic class TestVectors {\n  // Test vectors from FIDO U2F: Raw Message Formats - Draft 4\n  protected static final int COUNTER_VALUE = 1;\n  protected static final String ACCOUNT_NAME = \"test@example.com\";\n  protected static final Set<String> TRUSTED_DOMAINS = ImmutableSet.of(\"http://example.com\");\n  protected static final String SESSION_ID = \"session_id\";\n  protected static final String APP_ID_ENROLL = \"http://example.com\";\n  protected static final byte[] APP_ID_ENROLL_SHA256 = computeSha256(APP_ID_ENROLL);\n  protected static final String APP_ID_SIGN = \"https://gstatic.com/securitykey/a/example.com\";\n  protected static final byte[] APP_ID_SIGN_SHA256 = computeSha256(APP_ID_SIGN);\n  protected static final String ORIGIN = \"http://example.com\";\n  protected static final String SERVER_CHALLENGE_ENROLL_BASE64 =\n      \"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\";\n  protected static final byte[] SERVER_CHALLENGE_ENROLL =\n      Base64.decodeBase64(SERVER_CHALLENGE_ENROLL_BASE64);\n  protected static final String SERVER_CHALLENGE_SIGN_BASE64 =\n      \"opsXqUifDriAAmWclinfbS0e-USY0CgyJHe_Otd7z8o\";\n  protected static final byte[] SERVER_CHALLENGE_SIGN =\n      Base64.decodeBase64(SERVER_CHALLENGE_SIGN_BASE64);\n  protected static final String VENDOR_CERTIFICATE_HEX =\n      \"3082013c3081e4a003020102020a47901280001155957352300a06082a8648ce\"\n      + \"3d0403023017311530130603550403130c476e756262792050696c6f74301e17\"\n      + \"0d3132303831343138323933325a170d3133303831343138323933325a303131\"\n      + \"2f302d0603550403132650696c6f74476e756262792d302e342e312d34373930\"\n      + \"313238303030313135353935373335323059301306072a8648ce3d020106082a\"\n      + \"8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c144668\"\n      + \"2c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23abaf02\"\n      + \"03b4b8911ba0569994e101300a06082a8648ce3d0403020347003044022060cd\"\n      + \"b6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30dfa0220\"\n      + \"631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b30410df\";\n  protected static final X509Certificate VENDOR_CERTIFICATE =\n      parseCertificate(VENDOR_CERTIFICATE_HEX);\n  protected static final PrivateKey VENDOR_CERTIFICATE_PRIVATE_KEY =\n      parsePrivateKey(\"f3fccc0d00d8031954f90864d43c247f4bf5f0665c6b50cc17749a27d1cf7664\");\n  protected static final String CHANNEL_ID_STRING =\n      \"{\"\n      + \"\\\"kty\\\":\\\"EC\\\",\"\n      + \"\\\"crv\\\":\\\"P-256\\\",\"\n      + \"\\\"x\\\":\\\"HzQwlfXX7Q4S5MtCCnZUNBw3RMzPO9tOyWjBqRl4tJ8\\\",\"\n      + \"\\\"y\\\":\\\"XVguGFLIZx1fXg3wNqfdbn75hi4-_7-BxhMljw42Ht4\\\"\"\n      + \"}\";\n  protected static final JsonObject CHANNEL_ID_JSON =\n      (JsonObject) new JsonParser().parse(CHANNEL_ID_STRING);\n  protected static final String BROWSER_DATA_ENROLL = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_ENROLL_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_ENROLL_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_ENROLL.getBytes());\n  protected static final byte[] BROWSER_DATA_ENROLL_SHA256 =\n      computeSha256(BROWSER_DATA_ENROLL.getBytes());\n  protected static final String BROWSER_DATA_SIGN = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.getAssertion\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_SIGN_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_SIGN_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_SIGN.getBytes());\n  protected static final byte[] BROWSER_DATA_SIGN_SHA256 =\n      parseHex(\"ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc57\");\n  protected static final byte[] REGISTRATION_REQUEST_DATA =\n      parseHex(\"4142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfacb\"\n          + \"f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1c4\");\n  protected static final byte[] REGISTRATION_RESPONSE_DATA =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2\"\n          + \"e3925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772\"\n          + \"d70c253082013c3081e4a003020102020a47901280001155957352300a06082a\"\n          + \"8648ce3d0403023017311530130603550403130c476e756262792050696c6f74\"\n          + \"301e170d3132303831343138323933325a170d3133303831343138323933325a\"\n          + \"3031312f302d0603550403132650696c6f74476e756262792d302e342e312d34\"\n          + \"373930313238303030313135353935373335323059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c\"\n          + \"1446682c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23\"\n          + \"abaf0203b4b8911ba0569994e101300a06082a8648ce3d040302034700304402\"\n          + \"2060cdb6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30d\"\n          + \"fa0220631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b3\"\n          + \"0410df304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80f\"\n          + \"cab017db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5\"\n          + \"ad7804a6d3d3961ef871\");\n  protected static final String REGISTRATION_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA);\n\n  // Has Bluetooth Radio transport\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc\"\n          + \"6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552d\"\n          + \"fdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab6\"\n          + \"1d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019a30820140\"\n          + \"a0030201020209012242000255962657300a06082a8648ce3d0403023045310b30090\"\n          + \"603550406130241553113301106035504080c0a536f6d652d53746174653121301f06\"\n          + \"0355040a0c18496e7465726e6574205769646769747320507479204c74643020170d3\"\n          + \"135303830353136353131325a180f32303633303630373136353131325a3045310b30\"\n          + \"090603550406130241553113301106035504080c0a536f6d652d53746174653121301\"\n          + \"f060355040a0c18496e7465726e6574205769646769747320507479204c7464305930\"\n          + \"1306072a8648ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b\"\n          + \"367eb0b8dcb4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932\"\n          + \"d3167e961eb664c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51\"\n          + \"c020101040403020780300a06082a8648ce3d040302034800304502202106e368bbe2\"\n          + \"fc9f86991826b90a51c694b90fb7c01945e7a9531e4b65315ac5022100aa8e75a071e\"\n          + \"645000376150c7faef1b8a57cb4bd41729c28d9b9bec744ebb4493045022070c1b332\"\n          + \"667853491a525850b15599cc88be0433fc673be89e991b550921c2110221008326311\"\n          + \"e0feaf1698110bed2c0737f3614298a8f265121f896db3cad459607fb\");\n  protected static final String REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6\"\n          + \"b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfd\"\n          + \"b7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1\"\n          + \"6591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019930820140a003\"\n          + \"0201020209012242000255962657300a06082a8648ce3d0403023045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643020170d31353038\"\n          + \"30353136343932345a180f32303633303630373136343932345a3045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643059301306072a86\"\n          + \"48ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb\"\n          + \"4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb6\"\n          + \"64c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51c020101040403\"\n          + \"0204d0300a06082a8648ce3d0403020347003044022058b52f205dc9772e1bef915973\"\n          + \"6098290ffb5850769efd1c37cfc97141279e5f02200c4d91c96c457d1a607a0d16b0b5\"\n          + \"47bbb2e5e2865490112e4b94607b3adcad18304402202548b5204488995f00c905d2b9\"\n          + \"25ca2f9b8c0aba76faf3461dc6778864eb5ee3022005f2d852969864577e01c71cbb10\"\n          + \"93412ef0fef518141d698cda2a45fe2bc767\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS);\n\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6b\"\n          + \"952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfdb7\"\n          + \"477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1659\"\n          + \"1659cbaf00b4950f7abfe6660e2e006f76868b772d70c25308201983082013ea0030201\"\n          + \"020209012242000255962657300a06082a8648ce3d0403023045310b300906035504061\"\n          + \"30241553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18\"\n          + \"496e7465726e6574205769646769747320507479204c74643020170d313530383036323\"\n          + \"3333532385a180f32303633303630383233333532385a3045310b300906035504061302\"\n          + \"41553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18496\"\n          + \"e7465726e6574205769646769747320507479204c74643059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb4a61d1fa336\"\n          + \"bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb664c3080347e5\"\n          + \"05626c1d5d15cfa31530133011060b2b0601040182e51c0201010402aa80300a06082a8\"\n          + \"648ce3d0403020348003045022100907f965f33d857982b39d9f4c22ccb4a63359fc10a\"\n          + \"af08a81997c0e04b73dc9b02204f45d556ae2ea71a5fdfa646b516584dada84954a5d8b\"\n          + \"9d27bdb041e89b216b6304402206b5085168e0c0e850677d3423c0f3972860bd3fbf6d2\"\n          + \"d98cd7af9e1d3f46269402201bde430c86260666bcaa23155296bd0627a8e48d98c2009\"\n          + \"212bec8a7a77f7974\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS);\n\n  protected static final byte[] KEY_HANDLE =\n      parseHex(\"2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a\"\n          + \"6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c25\");\n  protected static final String KEY_HANDLE_BASE64 = Base64.encodeBase64URLSafeString(KEY_HANDLE);\n  protected static final byte[] USER_PUBLIC_KEY_ENROLL_HEX =\n      parseHex(\"04b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b65\"\n          + \"7c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6\"\n          + \"d9\");\n  protected static final String USER_PRIVATE_KEY_ENROLL_HEX =\n      \"9a9684b127c5e3a706d618c86401c7cf6fd827fd0bc18d24b0eb842e36d16df1\";\n  protected static final PublicKey USER_PUBLIC_KEY_ENROLL =\n      parsePublicKey(USER_PUBLIC_KEY_ENROLL_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_ENROLL =\n      parsePrivateKey(USER_PRIVATE_KEY_ENROLL_HEX);\n  protected static final KeyPair USER_KEY_PAIR_ENROLL =\n      new KeyPair(USER_PUBLIC_KEY_ENROLL, USER_PRIVATE_KEY_ENROLL);\n  protected static final String USER_PRIVATE_KEY_SIGN_HEX =\n      \"ffa1e110dde5a2f8d93c4df71e2d4337b7bf5ddb60c75dc2b6b81433b54dd3c0\";\n  protected static final byte[] USER_PUBLIC_KEY_SIGN_HEX =\n      parseHex(\"04d368f1b665bade3c33a20f1e429c7750d5033660c019119d29aa4ba7abc04a\"\n          + \"a7c80a46bbe11ca8cb5674d74f31f8a903f6bad105fb6ab74aefef4db8b0025e\"\n          + \"1d\");\n  protected static final PublicKey USER_PUBLIC_KEY_SIGN = parsePublicKey(USER_PUBLIC_KEY_SIGN_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_SIGN =\n      parsePrivateKey(USER_PRIVATE_KEY_SIGN_HEX);\n  protected static final KeyPair USER_KEY_PAIR_SIGN =\n      new KeyPair(USER_PUBLIC_KEY_SIGN, USER_PRIVATE_KEY_SIGN);\n  protected static final byte[] SIGN_REQUEST_DATA =\n      parseHex(\"03ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc\"\n          + \"574b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992\"\n          + \"ca402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3\"\n          + \"925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d7\"\n          + \"0c25\");\n  protected static final byte[] SIGN_RESPONSE_DATA =\n      parseHex(\"0100000001304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030c\"\n          + \"e43d406de870b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f\"\n          + \"53c7b22272ec10047a923f\");\n  protected static final String SIGN_RESPONSE_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(SIGN_RESPONSE_DATA);\n  protected static final byte[] EXPECTED_REGISTER_SIGNED_BYTES =\n      parseHex(\"00f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1\"\n          + \"c44142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfa\"\n          + \"cb2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e392\"\n          + \"5a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c\"\n          + \"2504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9\");\n  protected static final byte[] EXPECTED_AUTHENTICATE_SIGNED_BYTES =\n      parseHex(\"4b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992ca\"\n          + \"0100000001ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c482\"\n          + \"1b3b9dbc57\");\n  protected static final byte[] SIGNATURE_ENROLL =\n      parseHex(\"304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80fcab017\"\n          + \"db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5ad7804\"\n          + \"a6d3d3961ef871\");\n  protected static final byte[] SIGNATURE_AUTHENTICATE =\n      parseHex(\"304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030ce43d406de8\"\n          + \"70b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f53c7b22272\"\n          + \"ec10047a923f\");\n\n  // Test vectors provided by Discretix\n  protected static final String APP_ID_2 = APP_ID_ENROLL;\n  protected static final String CHALLENGE_2_BASE64 = SERVER_CHALLENGE_ENROLL_BASE64;\n  protected static final String BROWSER_DATA_2_BASE64 = BROWSER_DATA_ENROLL_BASE64;\n\n  protected static final String TRUSTED_CERTIFICATE_2_HEX =\n      \"308201443081eaa0030201020209019189ffffffff5183300a06082a8648ce3d\"\n      + \"040302301b3119301706035504031310476e756262792048534d204341203030\"\n      + \"3022180f32303132303630313030303030305a180f3230363230353331323335\"\n      + \"3935395a30303119301706035504031310476f6f676c6520476e756262792076\"\n      + \"3031133011060355042d030a00019189ffffffff51833059301306072a8648ce\"\n      + \"3d020106082a8648ce3d030107034200041f1302f12173a9cbea83d06d755411\"\n      + \"e582a87fbb5850eddcf3607ec759a4a12c3cb392235e8d5b17caee1b34e5b5eb\"\n      + \"548649696257f0ea8efb90846f88ad5f72300a06082a8648ce3d040302034900\"\n      + \"3046022100b4caea5dc60fbf9f004ed84fc4f18522981c1c303155c08274e889\"\n      + \"f3f10c5b23022100faafb4f10b92f4754e3b08b5af353f78485bc903ece7ea91\"\n      + \"1264fc1673b6598f\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_2 =\n      parseCertificate(TRUSTED_CERTIFICATE_2_HEX);\n\n  // Has Bluetooth Radio transport\n  private static final String TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64 =\n      \"MIIBmjCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY1MTEyWhgPMjA2MzA2MDcxNjUxMTJaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIHgDAKBggqhkjO\"\n      + \"PQQDAgNIADBFAiAhBuNou+L8n4aZGCa5ClHGlLkPt8AZReepUx5LZTFaxQIhAKqO\"\n      + \"daBx5kUAA3YVDH+u8bilfLS9QXKcKNm5vsdE67RJ\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_ONE_TRANSPORT =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  private static final String TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64 =\n      \"MIIBmTCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY0OTI0WhgPMjA2MzA2MDcxNjQ5MjRaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIE0DAKBggqhkjO\"\n      + \"PQQDAgNHADBEAiBYtS8gXcl3LhvvkVlzYJgpD/tYUHae/Rw3z8lxQSeeXwIgDE2R\"\n      + \"yWxFfRpgeg0WsLVHu7Ll4oZUkBEuS5RgezrcrRg=\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64);\n\n  private static final String TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64 =\n      \"MIIBmDCCAT6gAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA2MjMzNTI4WhgPMjA2MzA2MDgyMzM1MjhaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxUwEzARBgsrBgEEAYLlHAIBAQQCqoAwCgYIKoZIzj0E\"\n      + \"AwIDSAAwRQIhAJB/ll8z2FeYKznZ9MIsy0pjNZ/BCq8IqBmXwOBLc9ybAiBPRdVW\"\n      + \"ri6nGl/fpka1FlhNrahJVKXYudJ72wQeibIWtg==\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64);\n\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64 =\n      \"MIIBlzCCAQCgAwIBAgICJxAwDQYJKoZIhvcNAQELBQAwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXlt\"\n      + \"YXN0ZXIwHhcNNzAwMTAxMDAwMDAwWhcNNzAwMTAxMDI0NjQwWjAaMRgwFgYDVQQDDA9BIEtleW1h\"\n      + \"c3RlciBLZXkwOjANBgkqhkiG9w0BAQEFAAMpADAmAiEAvKVptjTyP1p0L8rF/XANRuIc/TOmDiBc\"\n      + \"yb0lMri0YpkCAQOjUDBOMEwGCisGAQQB1nkCAREEPjA8MDihBgIBAgIBA4IBAYMCAQClAwIBAKYD\"\n      + \"AgEBn4FIAQOfg3gBAZ+DeQIBLJ+FPQYBUqVEtxCfhT4BADAAMA0GCSqGSIb3DQEBCwUAA4GBAHwH\"\n      + \"DZvsYbkgWAPv7QRa+cxLrFxrmv7M3HxYL7UdbpXP5/5sOp3hkhBdtAwlUW9tgGLdjheFFcz0lUSP\"\n      + \"uK5et199s1ifeNzV4fePlBAGvzKFci6adJgGDMXDodM49jhIEF1KC4xlbwBWR/brl4vZa4h1EZ9H\"\n      + \"ghyoJ3PFFZC8xYOB\";\n  protected static final X509Certificate ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION =\n      parseCertificateBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64);\n\n  /**\n   * Contains a chain where:\n   *   cert[0] = attestation certificate describing some new key\n   *   cert[1] = batch certificate\n   *\n   * Note that cert[1] is signed by another cert that should be known to RPs.\n   */\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64 =\n      \"MIIBjTCCATKgAwIBAgICJxAwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXltYXN0\"\n      + \"ZXIwIBcNNzAwMTAxMDAwMDAwWhgPMjEwNjAyMDcwNjI4MTVaMBoxGDAWBgNVBAMMD0EgS2V5bWFz\"\n      + \"dGVyIEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJiTI/rSw9N1NYV3FGxgeJSj1NWyyb61\"\n      + \"/gbdEefKuM3dYOeUZhciSigDY/u9Y3gBKm0wmXsd7DxXibDk/VvGIVWjZDBiMGAGCisGAQQB1nkC\"\n      + \"AREEUjBQAgECBAljaGFsbGVuZ2UwPqEIMQYCAQICAQOiAwIBA6MEAgIBAKUFMQMCAQS/g3gDAgEB\"\n      + \"v4N5BAICASy/hT0IAgYBUqi8MmC/hT4DAgEAMAAwCgYIKoZIzj0EAwIDSQAwRgIhANnmsSeWsnVH\"\n      + \"aF5zII50tkiA7fRhIMNeZZBcPvSV2BN5AiEAwUZm63OxMZEHTIFL50ASKVN/sCLs8+gMY6uEVZRy\"\n      + \"61QwggK2MIICH6ADAgECAgIQADANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQGEwJVUzETMBEGA1UE\"\n      + \"CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UECgwMR29vZ2xlLCBJ\"\n      + \"bmMuMRAwDgYDVQQLDAdBbmRyb2lkMB4XDTE2MDEwNDEyNDA1M1oXDTM1MTIzMDEyNDA1M1owdjEL\"\n      + \"MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFTATBgNVBAoMDEdvb2dsZSwgSW5jLjEQ\"\n      + \"MA4GA1UECwwHQW5kcm9pZDEpMCcGA1UEAwwgQW5kcm9pZCBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBL\"\n      + \"ZXkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMCDI9xWiBu4MCBp9bCFYcbuvn8F4vWoQgSK\"\n      + \"votHvnb+rvJc8psq+jIAFBYBQpmJoV/PxoFes2NYPC/S8gvkmDKD3YFLFtfhhUF65Uq8KWo6bbXA\"\n      + \"BAg7aMVWwfAjOZFkGYZNULdNQK7KSEx3NWyJWgwnWr+sSZ1dfSNi8pxeAuhxAgMBAAGjZjBkMB0G\"\n      + \"A1UdDgQWBBTUDBAb+M1jufc5UrUOE1ym15mThjAfBgNVHSMEGDAWgBQp+vGszE3STJZAJ3W2sOky\"\n      + \"5Qf+LjASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIChDANBgkqhkiG9w0BAQsFAAOB\"\n      + \"gQCeLUhfjGcz3BqFrZnXUCPqFOxDsOGd6sIjRh5ytRncYCLkpWgxbAtVxOacoi2fOk+TazGLFngW\"\n      + \"DYjL2YvMgJ2E8MIn42s48f3R5xdyMVk1fZbzxX+rnY+WYSZPsr6Buw1JBCKKzp/39UIuJUT6IQcS\"\n      + \"WoO1Va0YgvhAFJucIGMEfw==\";\n  protected static final X509Certificate[] ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN =\n      parseCertificateChainBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64);\n\n  protected static final byte[] REGISTRATION_DATA_2 =\n      parseHex(\"0504478E16BBDBBB741A660A000314A8B6BD63095196ED704C52EEBC0FA02A61\"\n          + \"8F19FF59DF18451A11CEE43DEFD9A29B5710F63DFC671F752B1B0C6CA76C8427\"\n          + \"AF2D403C2415E1760D1108105720C6069A9039C99D09F76909C36D9EFC350937\"\n          + \"31F85F55AC6D73EA69DE7D9005AE9507B95E149E19676272FC202D949A3AB151\"\n          + \"B96870308201443081EAA0030201020209019189FFFFFFFF5183300A06082A86\"\n          + \"48CE3D040302301B3119301706035504031310476E756262792048534D204341\"\n          + \"2030303022180F32303132303630313030303030305A180F3230363230353331\"\n          + \"3233353935395A30303119301706035504031310476F6F676C6520476E756262\"\n          + \"7920763031133011060355042D030A00019189FFFFFFFF51833059301306072A\"\n          + \"8648CE3D020106082A8648CE3D030107034200041F1302F12173A9CBEA83D06D\"\n          + \"755411E582A87FBB5850EDDCF3607EC759A4A12C3CB392235E8D5B17CAEE1B34\"\n          + \"E5B5EB548649696257F0EA8EFB90846F88AD5F72300A06082A8648CE3D040302\"\n          + \"0349003046022100B4CAEA5DC60FBF9F004ED84FC4F18522981C1C303155C082\"\n          + \"74E889F3F10C5B23022100FAAFB4F10B92F4754E3B08B5AF353F78485BC903EC\"\n          + \"E7EA911264FC1673B6598F3046022100F3BE1BF12CBF0BE7EAB5EA32F3664EDB\"\n          + \"18A24D4999AAC5AA40FF39CF6F34C9ED022100CE72631767367467DFE2AECF6A\"\n          + \"5A4EBA9779FAC65F5CA8A2C325B174EE4769AC\");\n  protected static final String REGISTRATION_DATA_2_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_DATA_2);\n  protected static final byte[] KEY_HANDLE_2 =\n      parseHex(\"3c2415e1760d1108105720c6069a9039c99d09f76909c36d9efc35093731f85f\"\n          + \"55ac6d73ea69de7d9005ae9507b95e149e19676272fc202d949a3ab151b96870\");\n  protected static final String KEY_HANDLE_2_BASE64 =\n      Base64.encodeBase64URLSafeString(KEY_HANDLE_2);\n  protected static final byte[] USER_PUBLIC_KEY_2 =\n      parseHex(\"04478e16bbdbbb741a660a000314a8b6bd63095196ed704c52eebc0fa02a618f\"\n          + \"19ff59df18451a11cee43defd9a29b5710f63dfc671f752b1b0c6ca76c8427af\"\n          + \"2d\");\n  protected static final byte[] SIGN_DATA_2 =\n      parseHex(\"01000000223045022100FB16D12F8EC73D93EAB43BFDF141BF94E31AD3B1C98E\"\n          + \"E4459E9E80CBBBD892F70220796DBCB8BBF57EC95A20A76D9ED3365CB688BF88\"\n          + \"2ECCEABCC8D4A674024F6ABA\");\n  protected static final String SIGN_DATA_2_BASE64 = Base64.encodeBase64URLSafeString(SIGN_DATA_2);\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegisteredKey.java\npublic class RegisteredKey {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /**\n   * websafe-base64 encoding of the key handle obtained from the U2F token\n   * during registration.\n   */\n  private final String keyHandle;\n\n  /**\n   * The transports registered for this key handle.\n   */\n  private final List<Transports> transports;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegisteredKey(String version, String keyHandle, List<Transports> transports,\n      String appId, String sessionId) {\n    super();\n    this.version = version;\n    this.keyHandle = keyHandle;\n    this.transports = transports;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(version, keyHandle, transports, appId, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegisteredKey other = (RegisteredKey) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(keyHandle, other.keyHandle)\n        && SecurityKeyData.containSameTransports(transports, other.transports)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n\n  public JsonObject getJson(String defaultAppId) {\n    JsonObject result = new JsonObject();\n    if (appId != null && !appId.equals(defaultAppId)) {\n      result.addProperty(\"appId\", appId);\n    }\n    result.addProperty(\"version\", version);\n    result.addProperty(\"keyHandle\", keyHandle);\n    result.addProperty(\"sessionId\", sessionId);\n    String transportsString = getTransportsAsString();\n    if (transportsString != null) {\n      result.addProperty(\"transports\", transportsString);\n    }\n    return result;\n  }\n\n  private String getTransportsAsString() {\n    if (this.transports == null) {\n      return null;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < transports.size(); i++) {\n      stringBuilder.append(transports.get(i));\n      if (i < transports.size() - 1) {\n        stringBuilder.append(\",\");\n      }\n    }\n    return stringBuilder.toString();\n  }\n}\n", "answers": ["    U2fSignRequest signRequest = u2fServer.getSignRequest(ACCOUNT_NAME, APP_ID_SIGN);"], "pred": "                                                                ", "length": 2959, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "d60990d706853cd274c7ff6b8b766fcccca25dc8de5ae49c"}
{"prompt": "Please complete the code given below. \nsippy/Rtp_proxy_session.py\nclass Rtp_proxy_session(object):\n    rtp_proxy_client = None\n    call_id = None\n    from_tag = None\n    to_tag = None\n    caller_session_exists = False\n    caller_codecs = None\n    caller_raddress = None\n    callee_session_exists = False\n    callee_codecs = None\n    callee_raddress = None\n    max_index = -1\n    origin = None\n    notify_socket = None\n    notify_tag = None\n    global_config = None\n\n    def __init__(self, global_config, call_id = None, from_tag = None, to_tag = None,\n      notify_socket = None, notify_tag = None):\n        self.global_config = global_config\n        if global_config.has_key('_rtp_proxy_clients'):\n            rtp_proxy_clients = [x for x in global_config['_rtp_proxy_clients'] if x.online]\n            n = len(rtp_proxy_clients)\n            if n == 0:\n                raise Exception('No online RTP proxy client has been found')\n            self.rtp_proxy_client = rtp_proxy_clients[int(random() * n)]\n        else:\n            self.rtp_proxy_client = global_config['rtp_proxy_client']\n            if not self.rtp_proxy_client.online:\n                raise Exception('No online RTP proxy client has been found')\n        if call_id != None:\n            self.call_id = call_id\n        else:\n            self.call_id = md5(str(random()) + str(time())).hexdigest()\n        if from_tag != None:\n            self.from_tag = from_tag\n        else:\n            self.from_tag = md5(str(random()) + str(time())).hexdigest()\n        if to_tag != None:\n            self.to_tag = to_tag\n        else:\n            self.to_tag = md5(str(random()) + str(time())).hexdigest()\n        self.origin = SdpOrigin()\n        self.notify_socket = notify_socket\n        self.notify_tag = notify_tag\n\n    def version(self, result_callback):\n        self.rtp_proxy_client.send_command('V', self.version_result, result_callback)\n\n    def version_result(self, result, result_callback):\n        result_callback(result)\n\n    def play_caller(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._play_caller, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_caller(None, prompt_name, times, result_callback, index)\n\n    def _play_caller(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.caller_codecs, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def play_callee(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            return\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._play_callee, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_callee(None, prompt_name, times, result_callback, index)\n\n    def _play_callee(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.callee_codecs, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_caller(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_callee(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_caller(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._copy_caller, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_caller(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_caller(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_callee(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._copy_callee, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_callee(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_callee(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def start_recording(self, rname = None, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._start_recording, '', index, rname, result_callback, index)\n            return\n        self._start_recording(None, rname, result_callback, index)\n\n    def _start_recording(self, result, rname, result_callback, index):\n        if rname == None:\n            command = 'R %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n            return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n        command = 'C %s %s.a %s %s' % ('%s-%d' % (self.call_id, index), rname, self.from_tag, self.to_tag)\n        return self.rtp_proxy_client.send_command(command, self._start_recording1, \\\n          (rname, result_callback, index))\n\n    def _start_recording1(self, result, args):\n        rname, result_callback, index = args\n        command = 'C %s %s.o %s %s' % ('%s-%d' % (self.call_id, index), rname, self.to_tag, self.from_tag)\n        return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def command_result(self, result, result_callback):\n        if result_callback != None:\n            result_callback(result)\n\n    def update_caller(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.caller_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.caller_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.caller_raddress[0]\n        command += options\n        command += ' %s %s %d %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag)\n        if self.caller_session_exists:\n            command += ' %s' % self.to_tag\n        if self.notify_socket != None and index == 0 and \\\n          self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'caller', callback_parameters))\n\n    def update_callee(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.callee_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.callee_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.callee_raddress[0]\n        command += options\n        command += ' %s %s %d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        if self.notify_socket != None and index == 0 \\\n          and self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'callee', callback_parameters))\n\n    def update_result(self, result, args):\n        result_callback, face, callback_parameters = args\n        if face == 'caller':\n            self.caller_session_exists = True\n        else:\n            self.callee_session_exists = True\n        if result == None:\n            result_callback(None, *callback_parameters)\n            return\n        t1 = result.split()\n        rtpproxy_port = int(t1[0])\n        if rtpproxy_port == 0:\n            result_callback(None, *callback_parameters)\n        family = 'IP4'\n        if len(t1) > 1:\n            rtpproxy_address = t1[1]\n            if len(t1) > 2 and t1[2] == '6':\n                family = 'IP6'\n        else:\n            rtpproxy_address = self.rtp_proxy_client.proxy_address\n        result_callback((rtpproxy_address, rtpproxy_port, family), *callback_parameters)\n\n    def delete(self):\n        while self.max_index >= 0:\n            command = 'D %s %s %s' % ('%s-%d' % (self.call_id, self.max_index), self.from_tag, self.to_tag)\n            self.rtp_proxy_client.send_command(command)\n            self.max_index -= 1\n\n    def on_caller_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_caller, sdp_body, result_callback)\n\n    def on_callee_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_callee, sdp_body, result_callback)\n\n    def on_xxx_sdp_change(self, update_xxx, sdp_body, result_callback):\n        sects = []\n        try:\n            sdp_body.parse()\n        except Exception, exception:\n            print datetime.now(), 'can\\'t parse SDP body: %s:' % str(exception)\n            print '-' * 70\n            print_exc(file = sys.stdout)\n            print '-' * 70\n            print sdp_body.content\n            print '-' * 70\n            sys.stdout.flush()\n            return\n        for i in range(0, len(sdp_body.content.sections)):\n            sect = sdp_body.content.sections[i]\n            if sect.m_header.transport.lower() not in ('udp', 'udptl', 'rtp/avp'):\n                continue\n            sects.append(sect)\n        if len(sects) == 0:\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n            return\n        formats = sects[0].m_header.formats\n        if update_xxx == self.update_caller:\n            if len(formats) > 1:\n                self.caller_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.caller_codecs = str(formats[0])\n        else:\n            if len(formats) > 1:\n                self.callee_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.callee_codecs = str(formats[0])\n        for sect in sects:\n            options = ''\n            if sect.c_header.atype == 'IP6':\n                options = '6'\n            update_xxx(sect.c_header.addr, sect.m_header.port, self.xxx_sdp_change_finish, options, \\\n              sects.index(sect), sdp_body, sect, sects, result_callback)\n        return\n\n    def xxx_sdp_change_finish(self, address_port, sdp_body, sect, sects, result_callback):\n        sect.needs_update = False\n        if address_port != None:\n            sect.c_header.atype = address_port[2]\n            sect.c_header.addr = address_port[0]\n            if sect.m_header.port != 0:\n                sect.m_header.port = address_port[1]\n        if len([x for x in sects if x.needs_update]) == 0:\n            sdp_body.content.o_header = self.origin\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n\n    def __del__(self):\n        self.delete()\n        self.rtp_proxy_client = None\nsippy/Signal.py\nclass Signal(object):\n    callback = None\n    parameters = None\n    previous_handler = None\n\n    def __init__(self, signum, callback, *parameters):\n        self.callback = callback\n        self.parameters = parameters\n        self.previous_handler = signal(signum, self.signal_handler)\n\n    def signal_handler(self, signum, *frame):\n        try:\n            reactor.callFromThread(self.callback, *self.parameters)\n        except:\n            print datetime.now(), 'Signal: unhandled exception in signal callback'\n            print '-' * 70\n            print_exc(file = stdout)\n            print '-' * 70\n            stdout.flush()\n        if self.previous_handler not in (SIG_IGN, SIG_DFL):\n            try:\n                self.previous_handler(signum, *frame)\n            except:\n                print datetime.now(), 'Signal: unhandled exception in signal chain'\n                print '-' * 70\n                print_exc(file = stdout)\n                print '-' * 70\n                stdout.flush()\nsippy/SipCiscoGUID.py\nclass SipCiscoGUID(SipGenericHF):\n    hf_names = ('cisco-guid', 'h323-conf-id')\n    ciscoGUID = None\n\n    def __init__(self, body = None, ciscoGUID = None):\n        SipGenericHF.__init__(self, body)\n        if body != None:\n            return\n        self.parsed = True\n        if ciscoGUID != None:\n            self.ciscoGUID = ciscoGUID\n        else:\n            s = md5(str((random() * 1000000000L) + time())).hexdigest()\n            self.ciscoGUID = (long(s[0:8], 16), long(s[8:16], 16), long(s[16:24], 16), long(s[24:32], 16))\n\n    def parse(self):\n        self.parsed = True\n        self.ciscoGUID = tuple([int(x) for x in  self.body.split('-', 3)])\n\n    def __str__(self):\n        if not self.parsed:\n            return self.body\n        return '%d-%d-%d-%d' % self.ciscoGUID\n\n    def getCiscoGUID(self):\n        return self.ciscoGUID\n\n    def hexForm(self):\n        return '%.8X %.8X %.8X %.8X' % self.ciscoGUID\n\n    def getCanName(self, name, compact = False):\n        if name.lower() == 'h323-conf-id':\n            return 'h323-conf-id'\n        else:\n            return 'cisco-GUID'\n\n    def getCopy(self):\n        if not self.parsed:\n            return SipCiscoGUID(self.body)\n        return SipCiscoGUID(ciscoGUID = self.ciscoGUID)\nsippy/SipHeader.py\nclass SipHeader(object):\n    name = None\n    body = None\n\n    def __init__(self, s = None, name = None, body = None, bodys = None, fixname = False):\n        if s != None:\n            name, bodys = [x.strip() for x in s.split(':', 1)]\n        if name != None:\n            self.name = name.lower()\n        if body == None:\n            try:\n                try:\n                    body = hf_types[self.name](bodys)\n                except KeyError:\n                    body = SipGenericHF(bodys, name)\n            except ESipHeaderCSV, einst:\n                einst.name = self.name\n                raise einst\n        self.body = body\n        # If no name is provided use canonic name from the body-specific\n        # class.\n        if self.name == None or fixname:\n            self.name = body.hf_names[0]\n\n    def __str__(self):\n        return str(self.body.getCanName(self.name)) + ': ' + str(self.body)\n\n    def localStr(self, local_addr = None, local_port = None, compact = False):\n        return str(self.body.getCanName(self.name, compact)) + ': ' + \\\n          self.body.localStr(local_addr, local_port)\n\n    def getBody(self):\n        if not self.body.parsed:\n            self.body.parse()\n        return self.body\nsippy/SipFrom.py\nclass SipFrom(SipAddressHF):\n    hf_names = ('from', 'f')\n\n    def __init__(self, body = None, address = None):\n        SipAddressHF.__init__(self, body, address)\n        if body == None and address == None:\n            self.address = SipAddress(name = 'Anonymous', url = SipURL(host = SipConf.my_address, port = SipConf.my_port))\n\n    def getTag(self):\n        return self.address.getParam('tag')\n\n    def genTag(self):\n        self.address.setParam('tag', md5(str((random() * 1000000000L) + time())).hexdigest())\n\n    def setTag(self, value):\n        self.address.setParam('tag', value)\n\n    def delTag(self):\n        self.address.delParam('tag')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 'f'\n        return 'From'\nsippy/CCEvents.py\nclass CCEventDisconnect(CCEventGeneric):\n    name = 'CCEventDisconnect'\n    pass\nsippy/UA.py\nclass UA(object):\n    global_config = None\n    state = None\n    event_cb = None\n    uasReq = None\n    uacResp = None\n    username = None\n    password = None\n    equeue = None\n    dId = None\n    credit_time = None\n    credit_times = None\n    credit_timer = None\n    conn_cbs = None\n    disc_cbs = None\n    fail_cbs = None\n    ring_cbs = None\n    dead_cbs = None\n    rCSeq = None\n    lTag = None\n    lUri = None\n    rUri = None\n    cId = None\n    lCSeq = None\n    lContact = None\n    cGUID = None\n    rAddr = None\n    rAddr0 = None\n    routes = None\n    rTarget = None\n    uasResp = None\n    lSDP = None\n    rSDP = None\n    kaInterval = 0\n    branch = None\n    reqs = None\n    extra_headers = None\n    useRefer = True\n    expire_time = None\n    expire_timer = None\n    no_progress_time = None\n    no_progress_timer = None\n    no_reply_time = None\n    no_reply_timer = None\n    on_local_sdp_change = None\n    on_remote_sdp_change = None\n    last_scode = 100\n    setup_ts = None\n    p100_ts = None\n    p1xx_ts = None\n    connect_ts = None\n    disconnect_ts = None\n    user_agent = None\n    elast_seq = None\n    origin = None\n    source_address = None\n\n    def __init__(self, global_config, event_cb = None, username = None, password = None, nh_address = None, credit_time = None, \\\n      conn_cbs = None, disc_cbs = None, fail_cbs = None, ring_cbs = None, dead_cbs = None, ltag = None, extra_headers = None, \\\n      expire_time = None, no_progress_time = None):\n        self.global_config = global_config\n        self.event_cb = event_cb\n        self.equeue = []\n        self.username = username\n        self.password = password\n        self.rAddr = nh_address\n        self.rAddr0 = self.rAddr\n        self.credit_time = credit_time\n        self.credit_times = {}\n        if conn_cbs != None:\n            self.conn_cbs = conn_cbs\n        else:\n            self.conn_cbs = ()\n        if disc_cbs != None:\n            self.disc_cbs = disc_cbs\n        else:\n            self.disc_cbs = ()\n        if fail_cbs != None:\n            self.fail_cbs = fail_cbs\n        else:\n            self.fail_cbs = ()\n        if ring_cbs != None:\n            self.ring_cbs = ring_cbs\n        else:\n            self.ring_cbs = ()\n        if dead_cbs != None:\n            self.dead_cbs = dead_cbs\n        else:\n            self.dead_cbs = ()\n        if ltag != None:\n            self.lTag = ltag\n        else:\n            self.lTag = md5(str((random() * 1000000000L) + time())).hexdigest()\n        self.reqs = {}\n        self.extra_headers = extra_headers\n        self.expire_time = expire_time\n        self.no_progress_time = no_progress_time\n        #print self.username, self.password\n\n    def recvRequest(self, req):\n        #print 'Received request %s in state %s instance %s' % (req.getMethod(), self.state, self)\n        #print self.rCSeq, req.getHFBody('cseq').getCSeqNum()\n        if self.user_agent == None:\n            self.update_ua(req)\n        if self.rCSeq != None and self.rCSeq >= req.getHFBody('cseq').getCSeqNum():\n            return (req.genResponse(500, 'Server Internal Error'), None, None)\n        self.rCSeq = req.getHFBody('cseq').getCSeqNum()\n        if self.state == None:\n            if req.getMethod() == 'INVITE':\n                self.changeState((UasStateIdle,))\n            else:\n                return None\n        newstate = self.state.recvRequest(req)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n        if newstate != None and req.getMethod() == 'INVITE':\n            return (None, self.state.cancel, self.disconnect)\n        else:\n            return None\n\n    def recvResponse(self, resp):\n        if self.state == None:\n            return\n        self.update_ua(resp)\n        code, reason = resp.getSCode()\n        cseq, method = resp.getHFBody('cseq').getCSeq()\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 401 and resp.countHFs('www-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('authorization') == 0:\n            challenge = resp.getHFBody('www-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm())\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 407 and resp.countHFs('proxy-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('proxy-authorization') == 0:\n            challenge = resp.getHFBody('proxy-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm(), SipProxyAuthorization)\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if code >= 200 and self.reqs.has_key(cseq):\n            del self.reqs[cseq]\n        newstate = self.state.recvResponse(resp)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def recvEvent(self, event):\n        #print self, event\n        if self.state == None:\n            if isinstance(event, CCEventTry) or isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect):\n                self.changeState((UacStateIdle,))\n            else:\n                return\n        newstate = self.state.recvEvent(event)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def disconnect(self, rtime = None):\n        if rtime == None:\n            rtime = time()\n        self.equeue.append(CCEventDisconnect(rtime = rtime))\n        self.recvEvent(CCEventDisconnect(rtime = rtime))\n\n    def expires(self):\n        self.expire_timer = None\n        self.disconnect()\n\n    def no_progress_expires(self):\n        self.no_progress_timer = None\n        self.disconnect()\n\n    def no_reply_expires(self):\n        self.no_reply_timer = None\n        self.disconnect()\n\n    def credit_expires(self, rtime):\n        self.credit_timer = None\n        self.disconnect(rtime)\n\n    def changeState(self, newstate):\n        if self.state != None:\n            self.state.onStateChange(newstate[0])\n        self.state = newstate[0](self)\n        if len(newstate) > 1:\n            for callback in newstate[1]:\n                callback(self, *newstate[2:])\n\n    def emitEvent(self, event):\n        if self.event_cb != None:\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                return\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def emitPendingEvents(self):\n        while len(self.equeue) != 0 and self.event_cb != None:\n            event = self.equeue.pop(0)\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                continue\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def genRequest(self, method, body = None, nonce = None, realm = None, SipXXXAuthorization = SipAuthorization, \\\n      reason = None):\n        req = SipRequest(method = method, ruri = self.rTarget, to = self.rUri, fr0m = self.lUri,\n                         cseq = self.lCSeq, callid = self.cId, contact = self.lContact,\n                         routes = self.routes, target = self.rAddr, cguid = self.cGUID)\n        if nonce != None and realm != None and self.username != None and self.password != None:\n            auth = SipXXXAuthorization(realm = realm, nonce = nonce, method = method, uri = str(self.rTarget),\n              username = self.username, password = self.password)\n            req.appendHeader(SipHeader(body = auth))\n        if body != None:\n            req.setBody(body)\n        if self.extra_headers != None:\n            req.appendHeaders(self.extra_headers)\n        if reason != None:\n            req.appendHeader(SipHeader(body = reason))\n        self.reqs[self.lCSeq] = req\n        return req\n\n    def sendUasResponse(self, scode, reason, body = None, contact = None, \\\n      reason_rfc3326 = None, extra_header = None):\n        self.uasResp.setSCode(scode, reason)\n        self.uasResp.setBody(body)\n        self.uasResp.delHFs('www-authenticate')\n        self.uasResp.delHFs('contact')\n        self.uasResp.delHFs('reason')\n        if contact != None:\n            self.uasResp.appendHeader(SipHeader(name = 'contact', body = contact))\n        if reason_rfc3326 != None:\n            self.uasResp.appendHeader(SipHeader(body = reason_rfc3326))\n        if extra_header != None:\n            self.uasResp.appendHeader(extra_header)\n        self.global_config['_sip_tm'].sendResponse(self.uasResp)\n\n    def isYours(self, req = None, call_id = None, from_tag = None, to_tag = None):\n        #print self.branch, req.getHFBody('via').getBranch()\n        if req != None:\n            if req.getMethod() != 'BYE' and self.branch != None and \\\n              self.branch != req.getHFBody('via').getBranch():\n                return None\n            call_id = str(req.getHFBody('call-id'))\n            from_tag = req.getHFBody('from').getTag()\n            to_tag = req.getHFBody('to').getTag()\n        #print str(self.cId), call_id\n        if call_id != str(self.cId):\n            return None\n        #print self.rUri.getTag(), from_tag\n        if self.rUri != None and self.rUri.getTag() != from_tag:\n            return None\n        #print self.lUri.getTag(), to_tag\n        if self.lUri != None and self.lUri.getTag() != to_tag:\n            return None\n        return self\n\n    def isDead(self):\n        if self.state != None:\n            return self.state.dead\n        return False\n\n    def isConnected(self):\n        if self.state != None:\n            return self.state.connected\n        return False\n\n    def getCLD(self):\n        if self.rUri == None:\n            return None\n        return self.rUri.getUrl().username\n\n    def getCLI(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUrl().username\n\n    def getCallingName(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUri().name\n\n    def getRAddr0(self):\n        return self.rAddr0\n\n    def getCID(self):\n        # Return tuple containing call-id, local tag and remote tag\n        rval = [str(self.cId), None, None]\n        if self.lUri != None:\n            rval[1] = self.lUri.getTag()\n        if self.rUri != None:\n            rval[2] = self.rUri.getTag()\n        return tuple(rval)\n\n    def delayed_remote_sdp_update(self, event, remote_sdp_body):\n        self.rSDP = remote_sdp_body.getCopy()\n        self.equeue.append(event)\n        self.emitPendingEvents()\n\n    def getAcct(self):\n        if self.disconnect_ts != None:\n            disconnect_ts = self.disconnect_ts\n            disconnected = True\n        else:\n            disconnect_ts = time()\n            disconnected = False\n        if self.connect_ts != None:\n            return (disconnect_ts - self.connect_ts, self.connect_ts - self.setup_ts, True, disconnected)\n        return (0, disconnect_ts - self.setup_ts, False, disconnected)\n\n    def update_ua(self, msg):\n        if msg.countHFs('user-agent') > 0:\n            self.user_agent = msg.getHFBody('user-agent').name\n        elif msg.countHFs('server') > 0:\n            self.user_agent = msg.getHFBody('server').name\n        return\n\n    def cancelCreditTimer(self):\n        if self.credit_timer != None:\n            self.credit_timer.cancel()\n            self.credit_timer = None\n\n    def startCreditTimer(self, rtime):\n        if self.credit_time != None:\n            self.credit_times[0] = rtime + self.credit_time\n            self.credit_time = None\n        try:\n            credit_time = min([x for x in self.credit_times.values() if x != None])\n        except ValueError:\n            return\n        self.credit_timer = TimeoutAbs(self.credit_expires, credit_time, credit_time)\n\n    def resetCreditTime(self, rtime, new_credit_times):\n        self.credit_times.update(new_credit_times)\n        if self.state.connected:\n            self.cancelCreditTimer()\n            self.startCreditTimer(rtime)\n\n    def cleanup(self):\n        pass\nsippy/CCEvents.py\nclass CCEventTry(CCEventGeneric):\n    name = 'CCEventTry'\n    pass\nsippy/RadiusAuthorisation.py\nclass RadiusAuthorisation(Radius_client):\n    def do_auth(self, username, caller, callee, h323_cid, sip_cid, remote_ip, res_cb, \\\n      realm = None, nonce = None, uri = None, response = None, extra_attributes = None):\n        sip_cid = str(sip_cid)\n        attributes = None\n        if None not in (realm, nonce, uri, response):\n            attributes = [('User-Name', username), ('Digest-Realm', realm), \\\n              ('Digest-Nonce', nonce), ('Digest-Method', 'INVITE'), ('Digest-URI', uri), \\\n              ('Digest-Algorithm', 'MD5'), ('Digest-User-Name', username), ('Digest-Response', response)]\n        else:\n            attributes = [('User-Name', remote_ip), ('Password', 'cisco')]\n        if caller == None:\n            caller = ''\n        attributes.extend((('Calling-Station-Id', caller), ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), \\\n          ('call-id', sip_cid), ('h323-remote-address', remote_ip), ('h323-session-protocol', 'sipv2')))\n        if extra_attributes != None:\n            for a, v in extra_attributes:\n                attributes.append((a, v))\n        message = 'sending AAA request:\\n' \n        message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes])\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        Radius_client.do_auth(self, attributes, self._process_result, res_cb, sip_cid, time())\n\n    def _process_result(self, results, res_cb, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'AAA request accepted (delay is %.3f), processing response:\\n' % delay\n            else:\n                message = 'AAA request rejected (delay is %.3f), processing response:\\n' % delay\n            if len(results[0]) > 0:\n                message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % x for x in results[0]])\n        else:\n            message = 'Error sending AAA request (delay is %.3f)\\n' % delay\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        res_cb(results)\nsippy/CCEvents.py\nclass CCEventConnect(CCEventGeneric):\n    name = 'CCEventConnect'\n    pass\nsippy/UasStateTrying.py\nclass UasStateTrying(UaStateGeneric):\n    sname = 'Trying(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body)\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n                if self.ua.expire_time != None:\n                    self.ua.expire_timer = TimeoutAbs(self.ua.expires, self.ua.expire_time)\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            return (UasStateRinging, self.ua.ring_cbs, event.rtime, event.origin, code)\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Trying state' % event\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/SipTo.py\nclass SipTo(SipFrom):\n    hf_names = ('to', 't')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 't'\n        return 'To'\nsippy/CCEvents.py\nclass CCEventUpdate(CCEventGeneric):\n    name = 'CCEventUpdate'\n    pass\nsippy/SipLogger.py\nclass SipLogger(object):\n    app = None\n    call_id = None\n    log = None\n    level = None\n    flock = lambda x, y, z: None\n\n    def __init__(self, app, call_id = 'GLOBAL', logfile = '/var/log/sip.log'):\n        self.app = app\n        self.call_id = call_id\n        bend = os.environ.get('SIPLOG_BEND', 'stderr').lower()\n        if bend == 'stderr':\n            self.log = sys.__stderr__\n        elif bend == 'none':\n            self.write = self.donoting\n        else:\n            logfile = os.environ.get('SIPLOG_LOGFILE_FILE', logfile)\n            self.log = file(logfile, 'a')\n            self.flock = flock\n            Signal(SIGUSR1, self.reopen, logfile)\n        self.level = eval('SIPLOG_' + os.environ.get('SIPLOG_LVL', 'INFO'))\n\n    def donoting(self, *args, **kwargs):\n        pass\n\n    def write(self, *args, **kwargs):\n        if kwargs.get('level', SIPLOG_INFO) < self.level:\n            return\n        ltime = kwargs.get('ltime', None)\n        if ltime == None:\n            ltime = time()\n        call_id = kwargs.get('call_id', self.call_id)\n        obuf = '%s.%.3d/%s/%s: %s\\n' % (strftime('%d %b %H:%M:%S', localtime(ltime)), \\\n          (ltime % 1) * 1000, call_id, self.app, \\\n          reduce(lambda x, y: x + y, [str(x) for x in args]))\n        try:\n            self.flock(self.log, LOCK_EX)\n        except IOError, e:\n            # Catch ENOTSUP\n            if e.args[0] != 45:\n                raise e\n            self.flock = lambda x, y: None\n        try:\n            self.log.write(obuf)\n        except IOError, e:\n            if e.args[0] != EINTR:\n                raise e\n        self.log.flush()\n        self.flock(self.log, LOCK_UN)\n\n    def reopen(self, logfile):\n        self.log = file(logfile, 'a')\nsippy/CCEvents.py\nclass CCEventFail(CCEventGeneric):\n    name = 'CCEventFail'\n    pass\nsippy/UasStateRinging.py\nclass UasStateRinging(UaStateGeneric):\n    sname = 'Ringing(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            self.ua.sendUasResponse(code, reason, body)\n            for ring_cb in self.ua.ring_cbs:\n                ring_cb(self.ua, event.rtime, event.origin, code)\n            return None\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Ringing state' % event\n        return None\n\n    def recvRequest(self, req):\n        if req.getMethod() == 'BYE':\n            self.ua.sendUasResponse(487, 'Request Terminated')\n            self.ua.global_config['_sip_tm'].sendResponse(req.genResponse(200, 'OK'))\n            #print 'BYE received in the Ringing state, going to the Disconnected state'\n            if req.countHFs('also') > 0:\n                also = req.getHFBody('also').getUrl().getCopy()\n            else:\n                also = None\n            event = CCEventDisconnect(also, rtime = req.rtime, origin = self.ua.origin)\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n            self.ua.equeue.append(event)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = req.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, req.rtime, self.ua.origin)\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/RadiusAccounting.py\nclass RadiusAccounting(object):\n    global_config = None\n    drec = None\n    crec = None\n    iTime = None\n    cTime = None\n    sip_cid = None\n    origin = None\n    lperiod = None\n    el = None\n    send_start = None\n    complete = False\n    ms_precision = False\n    user_agent = None\n    p1xx_ts = None\n    p100_ts = None\n\n    def __init__(self, global_config, origin, lperiod = None, send_start = False):\n        self.global_config = global_config\n        self._attributes = [('h323-call-origin', origin), ('h323-call-type', 'VoIP'), \\\n          ('h323-session-protocol', 'sipv2')]\n        self.drec = False\n        self.crec = False\n        self.origin = origin\n        self.lperiod = lperiod\n        self.send_start = send_start\n\n    def setParams(self, username, caller, callee, h323_cid, sip_cid, remote_ip, \\\n      h323_in_cid = None):\n        if caller == None:\n            caller = ''\n        self._attributes.extend((('User-Name', username), ('Calling-Station-Id', caller), \\\n          ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), ('call-id', sip_cid), \\\n          ('Acct-Session-Id', sip_cid), ('h323-remote-address', remote_ip)))\n        if h323_in_cid != None and h323_in_cid != h323_cid:\n            self._attributes.append(('h323-incoming-conf-id', h323_in_cid))\n        self.sip_cid = str(sip_cid)\n        self.complete = True\n\n    def conn(self, ua, rtime, origin):\n        if self.crec:\n            return\n        self.crec = True\n        self.iTime = ua.setup_ts\n        self.cTime = ua.connect_ts\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        if self.send_start:\n            self.asend('Start', rtime, origin, ua)\n        self._attributes.extend((('h323-voice-quality', 0), ('Acct-Terminate-Cause', 'User-Request')))\n        if self.lperiod != None and self.lperiod > 0:\n            self.el = Timeout(self.asend, self.lperiod, -1, 'Alive')\n\n    def disc(self, ua, rtime, origin, result = 0):\n        if self.drec:\n            return\n        self.drec = True\n        if self.el != None:\n            self.el.cancel()\n            self.el = None\n        if self.iTime == None:\n            self.iTime = ua.setup_ts\n        if self.cTime == None:\n            self.cTime = rtime\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        self.asend('Stop', rtime, origin, result, ua)\n\n    def asend(self, type, rtime = None, origin = None, result = 0, ua = None):\n        if not self.complete:\n            return\n        if rtime == None:\n            rtime = time()\n        if ua != None:\n            duration, delay, connected = ua.getAcct()[:3]\n        else:\n            # Alive accounting\n            duration = rtime - self.cTime\n            delay = self.cTime - self.iTime\n            connected = True\n        if not(self.ms_precision):\n            duration = round(duration)\n            delay = round(delay)\n        attributes = self._attributes[:]\n        if type != 'Start':\n            if result >= 400:\n                try:\n                    dc = sipErrToH323Err[result][0]\n                except:\n                    dc = '7f'\n            elif result < 200:\n                dc = '10'\n            else:\n                dc = '0'\n            attributes.extend((('h323-disconnect-time', self.ftime(self.iTime + delay + duration)), \\\n              ('Acct-Session-Time', '%d' % round(duration)), ('h323-disconnect-cause', dc)))\n        if type == 'Stop':\n            if origin == 'caller':\n                release_source = '2'\n            elif origin == 'callee':\n                release_source = '4'\n            else:\n                release_source = '8'\n            attributes.append(('release-source', release_source))\n        attributes.extend((('h323-connect-time', self.ftime(self.iTime + delay)), ('h323-setup-time', self.ftime(self.iTime)), \\\n          ('Acct-Status-Type', type)))\n        if self.user_agent != None:\n            attributes.append(('h323-ivr-out', 'sip_ua:' + self.user_agent))\n        if self.p1xx_ts != None:\n            attributes.append(('Acct-Delay-Time', round(self.p1xx_ts)))\n        if self.p100_ts != None:\n            attributes.append(('provisional-timepoint', self.ftime(self.p100_ts)))\n        pattributes = ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes]\n        pattributes.insert(0, 'sending Acct %s (%s):\\n' % (type, self.origin.capitalize()))\n        self.global_config['_sip_logger'].write(call_id = self.sip_cid, *pattributes)\n        self.global_config['_radius_client'].do_acct(attributes, self._process_result, self.sip_cid, time())\n\n    def ftime(self, t):\n        gt = gmtime(t)\n        day = strftime('%d', gt)\n        if day[0] == '0':\n            day = day[1]\n        if self.ms_precision:\n            msec = (t % 1) * 1000\n        else:\n            msec = 0\n        return strftime('%%H:%%M:%%S.%.3d GMT %%a %%b %s %%Y' % (msec, day), gt)\n\n    def _process_result(self, results, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'Acct/%s request accepted (delay is %.3f)\\n' % (self.origin, delay)\n            else:\n                message = 'Acct/%s request rejected (delay is %.3f)\\n' % (self.origin, delay)\n        else:\n            message = 'Error sending Acct/%s request (delay is %.3f)\\n' % (self.origin, delay)\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\nsippy/MyConfigParser.py\nclass MyConfigParser(RawConfigParser):\n    default_section = None\n    _private_keys = None\n\n    def __init__(self, default_section = 'general'):\n        self.default_section = default_section\n        self._private_keys = {}\n        RawConfigParser.__init__(self)\n        self.add_section(self.default_section)\n\n    def __getitem__(self, key):\n        if key.startswith('_'):\n            return self._private_keys[key]\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type  == 'B':\n            return self.getboolean(self.default_section, key)\n        elif value_type == 'I':\n            return self.getint(self.default_section, key)\n        return self.get(self.default_section, key)\n\n    def __setitem__(self, key, value):\n        if key.startswith('_'):\n            self._private_keys[key] = value\n        else:\n            self.set(self.default_section, key, str(value))\n        return\n\n    def has_key(self, key):\n        return self.__contains__(key)\n\n    def __contains__(self, key):\n        if key.startswith('_'):\n            return self._private_keys.has_key(key)\n        return self.has_option(self.default_section, key)\n\n    def get(self, *args):\n        if len(args) == 1:\n            return self.__getitem__(args[0])\n        return RawConfigParser.get(self, *args)\n\n    def getdefault(self, key, default_value):\n        if self.__contains__(key):\n            return self.__getitem__(key)\n        return default_value\n\n    def get_longopts(self):\n        return tuple([x + '=' for x in SUPPORTED_OPTIONS.keys()])\n\n    def read(self, fname):\n        RawConfigParser.readfp(self, open(fname))\n        for key in tuple(self.options(self.default_section)):\n            self.check_and_set(key, RawConfigParser.get(self, \\\n              self.default_section, key), False)\n\n    def check_and_set(self, key, value, compat = True):\n        value = value.strip()\n        if compat:\n            if key == 'rtp_proxy_client':\n                # XXX compatibility option\n                if self.has_key('_rtp_proxy_clients'):\n                    self['_rtp_proxy_clients'].append(value)\n                else:\n                    self['_rtp_proxy_clients'] = [value,]\n                if self.has_key('rtp_proxy_clients'):\n                    self['rtp_proxy_clients'] += ',' + value\n                else:\n                    self['rtp_proxy_clients'] = value\n                return\n            elif key == 'pass_header':\n                # XXX compatibility option\n                if self.has_key('_pass_headers'):\n                    self['_pass_headers'].append(value)\n                else:\n                    self['_pass_headers'] = [value,]\n                if self.has_key('pass_headers'):\n                    self['pass_headers'] += ',' + value\n                else:\n                    self['pass_headers'] = value\n                return\n\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type == 'B':\n            if value.lower() not in self._boolean_states:\n                raise ValueError, 'Not a boolean: %s' % value\n        elif value_type == 'I':\n            _value = int(value)\n        if key in ('keepalive_ans', 'keepalive_orig'):\n            if _value < 0:\n                raise ValueError, 'keepalive_ans should be non-negative'\n        elif key == 'max_credit_time':\n            if _value <= 0:\n                raise ValueError, 'max_credit_time should be more than zero'\n        elif key == 'allowed_pts':\n            self['_allowed_pts'] = [int(x) for x in value.split(',')]\n        elif key in ('accept_ips', 'pass_headers', 'rtp_proxy_clients'):\n            self['_' + key] = [x.strip() for x in value.split(',')]\n        elif key == 'sip_address':\n            if 'my' in dir(value):\n                self['_sip_address'] = value\n                value = '*'\n            elif value in ('*', '0.0.0.0', '::'):\n                self['_sip_address'] = SipConf.my_address\n            else:\n                self['_sip_address'] = value\n        elif key == 'sip_port':\n            if _value <= 0 or _value > 65535:\n                raise ValueError, 'sip_port should be in the range 1-65535'\n            self['_sip_port'] = _value\n        self[key] = value\n\n    def options_help(self):\n        supported_options = SUPPORTED_OPTIONS.items()\n        supported_options.sort()\n        for option, (value_type, helptext) in supported_options:\n            if value_type == 'B':\n                value = 'on/off'\n            elif value_type == 'I':\n                value = 'number'\n            else:\n                value = '\"string\"'\n            print '--%s=%s\\n\\t%s\\n' % (option, value, helptext)\nsippy/UaStateDead.py\nclass UaStateDead(UaStateGeneric):\n    sname = 'Dead'\n    dead = True\n\n    def __init__(self, ua):\n        UaStateGeneric.__init__(self, None)\n        if ua.cId != None:\n            ua.global_config['_sip_tm'].unregConsumer(ua, str(ua.cId))\n        ua.tr = None\n        ua.event_cb = None\n        ua.conn_cbs = ()\n        ua.disc_cbs = ()\n        ua.fail_cbs = ()\n        ua.on_local_sdp_change = None\n        ua.on_remote_sdp_change = None\n        ua.expire_timer = None\n        ua.no_progress_timer = None\n        ua.credit_timer = None\n        # Keep this at the very end of processing\n        for callback in ua.dead_cbs:\n            callback(ua)\n        ua.dead_cbs = ()\n        ua.cleanup()\n        # Break cross-ref chain\n        self.ua = None\nsippy/SipTransactionManager.py\nclass SipTransactionManager(object):\n    global_config = None\n    l4r = None\n    tclient = None\n    tserver = None\n    req_cb = None\n    l1rcache = None\n    l2rcache = None\n    nat_traversal = False\n    req_consumers = None\n    provisional_retr = 0\n\n    def __init__(self, global_config, req_cb = None):\n        self.global_config = global_config\n        self.l4r = local4remote(global_config, self.handleIncoming)\n        self.tclient = {}\n        self.tserver = {}\n        self.req_cb = req_cb\n        self.l1rcache = {}\n        self.l2rcache = {}\n        self.req_consumers = {}\n        Timeout(self.rCachePurge, 32, -1)\n\n    def handleIncoming(self, data, address, server):\n        if len(data) < 32:\n            return\n        rtime = time()\n        self.global_config['_sip_logger'].write('RECEIVED message from %s:%d:\\n' % address, data, ltime = rtime)\n        checksum = md5(data).digest()\n        retrans = self.l1rcache.get(checksum, None)\n        if retrans == None:\n            retrans = self.l2rcache.get(checksum, None)\n        if retrans != None:\n            userv, data, address = retrans\n            if data == None:\n                return\n            self.transmitData(userv, data, address)\n            return\n        if data.startswith('SIP/2.0 '):\n            try:\n                resp = SipResponse(data)\n                tid = resp.getTId(True, True)\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP response from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            if resp.getSCode()[0] < 100 or resp.getSCode()[0] > 999:\n                print datetime.now(), 'invalid status code in SIP response from %s:%d:' % address\n                print data\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            resp.rtime = rtime\n            if not self.tclient.has_key(tid):\n                #print 'no transaction with tid of %s in progress' % str(tid)\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            t = self.tclient[tid]\n            if self.nat_traversal and resp.countHFs('contact') > 0 and not check1918(t.address[0]):\n                curl = resp.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n            resp.setSource(address)\n            self.incomingResponse(resp, t, checksum)\n        else:\n            if self.req_cb == None:\n                return\n            try:\n                req = SipRequest(data)\n                tids = req.getTIds()\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP request from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            req.rtime = rtime\n            via0 = req.getHFBody('via')\n            ahost, aport = via0.getAddr()\n            rhost, rport = address\n            if self.nat_traversal and rport != aport and check1918(ahost):\n                req.nated = True\n            if ahost != rhost:\n                via0.params['received'] = rhost\n            if via0.params.has_key('rport') or req.nated:\n                via0.params['rport'] = str(rport)\n            if self.nat_traversal and req.countHFs('contact') > 0 and req.countHFs('via') == 1:\n                curl = req.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n                    req.nated = True\n            req.setSource(address)\n            self.incomingRequest(req, checksum, tids, server)\n\n    # 1. Client transaction methods\n    def newTransaction(self, msg, resp_cb = None, laddress = None, userv = None):\n        t = SipTransaction()\n        t.tid = msg.getTId(True, True)\n        if self.tclient.has_key(t.tid):\n            raise ValueError('BUG: Attempt to initiate transaction with the same TID as existing one!!!')\n        t.tout = 0.5\n        t.fcode = None\n        t.address = msg.getTarget()\n        if userv == None:\n            if laddress == None:\n                t.userv = self.l4r.getServer(t.address)\n            else:\n                t.userv = self.l4r.getServer(laddress, is_local = True)\n        else:\n            t.userv = userv\n        t.data = msg.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        try:\n            t.expires = msg.getHFBody('expires').getNum()\n            if t.expires <= 0:\n                t.expires = 300\n        except IndexError:\n            t.expires = 300\n        if msg.getMethod() == 'INVITE':\n            t.needack = True\n            t.ack = msg.genACK()\n            t.cancel = msg.genCANCEL()\n        else:\n            t.needack = False\n            t.ack = None\n            t.cancel = None\n        t.cancelPending = False\n        t.resp_cb = resp_cb\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n        if resp_cb != None:\n            t.r408 = msg.genResponse(408, 'Request Timeout')\n        t.teB = Timeout(self.timerB, 32.0, 1, t)\n        t.teC = None\n        t.state = TRYING\n        self.tclient[t.tid] = t\n        self.transmitData(t.userv, t.data, t.address)\n        return t\n\n    def cancelTransaction(self, t, reason = None):\n        # If we got at least one provisional reply then (state == RINGING)\n        # then start CANCEL transaction, otherwise deffer it\n        if t.state != RINGING:\n            t.cancelPending = True\n        else:\n            if reason != None:\n                t.cancel.appendHeader(SipHeader(body = reason))\n            self.newTransaction(t.cancel, userv = t.userv)\n\n    def incomingResponse(self, msg, t, checksum):\n        # In those two states upper level already notified, only do ACK retransmit\n        # if needed\n        if t.state == TERMINATED:\n            return\n\n        if t.state == TRYING:\n            # Stop timers\n            if t.teA != None:\n                t.teA.cancel()\n                t.teA = None\n\n        if t.state in (TRYING, RINGING):\n            if t.teB != None:\n                t.teB.cancel()\n                t.teB = None\n\n            if msg.getSCode()[0] < 200:\n                # Privisional response - leave everything as is, except that\n                # change state and reload timeout timer\n                if t.state == TRYING:\n                    t.state = RINGING\n                    if t.cancelPending:\n                        self.newTransaction(t.cancel, userv = t.userv)\n                        t.cancelPending = False\n                t.teB = Timeout(self.timerB, t.expires, 1, t)\n                self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n            else:\n                # Final response - notify upper layer and remove transaction\n                if t.needack:\n                    # Prepare and send ACK if necessary\n                    fcode = msg.getSCode()[0]\n                    tag = msg.getHFBody('to').getTag()\n                    if tag != None:\n                        t.ack.getHFBody('to').setTag(tag)\n                    rAddr = None\n                    if msg.getSCode()[0] >= 200 and msg.getSCode()[0] < 300:\n                        # Some hairy code ahead\n                        if msg.countHFs('contact') > 0:\n                            rTarget = msg.getHFBody('contact').getUrl().getCopy()\n                        else:\n                            rTarget = None\n                        routes = [x.getCopy() for x in msg.getHFBodys('record-route')]\n                        routes.reverse()\n                        if len(routes) > 0:\n                            if not routes[0].getUrl().lr:\n                                if rTarget != None:\n                                    routes.append(SipRoute(address = SipAddress(url = rTarget)))\n                                rTarget = routes.pop(0).getUrl()\n                                rAddr = rTarget.getAddr()\n                            else:\n                                rAddr = routes[0].getAddr()\n                        elif rTarget != None:\n                            rAddr = rTarget.getAddr()\n                        if rTarget != None:\n                            t.ack.setRURI(rTarget)\n                        if rAddr != None:\n                            t.ack.setTarget(rAddr)\n                        t.ack.delHFs('route')\n                        t.ack.appendHeaders([SipHeader(name = 'route', body = x) for x in routes])\n                    if fcode >= 200 and fcode < 300:\n                        t.ack.getHFBody('via').genBranch()\n                    if rAddr == None:\n                        rAddr = t.address\n                    self.transmitMsg(t.userv, t.ack, rAddr, checksum)\n                else:\n                    self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n                del self.tclient[t.tid]\n                t.cleanup()\n\n    def timerA(self, t):\n        #print 'timerA', t\n        self.transmitData(t.userv, t.data, t.address)\n        t.tout *= 2\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n\n    def timerB(self, t):\n        #print 'timerB', t\n        t.teB = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        t.state = TERMINATED\n        #print '2: Timeout(self.timerC, 32.0, 1, t)', t\n        t.teC = Timeout(self.timerC, 32.0, 1, t)\n        if t.resp_cb == None:\n            return\n        t.r408.rtime = time()\n        t.resp_cb(t.r408)\n        #try:\n        #    t.resp_cb(SipRequest(t.data).genResponse(408, 'Request Timeout'))\n        #except:\n        #    print 'SipTransactionManager: unhandled exception when processing response!'\n\n    def timerC(self, t):\n        #print 'timerC', t\n        #print self.tclient\n        t.teC = None\n        del self.tclient[t.tid]\n        t.cleanup()\n\n    # 2. Server transaction methods\n    def incomingRequest(self, msg, checksum, tids, server):\n        for tid in tids:\n            if self.tclient.has_key(tid):\n                resp = msg.genResponse(482, 'Loop Detected')\n                self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                return\n        tid = msg.getTId()\n        # Fasten seatbelts - bumpy transaction matching code ahead!\n        if msg.getMethod() in ('INVITE', 'CANCEL', 'ACK'):\n            btid = msg.getTId(wBRN = True)\n            t = self.tserver.get(btid, None)\n            if t == None:\n                t = self.tserver.get(tid, None)\n                if t != None and t.branch != btid[3]:\n                    if msg.getMethod() == 'INVITE':\n                        # Different branch on transaction to which no final reply\n                        # has been sent yet - merge requests\n                        resp = msg.genResponse(482, 'Loop Detected')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n                    elif msg.getMethod() == 'CANCEL':\n                        # CANCEL, but with branch that doesn't match any existing\n                        # transactions\n                        resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n        else:\n            t = self.tserver.get(tid, None)\n        if t != None:\n            #print 'existing transaction'\n            if msg.getMethod() == t.method:\n                # Duplicate received, check that we have sent any response on this\n                # request already\n                if t.data != None:\n                    self.transmitData(t.userv, t.data, t.address, checksum)\n                return\n            elif msg.getMethod() == 'CANCEL':\n                # RFC3261 says that we have to reply 200 OK in all cases if\n                # there is such transaction\n                resp = msg.genResponse(200, 'OK')\n                self.transmitMsg(t.userv, resp, resp.getHFBody('via').getTAddr(), checksum)\n                if t.state in (TRYING, RINGING):\n                    self.doCancel(t, msg.rtime, msg)\n            elif msg.getMethod() == 'ACK' and t.state == COMPLETED:\n                t.state = CONFIRMED\n                if t.teA != None:\n                    t.teA.cancel()\n                    t.teA = None\n                t.teD.cancel()\n                # We have done with the transaction, no need to wait for timeout\n                del self.tserver[t.tid]\n                t.cleanup()\n                self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'ACK':\n            # Some ACK that doesn't match any existing transaction.\n            # Drop and forget it - upper layer is unlikely to be interested\n            # to seeing this anyway.\n            print datetime.now(), 'unmatched ACK transaction - ignoring'\n            sys.stdout.flush()\n            self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'CANCEL':\n            resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n            self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n        else:\n            #print 'new transaction', msg.getMethod()\n            t = SipTransaction()\n            t.tid = tid\n            t.state = TRYING\n            t.teA = None\n            t.teD = None\n            t.teE = None\n            t.teF = None\n            t.method = msg.getMethod()\n            t.data = None\n            t.address = None\n            t.noack_cb = None\n            t.cancel_cb = None\n            t.checksum = checksum\n            if server.laddress[0] not in ('0.0.0.0', '[::]'):\n                t.userv = server\n            else:\n                # For messages received on the wildcard interface find\n                # or create more specific server.\n                t.userv = self.l4r.getServer(msg.getSource())\n            if msg.getMethod() == 'INVITE':\n                t.r487 = msg.genResponse(487, 'Request Terminated')\n                t.needack = True\n                t.branch = msg.getHFBody('via').getBranch()\n                try:\n                    e = msg.getHFBody('expires').getNum()\n                    if e <= 0:\n                        e = 300\n                except IndexError:\n                    e = 300\n                t.teE = Timeout(self.timerE, e, 1, t)\n            else:\n                t.r487 = None\n                t.needack = False\n                t.branch = None\n            self.tserver[t.tid] = t\n            for consumer in self.req_consumers.get(t.tid[0], ()):\n                consumer = consumer.isYours(msg)\n                if consumer != None:\n                    rval = consumer.recvRequest(msg)\n                    break\n            else:\n                rval = self.req_cb(msg)\n            if rval == None:\n                if t.teA != None or t.teD != None or t.teE != None or t.teF != None:\n                    return\n                if self.tserver.has_key(t.tid):\n                    del self.tserver[t.tid]\n                t.cleanup()\n                return\n            resp, cancel_cb, noack_cb = rval\n            t.cancel_cb = cancel_cb\n            t.noack_cb = noack_cb\n            if resp != None:\n                self.sendResponse(resp, t)\n\n    def regConsumer(self, consumer, call_id):\n        self.req_consumers.setdefault(call_id, []).append(consumer)\n\n    def unregConsumer(self, consumer, call_id):\n        # Usually there will be only one consumer per call_id, so that\n        # optimize management for this case\n        consumers = self.req_consumers.pop(call_id)\n        if len(consumers) > 1:\n            consumers.remove(consumer)\n            self.req_consumers[call_id] = consumers\n\n    def sendResponse(self, resp, t = None, retrans = False):\n        #print self.tserver\n        if t == None:\n            tid = resp.getTId()\n            t = self.tserver[tid]\n        if t.state not in (TRYING, RINGING) and not retrans:\n            raise ValueError('BUG: attempt to send reply on already finished transaction!!!')\n        scode = resp.getSCode()[0]\n        toHF = resp.getHFBody('to')\n        if scode > 100 and toHF.getTag() == None:\n            toHF.genTag()\n        t.data = resp.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        t.address = resp.getHFBody('via').getTAddr()\n        self.transmitData(t.userv, t.data, t.address, t.checksum)\n        if scode < 200:\n            t.state = RINGING\n            if self.provisional_retr > 0 and scode > 100:\n                if t.teF != None:\n                    t.teF.cancel()\n                t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n        else:\n            t.state = COMPLETED\n            if t.teE != None:\n                t.teE.cancel()\n                t.teE = None\n            if t.teF != None:\n                t.teF.cancel()\n                t.teF = None\n            if t.needack:\n                # Schedule removal of the transaction\n                t.teD = Timeout(self.timerD, 32.0, 1, t)\n                if scode >= 300:\n                    # Black magick to allow proxy send us another INVITE with diffetent branch\n                    del self.tserver[t.tid]\n                    t.tid = list(t.tid)\n                    t.tid.append(t.branch)\n                    t.tid = tuple(t.tid)\n                    self.tserver[t.tid] = t\n                # Install retransmit timer if necessary\n                t.tout = 0.5\n                t.teA = Timeout(self.timerA, t.tout, 1, t)\n            else:\n                # We have done with the transaction\n                del self.tserver[t.tid]\n                t.cleanup()\n\n    def doCancel(self, t, rtime = None, req = None):\n        if rtime == None:\n            rtime = time()\n        if t.r487 != None:\n            self.sendResponse(t.r487, t, True)\n        if t.cancel_cb != None:\n            t.cancel_cb(rtime, req)\n\n    def timerD(self, t):\n        #print 'timerD'\n        t.teD = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        if t.noack_cb != None and t.state != CONFIRMED:\n            t.noack_cb()\n        del self.tserver[t.tid]\n        t.cleanup()\n\n    def timerE(self, t):\n        #print 'timerE'\n        t.teE = None\n        if t.teF != None:\n            t.teF.cancel()\n            t.teF = None\n        if t.state in (TRYING, RINGING):\n            if t.r487 != None:\n                t.r487.reason = 'Request Expired'\n            self.doCancel(t)\n\n    # Timer to retransmit the last provisional reply every\n    # 2 seconds\n    def timerF(self, t):\n        #print 'timerF', t.state\n        t.teF = None\n        if t.state == RINGING and self.provisional_retr > 0:\n            self.transmitData(t.userv, t.data, t.address)\n            t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n\n    def rCachePurge(self):\n        self.l2rcache = self.l1rcache\n        self.l1rcache = {}\n        self.l4r.rotateCache()\n\n    def transmitMsg(self, userv, msg, address, cachesum, compact = False):\n        data = msg.localStr(userv.laddress[0], userv.laddress[1], compact)\n        self.transmitData(userv, data, address, cachesum)\n\n    def transmitData(self, userv, data, address, cachesum = None):\n        userv.send_to(data, address)\n        self.global_config['_sip_logger'].write('SENDING message to %s:%d:\\n' % address, data)\n        if cachesum != None:\n            self.l1rcache[cachesum] = (userv, data, address)\nsippy/CCEvents.py\nclass CCEventRing(CCEventGeneric):\n    name = 'CCEventRing'\n    pass\nfrom sippy.Timeout import Timeout\nfrom sippy.Signal import Signal\nfrom sippy.SipFrom import SipFrom\nfrom sippy.SipTo import SipTo\nfrom sippy.SipCiscoGUID import SipCiscoGUID\nfrom sippy.UA import UA\nfrom sippy.CCEvents import CCEventRing, CCEventConnect, CCEventDisconnect, CCEventTry, CCEventUpdate, CCEventFail\nfrom sippy.UasStateTrying import UasStateTrying\nfrom sippy.UasStateRinging import UasStateRinging\nfrom sippy.UaStateDead import UaStateDead\nfrom sippy.SipConf import SipConf\nfrom sippy.SipHeader import SipHeader\nfrom sippy.RadiusAuthorisation import RadiusAuthorisation\nfrom sippy.RadiusAccounting import RadiusAccounting\nfrom sippy.FakeAccounting import FakeAccounting\nfrom sippy.SipLogger import SipLogger\nfrom sippy.Rtp_proxy_session import Rtp_proxy_session\nfrom sippy.Rtp_proxy_client import Rtp_proxy_client\nfrom signal import SIGHUP, SIGPROF, SIGUSR1, SIGUSR2\nfrom twisted.internet import reactor\nfrom urllib import unquote\nfrom sippy.Cli_server_local import Cli_server_local\nfrom sippy.SipTransactionManager import SipTransactionManager\nfrom sippy.SipCallId import SipCallId\nfrom re import sub\nfrom time import time\nfrom urllib import quote\nfrom hashlib import md5\nfrom sippy.MyConfigParser import MyConfigParser\nimport gc, getopt, os, sys\n    id = 1\n    uaA = None\n    uaO = None\n    state = None\n    cId = None\n    cld = None\n    eTry = None\n    routes = None\n    remote_ip = None\n    source = None\n    acctA = None\n    acctO = None\n    global_config = None\n    rtp_proxy_session = None\n    huntstop_scodes = None\n    pass_headers = None\n    auth_proc = None\n    proxied = False\n    challenge = None\n\n    def __init__(self, remote_ip, source, global_config, pass_headers):\n        self.id = CallController.id\n        CallController.id += 1\n        self.global_config = global_config\n        self.uaA = UA(self.global_config, event_cb = self.recvEvent, conn_cbs = (self.aConn,), disc_cbs = (self.aDisc,), \\\n          fail_cbs = (self.aDisc,), dead_cbs = (self.aDead,))\n        self.uaA.kaInterval = self.global_config['keepalive_ans']\n        self.state = CCStateIdle\n        self.uaO = None\n        self.routes = []\n        self.remote_ip = remote_ip\n        self.source = source\n        self.pass_headers = pass_headers\n\n    def recvEvent(self, event, ua):\n        if ua == self.uaA:\n            if self.state == CCStateIdle:\n                if not isinstance(event, CCEventTry):\n                    # Some weird event received\n                    self.uaA.recvEvent(CCEventDisconnect(rtime = event.rtime))\n                    return\n                self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name = event.getData()\n                self.cGUID = cGUID.hexForm()\n                if self.cld == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Internal Server Error (1)'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if body == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Body-less INVITE is not supported'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if self.global_config.has_key('_allowed_pts'):\n                    try:\n                        body.parse()\n                    except:\n                        self.uaA.recvEvent(CCEventFail((400, 'Malformed SDP Body'), rtime = event.rtime))\n                        self.state = CCStateDead\n                        return\n                    allowed_pts = self.global_config['_allowed_pts']\n                    mbody = body.content.sections[0].m_header\n                    if mbody.transport.lower() == 'rtp/avp':\n                        mbody.formats = [x for x in mbody.formats if x in allowed_pts]\n                        if len(mbody.formats) == 0:\n                            self.uaA.recvEvent(CCEventFail((488, 'Not Acceptable Here')))\n                            self.state = CCStateDead\n                            return\n                if self.cld.startswith('nat-'):\n                    self.cld = self.cld[4:]\n                    body.content += 'a=nated:yes\\r\\n'\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('static_tr_in'):\n                    self.cld = re_replace(self.global_config['static_tr_in'], self.cld)\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('_rtp_proxy_clients'):\n                    self.rtp_proxy_session = Rtp_proxy_session(self.global_config, call_id = self.cId, \\\n                      notify_socket = global_config['b2bua_socket'], \\\n                      notify_tag = quote('r %s' % str(self.id)))\n                    self.rtp_proxy_session.callee_raddress = (self.remote_ip, 5060)\n                self.eTry = event\n                self.state = CCStateWaitRoute\n                if not self.global_config['auth_enable']:\n                    self.username = self.remote_ip\n                    self.rDone(((), 0))\n                elif auth == None or auth.username == None or len(auth.username) == 0:\n                    self.username = self.remote_ip\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(self.remote_ip, self.cli, self.cld, self.cGUID, \\\n                      self.cId, self.remote_ip, self.rDone)\n                else:\n                    self.username = auth.username\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(auth.username, self.cli, self.cld, self.cGUID, \n                      self.cId, self.remote_ip, self.rDone, auth.realm, auth.nonce, auth.uri, auth.response)\n                return\n            if self.state not in (CCStateARComplete, CCStateConnected, CCStateDisconnecting) or self.uaO == None:\n                return\n            self.uaO.recvEvent(event)\n        else:\n            if (isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect)) and self.state == CCStateARComplete and \\\n              (isinstance(self.uaA.state, UasStateTrying) or isinstance(self.uaA.state, UasStateRinging)) and len(self.routes) > 0:\n                if isinstance(event, CCEventFail):\n                    code = event.getData()[0]\n                else:\n                    code = None\n                if code == None or code not in self.huntstop_scodes:\n                    self.placeOriginate(self.routes.pop(0))\n                    return\n            self.uaA.recvEvent(event)\n\n    def rDone(self, results):\n        # Check that we got necessary result from Radius\n        if len(results) != 2 or results[1] != 0:\n            if isinstance(self.uaA.state, UasStateTrying):\n                if self.challenge != None:\n                    event = CCEventFail((401, 'Unauthorized'))\n                    event.extra_header = self.challenge\n                else:\n                    event = CCEventFail((403, 'Auth Failed'))\n                self.uaA.recvEvent(event)\n                self.state = CCStateDead\n            return\n        if self.global_config['acct_enable']:\nNext line of code:\n", "input": "from sippy.Timeout import Timeout\nfrom sippy.Signal import Signal\nfrom sippy.SipFrom import SipFrom\nfrom sippy.SipTo import SipTo\nfrom sippy.SipCiscoGUID import SipCiscoGUID\nfrom sippy.UA import UA\nfrom sippy.CCEvents import CCEventRing, CCEventConnect, CCEventDisconnect, CCEventTry, CCEventUpdate, CCEventFail\nfrom sippy.UasStateTrying import UasStateTrying\nfrom sippy.UasStateRinging import UasStateRinging\nfrom sippy.UaStateDead import UaStateDead\nfrom sippy.SipConf import SipConf\nfrom sippy.SipHeader import SipHeader\nfrom sippy.RadiusAuthorisation import RadiusAuthorisation\nfrom sippy.RadiusAccounting import RadiusAccounting\nfrom sippy.FakeAccounting import FakeAccounting\nfrom sippy.SipLogger import SipLogger\nfrom sippy.Rtp_proxy_session import Rtp_proxy_session\nfrom sippy.Rtp_proxy_client import Rtp_proxy_client\nfrom signal import SIGHUP, SIGPROF, SIGUSR1, SIGUSR2\nfrom twisted.internet import reactor\nfrom urllib import unquote\nfrom sippy.Cli_server_local import Cli_server_local\nfrom sippy.SipTransactionManager import SipTransactionManager\nfrom sippy.SipCallId import SipCallId\nfrom re import sub\nfrom time import time\nfrom urllib import quote\nfrom hashlib import md5\nfrom sippy.MyConfigParser import MyConfigParser\nimport gc, getopt, os, sys\n    id = 1\n    uaA = None\n    uaO = None\n    state = None\n    cId = None\n    cld = None\n    eTry = None\n    routes = None\n    remote_ip = None\n    source = None\n    acctA = None\n    acctO = None\n    global_config = None\n    rtp_proxy_session = None\n    huntstop_scodes = None\n    pass_headers = None\n    auth_proc = None\n    proxied = False\n    challenge = None\n\n    def __init__(self, remote_ip, source, global_config, pass_headers):\n        self.id = CallController.id\n        CallController.id += 1\n        self.global_config = global_config\n        self.uaA = UA(self.global_config, event_cb = self.recvEvent, conn_cbs = (self.aConn,), disc_cbs = (self.aDisc,), \\\n          fail_cbs = (self.aDisc,), dead_cbs = (self.aDead,))\n        self.uaA.kaInterval = self.global_config['keepalive_ans']\n        self.state = CCStateIdle\n        self.uaO = None\n        self.routes = []\n        self.remote_ip = remote_ip\n        self.source = source\n        self.pass_headers = pass_headers\n\n    def recvEvent(self, event, ua):\n        if ua == self.uaA:\n            if self.state == CCStateIdle:\n                if not isinstance(event, CCEventTry):\n                    # Some weird event received\n                    self.uaA.recvEvent(CCEventDisconnect(rtime = event.rtime))\n                    return\n                self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name = event.getData()\n                self.cGUID = cGUID.hexForm()\n                if self.cld == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Internal Server Error (1)'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if body == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Body-less INVITE is not supported'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if self.global_config.has_key('_allowed_pts'):\n                    try:\n                        body.parse()\n                    except:\n                        self.uaA.recvEvent(CCEventFail((400, 'Malformed SDP Body'), rtime = event.rtime))\n                        self.state = CCStateDead\n                        return\n                    allowed_pts = self.global_config['_allowed_pts']\n                    mbody = body.content.sections[0].m_header\n                    if mbody.transport.lower() == 'rtp/avp':\n                        mbody.formats = [x for x in mbody.formats if x in allowed_pts]\n                        if len(mbody.formats) == 0:\n                            self.uaA.recvEvent(CCEventFail((488, 'Not Acceptable Here')))\n                            self.state = CCStateDead\n                            return\n                if self.cld.startswith('nat-'):\n                    self.cld = self.cld[4:]\n                    body.content += 'a=nated:yes\\r\\n'\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('static_tr_in'):\n                    self.cld = re_replace(self.global_config['static_tr_in'], self.cld)\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('_rtp_proxy_clients'):\n                    self.rtp_proxy_session = Rtp_proxy_session(self.global_config, call_id = self.cId, \\\n                      notify_socket = global_config['b2bua_socket'], \\\n                      notify_tag = quote('r %s' % str(self.id)))\n                    self.rtp_proxy_session.callee_raddress = (self.remote_ip, 5060)\n                self.eTry = event\n                self.state = CCStateWaitRoute\n                if not self.global_config['auth_enable']:\n                    self.username = self.remote_ip\n                    self.rDone(((), 0))\n                elif auth == None or auth.username == None or len(auth.username) == 0:\n                    self.username = self.remote_ip\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(self.remote_ip, self.cli, self.cld, self.cGUID, \\\n                      self.cId, self.remote_ip, self.rDone)\n                else:\n                    self.username = auth.username\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(auth.username, self.cli, self.cld, self.cGUID, \n                      self.cId, self.remote_ip, self.rDone, auth.realm, auth.nonce, auth.uri, auth.response)\n                return\n            if self.state not in (CCStateARComplete, CCStateConnected, CCStateDisconnecting) or self.uaO == None:\n                return\n            self.uaO.recvEvent(event)\n        else:\n            if (isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect)) and self.state == CCStateARComplete and \\\n              (isinstance(self.uaA.state, UasStateTrying) or isinstance(self.uaA.state, UasStateRinging)) and len(self.routes) > 0:\n                if isinstance(event, CCEventFail):\n                    code = event.getData()[0]\n                else:\n                    code = None\n                if code == None or code not in self.huntstop_scodes:\n                    self.placeOriginate(self.routes.pop(0))\n                    return\n            self.uaA.recvEvent(event)\n\n    def rDone(self, results):\n        # Check that we got necessary result from Radius\n        if len(results) != 2 or results[1] != 0:\n            if isinstance(self.uaA.state, UasStateTrying):\n                if self.challenge != None:\n                    event = CCEventFail((401, 'Unauthorized'))\n                    event.extra_header = self.challenge\n                else:\n                    event = CCEventFail((403, 'Auth Failed'))\n                self.uaA.recvEvent(event)\n                self.state = CCStateDead\n            return\n        if self.global_config['acct_enable']:\n", "context": "sippy/Rtp_proxy_session.py\nclass Rtp_proxy_session(object):\n    rtp_proxy_client = None\n    call_id = None\n    from_tag = None\n    to_tag = None\n    caller_session_exists = False\n    caller_codecs = None\n    caller_raddress = None\n    callee_session_exists = False\n    callee_codecs = None\n    callee_raddress = None\n    max_index = -1\n    origin = None\n    notify_socket = None\n    notify_tag = None\n    global_config = None\n\n    def __init__(self, global_config, call_id = None, from_tag = None, to_tag = None,\n      notify_socket = None, notify_tag = None):\n        self.global_config = global_config\n        if global_config.has_key('_rtp_proxy_clients'):\n            rtp_proxy_clients = [x for x in global_config['_rtp_proxy_clients'] if x.online]\n            n = len(rtp_proxy_clients)\n            if n == 0:\n                raise Exception('No online RTP proxy client has been found')\n            self.rtp_proxy_client = rtp_proxy_clients[int(random() * n)]\n        else:\n            self.rtp_proxy_client = global_config['rtp_proxy_client']\n            if not self.rtp_proxy_client.online:\n                raise Exception('No online RTP proxy client has been found')\n        if call_id != None:\n            self.call_id = call_id\n        else:\n            self.call_id = md5(str(random()) + str(time())).hexdigest()\n        if from_tag != None:\n            self.from_tag = from_tag\n        else:\n            self.from_tag = md5(str(random()) + str(time())).hexdigest()\n        if to_tag != None:\n            self.to_tag = to_tag\n        else:\n            self.to_tag = md5(str(random()) + str(time())).hexdigest()\n        self.origin = SdpOrigin()\n        self.notify_socket = notify_socket\n        self.notify_tag = notify_tag\n\n    def version(self, result_callback):\n        self.rtp_proxy_client.send_command('V', self.version_result, result_callback)\n\n    def version_result(self, result, result_callback):\n        result_callback(result)\n\n    def play_caller(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._play_caller, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_caller(None, prompt_name, times, result_callback, index)\n\n    def _play_caller(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.caller_codecs, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def play_callee(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            return\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._play_callee, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_callee(None, prompt_name, times, result_callback, index)\n\n    def _play_callee(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.callee_codecs, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_caller(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_callee(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_caller(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._copy_caller, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_caller(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_caller(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_callee(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._copy_callee, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_callee(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_callee(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def start_recording(self, rname = None, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._start_recording, '', index, rname, result_callback, index)\n            return\n        self._start_recording(None, rname, result_callback, index)\n\n    def _start_recording(self, result, rname, result_callback, index):\n        if rname == None:\n            command = 'R %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n            return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n        command = 'C %s %s.a %s %s' % ('%s-%d' % (self.call_id, index), rname, self.from_tag, self.to_tag)\n        return self.rtp_proxy_client.send_command(command, self._start_recording1, \\\n          (rname, result_callback, index))\n\n    def _start_recording1(self, result, args):\n        rname, result_callback, index = args\n        command = 'C %s %s.o %s %s' % ('%s-%d' % (self.call_id, index), rname, self.to_tag, self.from_tag)\n        return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def command_result(self, result, result_callback):\n        if result_callback != None:\n            result_callback(result)\n\n    def update_caller(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.caller_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.caller_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.caller_raddress[0]\n        command += options\n        command += ' %s %s %d %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag)\n        if self.caller_session_exists:\n            command += ' %s' % self.to_tag\n        if self.notify_socket != None and index == 0 and \\\n          self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'caller', callback_parameters))\n\n    def update_callee(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.callee_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.callee_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.callee_raddress[0]\n        command += options\n        command += ' %s %s %d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        if self.notify_socket != None and index == 0 \\\n          and self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'callee', callback_parameters))\n\n    def update_result(self, result, args):\n        result_callback, face, callback_parameters = args\n        if face == 'caller':\n            self.caller_session_exists = True\n        else:\n            self.callee_session_exists = True\n        if result == None:\n            result_callback(None, *callback_parameters)\n            return\n        t1 = result.split()\n        rtpproxy_port = int(t1[0])\n        if rtpproxy_port == 0:\n            result_callback(None, *callback_parameters)\n        family = 'IP4'\n        if len(t1) > 1:\n            rtpproxy_address = t1[1]\n            if len(t1) > 2 and t1[2] == '6':\n                family = 'IP6'\n        else:\n            rtpproxy_address = self.rtp_proxy_client.proxy_address\n        result_callback((rtpproxy_address, rtpproxy_port, family), *callback_parameters)\n\n    def delete(self):\n        while self.max_index >= 0:\n            command = 'D %s %s %s' % ('%s-%d' % (self.call_id, self.max_index), self.from_tag, self.to_tag)\n            self.rtp_proxy_client.send_command(command)\n            self.max_index -= 1\n\n    def on_caller_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_caller, sdp_body, result_callback)\n\n    def on_callee_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_callee, sdp_body, result_callback)\n\n    def on_xxx_sdp_change(self, update_xxx, sdp_body, result_callback):\n        sects = []\n        try:\n            sdp_body.parse()\n        except Exception, exception:\n            print datetime.now(), 'can\\'t parse SDP body: %s:' % str(exception)\n            print '-' * 70\n            print_exc(file = sys.stdout)\n            print '-' * 70\n            print sdp_body.content\n            print '-' * 70\n            sys.stdout.flush()\n            return\n        for i in range(0, len(sdp_body.content.sections)):\n            sect = sdp_body.content.sections[i]\n            if sect.m_header.transport.lower() not in ('udp', 'udptl', 'rtp/avp'):\n                continue\n            sects.append(sect)\n        if len(sects) == 0:\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n            return\n        formats = sects[0].m_header.formats\n        if update_xxx == self.update_caller:\n            if len(formats) > 1:\n                self.caller_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.caller_codecs = str(formats[0])\n        else:\n            if len(formats) > 1:\n                self.callee_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.callee_codecs = str(formats[0])\n        for sect in sects:\n            options = ''\n            if sect.c_header.atype == 'IP6':\n                options = '6'\n            update_xxx(sect.c_header.addr, sect.m_header.port, self.xxx_sdp_change_finish, options, \\\n              sects.index(sect), sdp_body, sect, sects, result_callback)\n        return\n\n    def xxx_sdp_change_finish(self, address_port, sdp_body, sect, sects, result_callback):\n        sect.needs_update = False\n        if address_port != None:\n            sect.c_header.atype = address_port[2]\n            sect.c_header.addr = address_port[0]\n            if sect.m_header.port != 0:\n                sect.m_header.port = address_port[1]\n        if len([x for x in sects if x.needs_update]) == 0:\n            sdp_body.content.o_header = self.origin\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n\n    def __del__(self):\n        self.delete()\n        self.rtp_proxy_client = None\nsippy/Signal.py\nclass Signal(object):\n    callback = None\n    parameters = None\n    previous_handler = None\n\n    def __init__(self, signum, callback, *parameters):\n        self.callback = callback\n        self.parameters = parameters\n        self.previous_handler = signal(signum, self.signal_handler)\n\n    def signal_handler(self, signum, *frame):\n        try:\n            reactor.callFromThread(self.callback, *self.parameters)\n        except:\n            print datetime.now(), 'Signal: unhandled exception in signal callback'\n            print '-' * 70\n            print_exc(file = stdout)\n            print '-' * 70\n            stdout.flush()\n        if self.previous_handler not in (SIG_IGN, SIG_DFL):\n            try:\n                self.previous_handler(signum, *frame)\n            except:\n                print datetime.now(), 'Signal: unhandled exception in signal chain'\n                print '-' * 70\n                print_exc(file = stdout)\n                print '-' * 70\n                stdout.flush()\nsippy/SipCiscoGUID.py\nclass SipCiscoGUID(SipGenericHF):\n    hf_names = ('cisco-guid', 'h323-conf-id')\n    ciscoGUID = None\n\n    def __init__(self, body = None, ciscoGUID = None):\n        SipGenericHF.__init__(self, body)\n        if body != None:\n            return\n        self.parsed = True\n        if ciscoGUID != None:\n            self.ciscoGUID = ciscoGUID\n        else:\n            s = md5(str((random() * 1000000000L) + time())).hexdigest()\n            self.ciscoGUID = (long(s[0:8], 16), long(s[8:16], 16), long(s[16:24], 16), long(s[24:32], 16))\n\n    def parse(self):\n        self.parsed = True\n        self.ciscoGUID = tuple([int(x) for x in  self.body.split('-', 3)])\n\n    def __str__(self):\n        if not self.parsed:\n            return self.body\n        return '%d-%d-%d-%d' % self.ciscoGUID\n\n    def getCiscoGUID(self):\n        return self.ciscoGUID\n\n    def hexForm(self):\n        return '%.8X %.8X %.8X %.8X' % self.ciscoGUID\n\n    def getCanName(self, name, compact = False):\n        if name.lower() == 'h323-conf-id':\n            return 'h323-conf-id'\n        else:\n            return 'cisco-GUID'\n\n    def getCopy(self):\n        if not self.parsed:\n            return SipCiscoGUID(self.body)\n        return SipCiscoGUID(ciscoGUID = self.ciscoGUID)\nsippy/SipHeader.py\nclass SipHeader(object):\n    name = None\n    body = None\n\n    def __init__(self, s = None, name = None, body = None, bodys = None, fixname = False):\n        if s != None:\n            name, bodys = [x.strip() for x in s.split(':', 1)]\n        if name != None:\n            self.name = name.lower()\n        if body == None:\n            try:\n                try:\n                    body = hf_types[self.name](bodys)\n                except KeyError:\n                    body = SipGenericHF(bodys, name)\n            except ESipHeaderCSV, einst:\n                einst.name = self.name\n                raise einst\n        self.body = body\n        # If no name is provided use canonic name from the body-specific\n        # class.\n        if self.name == None or fixname:\n            self.name = body.hf_names[0]\n\n    def __str__(self):\n        return str(self.body.getCanName(self.name)) + ': ' + str(self.body)\n\n    def localStr(self, local_addr = None, local_port = None, compact = False):\n        return str(self.body.getCanName(self.name, compact)) + ': ' + \\\n          self.body.localStr(local_addr, local_port)\n\n    def getBody(self):\n        if not self.body.parsed:\n            self.body.parse()\n        return self.body\nsippy/SipFrom.py\nclass SipFrom(SipAddressHF):\n    hf_names = ('from', 'f')\n\n    def __init__(self, body = None, address = None):\n        SipAddressHF.__init__(self, body, address)\n        if body == None and address == None:\n            self.address = SipAddress(name = 'Anonymous', url = SipURL(host = SipConf.my_address, port = SipConf.my_port))\n\n    def getTag(self):\n        return self.address.getParam('tag')\n\n    def genTag(self):\n        self.address.setParam('tag', md5(str((random() * 1000000000L) + time())).hexdigest())\n\n    def setTag(self, value):\n        self.address.setParam('tag', value)\n\n    def delTag(self):\n        self.address.delParam('tag')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 'f'\n        return 'From'\nsippy/CCEvents.py\nclass CCEventDisconnect(CCEventGeneric):\n    name = 'CCEventDisconnect'\n    pass\nsippy/UA.py\nclass UA(object):\n    global_config = None\n    state = None\n    event_cb = None\n    uasReq = None\n    uacResp = None\n    username = None\n    password = None\n    equeue = None\n    dId = None\n    credit_time = None\n    credit_times = None\n    credit_timer = None\n    conn_cbs = None\n    disc_cbs = None\n    fail_cbs = None\n    ring_cbs = None\n    dead_cbs = None\n    rCSeq = None\n    lTag = None\n    lUri = None\n    rUri = None\n    cId = None\n    lCSeq = None\n    lContact = None\n    cGUID = None\n    rAddr = None\n    rAddr0 = None\n    routes = None\n    rTarget = None\n    uasResp = None\n    lSDP = None\n    rSDP = None\n    kaInterval = 0\n    branch = None\n    reqs = None\n    extra_headers = None\n    useRefer = True\n    expire_time = None\n    expire_timer = None\n    no_progress_time = None\n    no_progress_timer = None\n    no_reply_time = None\n    no_reply_timer = None\n    on_local_sdp_change = None\n    on_remote_sdp_change = None\n    last_scode = 100\n    setup_ts = None\n    p100_ts = None\n    p1xx_ts = None\n    connect_ts = None\n    disconnect_ts = None\n    user_agent = None\n    elast_seq = None\n    origin = None\n    source_address = None\n\n    def __init__(self, global_config, event_cb = None, username = None, password = None, nh_address = None, credit_time = None, \\\n      conn_cbs = None, disc_cbs = None, fail_cbs = None, ring_cbs = None, dead_cbs = None, ltag = None, extra_headers = None, \\\n      expire_time = None, no_progress_time = None):\n        self.global_config = global_config\n        self.event_cb = event_cb\n        self.equeue = []\n        self.username = username\n        self.password = password\n        self.rAddr = nh_address\n        self.rAddr0 = self.rAddr\n        self.credit_time = credit_time\n        self.credit_times = {}\n        if conn_cbs != None:\n            self.conn_cbs = conn_cbs\n        else:\n            self.conn_cbs = ()\n        if disc_cbs != None:\n            self.disc_cbs = disc_cbs\n        else:\n            self.disc_cbs = ()\n        if fail_cbs != None:\n            self.fail_cbs = fail_cbs\n        else:\n            self.fail_cbs = ()\n        if ring_cbs != None:\n            self.ring_cbs = ring_cbs\n        else:\n            self.ring_cbs = ()\n        if dead_cbs != None:\n            self.dead_cbs = dead_cbs\n        else:\n            self.dead_cbs = ()\n        if ltag != None:\n            self.lTag = ltag\n        else:\n            self.lTag = md5(str((random() * 1000000000L) + time())).hexdigest()\n        self.reqs = {}\n        self.extra_headers = extra_headers\n        self.expire_time = expire_time\n        self.no_progress_time = no_progress_time\n        #print self.username, self.password\n\n    def recvRequest(self, req):\n        #print 'Received request %s in state %s instance %s' % (req.getMethod(), self.state, self)\n        #print self.rCSeq, req.getHFBody('cseq').getCSeqNum()\n        if self.user_agent == None:\n            self.update_ua(req)\n        if self.rCSeq != None and self.rCSeq >= req.getHFBody('cseq').getCSeqNum():\n            return (req.genResponse(500, 'Server Internal Error'), None, None)\n        self.rCSeq = req.getHFBody('cseq').getCSeqNum()\n        if self.state == None:\n            if req.getMethod() == 'INVITE':\n                self.changeState((UasStateIdle,))\n            else:\n                return None\n        newstate = self.state.recvRequest(req)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n        if newstate != None and req.getMethod() == 'INVITE':\n            return (None, self.state.cancel, self.disconnect)\n        else:\n            return None\n\n    def recvResponse(self, resp):\n        if self.state == None:\n            return\n        self.update_ua(resp)\n        code, reason = resp.getSCode()\n        cseq, method = resp.getHFBody('cseq').getCSeq()\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 401 and resp.countHFs('www-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('authorization') == 0:\n            challenge = resp.getHFBody('www-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm())\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 407 and resp.countHFs('proxy-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('proxy-authorization') == 0:\n            challenge = resp.getHFBody('proxy-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm(), SipProxyAuthorization)\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if code >= 200 and self.reqs.has_key(cseq):\n            del self.reqs[cseq]\n        newstate = self.state.recvResponse(resp)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def recvEvent(self, event):\n        #print self, event\n        if self.state == None:\n            if isinstance(event, CCEventTry) or isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect):\n                self.changeState((UacStateIdle,))\n            else:\n                return\n        newstate = self.state.recvEvent(event)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def disconnect(self, rtime = None):\n        if rtime == None:\n            rtime = time()\n        self.equeue.append(CCEventDisconnect(rtime = rtime))\n        self.recvEvent(CCEventDisconnect(rtime = rtime))\n\n    def expires(self):\n        self.expire_timer = None\n        self.disconnect()\n\n    def no_progress_expires(self):\n        self.no_progress_timer = None\n        self.disconnect()\n\n    def no_reply_expires(self):\n        self.no_reply_timer = None\n        self.disconnect()\n\n    def credit_expires(self, rtime):\n        self.credit_timer = None\n        self.disconnect(rtime)\n\n    def changeState(self, newstate):\n        if self.state != None:\n            self.state.onStateChange(newstate[0])\n        self.state = newstate[0](self)\n        if len(newstate) > 1:\n            for callback in newstate[1]:\n                callback(self, *newstate[2:])\n\n    def emitEvent(self, event):\n        if self.event_cb != None:\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                return\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def emitPendingEvents(self):\n        while len(self.equeue) != 0 and self.event_cb != None:\n            event = self.equeue.pop(0)\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                continue\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def genRequest(self, method, body = None, nonce = None, realm = None, SipXXXAuthorization = SipAuthorization, \\\n      reason = None):\n        req = SipRequest(method = method, ruri = self.rTarget, to = self.rUri, fr0m = self.lUri,\n                         cseq = self.lCSeq, callid = self.cId, contact = self.lContact,\n                         routes = self.routes, target = self.rAddr, cguid = self.cGUID)\n        if nonce != None and realm != None and self.username != None and self.password != None:\n            auth = SipXXXAuthorization(realm = realm, nonce = nonce, method = method, uri = str(self.rTarget),\n              username = self.username, password = self.password)\n            req.appendHeader(SipHeader(body = auth))\n        if body != None:\n            req.setBody(body)\n        if self.extra_headers != None:\n            req.appendHeaders(self.extra_headers)\n        if reason != None:\n            req.appendHeader(SipHeader(body = reason))\n        self.reqs[self.lCSeq] = req\n        return req\n\n    def sendUasResponse(self, scode, reason, body = None, contact = None, \\\n      reason_rfc3326 = None, extra_header = None):\n        self.uasResp.setSCode(scode, reason)\n        self.uasResp.setBody(body)\n        self.uasResp.delHFs('www-authenticate')\n        self.uasResp.delHFs('contact')\n        self.uasResp.delHFs('reason')\n        if contact != None:\n            self.uasResp.appendHeader(SipHeader(name = 'contact', body = contact))\n        if reason_rfc3326 != None:\n            self.uasResp.appendHeader(SipHeader(body = reason_rfc3326))\n        if extra_header != None:\n            self.uasResp.appendHeader(extra_header)\n        self.global_config['_sip_tm'].sendResponse(self.uasResp)\n\n    def isYours(self, req = None, call_id = None, from_tag = None, to_tag = None):\n        #print self.branch, req.getHFBody('via').getBranch()\n        if req != None:\n            if req.getMethod() != 'BYE' and self.branch != None and \\\n              self.branch != req.getHFBody('via').getBranch():\n                return None\n            call_id = str(req.getHFBody('call-id'))\n            from_tag = req.getHFBody('from').getTag()\n            to_tag = req.getHFBody('to').getTag()\n        #print str(self.cId), call_id\n        if call_id != str(self.cId):\n            return None\n        #print self.rUri.getTag(), from_tag\n        if self.rUri != None and self.rUri.getTag() != from_tag:\n            return None\n        #print self.lUri.getTag(), to_tag\n        if self.lUri != None and self.lUri.getTag() != to_tag:\n            return None\n        return self\n\n    def isDead(self):\n        if self.state != None:\n            return self.state.dead\n        return False\n\n    def isConnected(self):\n        if self.state != None:\n            return self.state.connected\n        return False\n\n    def getCLD(self):\n        if self.rUri == None:\n            return None\n        return self.rUri.getUrl().username\n\n    def getCLI(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUrl().username\n\n    def getCallingName(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUri().name\n\n    def getRAddr0(self):\n        return self.rAddr0\n\n    def getCID(self):\n        # Return tuple containing call-id, local tag and remote tag\n        rval = [str(self.cId), None, None]\n        if self.lUri != None:\n            rval[1] = self.lUri.getTag()\n        if self.rUri != None:\n            rval[2] = self.rUri.getTag()\n        return tuple(rval)\n\n    def delayed_remote_sdp_update(self, event, remote_sdp_body):\n        self.rSDP = remote_sdp_body.getCopy()\n        self.equeue.append(event)\n        self.emitPendingEvents()\n\n    def getAcct(self):\n        if self.disconnect_ts != None:\n            disconnect_ts = self.disconnect_ts\n            disconnected = True\n        else:\n            disconnect_ts = time()\n            disconnected = False\n        if self.connect_ts != None:\n            return (disconnect_ts - self.connect_ts, self.connect_ts - self.setup_ts, True, disconnected)\n        return (0, disconnect_ts - self.setup_ts, False, disconnected)\n\n    def update_ua(self, msg):\n        if msg.countHFs('user-agent') > 0:\n            self.user_agent = msg.getHFBody('user-agent').name\n        elif msg.countHFs('server') > 0:\n            self.user_agent = msg.getHFBody('server').name\n        return\n\n    def cancelCreditTimer(self):\n        if self.credit_timer != None:\n            self.credit_timer.cancel()\n            self.credit_timer = None\n\n    def startCreditTimer(self, rtime):\n        if self.credit_time != None:\n            self.credit_times[0] = rtime + self.credit_time\n            self.credit_time = None\n        try:\n            credit_time = min([x for x in self.credit_times.values() if x != None])\n        except ValueError:\n            return\n        self.credit_timer = TimeoutAbs(self.credit_expires, credit_time, credit_time)\n\n    def resetCreditTime(self, rtime, new_credit_times):\n        self.credit_times.update(new_credit_times)\n        if self.state.connected:\n            self.cancelCreditTimer()\n            self.startCreditTimer(rtime)\n\n    def cleanup(self):\n        pass\nsippy/CCEvents.py\nclass CCEventTry(CCEventGeneric):\n    name = 'CCEventTry'\n    pass\nsippy/RadiusAuthorisation.py\nclass RadiusAuthorisation(Radius_client):\n    def do_auth(self, username, caller, callee, h323_cid, sip_cid, remote_ip, res_cb, \\\n      realm = None, nonce = None, uri = None, response = None, extra_attributes = None):\n        sip_cid = str(sip_cid)\n        attributes = None\n        if None not in (realm, nonce, uri, response):\n            attributes = [('User-Name', username), ('Digest-Realm', realm), \\\n              ('Digest-Nonce', nonce), ('Digest-Method', 'INVITE'), ('Digest-URI', uri), \\\n              ('Digest-Algorithm', 'MD5'), ('Digest-User-Name', username), ('Digest-Response', response)]\n        else:\n            attributes = [('User-Name', remote_ip), ('Password', 'cisco')]\n        if caller == None:\n            caller = ''\n        attributes.extend((('Calling-Station-Id', caller), ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), \\\n          ('call-id', sip_cid), ('h323-remote-address', remote_ip), ('h323-session-protocol', 'sipv2')))\n        if extra_attributes != None:\n            for a, v in extra_attributes:\n                attributes.append((a, v))\n        message = 'sending AAA request:\\n' \n        message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes])\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        Radius_client.do_auth(self, attributes, self._process_result, res_cb, sip_cid, time())\n\n    def _process_result(self, results, res_cb, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'AAA request accepted (delay is %.3f), processing response:\\n' % delay\n            else:\n                message = 'AAA request rejected (delay is %.3f), processing response:\\n' % delay\n            if len(results[0]) > 0:\n                message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % x for x in results[0]])\n        else:\n            message = 'Error sending AAA request (delay is %.3f)\\n' % delay\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        res_cb(results)\nsippy/CCEvents.py\nclass CCEventConnect(CCEventGeneric):\n    name = 'CCEventConnect'\n    pass\nsippy/UasStateTrying.py\nclass UasStateTrying(UaStateGeneric):\n    sname = 'Trying(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body)\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n                if self.ua.expire_time != None:\n                    self.ua.expire_timer = TimeoutAbs(self.ua.expires, self.ua.expire_time)\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            return (UasStateRinging, self.ua.ring_cbs, event.rtime, event.origin, code)\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Trying state' % event\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/SipTo.py\nclass SipTo(SipFrom):\n    hf_names = ('to', 't')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 't'\n        return 'To'\nsippy/CCEvents.py\nclass CCEventUpdate(CCEventGeneric):\n    name = 'CCEventUpdate'\n    pass\nsippy/SipLogger.py\nclass SipLogger(object):\n    app = None\n    call_id = None\n    log = None\n    level = None\n    flock = lambda x, y, z: None\n\n    def __init__(self, app, call_id = 'GLOBAL', logfile = '/var/log/sip.log'):\n        self.app = app\n        self.call_id = call_id\n        bend = os.environ.get('SIPLOG_BEND', 'stderr').lower()\n        if bend == 'stderr':\n            self.log = sys.__stderr__\n        elif bend == 'none':\n            self.write = self.donoting\n        else:\n            logfile = os.environ.get('SIPLOG_LOGFILE_FILE', logfile)\n            self.log = file(logfile, 'a')\n            self.flock = flock\n            Signal(SIGUSR1, self.reopen, logfile)\n        self.level = eval('SIPLOG_' + os.environ.get('SIPLOG_LVL', 'INFO'))\n\n    def donoting(self, *args, **kwargs):\n        pass\n\n    def write(self, *args, **kwargs):\n        if kwargs.get('level', SIPLOG_INFO) < self.level:\n            return\n        ltime = kwargs.get('ltime', None)\n        if ltime == None:\n            ltime = time()\n        call_id = kwargs.get('call_id', self.call_id)\n        obuf = '%s.%.3d/%s/%s: %s\\n' % (strftime('%d %b %H:%M:%S', localtime(ltime)), \\\n          (ltime % 1) * 1000, call_id, self.app, \\\n          reduce(lambda x, y: x + y, [str(x) for x in args]))\n        try:\n            self.flock(self.log, LOCK_EX)\n        except IOError, e:\n            # Catch ENOTSUP\n            if e.args[0] != 45:\n                raise e\n            self.flock = lambda x, y: None\n        try:\n            self.log.write(obuf)\n        except IOError, e:\n            if e.args[0] != EINTR:\n                raise e\n        self.log.flush()\n        self.flock(self.log, LOCK_UN)\n\n    def reopen(self, logfile):\n        self.log = file(logfile, 'a')\nsippy/CCEvents.py\nclass CCEventFail(CCEventGeneric):\n    name = 'CCEventFail'\n    pass\nsippy/UasStateRinging.py\nclass UasStateRinging(UaStateGeneric):\n    sname = 'Ringing(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            self.ua.sendUasResponse(code, reason, body)\n            for ring_cb in self.ua.ring_cbs:\n                ring_cb(self.ua, event.rtime, event.origin, code)\n            return None\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Ringing state' % event\n        return None\n\n    def recvRequest(self, req):\n        if req.getMethod() == 'BYE':\n            self.ua.sendUasResponse(487, 'Request Terminated')\n            self.ua.global_config['_sip_tm'].sendResponse(req.genResponse(200, 'OK'))\n            #print 'BYE received in the Ringing state, going to the Disconnected state'\n            if req.countHFs('also') > 0:\n                also = req.getHFBody('also').getUrl().getCopy()\n            else:\n                also = None\n            event = CCEventDisconnect(also, rtime = req.rtime, origin = self.ua.origin)\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n            self.ua.equeue.append(event)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = req.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, req.rtime, self.ua.origin)\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/RadiusAccounting.py\nclass RadiusAccounting(object):\n    global_config = None\n    drec = None\n    crec = None\n    iTime = None\n    cTime = None\n    sip_cid = None\n    origin = None\n    lperiod = None\n    el = None\n    send_start = None\n    complete = False\n    ms_precision = False\n    user_agent = None\n    p1xx_ts = None\n    p100_ts = None\n\n    def __init__(self, global_config, origin, lperiod = None, send_start = False):\n        self.global_config = global_config\n        self._attributes = [('h323-call-origin', origin), ('h323-call-type', 'VoIP'), \\\n          ('h323-session-protocol', 'sipv2')]\n        self.drec = False\n        self.crec = False\n        self.origin = origin\n        self.lperiod = lperiod\n        self.send_start = send_start\n\n    def setParams(self, username, caller, callee, h323_cid, sip_cid, remote_ip, \\\n      h323_in_cid = None):\n        if caller == None:\n            caller = ''\n        self._attributes.extend((('User-Name', username), ('Calling-Station-Id', caller), \\\n          ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), ('call-id', sip_cid), \\\n          ('Acct-Session-Id', sip_cid), ('h323-remote-address', remote_ip)))\n        if h323_in_cid != None and h323_in_cid != h323_cid:\n            self._attributes.append(('h323-incoming-conf-id', h323_in_cid))\n        self.sip_cid = str(sip_cid)\n        self.complete = True\n\n    def conn(self, ua, rtime, origin):\n        if self.crec:\n            return\n        self.crec = True\n        self.iTime = ua.setup_ts\n        self.cTime = ua.connect_ts\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        if self.send_start:\n            self.asend('Start', rtime, origin, ua)\n        self._attributes.extend((('h323-voice-quality', 0), ('Acct-Terminate-Cause', 'User-Request')))\n        if self.lperiod != None and self.lperiod > 0:\n            self.el = Timeout(self.asend, self.lperiod, -1, 'Alive')\n\n    def disc(self, ua, rtime, origin, result = 0):\n        if self.drec:\n            return\n        self.drec = True\n        if self.el != None:\n            self.el.cancel()\n            self.el = None\n        if self.iTime == None:\n            self.iTime = ua.setup_ts\n        if self.cTime == None:\n            self.cTime = rtime\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        self.asend('Stop', rtime, origin, result, ua)\n\n    def asend(self, type, rtime = None, origin = None, result = 0, ua = None):\n        if not self.complete:\n            return\n        if rtime == None:\n            rtime = time()\n        if ua != None:\n            duration, delay, connected = ua.getAcct()[:3]\n        else:\n            # Alive accounting\n            duration = rtime - self.cTime\n            delay = self.cTime - self.iTime\n            connected = True\n        if not(self.ms_precision):\n            duration = round(duration)\n            delay = round(delay)\n        attributes = self._attributes[:]\n        if type != 'Start':\n            if result >= 400:\n                try:\n                    dc = sipErrToH323Err[result][0]\n                except:\n                    dc = '7f'\n            elif result < 200:\n                dc = '10'\n            else:\n                dc = '0'\n            attributes.extend((('h323-disconnect-time', self.ftime(self.iTime + delay + duration)), \\\n              ('Acct-Session-Time', '%d' % round(duration)), ('h323-disconnect-cause', dc)))\n        if type == 'Stop':\n            if origin == 'caller':\n                release_source = '2'\n            elif origin == 'callee':\n                release_source = '4'\n            else:\n                release_source = '8'\n            attributes.append(('release-source', release_source))\n        attributes.extend((('h323-connect-time', self.ftime(self.iTime + delay)), ('h323-setup-time', self.ftime(self.iTime)), \\\n          ('Acct-Status-Type', type)))\n        if self.user_agent != None:\n            attributes.append(('h323-ivr-out', 'sip_ua:' + self.user_agent))\n        if self.p1xx_ts != None:\n            attributes.append(('Acct-Delay-Time', round(self.p1xx_ts)))\n        if self.p100_ts != None:\n            attributes.append(('provisional-timepoint', self.ftime(self.p100_ts)))\n        pattributes = ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes]\n        pattributes.insert(0, 'sending Acct %s (%s):\\n' % (type, self.origin.capitalize()))\n        self.global_config['_sip_logger'].write(call_id = self.sip_cid, *pattributes)\n        self.global_config['_radius_client'].do_acct(attributes, self._process_result, self.sip_cid, time())\n\n    def ftime(self, t):\n        gt = gmtime(t)\n        day = strftime('%d', gt)\n        if day[0] == '0':\n            day = day[1]\n        if self.ms_precision:\n            msec = (t % 1) * 1000\n        else:\n            msec = 0\n        return strftime('%%H:%%M:%%S.%.3d GMT %%a %%b %s %%Y' % (msec, day), gt)\n\n    def _process_result(self, results, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'Acct/%s request accepted (delay is %.3f)\\n' % (self.origin, delay)\n            else:\n                message = 'Acct/%s request rejected (delay is %.3f)\\n' % (self.origin, delay)\n        else:\n            message = 'Error sending Acct/%s request (delay is %.3f)\\n' % (self.origin, delay)\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\nsippy/MyConfigParser.py\nclass MyConfigParser(RawConfigParser):\n    default_section = None\n    _private_keys = None\n\n    def __init__(self, default_section = 'general'):\n        self.default_section = default_section\n        self._private_keys = {}\n        RawConfigParser.__init__(self)\n        self.add_section(self.default_section)\n\n    def __getitem__(self, key):\n        if key.startswith('_'):\n            return self._private_keys[key]\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type  == 'B':\n            return self.getboolean(self.default_section, key)\n        elif value_type == 'I':\n            return self.getint(self.default_section, key)\n        return self.get(self.default_section, key)\n\n    def __setitem__(self, key, value):\n        if key.startswith('_'):\n            self._private_keys[key] = value\n        else:\n            self.set(self.default_section, key, str(value))\n        return\n\n    def has_key(self, key):\n        return self.__contains__(key)\n\n    def __contains__(self, key):\n        if key.startswith('_'):\n            return self._private_keys.has_key(key)\n        return self.has_option(self.default_section, key)\n\n    def get(self, *args):\n        if len(args) == 1:\n            return self.__getitem__(args[0])\n        return RawConfigParser.get(self, *args)\n\n    def getdefault(self, key, default_value):\n        if self.__contains__(key):\n            return self.__getitem__(key)\n        return default_value\n\n    def get_longopts(self):\n        return tuple([x + '=' for x in SUPPORTED_OPTIONS.keys()])\n\n    def read(self, fname):\n        RawConfigParser.readfp(self, open(fname))\n        for key in tuple(self.options(self.default_section)):\n            self.check_and_set(key, RawConfigParser.get(self, \\\n              self.default_section, key), False)\n\n    def check_and_set(self, key, value, compat = True):\n        value = value.strip()\n        if compat:\n            if key == 'rtp_proxy_client':\n                # XXX compatibility option\n                if self.has_key('_rtp_proxy_clients'):\n                    self['_rtp_proxy_clients'].append(value)\n                else:\n                    self['_rtp_proxy_clients'] = [value,]\n                if self.has_key('rtp_proxy_clients'):\n                    self['rtp_proxy_clients'] += ',' + value\n                else:\n                    self['rtp_proxy_clients'] = value\n                return\n            elif key == 'pass_header':\n                # XXX compatibility option\n                if self.has_key('_pass_headers'):\n                    self['_pass_headers'].append(value)\n                else:\n                    self['_pass_headers'] = [value,]\n                if self.has_key('pass_headers'):\n                    self['pass_headers'] += ',' + value\n                else:\n                    self['pass_headers'] = value\n                return\n\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type == 'B':\n            if value.lower() not in self._boolean_states:\n                raise ValueError, 'Not a boolean: %s' % value\n        elif value_type == 'I':\n            _value = int(value)\n        if key in ('keepalive_ans', 'keepalive_orig'):\n            if _value < 0:\n                raise ValueError, 'keepalive_ans should be non-negative'\n        elif key == 'max_credit_time':\n            if _value <= 0:\n                raise ValueError, 'max_credit_time should be more than zero'\n        elif key == 'allowed_pts':\n            self['_allowed_pts'] = [int(x) for x in value.split(',')]\n        elif key in ('accept_ips', 'pass_headers', 'rtp_proxy_clients'):\n            self['_' + key] = [x.strip() for x in value.split(',')]\n        elif key == 'sip_address':\n            if 'my' in dir(value):\n                self['_sip_address'] = value\n                value = '*'\n            elif value in ('*', '0.0.0.0', '::'):\n                self['_sip_address'] = SipConf.my_address\n            else:\n                self['_sip_address'] = value\n        elif key == 'sip_port':\n            if _value <= 0 or _value > 65535:\n                raise ValueError, 'sip_port should be in the range 1-65535'\n            self['_sip_port'] = _value\n        self[key] = value\n\n    def options_help(self):\n        supported_options = SUPPORTED_OPTIONS.items()\n        supported_options.sort()\n        for option, (value_type, helptext) in supported_options:\n            if value_type == 'B':\n                value = 'on/off'\n            elif value_type == 'I':\n                value = 'number'\n            else:\n                value = '\"string\"'\n            print '--%s=%s\\n\\t%s\\n' % (option, value, helptext)\nsippy/UaStateDead.py\nclass UaStateDead(UaStateGeneric):\n    sname = 'Dead'\n    dead = True\n\n    def __init__(self, ua):\n        UaStateGeneric.__init__(self, None)\n        if ua.cId != None:\n            ua.global_config['_sip_tm'].unregConsumer(ua, str(ua.cId))\n        ua.tr = None\n        ua.event_cb = None\n        ua.conn_cbs = ()\n        ua.disc_cbs = ()\n        ua.fail_cbs = ()\n        ua.on_local_sdp_change = None\n        ua.on_remote_sdp_change = None\n        ua.expire_timer = None\n        ua.no_progress_timer = None\n        ua.credit_timer = None\n        # Keep this at the very end of processing\n        for callback in ua.dead_cbs:\n            callback(ua)\n        ua.dead_cbs = ()\n        ua.cleanup()\n        # Break cross-ref chain\n        self.ua = None\nsippy/SipTransactionManager.py\nclass SipTransactionManager(object):\n    global_config = None\n    l4r = None\n    tclient = None\n    tserver = None\n    req_cb = None\n    l1rcache = None\n    l2rcache = None\n    nat_traversal = False\n    req_consumers = None\n    provisional_retr = 0\n\n    def __init__(self, global_config, req_cb = None):\n        self.global_config = global_config\n        self.l4r = local4remote(global_config, self.handleIncoming)\n        self.tclient = {}\n        self.tserver = {}\n        self.req_cb = req_cb\n        self.l1rcache = {}\n        self.l2rcache = {}\n        self.req_consumers = {}\n        Timeout(self.rCachePurge, 32, -1)\n\n    def handleIncoming(self, data, address, server):\n        if len(data) < 32:\n            return\n        rtime = time()\n        self.global_config['_sip_logger'].write('RECEIVED message from %s:%d:\\n' % address, data, ltime = rtime)\n        checksum = md5(data).digest()\n        retrans = self.l1rcache.get(checksum, None)\n        if retrans == None:\n            retrans = self.l2rcache.get(checksum, None)\n        if retrans != None:\n            userv, data, address = retrans\n            if data == None:\n                return\n            self.transmitData(userv, data, address)\n            return\n        if data.startswith('SIP/2.0 '):\n            try:\n                resp = SipResponse(data)\n                tid = resp.getTId(True, True)\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP response from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            if resp.getSCode()[0] < 100 or resp.getSCode()[0] > 999:\n                print datetime.now(), 'invalid status code in SIP response from %s:%d:' % address\n                print data\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            resp.rtime = rtime\n            if not self.tclient.has_key(tid):\n                #print 'no transaction with tid of %s in progress' % str(tid)\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            t = self.tclient[tid]\n            if self.nat_traversal and resp.countHFs('contact') > 0 and not check1918(t.address[0]):\n                curl = resp.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n            resp.setSource(address)\n            self.incomingResponse(resp, t, checksum)\n        else:\n            if self.req_cb == None:\n                return\n            try:\n                req = SipRequest(data)\n                tids = req.getTIds()\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP request from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            req.rtime = rtime\n            via0 = req.getHFBody('via')\n            ahost, aport = via0.getAddr()\n            rhost, rport = address\n            if self.nat_traversal and rport != aport and check1918(ahost):\n                req.nated = True\n            if ahost != rhost:\n                via0.params['received'] = rhost\n            if via0.params.has_key('rport') or req.nated:\n                via0.params['rport'] = str(rport)\n            if self.nat_traversal and req.countHFs('contact') > 0 and req.countHFs('via') == 1:\n                curl = req.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n                    req.nated = True\n            req.setSource(address)\n            self.incomingRequest(req, checksum, tids, server)\n\n    # 1. Client transaction methods\n    def newTransaction(self, msg, resp_cb = None, laddress = None, userv = None):\n        t = SipTransaction()\n        t.tid = msg.getTId(True, True)\n        if self.tclient.has_key(t.tid):\n            raise ValueError('BUG: Attempt to initiate transaction with the same TID as existing one!!!')\n        t.tout = 0.5\n        t.fcode = None\n        t.address = msg.getTarget()\n        if userv == None:\n            if laddress == None:\n                t.userv = self.l4r.getServer(t.address)\n            else:\n                t.userv = self.l4r.getServer(laddress, is_local = True)\n        else:\n            t.userv = userv\n        t.data = msg.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        try:\n            t.expires = msg.getHFBody('expires').getNum()\n            if t.expires <= 0:\n                t.expires = 300\n        except IndexError:\n            t.expires = 300\n        if msg.getMethod() == 'INVITE':\n            t.needack = True\n            t.ack = msg.genACK()\n            t.cancel = msg.genCANCEL()\n        else:\n            t.needack = False\n            t.ack = None\n            t.cancel = None\n        t.cancelPending = False\n        t.resp_cb = resp_cb\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n        if resp_cb != None:\n            t.r408 = msg.genResponse(408, 'Request Timeout')\n        t.teB = Timeout(self.timerB, 32.0, 1, t)\n        t.teC = None\n        t.state = TRYING\n        self.tclient[t.tid] = t\n        self.transmitData(t.userv, t.data, t.address)\n        return t\n\n    def cancelTransaction(self, t, reason = None):\n        # If we got at least one provisional reply then (state == RINGING)\n        # then start CANCEL transaction, otherwise deffer it\n        if t.state != RINGING:\n            t.cancelPending = True\n        else:\n            if reason != None:\n                t.cancel.appendHeader(SipHeader(body = reason))\n            self.newTransaction(t.cancel, userv = t.userv)\n\n    def incomingResponse(self, msg, t, checksum):\n        # In those two states upper level already notified, only do ACK retransmit\n        # if needed\n        if t.state == TERMINATED:\n            return\n\n        if t.state == TRYING:\n            # Stop timers\n            if t.teA != None:\n                t.teA.cancel()\n                t.teA = None\n\n        if t.state in (TRYING, RINGING):\n            if t.teB != None:\n                t.teB.cancel()\n                t.teB = None\n\n            if msg.getSCode()[0] < 200:\n                # Privisional response - leave everything as is, except that\n                # change state and reload timeout timer\n                if t.state == TRYING:\n                    t.state = RINGING\n                    if t.cancelPending:\n                        self.newTransaction(t.cancel, userv = t.userv)\n                        t.cancelPending = False\n                t.teB = Timeout(self.timerB, t.expires, 1, t)\n                self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n            else:\n                # Final response - notify upper layer and remove transaction\n                if t.needack:\n                    # Prepare and send ACK if necessary\n                    fcode = msg.getSCode()[0]\n                    tag = msg.getHFBody('to').getTag()\n                    if tag != None:\n                        t.ack.getHFBody('to').setTag(tag)\n                    rAddr = None\n                    if msg.getSCode()[0] >= 200 and msg.getSCode()[0] < 300:\n                        # Some hairy code ahead\n                        if msg.countHFs('contact') > 0:\n                            rTarget = msg.getHFBody('contact').getUrl().getCopy()\n                        else:\n                            rTarget = None\n                        routes = [x.getCopy() for x in msg.getHFBodys('record-route')]\n                        routes.reverse()\n                        if len(routes) > 0:\n                            if not routes[0].getUrl().lr:\n                                if rTarget != None:\n                                    routes.append(SipRoute(address = SipAddress(url = rTarget)))\n                                rTarget = routes.pop(0).getUrl()\n                                rAddr = rTarget.getAddr()\n                            else:\n                                rAddr = routes[0].getAddr()\n                        elif rTarget != None:\n                            rAddr = rTarget.getAddr()\n                        if rTarget != None:\n                            t.ack.setRURI(rTarget)\n                        if rAddr != None:\n                            t.ack.setTarget(rAddr)\n                        t.ack.delHFs('route')\n                        t.ack.appendHeaders([SipHeader(name = 'route', body = x) for x in routes])\n                    if fcode >= 200 and fcode < 300:\n                        t.ack.getHFBody('via').genBranch()\n                    if rAddr == None:\n                        rAddr = t.address\n                    self.transmitMsg(t.userv, t.ack, rAddr, checksum)\n                else:\n                    self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n                del self.tclient[t.tid]\n                t.cleanup()\n\n    def timerA(self, t):\n        #print 'timerA', t\n        self.transmitData(t.userv, t.data, t.address)\n        t.tout *= 2\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n\n    def timerB(self, t):\n        #print 'timerB', t\n        t.teB = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        t.state = TERMINATED\n        #print '2: Timeout(self.timerC, 32.0, 1, t)', t\n        t.teC = Timeout(self.timerC, 32.0, 1, t)\n        if t.resp_cb == None:\n            return\n        t.r408.rtime = time()\n        t.resp_cb(t.r408)\n        #try:\n        #    t.resp_cb(SipRequest(t.data).genResponse(408, 'Request Timeout'))\n        #except:\n        #    print 'SipTransactionManager: unhandled exception when processing response!'\n\n    def timerC(self, t):\n        #print 'timerC', t\n        #print self.tclient\n        t.teC = None\n        del self.tclient[t.tid]\n        t.cleanup()\n\n    # 2. Server transaction methods\n    def incomingRequest(self, msg, checksum, tids, server):\n        for tid in tids:\n            if self.tclient.has_key(tid):\n                resp = msg.genResponse(482, 'Loop Detected')\n                self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                return\n        tid = msg.getTId()\n        # Fasten seatbelts - bumpy transaction matching code ahead!\n        if msg.getMethod() in ('INVITE', 'CANCEL', 'ACK'):\n            btid = msg.getTId(wBRN = True)\n            t = self.tserver.get(btid, None)\n            if t == None:\n                t = self.tserver.get(tid, None)\n                if t != None and t.branch != btid[3]:\n                    if msg.getMethod() == 'INVITE':\n                        # Different branch on transaction to which no final reply\n                        # has been sent yet - merge requests\n                        resp = msg.genResponse(482, 'Loop Detected')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n                    elif msg.getMethod() == 'CANCEL':\n                        # CANCEL, but with branch that doesn't match any existing\n                        # transactions\n                        resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n        else:\n            t = self.tserver.get(tid, None)\n        if t != None:\n            #print 'existing transaction'\n            if msg.getMethod() == t.method:\n                # Duplicate received, check that we have sent any response on this\n                # request already\n                if t.data != None:\n                    self.transmitData(t.userv, t.data, t.address, checksum)\n                return\n            elif msg.getMethod() == 'CANCEL':\n                # RFC3261 says that we have to reply 200 OK in all cases if\n                # there is such transaction\n                resp = msg.genResponse(200, 'OK')\n                self.transmitMsg(t.userv, resp, resp.getHFBody('via').getTAddr(), checksum)\n                if t.state in (TRYING, RINGING):\n                    self.doCancel(t, msg.rtime, msg)\n            elif msg.getMethod() == 'ACK' and t.state == COMPLETED:\n                t.state = CONFIRMED\n                if t.teA != None:\n                    t.teA.cancel()\n                    t.teA = None\n                t.teD.cancel()\n                # We have done with the transaction, no need to wait for timeout\n                del self.tserver[t.tid]\n                t.cleanup()\n                self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'ACK':\n            # Some ACK that doesn't match any existing transaction.\n            # Drop and forget it - upper layer is unlikely to be interested\n            # to seeing this anyway.\n            print datetime.now(), 'unmatched ACK transaction - ignoring'\n            sys.stdout.flush()\n            self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'CANCEL':\n            resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n            self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n        else:\n            #print 'new transaction', msg.getMethod()\n            t = SipTransaction()\n            t.tid = tid\n            t.state = TRYING\n            t.teA = None\n            t.teD = None\n            t.teE = None\n            t.teF = None\n            t.method = msg.getMethod()\n            t.data = None\n            t.address = None\n            t.noack_cb = None\n            t.cancel_cb = None\n            t.checksum = checksum\n            if server.laddress[0] not in ('0.0.0.0', '[::]'):\n                t.userv = server\n            else:\n                # For messages received on the wildcard interface find\n                # or create more specific server.\n                t.userv = self.l4r.getServer(msg.getSource())\n            if msg.getMethod() == 'INVITE':\n                t.r487 = msg.genResponse(487, 'Request Terminated')\n                t.needack = True\n                t.branch = msg.getHFBody('via').getBranch()\n                try:\n                    e = msg.getHFBody('expires').getNum()\n                    if e <= 0:\n                        e = 300\n                except IndexError:\n                    e = 300\n                t.teE = Timeout(self.timerE, e, 1, t)\n            else:\n                t.r487 = None\n                t.needack = False\n                t.branch = None\n            self.tserver[t.tid] = t\n            for consumer in self.req_consumers.get(t.tid[0], ()):\n                consumer = consumer.isYours(msg)\n                if consumer != None:\n                    rval = consumer.recvRequest(msg)\n                    break\n            else:\n                rval = self.req_cb(msg)\n            if rval == None:\n                if t.teA != None or t.teD != None or t.teE != None or t.teF != None:\n                    return\n                if self.tserver.has_key(t.tid):\n                    del self.tserver[t.tid]\n                t.cleanup()\n                return\n            resp, cancel_cb, noack_cb = rval\n            t.cancel_cb = cancel_cb\n            t.noack_cb = noack_cb\n            if resp != None:\n                self.sendResponse(resp, t)\n\n    def regConsumer(self, consumer, call_id):\n        self.req_consumers.setdefault(call_id, []).append(consumer)\n\n    def unregConsumer(self, consumer, call_id):\n        # Usually there will be only one consumer per call_id, so that\n        # optimize management for this case\n        consumers = self.req_consumers.pop(call_id)\n        if len(consumers) > 1:\n            consumers.remove(consumer)\n            self.req_consumers[call_id] = consumers\n\n    def sendResponse(self, resp, t = None, retrans = False):\n        #print self.tserver\n        if t == None:\n            tid = resp.getTId()\n            t = self.tserver[tid]\n        if t.state not in (TRYING, RINGING) and not retrans:\n            raise ValueError('BUG: attempt to send reply on already finished transaction!!!')\n        scode = resp.getSCode()[0]\n        toHF = resp.getHFBody('to')\n        if scode > 100 and toHF.getTag() == None:\n            toHF.genTag()\n        t.data = resp.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        t.address = resp.getHFBody('via').getTAddr()\n        self.transmitData(t.userv, t.data, t.address, t.checksum)\n        if scode < 200:\n            t.state = RINGING\n            if self.provisional_retr > 0 and scode > 100:\n                if t.teF != None:\n                    t.teF.cancel()\n                t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n        else:\n            t.state = COMPLETED\n            if t.teE != None:\n                t.teE.cancel()\n                t.teE = None\n            if t.teF != None:\n                t.teF.cancel()\n                t.teF = None\n            if t.needack:\n                # Schedule removal of the transaction\n                t.teD = Timeout(self.timerD, 32.0, 1, t)\n                if scode >= 300:\n                    # Black magick to allow proxy send us another INVITE with diffetent branch\n                    del self.tserver[t.tid]\n                    t.tid = list(t.tid)\n                    t.tid.append(t.branch)\n                    t.tid = tuple(t.tid)\n                    self.tserver[t.tid] = t\n                # Install retransmit timer if necessary\n                t.tout = 0.5\n                t.teA = Timeout(self.timerA, t.tout, 1, t)\n            else:\n                # We have done with the transaction\n                del self.tserver[t.tid]\n                t.cleanup()\n\n    def doCancel(self, t, rtime = None, req = None):\n        if rtime == None:\n            rtime = time()\n        if t.r487 != None:\n            self.sendResponse(t.r487, t, True)\n        if t.cancel_cb != None:\n            t.cancel_cb(rtime, req)\n\n    def timerD(self, t):\n        #print 'timerD'\n        t.teD = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        if t.noack_cb != None and t.state != CONFIRMED:\n            t.noack_cb()\n        del self.tserver[t.tid]\n        t.cleanup()\n\n    def timerE(self, t):\n        #print 'timerE'\n        t.teE = None\n        if t.teF != None:\n            t.teF.cancel()\n            t.teF = None\n        if t.state in (TRYING, RINGING):\n            if t.r487 != None:\n                t.r487.reason = 'Request Expired'\n            self.doCancel(t)\n\n    # Timer to retransmit the last provisional reply every\n    # 2 seconds\n    def timerF(self, t):\n        #print 'timerF', t.state\n        t.teF = None\n        if t.state == RINGING and self.provisional_retr > 0:\n            self.transmitData(t.userv, t.data, t.address)\n            t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n\n    def rCachePurge(self):\n        self.l2rcache = self.l1rcache\n        self.l1rcache = {}\n        self.l4r.rotateCache()\n\n    def transmitMsg(self, userv, msg, address, cachesum, compact = False):\n        data = msg.localStr(userv.laddress[0], userv.laddress[1], compact)\n        self.transmitData(userv, data, address, cachesum)\n\n    def transmitData(self, userv, data, address, cachesum = None):\n        userv.send_to(data, address)\n        self.global_config['_sip_logger'].write('SENDING message to %s:%d:\\n' % address, data)\n        if cachesum != None:\n            self.l1rcache[cachesum] = (userv, data, address)\nsippy/CCEvents.py\nclass CCEventRing(CCEventGeneric):\n    name = 'CCEventRing'\n    pass\n", "answers": ["            self.acctA = RadiusAccounting(self.global_config, 'answer', \\"], "pred": "  Code:   0:  0:  0:  0:  0:  0:  0:  0:  0:  0:  0:  0:  0:  0:  0:", "length": 7126, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "3cd8fefa66ffe61edf15dd8ce125f6e4933fb96d398da6b5"}

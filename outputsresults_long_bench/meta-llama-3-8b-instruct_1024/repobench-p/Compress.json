{"prompt": "Please complete the code given below. \nsrc/kademlia/operation/KadRefreshOperation.java\npublic class KadRefreshOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public KadRefreshOperation(KadServer server, KademliaNode localNode, KademliaDHT dht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public void execute() throws IOException\n    {\n        /* Run our BucketRefreshOperation to refresh buckets */\n        new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n\n        /* After buckets have been refreshed, we refresh content */\n        new ContentRefreshOperation(this.server, this.localNode, this.dht, this.config).execute();\n    }\n}\nsrc/kademlia/operation/StoreOperation.java\npublic class StoreOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final JKademliaStorageEntry storageEntry;\n    private final KademliaDHT localDht;\n    private final KadConfiguration config;\n\n    /**\n     * @param server\n     * @param localNode\n     * @param storageEntry The content to be stored on the DHT\n     * @param localDht     The local DHT\n     * @param config\n     */\n    public StoreOperation(KadServer server, KademliaNode localNode, JKademliaStorageEntry storageEntry, KademliaDHT localDht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.storageEntry = storageEntry;\n        this.localDht = localDht;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        /* Get the nodes on which we need to store the content */\n        NodeLookupOperation ndlo = new NodeLookupOperation(this.server, this.localNode, this.storageEntry.getContentMetadata().getKey(), this.config);\n        ndlo.execute();\n        List<Node> nodes = ndlo.getClosestNodes();\n\n        /* Create the message */\n        Message msg = new StoreContentMessage(this.localNode.getNode(), this.storageEntry);\n\n        /*Store the message on all of the K-Nodes*/\n        for (Node n : nodes)\n        {\n            if (n.equals(this.localNode.getNode()))\n            {\n                /* Store the content locally */\n                this.localDht.store(this.storageEntry);\n            }\n            else\n            {\n                /**\n                 * @todo Create a receiver that receives a store acknowledgement message to count how many nodes a content have been stored at\n                 */\n                this.server.sendMessage(n, msg, null);\n            }\n        }\n    }\n\n    /**\n     * @return The number of nodes that have stored this content\n     *\n     * @todo Implement this method\n     */\n    public int numNodesStoredAt()\n    {\n        return 1;\n    }\n}\nsrc/kademlia/dht/JKademliaStorageEntry.java\npublic class JKademliaStorageEntry implements KademliaStorageEntry\n{\n\n    private String content;\n    private final StorageEntryMetadata metadata;\n\n    public JKademliaStorageEntry(final KadContent content)\n    {\n        this(content, new StorageEntryMetadata(content));\n    }\n\n    public JKademliaStorageEntry(final KadContent content, final StorageEntryMetadata metadata)\n    {\n        this.setContent(content.toSerializedForm());\n        this.metadata = metadata;\n    }\n\n    @Override\n    public final void setContent(final byte[] data)\n    {\n        this.content = new String(data);\n    }\n\n    @Override\n    public final byte[] getContent()\n    {\n        return this.content.getBytes();\n    }\n\n    @Override\n    public final KademliaStorageEntryMetadata getContentMetadata()\n    {\n        return this.metadata;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"[StorageEntry: \");\n\n        sb.append(\"[Content: \");\n        sb.append(this.getContent());\n        sb.append(\"]\");\n\n        sb.append(this.getContentMetadata());\n\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/dht/DHT.java\npublic class DHT implements KademliaDHT\n{\n\n    private transient StoredContentManager contentManager;\n    private transient KadSerializer<JKademliaStorageEntry> serializer = null;\n    private transient KadConfiguration config;\n\n    private final String ownerId;\n\n    public DHT(String ownerId, KadConfiguration config)\n    {\n        this.ownerId = ownerId;\n        this.config = config;\n        this.initialize();\n    }\n\n    @Override\n    public final void initialize()\n    {\n        contentManager = new StoredContentManager();\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration con)\n    {\n        this.config = con;\n    }\n\n    @Override\n    public KadSerializer<JKademliaStorageEntry> getSerializer()\n    {\n        if (null == serializer)\n        {\n            serializer = new JsonSerializer<>();\n        }\n\n        return serializer;\n    }\n\n    @Override\n    public boolean store(JKademliaStorageEntry content) throws IOException\n    {\n        /* Lets check if we have this content and it's the updated version */\n        if (this.contentManager.contains(content.getContentMetadata()))\n        {\n            KademliaStorageEntryMetadata current = this.contentManager.get(content.getContentMetadata());\n\n            /* update the last republished time */\n            current.updateLastRepublished();\n\n            if (current.getLastUpdatedTimestamp() >= content.getContentMetadata().getLastUpdatedTimestamp())\n            {\n                /* We have the current content, no need to update it! just leave this method now */\n                return false;\n            }\n            else\n            {\n                /* We have this content, but not the latest version, lets delete it so the new version will be added below */\n                try\n                {\n                    //System.out.println(\"Removing older content to update it\");\n                    this.remove(content.getContentMetadata());\n                }\n                catch (ContentNotFoundException ex)\n                {\n                    /* This won't ever happen at this point since we only get here if the content is found, lets ignore it  */\n                }\n            }\n        }\n\n        /**\n         * If we got here means we don't have this content, or we need to update the content\n         * If we need to update the content, the code above would've already deleted it, so we just need to re-add it\n         */\n        try\n        {\n            //System.out.println(\"Adding new content.\");\n            /* Keep track of this content in the entries manager */\n            KademliaStorageEntryMetadata sEntry = this.contentManager.put(content.getContentMetadata());\n\n            /* Now we store the content locally in a file */\n            String contentStorageFolder = this.getContentStorageFolderName(content.getContentMetadata().getKey());\n\n            try (FileOutputStream fout = new FileOutputStream(contentStorageFolder + File.separator + sEntry.hashCode() + \".kct\");\n                    DataOutputStream dout = new DataOutputStream(fout))\n            {\n                this.getSerializer().write(content, dout);\n            }\n            return true;\n        }\n        catch (ContentExistException e)\n        {\n            /**\n             * Content already exist on the DHT\n             * This won't happen because above takes care of removing the content if it's older and needs to be updated,\n             * or returning if we already have the current content version.\n             */\n            return false;\n        }\n    }\n\n    @Override\n    public boolean store(KadContent content) throws IOException\n    {\n        return this.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(key);\n        DataInputStream din = new DataInputStream(new FileInputStream(folder + File.separator + hashCode + \".kct\"));\n        return this.getSerializer().read(din);\n    }\n\n    @Override\n    public boolean contains(GetParameter param)\n    {\n        return this.contentManager.contains(param);\n    }\n\n    @Override\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException\n    {\n        try\n        {\n            return this.retrieve(entry.getKey(), entry.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException\n    {\n        /* Load a KadContent if any exist for the given criteria */\n        try\n        {\n            KademliaStorageEntryMetadata e = this.contentManager.get(param);\n            return this.retrieve(e.getKey(), e.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove(KadContent content) throws ContentNotFoundException\n    {\n        this.remove(new StorageEntryMetadata(content));\n    }\n\n    @Override\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(entry.getKey());\n        File file = new File(folder + File.separator + entry.hashCode() + \".kct\");\n\n        contentManager.remove(entry);\n\n        if (file.exists())\n        {\n            file.delete();\n        }\n        else\n        {\n            throw new ContentNotFoundException();\n        }\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @param key The key of the content\n     *\n     * @return String The name of the folder\n     */\n    private String getContentStorageFolderName(KademliaId key)\n    {\n        /**\n         * Each content is stored in a folder named after the first 2 characters of the NodeId\n         *\n         * The name of the file containing the content is the hash of this content\n         */\n        String folderName = key.hexRepresentation().substring(0, 2);\n        File contentStorageFolder = new File(this.config.getNodeDataFolder(ownerId) + File.separator + folderName);\n\n        /* Create the content folder if it doesn't exist */\n        if (!contentStorageFolder.isDirectory())\n        {\n            contentStorageFolder.mkdir();\n        }\n\n        return contentStorageFolder.toString();\n    }\n\n    @Override\n    public List<KademliaStorageEntryMetadata> getStorageEntries()\n    {\n        return contentManager.getAllEntries();\n    }\n\n    @Override\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries)\n    {\n        for (KademliaStorageEntryMetadata e : ientries)\n        {\n            try\n            {\n                this.contentManager.put(e);\n            }\n            catch (ContentExistException ex)\n            {\n                /* Entry already exist, no need to store it again */\n            }\n        }\n    }\n\n    @Override\n    public synchronized String toString()\n    {\n        return this.contentManager.toString();\n    }\n}\nsrc/kademlia/routing/KademliaRoutingTable.java\npublic interface KademliaRoutingTable\n{\n\n    /**\n     * Initialize the RoutingTable to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Sets the configuration file for this routing table\n     *\n     * @param config\n     */\n    public void setConfiguration(KadConfiguration config);\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    public void insert(Contact c);\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    public void insert(Node n);\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    public int getBucketId(KademliaId nid);\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    public List<Node> findClosest(KademliaId target, int numNodesRequired);\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllNodes();\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllContacts();\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    public KademliaBucket[] getBuckets();\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    public void setUnresponsiveContacts(List<Node> contacts);\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    public void setUnresponsiveContact(Node n);\n\n}\nsrc/kademlia/dht/KadContent.java\npublic interface KadContent\n{\n\n    /**\n     * @return NodeId The DHT key for this content\n     */\n    public KademliaId getKey();\n\n    /**\n     * @return String The type of content\n     */\n    public String getType();\n\n    /**\n     * Each content will have an created date\n     * This allows systems to know when to delete a content form his/her machine\n     *\n     * @return long The create date of this content\n     */\n    public long getCreatedTimestamp();\n\n    /**\n     * Each content will have an update timestamp\n     * This allows the DHT to keep only the latest version of a content\n     *\n     * @return long The timestamp of when this content was last updated\n     */\n    public long getLastUpdatedTimestamp();\n\n    /**\n     * @return The ID of the owner of this content\n     */\n    public String getOwnerId();\n\n    /**\n     * Each content needs to be in byte format for transporting and storage,\n     * this method takes care of that.\n     *\n     * Each object is responsible for transforming itself to byte format since the\n     * structure of methods may differ.\n     *\n     * @return The content in byte format\n     */\n    public byte[] toSerializedForm();\n\n    /**\n     * Given the Content in byte format, read it\n     *\n     * @param data The object in byte format\n     *\n     * @return A new object from the given\n     */\n    public KadContent fromSerializedForm(byte[] data);\n}\nsrc/kademlia/util/serializer/JsonRoutingTableSerializer.java\npublic class JsonRoutingTableSerializer implements KadSerializer<KademliaRoutingTable>\n{\n\n    private final Gson gson;\n\n    Type contactCollectionType = new TypeToken<List<Contact>>()\n    {\n    }.getType();\n\n    private final KadConfiguration config;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    /**\n     * Initialize the class\n     *\n     * @param config\n     */\n    public JsonRoutingTableSerializer(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    @Override\n    public void write(KademliaRoutingTable data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic JKademliaRoutingTable */\n            gson.toJson(data, JKademliaRoutingTable.class, writer);\n\n            /* Now Store the Contacts  */\n            gson.toJson(data.getAllContacts(), contactCollectionType, writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public KademliaRoutingTable read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic JKademliaRoutingTable */\n            KademliaRoutingTable tbl = gson.fromJson(reader, KademliaRoutingTable.class);\n            tbl.setConfiguration(config);\n            \n            /* Now get the Contacts and add them back to the JKademliaRoutingTable */\n            List<Contact> contacts = gson.fromJson(reader, contactCollectionType);\n            tbl.initialize();\n\n            for (Contact c : contacts)\n            {\n                tbl.insert(c);\n            }\n\n            reader.endArray();\n            /* Read and return the Content*/\n            return tbl;\n        }\n    }\n}\nsrc/kademlia/operation/ConnectOperation.java\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final Node bootstrapNode;\n    private final KadConfiguration config;\n\n    private boolean error;\n    private int attempts;\n\n    /**\n     * @param server    The message server used to send/receive messages\n     * @param local     The local node\n     * @param bootstrap Node to use to bootstrap the local node onto the network\n     * @param config\n     */\n    public ConnectOperation(KadServer server, KademliaNode local, Node bootstrap, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = local;\n        this.bootstrapNode = bootstrap;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        try\n        {\n            /* Contact the bootstrap node */\n            this.error = true;\n            this.attempts = 0;\n            Message m = new ConnectMessage(this.localNode.getNode());\n\n            /* Send a connect message to the bootstrap node */\n            server.sendMessage(this.bootstrapNode, m, this);\n\n            /* If we haven't finished as yet, wait for a maximum of config.operationTimeout() time */\n            int totalTimeWaited = 0;\n            int timeInterval = 50;     // We re-check every 300 milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (error)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            if (error)\n            {\n                /* If we still haven't received any responses by then, do a routing timeout */\n                throw new RoutingException(\"ConnectOperation: Bootstrap node did not respond: \" + bootstrapNode);\n            }\n\n            /* Perform lookup for our own ID to get nodes close to us */\n            Operation lookup = new NodeLookupOperation(this.server, this.localNode, this.localNode.getNode().getNodeId(), this.config);\n            lookup.execute();\n\n            /**\n             * Refresh buckets to get a good routing table\n             * After the above lookup operation, K nodes will be in our routing table,\n             * Now we try to populate all of our buckets.\n             */\n            new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n        }\n        catch (InterruptedException e)\n        {\n            System.err.println(\"Connect operation was interrupted. \");\n        }\n    }\n\n    /**\n     * Receives an AcknowledgeMessage from the bootstrap node.\n     *\n     * @param comm\n     */\n    @Override\n    public synchronized void receive(Message incoming, int comm)\n    {\n        /* The incoming message will be an acknowledgement message */\n        AcknowledgeMessage msg = (AcknowledgeMessage) incoming;\n\n        /* The bootstrap node has responded, insert it into our space */\n        this.localNode.getRoutingTable().insert(this.bootstrapNode);\n\n        /* We got a response, so the error is false */\n        error = false;\n\n        /* Wake up any waiting thread */\n        notify();\n    }\n\n    /**\n     * Resends a ConnectMessage to the boot strap node a maximum of MAX_ATTEMPTS\n     * times.\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        if (++this.attempts < MAX_CONNECT_ATTEMPTS)\n        {\n            this.server.sendMessage(this.bootstrapNode, new ConnectMessage(this.localNode.getNode()), this);\n        }\n        else\n        {\n            /* We just exit, so notify all other threads that are possibly waiting */\n            notify();\n        }\n    }\n}\nsrc/kademlia/dht/KademliaStorageEntry.java\npublic interface KademliaStorageEntry\n{\n\n    /**\n     * Add the content to the storage entry\n     *\n     * @param data The content data in byte[] format\n     */\n    public void setContent(final byte[] data);\n\n    /**\n     * Get the content from this storage entry\n     *\n     * @return The content in byte format\n     */\n    public byte[] getContent();\n\n    /**\n     * Get the metadata for this storage entry\n     *\n     * @return the storage entry metadata\n     */\n    public KademliaStorageEntryMetadata getContentMetadata();\n}\nsrc/kademlia/message/MessageFactory.java\npublic class MessageFactory implements KademliaMessageFactory\n{\n\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public MessageFactory(KademliaNode local, KademliaDHT dht, KadConfiguration config)\n    {\n        this.localNode = local;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public Message createMessage(byte code, DataInputStream in) throws IOException\n    {\n        switch (code)\n        {\n            case AcknowledgeMessage.CODE:\n                return new AcknowledgeMessage(in);\n            case ConnectMessage.CODE:\n                return new ConnectMessage(in);\n            case ContentMessage.CODE:\n                return new ContentMessage(in);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupMessage(in);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupMessage(in);\n            case NodeReplyMessage.CODE:\n                return new NodeReplyMessage(in);\n            case SimpleMessage.CODE:\n                return new SimpleMessage(in);\n            case StoreContentMessage.CODE:\n                return new StoreContentMessage(in);\n            default:\n                //System.out.println(this.localNode + \" - No Message handler found for message. Code: \" + code);\n                return new SimpleMessage(in);\n\n        }\n    }\n\n    @Override\n    public Receiver createReceiver(byte code, KadServer server)\n    {\n        switch (code)\n        {\n            case ConnectMessage.CODE:\n                return new ConnectReceiver(server, this.localNode);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupReceiver(server, this.localNode, this.dht, this.config);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupReceiver(server, this.localNode, this.config);\n            case StoreContentMessage.CODE:\n                return new StoreContentReceiver(server, this.localNode, this.dht);\n            default:\n                //System.out.println(\"No receiver found for message. Code: \" + code);\n                return new SimpleReceiver();\n        }\n    }\n}\nsrc/kademlia/util/serializer/JsonSerializer.java\npublic class JsonSerializer<T> implements KadSerializer<T>\n{\n\n    private final Gson gson;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    @Override\n    public void write(T data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Store the content type */\n            gson.toJson(data.getClass().getName(), String.class, writer);\n\n            /* Now Store the content */\n            gson.toJson(data, data.getClass(), writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public T read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the class name */\n            String className = gson.fromJson(reader, String.class);\n\n            /* Read and return the Content*/\n            T ret = gson.fromJson(reader, Class.forName(className));\n            \n            reader.endArray();\n            \n            return ret;\n        }\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/node/KademliaId.java\npublic class KademliaId implements Streamable, Serializable\n{\n\n    public final transient static int ID_LENGTH = 160;\n    private byte[] keyBytes;\n\n    /**\n     * Construct the NodeId from some string\n     *\n     * @param data The user generated key string\n     */\n    public KademliaId(String data)\n    {\n        keyBytes = data.getBytes();\n        if (keyBytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long.\");\n        }\n    }\n\n    /**\n     * Generate a random key\n     */\n    public KademliaId()\n    {\n        keyBytes = new byte[ID_LENGTH / 8];\n        new Random().nextBytes(keyBytes);\n    }\n\n    /**\n     * Generate the NodeId from a given byte[]\n     *\n     * @param bytes\n     */\n    public KademliaId(byte[] bytes)\n    {\n        if (bytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long. Data Given: '\" + new String(bytes) + \"'\");\n        }\n        this.keyBytes = bytes;\n    }\n\n    /**\n     * Load the NodeId from a DataInput stream\n     *\n     * @param in The stream from which to load the NodeId\n     *\n     * @throws IOException\n     */\n    public KademliaId(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    public byte[] getBytes()\n    {\n        return this.keyBytes;\n    }\n\n    /**\n     * @return The BigInteger representation of the key\n     */\n    public BigInteger getInt()\n    {\n        return new BigInteger(1, this.getBytes());\n    }\n\n    /**\n     * Compares a NodeId to this NodeId\n     *\n     * @param o The NodeId to compare to this NodeId\n     *\n     * @return boolean Whether the 2 NodeIds are equal\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof KademliaId)\n        {\n            KademliaId nid = (KademliaId) o;\n            return this.hashCode() == nid.hashCode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 7;\n        hash = 83 * hash + Arrays.hashCode(this.keyBytes);\n        return hash;\n    }\n\n    /**\n     * Checks the distance between this and another NodeId\n     *\n     * @param nid\n     *\n     * @return The distance of this NodeId from the given NodeId\n     */\n    public KademliaId xor(KademliaId nid)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n        byte[] nidBytes = nid.getBytes();\n\n        for (int i = 0; i < ID_LENGTH / 8; i++)\n        {\n            result[i] = (byte) (this.keyBytes[i] ^ nidBytes[i]);\n        }\n\n        KademliaId resNid = new KademliaId(result);\n\n        return resNid;\n    }\n\n    /**\n     * Generates a NodeId that is some distance away from this NodeId\n     *\n     * @param distance in number of bits\n     *\n     * @return NodeId The newly generated NodeId\n     */\n    public KademliaId generateNodeIdByDistance(int distance)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n\n        /* Since distance = ID_LENGTH - prefixLength, we need to fill that amount with 0's */\n        int numByteZeroes = (ID_LENGTH - distance) / 8;\n        int numBitZeroes = 8 - (distance % 8);\n\n        /* Filling byte zeroes */\n        for (int i = 0; i < numByteZeroes; i++)\n        {\n            result[i] = 0;\n        }\n\n        /* Filling bit zeroes */\n        BitSet bits = new BitSet(8);\n        bits.set(0, 8);\n\n        for (int i = 0; i < numBitZeroes; i++)\n        {\n            /* Shift 1 zero into the start of the value */\n            bits.clear(i);\n        }\n        bits.flip(0, 8);        // Flip the bits since they're in reverse order\n        result[numByteZeroes] = (byte) bits.toByteArray()[0];\n\n        /* Set the remaining bytes to Maximum value */\n        for (int i = numByteZeroes + 1; i < result.length; i++)\n        {\n            result[i] = Byte.MAX_VALUE;\n        }\n\n        return this.xor(new KademliaId(result));\n    }\n\n    /**\n     * Counts the number of leading 0's in this NodeId\n     *\n     * @return Integer The number of leading 0's\n     */\n    public int getFirstSetBitIndex()\n    {\n        int prefixLength = 0;\n\n        for (byte b : this.keyBytes)\n        {\n            if (b == 0)\n            {\n                prefixLength += 8;\n            }\n            else\n            {\n                /* If the byte is not 0, we need to count how many MSBs are 0 */\n                int count = 0;\n                for (int i = 7; i >= 0; i--)\n                {\n                    boolean a = (b & (1 << i)) == 0;\n                    if (a)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        break;   // Reset the count if we encounter a non-zero number\n                    }\n                }\n\n                /* Add the count of MSB 0s to the prefix length */\n                prefixLength += count;\n\n                /* Break here since we've now covered the MSB 0s */\n                break;\n            }\n        }\n        return prefixLength;\n    }\n\n    /**\n     * Gets the distance from this NodeId to another NodeId\n     *\n     * @param to\n     *\n     * @return Integer The distance\n     */\n    public int getDistance(KademliaId to)\n    {\n        /**\n         * Compute the xor of this and to\n         * Get the index i of the first set bit of the xor returned NodeId\n         * The distance between them is ID_LENGTH - i\n         */\n        return ID_LENGTH - this.xor(to).getFirstSetBitIndex();\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        out.write(this.getBytes());\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        byte[] input = new byte[ID_LENGTH / 8];\n        in.readFully(input);\n        this.keyBytes = input;\n    }\n\n    public String hexRepresentation()\n    {\n        /* Returns the hex format of this NodeId */\n        BigInteger bi = new BigInteger(1, this.keyBytes);\n        return String.format(\"%0\" + (this.keyBytes.length << 1) + \"X\", bi);\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hexRepresentation();\n    }\n\n}\nsrc/kademlia/dht/KademliaDHT.java\npublic interface KademliaDHT\n{\n\n    /**\n     * Initialize this DHT to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Set a new configuration. Mainly used when we restore the DHT state from a file\n     *\n     * @param con The new configuration file\n     */\n    public void setConfiguration(KadConfiguration con);\n\n    /**\n     * Creates a new Serializer or returns an existing serializer\n     *\n     * @return The new ContentSerializer\n     */\n    public KadSerializer<JKademliaStorageEntry> getSerializer();\n\n    /**\n     * Handle storing content locally\n     *\n     * @param content The DHT content to store\n     *\n     * @return boolean true if we stored the content, false if the content already exists and is up to date\n     *\n     * @throws java.io.IOException\n     */\n    public boolean store(JKademliaStorageEntry content) throws IOException;\n\n    public boolean store(KadContent content) throws IOException;\n\n    /**\n     * Retrieves a Content from local storage\n     *\n     * @param key      The Key of the content to retrieve\n     * @param hashCode The hash code of the content to retrieve\n     *\n     * @return A KadContent object\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException;\n\n    /**\n     * Check if any content for the given criteria exists in this DHT\n     *\n     * @param param The content search criteria\n     *\n     * @return boolean Whether any content exist that satisfy the criteria\n     */\n    public boolean contains(GetParameter param);\n\n    /**\n     * Retrieve and create a KadContent object given the StorageEntry object\n     *\n     * @param entry The StorageEntry used to retrieve this content\n     *\n     * @return KadContent The content object\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException;\n\n    /**\n     * Get the StorageEntry for the content if any exist.\n     *\n     * @param param The parameters used to filter the content needed\n     *\n     * @return KadContent A KadContent found on the DHT satisfying the given criteria\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException;\n\n    /**\n     * Delete a content from local storage\n     *\n     * @param content The Content to Remove\n     *\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public void remove(KadContent content) throws ContentNotFoundException;\n\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException;\n\n    /**\n     * @return A List of all StorageEntries for this node\n     */\n    public List<KademliaStorageEntryMetadata> getStorageEntries();\n\n    /**\n     * Used to add a list of storage entries for existing content to the DHT.\n     * Mainly used when retrieving StorageEntries from a saved state file.\n     *\n     * @param ientries The entries to add\n     */\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries);\n\n}\nsrc/kademlia/operation/Operation.java\npublic interface Operation\n{\n\n    /**\n     * Starts an operation and returns when the operation is finished\n     *\n     * @throws kademlia.exceptions.RoutingException\n     */\n    public void execute() throws IOException, RoutingException;\n}\nsrc/kademlia/routing/JKademliaRoutingTable.java\npublic class JKademliaRoutingTable implements KademliaRoutingTable\n{\n\n    private final Node localNode;  // The current node\n    private transient KademliaBucket[] buckets;\n\n    private transient KadConfiguration config;\n\n    public JKademliaRoutingTable(Node localNode, KadConfiguration config)\n    {\n        this.localNode = localNode;\n        this.config = config;\n\n        /* Initialize all of the buckets to a specific depth */\n        this.initialize();\n\n        /* Insert the local node */\n        this.insert(localNode);\n    }\n\n    /**\n     * Initialize the JKademliaRoutingTable to it's default state\n     */\n    @Override\n    public final void initialize()\n    {\n        this.buckets = new KademliaBucket[KademliaId.ID_LENGTH];\n        for (int i = 0; i < KademliaId.ID_LENGTH; i++)\n        {\n            buckets[i] = new JKademliaBucket(i, this.config);\n        }\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    @Override\n    public synchronized final void insert(Contact c)\n    {\n        this.buckets[this.getBucketId(c.getNode().getNodeId())].insert(c);\n    }\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    @Override\n    public synchronized final void insert(Node n)\n    {\n        this.buckets[this.getBucketId(n.getNodeId())].insert(n);\n    }\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    @Override\n    public final int getBucketId(KademliaId nid)\n    {\n        int bId = this.localNode.getNodeId().getDistance(nid) - 1;\n\n        /* If we are trying to insert a node into it's own routing table, then the bucket ID will be -1, so let's just keep it in bucket 0 */\n        return bId < 0 ? 0 : bId;\n    }\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    @Override\n    public synchronized final List<Node> findClosest(KademliaId target, int numNodesRequired)\n    {\n        TreeSet<Node> sortedSet = new TreeSet<>(new KeyComparator(target));\n        sortedSet.addAll(this.getAllNodes());\n\n        List<Node> closest = new ArrayList<>(numNodesRequired);\n\n        /* Now we have the sorted set, lets get the top numRequired */\n        int count = 0;\n        for (Node n : sortedSet)\n        {\n            closest.add(n);\n            if (++count == numNodesRequired)\n            {\n                break;\n            }\n        }\n        return closest;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public synchronized final List<Node> getAllNodes()\n    {\n        List<Node> nodes = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            for (Contact c : b.getContacts())\n            {\n                nodes.add(c.getNode());\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public final List<Contact> getAllContacts()\n    {\n        List<Contact> contacts = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            contacts.addAll(b.getContacts());\n        }\n\n        return contacts;\n    }\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    @Override\n    public final KademliaBucket[] getBuckets()\n    {\n        return this.buckets;\n    }\n\n    /**\n     * Set the KadBuckets of this routing table, mainly used when retrieving saved state\n     *\n     * @param buckets\n     */\n    public final void setBuckets(KademliaBucket[] buckets)\n    {\n        this.buckets = buckets;\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    @Override\n    public void setUnresponsiveContacts(List<Node> contacts)\n    {\n        if (contacts.isEmpty())\n        {\n            return;\n        }\n        for (Node n : contacts)\n        {\n            this.setUnresponsiveContact(n);\n        }\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    @Override\n    public synchronized void setUnresponsiveContact(Node n)\n    {\n        int bucketId = this.getBucketId(n.getNodeId());\n\n        /* Remove the contact from the bucket */\n        this.buckets[bucketId].removeNode(n);\n    }\n\n    @Override\n    public synchronized final String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\nPrinting Routing Table Started ***************** \\n\");\n        int totalContacts = 0;\n        for (KademliaBucket b : this.buckets)\n        {\n            if (b.numContacts() > 0)\n            {\n                totalContacts += b.numContacts();\n                sb.append(\"# nodes in Bucket with depth \");\n                sb.append(b.getDepth());\n                sb.append(\": \");\n                sb.append(b.numContacts());\n                sb.append(\"\\n\");\n                sb.append(b.toString());\n                sb.append(\"\\n\");\n            }\n        }\n\n        sb.append(\"\\nTotal Contacts: \");\n        sb.append(totalContacts);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"Printing Routing Table Ended ******************** \");\n\n        return sb.toString();\n    }\n\n}\nsrc/kademlia/util/serializer/JsonDHTSerializer.java\npublic class JsonDHTSerializer implements KadSerializer<KademliaDHT>\n{\n\n    private final Gson gson;\n    private final Type storageEntriesCollectionType;\n\n    \n    {\n        gson = new Gson();\n\n        storageEntriesCollectionType = new TypeToken<List<KademliaStorageEntryMetadata>>()\n        {\n        }.getType();\n    }\n\n    @Override\n    public void write(KademliaDHT data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic DHT */\n            gson.toJson(data, DHT.class, writer);\n\n            /* Now Store the Entries  */\n            gson.toJson(data.getStorageEntries(), this.storageEntriesCollectionType, writer);\n\n            writer.endArray();\n        }\n\n    }\n\n    @Override\n    public KademliaDHT read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic DHT */\n            DHT dht = gson.fromJson(reader, DHT.class);\n            dht.initialize();\n\n            /* Now get the entries and add them back to the DHT */\n            List<KademliaStorageEntryMetadata> entries = gson.fromJson(reader, this.storageEntriesCollectionType);\n            dht.putStorageEntries(entries);\n\n            reader.endArray();\n            return dht;\n        }\n    }\n}\nsrc/kademlia/exceptions/ContentNotFoundException.java\npublic class ContentNotFoundException extends Exception\n{\n\n    public ContentNotFoundException()\n    {\n        super();\n    }\n\n    public ContentNotFoundException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/dht/GetParameter.java\npublic class GetParameter\n{\n\n    private KademliaId key;\n    private String ownerId = null;\n    private String type = null;\n\n    /**\n     * Construct a GetParameter to search for data by NodeId and owner\n     *\n     * @param key\n     * @param type\n     */\n    public GetParameter(KademliaId key, String type)\n    {\n        this.key = key;\n        this.type = type;\n    }\n\n    /**\n     * Construct a GetParameter to search for data by NodeId, owner, type\n     *\n     * @param key\n     * @param type\n     * @param owner\n     */\n    public GetParameter(KademliaId key, String type, String owner)\n    {\n        this(key, type);\n        this.ownerId = owner;\n    }\n\n    /**\n     * Construct our get parameter from a Content\n     *\n     * @param c\n     */\n    public GetParameter(KadContent c)\n    {\n        this.key = c.getKey();\n\n        if (c.getType() != null)\n        {\n            this.type = c.getType();\n        }\n\n        if (c.getOwnerId() != null)\n        {\n            this.ownerId = c.getOwnerId();\n        }\n    }\n\n    /**\n     * Construct our get parameter from a StorageEntryMeta data\n     *\n     * @param md\n     */\n    public GetParameter(KademliaStorageEntryMetadata md)\n    {\n        this.key = md.getKey();\n\n        if (md.getType() != null)\n        {\n            this.type = md.getType();\n        }\n\n        if (md.getOwnerId() != null)\n        {\n            this.ownerId = md.getOwnerId();\n        }\n    }\n\n    public KademliaId getKey()\n    {\n        return this.key;\n    }\n\n    public void setOwnerId(String ownerId)\n    {\n        this.ownerId = ownerId;\n    }\n\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    public void setType(String type)\n    {\n        this.type = type;\n    }\n\n    public String getType()\n    {\n        return this.type;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"GetParameter - [Key: \" + key + \"][Owner: \" + this.ownerId + \"][Type: \" + this.type + \"]\";\n    }\n}\nsrc/kademlia/operation/ContentLookupOperation.java\npublic class ContentLookupOperation implements Operation, Receiver\n{\n\n    /* Constants */\n    private static final Byte UNASKED = (byte) 0x00;\n    private static final Byte AWAITING = (byte) 0x01;\n    private static final Byte ASKED = (byte) 0x02;\n    private static final Byte FAILED = (byte) 0x03;\n\n    private final KadServer server;\n    private final JKademliaNode localNode;\n    private JKademliaStorageEntry contentFound = null;\n    private final KadConfiguration config;\n\n    private final ContentLookupMessage lookupMessage;\n\n    private boolean isContentFound;\n    private final SortedMap<Node, Byte> nodes;\n\n    /* Tracks messages in transit and awaiting reply */\n    private final Map<Integer, Node> messagesTransiting;\n\n    /* Used to sort nodes */\n    private final Comparator comparator;\n\n    /* Statistical information */\n    private final RouteLengthChecker routeLengthChecker;\n\n    \n    {\n        messagesTransiting = new HashMap<>();\n        isContentFound = false;\n        routeLengthChecker = new RouteLengthChecker();\n    }\n\n    /**\n     * @param server\n     * @param localNode\n     * @param params    The parameters to search for the content which we need to find\n     * @param config\n     */\n    public ContentLookupOperation(KadServer server, JKademliaNode localNode, GetParameter params, KadConfiguration config)\n    {\n        /* Construct our lookup message */\n        this.lookupMessage = new ContentLookupMessage(localNode.getNode(), params);\n\n        this.server = server;\n        this.localNode = localNode;\n        this.config = config;\n\n        /**\n         * We initialize a TreeMap to store nodes.\n         * This map will be sorted by which nodes are closest to the lookupId\n         */\n        this.comparator = new KeyComparator(params.getKey());\n        this.nodes = new TreeMap(this.comparator);\n    }\n\n    /**\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.RoutingException\n     */\n    @Override\n    public synchronized void execute() throws IOException, RoutingException\n    {\n        try\n        {\n            /* Set the local node as already asked */\n            nodes.put(this.localNode.getNode(), ASKED);\n\n            /**\n             * We add all nodes here instead of the K-Closest because there may be the case that the K-Closest are offline\n             * - The operation takes care of looking at the K-Closest.\n             */\n            List<Node> allNodes = this.localNode.getRoutingTable().getAllNodes();\n            this.addNodes(allNodes);\n            \n            /* Also add the initial set of nodes to the routeLengthChecker */\n            this.routeLengthChecker.addInitialNodes(allNodes);\n\n            /**\n             * If we haven't found the requested amount of content as yet,\n             * keey trying until config.operationTimeout() time has expired\n             */\n            int totalTimeWaited = 0;\n            int timeInterval = 10;     // We re-check every n milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (!this.askNodesorFinish() && !isContentFound)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add nodes from this list to the set of nodes to lookup\n     *\n     * @param list The list from which to add nodes\n     */\n    public void addNodes(List<Node> list)\n    {\n        for (Node o : list)\n        {\n            /* If this node is not in the list, add the node */\n            if (!nodes.containsKey(o))\n            {\n                nodes.put(o, UNASKED);\n            }\n        }\n    }\n\n    /**\n     * Asks some of the K closest nodes seen but not yet queried.\n     * Assures that no more than DefaultConfiguration.CONCURRENCY messages are in transit at a time\n     *\n     * This method should be called every time a reply is received or a timeout occurs.\n     *\n     * If all K closest nodes have been asked and there are no messages in transit,\n     * the algorithm is finished.\n     *\n     * @return <code>true</code> if finished OR <code>false</code> otherwise\n     */\n    private boolean askNodesorFinish() throws IOException\n    {\n        /* If >= CONCURRENCY nodes are in transit, don't do anything */\n        if (this.config.maxConcurrentMessagesTransiting() <= this.messagesTransiting.size())\n        {\n            return false;\n        }\n\n        /* Get unqueried nodes among the K closest seen that have not FAILED */\n        List<Node> unasked = this.closestNodesNotFailed(UNASKED);\n\n        if (unasked.isEmpty() && this.messagesTransiting.isEmpty())\n        {\n            /* We have no unasked nodes nor any messages in transit, we're finished! */\n            return true;\n        }\n\n        /* Sort nodes according to criteria */\n        Collections.sort(unasked, this.comparator);\n\n        /**\n         * Send messages to nodes in the list;\n         * making sure than no more than CONCURRENCY messsages are in transit\n         */\n        for (int i = 0; (this.messagesTransiting.size() < this.config.maxConcurrentMessagesTransiting()) && (i < unasked.size()); i++)\n        {\n            Node n = (Node) unasked.get(i);\n\n            int comm = server.sendMessage(n, lookupMessage, this);\n\n            this.nodes.put(n, AWAITING);\n            this.messagesTransiting.put(comm, n);\n        }\n\n        /* We're not finished as yet, return false */\n        return false;\n    }\n\n    /**\n     * Find The K closest nodes to the target lookupId given that have not FAILED.\n     * From those K, get those that have the specified status\n     *\n     * @param status The status of the nodes to return\n     *\n     * @return A List of the closest nodes\n     */\n    private List<Node> closestNodesNotFailed(Byte status)\n    {\n        List<Node> closestNodes = new ArrayList<>(this.config.k());\n        int remainingSpaces = this.config.k();\n\n        for (Map.Entry e : this.nodes.entrySet())\n        {\n            if (!FAILED.equals(e.getValue()))\n            {\n                if (status.equals(e.getValue()))\n                {\n                    /* We got one with the required status, now add it */\n                    closestNodes.add((Node) e.getKey());\n                }\n\n                if (--remainingSpaces == 0)\n                {\n                    break;\n                }\n            }\n        }\n\n        return closestNodes;\n    }\n\n    @Override\n    public synchronized void receive(Message incoming, int comm) throws IOException, RoutingException\n    {\n        if (this.isContentFound)\n        {\n            return;\n        }\n\n        if (incoming instanceof ContentMessage)\n        {\n            /* The reply received is a content message with the required content, take it in */\n            ContentMessage msg = (ContentMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            this.localNode.getRoutingTable().insert(msg.getOrigin());\n\n            /* Get the Content and check if it satisfies the required parameters */\n            JKademliaStorageEntry content = msg.getContent();\n            this.contentFound = content;\n            this.isContentFound = true;\n        }\n        else\n        {\n            /* The reply received is a NodeReplyMessage with nodes closest to the content needed */\n            NodeReplyMessage msg = (NodeReplyMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            Node origin = msg.getOrigin();\n            this.localNode.getRoutingTable().insert(origin);\n\n            /* Set that we've completed ASKing the origin node */\n            this.nodes.put(origin, ASKED);\n\n            /* Remove this msg from messagesTransiting since it's completed now */\n            this.messagesTransiting.remove(comm);\n            \n            /* Add the received nodes to the routeLengthChecker */\n            this.routeLengthChecker.addNodes(msg.getNodes(), origin);\n\n            /* Add the received nodes to our nodes list to query */\n            this.addNodes(msg.getNodes());\n            this.askNodesorFinish();\n        }\n    }\n\n    /**\n     * A node does not respond or a packet was lost, we set this node as failed\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        /* Get the node associated with this communication */\n        Node n = this.messagesTransiting.get(new Integer(comm));\n\n        if (n == null)\n        {\n            throw new UnknownMessageException(\"Unknown comm: \" + comm);\n        }\n\n        /* Mark this node as failed and inform the routing table that it's unresponsive */\n        this.nodes.put(n, FAILED);\n        this.localNode.getRoutingTable().setUnresponsiveContact(n);\n        this.messagesTransiting.remove(comm);\n\n        this.askNodesorFinish();\n    }\n    \n    /**\n     * @return Whether the content was found or not.\n     */\n    public boolean isContentFound()\n    {\n        return this.isContentFound;\n    }\n\n    /**\n     * @return The list of all content found during the lookup operation\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry getContentFound() throws ContentNotFoundException\n    {\n        if (this.isContentFound)\n        {\n            return this.contentFound;\n        }\n        else\n        {\n            throw new ContentNotFoundException(\"No Value was found for the given key.\");\n        }\n    }\n\n    /**\n     * @return How many hops it took in order to get to the content.\n     */\n    public int routeLength()\n    {\n        return this.routeLengthChecker.getRouteLength();\n    }\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\npackage kademlia;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.NoSuchElementException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport kademlia.dht.GetParameter;\nimport kademlia.dht.DHT;\nimport kademlia.dht.KadContent;\nimport kademlia.dht.KademliaDHT;\nimport kademlia.dht.KademliaStorageEntry;\nimport kademlia.dht.JKademliaStorageEntry;\nimport kademlia.exceptions.ContentNotFoundException;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.MessageFactory;\nimport kademlia.node.Node;\nimport kademlia.node.KademliaId;\nimport kademlia.operation.ConnectOperation;\nimport kademlia.operation.ContentLookupOperation;\nimport kademlia.operation.Operation;\nimport kademlia.operation.KadRefreshOperation;\nimport kademlia.operation.StoreOperation;\nimport kademlia.routing.JKademliaRoutingTable;\nimport kademlia.routing.KademliaRoutingTable;\nimport kademlia.util.serializer.JsonDHTSerializer;\nimport kademlia.util.serializer.JsonRoutingTableSerializer;\nimport kademlia.util.serializer.JsonSerializer;\n\n\n/**\n * The main Kademlia Node on the network, this node manages everything for this local system.\n *\n * @author Joshua Kissoon\n * @since 20140215\n *\n * @todo When we receive a store message - if we have a newer version of the content, re-send this newer version to that node so as to update their version\n * @todo Handle IPv6 Addresses\n *\n */\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;Next line of code:\n", "input": "package kademlia;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.NoSuchElementException;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport kademlia.dht.GetParameter;\nimport kademlia.dht.DHT;\nimport kademlia.dht.KadContent;\nimport kademlia.dht.KademliaDHT;\nimport kademlia.dht.KademliaStorageEntry;\nimport kademlia.dht.JKademliaStorageEntry;\nimport kademlia.exceptions.ContentNotFoundException;\nimport kademlia.exceptions.RoutingException;\nimport kademlia.message.MessageFactory;\nimport kademlia.node.Node;\nimport kademlia.node.KademliaId;\nimport kademlia.operation.ConnectOperation;\nimport kademlia.operation.ContentLookupOperation;\nimport kademlia.operation.Operation;\nimport kademlia.operation.KadRefreshOperation;\nimport kademlia.operation.StoreOperation;\nimport kademlia.routing.JKademliaRoutingTable;\nimport kademlia.routing.KademliaRoutingTable;\nimport kademlia.util.serializer.JsonDHTSerializer;\nimport kademlia.util.serializer.JsonRoutingTableSerializer;\nimport kademlia.util.serializer.JsonSerializer;\n\n\n/**\n * The main Kademlia Node on the network, this node manages everything for this local system.\n *\n * @author Joshua Kissoon\n * @since 20140215\n *\n * @todo When we receive a store message - if we have a newer version of the content, re-send this newer version to that node so as to update their version\n * @todo Handle IPv6 Addresses\n *\n */\npublic class JKademliaNode implements KademliaNode\n{\n\n    /* Kademlia Attributes */\n    private final String ownerId;\n\n    /* Objects to be used */\n    private final transient Node localNode;\n    private final transient KadServer server;\n    private final transient KademliaDHT dht;", "context": "src/kademlia/operation/KadRefreshOperation.java\npublic class KadRefreshOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public KadRefreshOperation(KadServer server, KademliaNode localNode, KademliaDHT dht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public void execute() throws IOException\n    {\n        /* Run our BucketRefreshOperation to refresh buckets */\n        new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n\n        /* After buckets have been refreshed, we refresh content */\n        new ContentRefreshOperation(this.server, this.localNode, this.dht, this.config).execute();\n    }\n}\nsrc/kademlia/operation/StoreOperation.java\npublic class StoreOperation implements Operation\n{\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final JKademliaStorageEntry storageEntry;\n    private final KademliaDHT localDht;\n    private final KadConfiguration config;\n\n    /**\n     * @param server\n     * @param localNode\n     * @param storageEntry The content to be stored on the DHT\n     * @param localDht     The local DHT\n     * @param config\n     */\n    public StoreOperation(KadServer server, KademliaNode localNode, JKademliaStorageEntry storageEntry, KademliaDHT localDht, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = localNode;\n        this.storageEntry = storageEntry;\n        this.localDht = localDht;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        /* Get the nodes on which we need to store the content */\n        NodeLookupOperation ndlo = new NodeLookupOperation(this.server, this.localNode, this.storageEntry.getContentMetadata().getKey(), this.config);\n        ndlo.execute();\n        List<Node> nodes = ndlo.getClosestNodes();\n\n        /* Create the message */\n        Message msg = new StoreContentMessage(this.localNode.getNode(), this.storageEntry);\n\n        /*Store the message on all of the K-Nodes*/\n        for (Node n : nodes)\n        {\n            if (n.equals(this.localNode.getNode()))\n            {\n                /* Store the content locally */\n                this.localDht.store(this.storageEntry);\n            }\n            else\n            {\n                /**\n                 * @todo Create a receiver that receives a store acknowledgement message to count how many nodes a content have been stored at\n                 */\n                this.server.sendMessage(n, msg, null);\n            }\n        }\n    }\n\n    /**\n     * @return The number of nodes that have stored this content\n     *\n     * @todo Implement this method\n     */\n    public int numNodesStoredAt()\n    {\n        return 1;\n    }\n}\nsrc/kademlia/dht/JKademliaStorageEntry.java\npublic class JKademliaStorageEntry implements KademliaStorageEntry\n{\n\n    private String content;\n    private final StorageEntryMetadata metadata;\n\n    public JKademliaStorageEntry(final KadContent content)\n    {\n        this(content, new StorageEntryMetadata(content));\n    }\n\n    public JKademliaStorageEntry(final KadContent content, final StorageEntryMetadata metadata)\n    {\n        this.setContent(content.toSerializedForm());\n        this.metadata = metadata;\n    }\n\n    @Override\n    public final void setContent(final byte[] data)\n    {\n        this.content = new String(data);\n    }\n\n    @Override\n    public final byte[] getContent()\n    {\n        return this.content.getBytes();\n    }\n\n    @Override\n    public final KademliaStorageEntryMetadata getContentMetadata()\n    {\n        return this.metadata;\n    }\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"[StorageEntry: \");\n\n        sb.append(\"[Content: \");\n        sb.append(this.getContent());\n        sb.append(\"]\");\n\n        sb.append(this.getContentMetadata());\n\n        sb.append(\"]\");\n\n        return sb.toString();\n    }\n}\nsrc/kademlia/dht/DHT.java\npublic class DHT implements KademliaDHT\n{\n\n    private transient StoredContentManager contentManager;\n    private transient KadSerializer<JKademliaStorageEntry> serializer = null;\n    private transient KadConfiguration config;\n\n    private final String ownerId;\n\n    public DHT(String ownerId, KadConfiguration config)\n    {\n        this.ownerId = ownerId;\n        this.config = config;\n        this.initialize();\n    }\n\n    @Override\n    public final void initialize()\n    {\n        contentManager = new StoredContentManager();\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration con)\n    {\n        this.config = con;\n    }\n\n    @Override\n    public KadSerializer<JKademliaStorageEntry> getSerializer()\n    {\n        if (null == serializer)\n        {\n            serializer = new JsonSerializer<>();\n        }\n\n        return serializer;\n    }\n\n    @Override\n    public boolean store(JKademliaStorageEntry content) throws IOException\n    {\n        /* Lets check if we have this content and it's the updated version */\n        if (this.contentManager.contains(content.getContentMetadata()))\n        {\n            KademliaStorageEntryMetadata current = this.contentManager.get(content.getContentMetadata());\n\n            /* update the last republished time */\n            current.updateLastRepublished();\n\n            if (current.getLastUpdatedTimestamp() >= content.getContentMetadata().getLastUpdatedTimestamp())\n            {\n                /* We have the current content, no need to update it! just leave this method now */\n                return false;\n            }\n            else\n            {\n                /* We have this content, but not the latest version, lets delete it so the new version will be added below */\n                try\n                {\n                    //System.out.println(\"Removing older content to update it\");\n                    this.remove(content.getContentMetadata());\n                }\n                catch (ContentNotFoundException ex)\n                {\n                    /* This won't ever happen at this point since we only get here if the content is found, lets ignore it  */\n                }\n            }\n        }\n\n        /**\n         * If we got here means we don't have this content, or we need to update the content\n         * If we need to update the content, the code above would've already deleted it, so we just need to re-add it\n         */\n        try\n        {\n            //System.out.println(\"Adding new content.\");\n            /* Keep track of this content in the entries manager */\n            KademliaStorageEntryMetadata sEntry = this.contentManager.put(content.getContentMetadata());\n\n            /* Now we store the content locally in a file */\n            String contentStorageFolder = this.getContentStorageFolderName(content.getContentMetadata().getKey());\n\n            try (FileOutputStream fout = new FileOutputStream(contentStorageFolder + File.separator + sEntry.hashCode() + \".kct\");\n                    DataOutputStream dout = new DataOutputStream(fout))\n            {\n                this.getSerializer().write(content, dout);\n            }\n            return true;\n        }\n        catch (ContentExistException e)\n        {\n            /**\n             * Content already exist on the DHT\n             * This won't happen because above takes care of removing the content if it's older and needs to be updated,\n             * or returning if we already have the current content version.\n             */\n            return false;\n        }\n    }\n\n    @Override\n    public boolean store(KadContent content) throws IOException\n    {\n        return this.store(new JKademliaStorageEntry(content));\n    }\n\n    @Override\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(key);\n        DataInputStream din = new DataInputStream(new FileInputStream(folder + File.separator + hashCode + \".kct\"));\n        return this.getSerializer().read(din);\n    }\n\n    @Override\n    public boolean contains(GetParameter param)\n    {\n        return this.contentManager.contains(param);\n    }\n\n    @Override\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException\n    {\n        try\n        {\n            return this.retrieve(entry.getKey(), entry.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException\n    {\n        /* Load a KadContent if any exist for the given criteria */\n        try\n        {\n            KademliaStorageEntryMetadata e = this.contentManager.get(param);\n            return this.retrieve(e.getKey(), e.hashCode());\n        }\n        catch (FileNotFoundException e)\n        {\n            System.err.println(\"Error while loading file for content. Message: \" + e.getMessage());\n        }\n        catch (ClassNotFoundException e)\n        {\n            System.err.println(\"The class for some content was not found. Message: \" + e.getMessage());\n        }\n\n        /* If we got here, means we got no entries */\n        throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove(KadContent content) throws ContentNotFoundException\n    {\n        this.remove(new StorageEntryMetadata(content));\n    }\n\n    @Override\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException\n    {\n        String folder = this.getContentStorageFolderName(entry.getKey());\n        File file = new File(folder + File.separator + entry.hashCode() + \".kct\");\n\n        contentManager.remove(entry);\n\n        if (file.exists())\n        {\n            file.delete();\n        }\n        else\n        {\n            throw new ContentNotFoundException();\n        }\n    }\n\n    /**\n     * Get the name of the folder for which a content should be stored\n     *\n     * @param key The key of the content\n     *\n     * @return String The name of the folder\n     */\n    private String getContentStorageFolderName(KademliaId key)\n    {\n        /**\n         * Each content is stored in a folder named after the first 2 characters of the NodeId\n         *\n         * The name of the file containing the content is the hash of this content\n         */\n        String folderName = key.hexRepresentation().substring(0, 2);\n        File contentStorageFolder = new File(this.config.getNodeDataFolder(ownerId) + File.separator + folderName);\n\n        /* Create the content folder if it doesn't exist */\n        if (!contentStorageFolder.isDirectory())\n        {\n            contentStorageFolder.mkdir();\n        }\n\n        return contentStorageFolder.toString();\n    }\n\n    @Override\n    public List<KademliaStorageEntryMetadata> getStorageEntries()\n    {\n        return contentManager.getAllEntries();\n    }\n\n    @Override\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries)\n    {\n        for (KademliaStorageEntryMetadata e : ientries)\n        {\n            try\n            {\n                this.contentManager.put(e);\n            }\n            catch (ContentExistException ex)\n            {\n                /* Entry already exist, no need to store it again */\n            }\n        }\n    }\n\n    @Override\n    public synchronized String toString()\n    {\n        return this.contentManager.toString();\n    }\n}\nsrc/kademlia/routing/KademliaRoutingTable.java\npublic interface KademliaRoutingTable\n{\n\n    /**\n     * Initialize the RoutingTable to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Sets the configuration file for this routing table\n     *\n     * @param config\n     */\n    public void setConfiguration(KadConfiguration config);\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    public void insert(Contact c);\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    public void insert(Node n);\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    public int getBucketId(KademliaId nid);\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    public List<Node> findClosest(KademliaId target, int numNodesRequired);\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllNodes();\n\n    /**\n     * @return List A List of all Nodes in this RoutingTable\n     */\n    public List getAllContacts();\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    public KademliaBucket[] getBuckets();\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    public void setUnresponsiveContacts(List<Node> contacts);\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    public void setUnresponsiveContact(Node n);\n\n}\nsrc/kademlia/dht/KadContent.java\npublic interface KadContent\n{\n\n    /**\n     * @return NodeId The DHT key for this content\n     */\n    public KademliaId getKey();\n\n    /**\n     * @return String The type of content\n     */\n    public String getType();\n\n    /**\n     * Each content will have an created date\n     * This allows systems to know when to delete a content form his/her machine\n     *\n     * @return long The create date of this content\n     */\n    public long getCreatedTimestamp();\n\n    /**\n     * Each content will have an update timestamp\n     * This allows the DHT to keep only the latest version of a content\n     *\n     * @return long The timestamp of when this content was last updated\n     */\n    public long getLastUpdatedTimestamp();\n\n    /**\n     * @return The ID of the owner of this content\n     */\n    public String getOwnerId();\n\n    /**\n     * Each content needs to be in byte format for transporting and storage,\n     * this method takes care of that.\n     *\n     * Each object is responsible for transforming itself to byte format since the\n     * structure of methods may differ.\n     *\n     * @return The content in byte format\n     */\n    public byte[] toSerializedForm();\n\n    /**\n     * Given the Content in byte format, read it\n     *\n     * @param data The object in byte format\n     *\n     * @return A new object from the given\n     */\n    public KadContent fromSerializedForm(byte[] data);\n}\nsrc/kademlia/util/serializer/JsonRoutingTableSerializer.java\npublic class JsonRoutingTableSerializer implements KadSerializer<KademliaRoutingTable>\n{\n\n    private final Gson gson;\n\n    Type contactCollectionType = new TypeToken<List<Contact>>()\n    {\n    }.getType();\n\n    private final KadConfiguration config;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    /**\n     * Initialize the class\n     *\n     * @param config\n     */\n    public JsonRoutingTableSerializer(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    @Override\n    public void write(KademliaRoutingTable data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic JKademliaRoutingTable */\n            gson.toJson(data, JKademliaRoutingTable.class, writer);\n\n            /* Now Store the Contacts  */\n            gson.toJson(data.getAllContacts(), contactCollectionType, writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public KademliaRoutingTable read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic JKademliaRoutingTable */\n            KademliaRoutingTable tbl = gson.fromJson(reader, KademliaRoutingTable.class);\n            tbl.setConfiguration(config);\n            \n            /* Now get the Contacts and add them back to the JKademliaRoutingTable */\n            List<Contact> contacts = gson.fromJson(reader, contactCollectionType);\n            tbl.initialize();\n\n            for (Contact c : contacts)\n            {\n                tbl.insert(c);\n            }\n\n            reader.endArray();\n            /* Read and return the Content*/\n            return tbl;\n        }\n    }\n}\nsrc/kademlia/operation/ConnectOperation.java\npublic class ConnectOperation implements Operation, Receiver\n{\n\n    public static final int MAX_CONNECT_ATTEMPTS = 5;       // Try 5 times to connect to a node\n\n    private final KadServer server;\n    private final KademliaNode localNode;\n    private final Node bootstrapNode;\n    private final KadConfiguration config;\n\n    private boolean error;\n    private int attempts;\n\n    /**\n     * @param server    The message server used to send/receive messages\n     * @param local     The local node\n     * @param bootstrap Node to use to bootstrap the local node onto the network\n     * @param config\n     */\n    public ConnectOperation(KadServer server, KademliaNode local, Node bootstrap, KadConfiguration config)\n    {\n        this.server = server;\n        this.localNode = local;\n        this.bootstrapNode = bootstrap;\n        this.config = config;\n    }\n\n    @Override\n    public synchronized void execute() throws IOException\n    {\n        try\n        {\n            /* Contact the bootstrap node */\n            this.error = true;\n            this.attempts = 0;\n            Message m = new ConnectMessage(this.localNode.getNode());\n\n            /* Send a connect message to the bootstrap node */\n            server.sendMessage(this.bootstrapNode, m, this);\n\n            /* If we haven't finished as yet, wait for a maximum of config.operationTimeout() time */\n            int totalTimeWaited = 0;\n            int timeInterval = 50;     // We re-check every 300 milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (error)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            if (error)\n            {\n                /* If we still haven't received any responses by then, do a routing timeout */\n                throw new RoutingException(\"ConnectOperation: Bootstrap node did not respond: \" + bootstrapNode);\n            }\n\n            /* Perform lookup for our own ID to get nodes close to us */\n            Operation lookup = new NodeLookupOperation(this.server, this.localNode, this.localNode.getNode().getNodeId(), this.config);\n            lookup.execute();\n\n            /**\n             * Refresh buckets to get a good routing table\n             * After the above lookup operation, K nodes will be in our routing table,\n             * Now we try to populate all of our buckets.\n             */\n            new BucketRefreshOperation(this.server, this.localNode, this.config).execute();\n        }\n        catch (InterruptedException e)\n        {\n            System.err.println(\"Connect operation was interrupted. \");\n        }\n    }\n\n    /**\n     * Receives an AcknowledgeMessage from the bootstrap node.\n     *\n     * @param comm\n     */\n    @Override\n    public synchronized void receive(Message incoming, int comm)\n    {\n        /* The incoming message will be an acknowledgement message */\n        AcknowledgeMessage msg = (AcknowledgeMessage) incoming;\n\n        /* The bootstrap node has responded, insert it into our space */\n        this.localNode.getRoutingTable().insert(this.bootstrapNode);\n\n        /* We got a response, so the error is false */\n        error = false;\n\n        /* Wake up any waiting thread */\n        notify();\n    }\n\n    /**\n     * Resends a ConnectMessage to the boot strap node a maximum of MAX_ATTEMPTS\n     * times.\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        if (++this.attempts < MAX_CONNECT_ATTEMPTS)\n        {\n            this.server.sendMessage(this.bootstrapNode, new ConnectMessage(this.localNode.getNode()), this);\n        }\n        else\n        {\n            /* We just exit, so notify all other threads that are possibly waiting */\n            notify();\n        }\n    }\n}\nsrc/kademlia/dht/KademliaStorageEntry.java\npublic interface KademliaStorageEntry\n{\n\n    /**\n     * Add the content to the storage entry\n     *\n     * @param data The content data in byte[] format\n     */\n    public void setContent(final byte[] data);\n\n    /**\n     * Get the content from this storage entry\n     *\n     * @return The content in byte format\n     */\n    public byte[] getContent();\n\n    /**\n     * Get the metadata for this storage entry\n     *\n     * @return the storage entry metadata\n     */\n    public KademliaStorageEntryMetadata getContentMetadata();\n}\nsrc/kademlia/message/MessageFactory.java\npublic class MessageFactory implements KademliaMessageFactory\n{\n\n    private final KademliaNode localNode;\n    private final KademliaDHT dht;\n    private final KadConfiguration config;\n\n    public MessageFactory(KademliaNode local, KademliaDHT dht, KadConfiguration config)\n    {\n        this.localNode = local;\n        this.dht = dht;\n        this.config = config;\n    }\n\n    @Override\n    public Message createMessage(byte code, DataInputStream in) throws IOException\n    {\n        switch (code)\n        {\n            case AcknowledgeMessage.CODE:\n                return new AcknowledgeMessage(in);\n            case ConnectMessage.CODE:\n                return new ConnectMessage(in);\n            case ContentMessage.CODE:\n                return new ContentMessage(in);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupMessage(in);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupMessage(in);\n            case NodeReplyMessage.CODE:\n                return new NodeReplyMessage(in);\n            case SimpleMessage.CODE:\n                return new SimpleMessage(in);\n            case StoreContentMessage.CODE:\n                return new StoreContentMessage(in);\n            default:\n                //System.out.println(this.localNode + \" - No Message handler found for message. Code: \" + code);\n                return new SimpleMessage(in);\n\n        }\n    }\n\n    @Override\n    public Receiver createReceiver(byte code, KadServer server)\n    {\n        switch (code)\n        {\n            case ConnectMessage.CODE:\n                return new ConnectReceiver(server, this.localNode);\n            case ContentLookupMessage.CODE:\n                return new ContentLookupReceiver(server, this.localNode, this.dht, this.config);\n            case NodeLookupMessage.CODE:\n                return new NodeLookupReceiver(server, this.localNode, this.config);\n            case StoreContentMessage.CODE:\n                return new StoreContentReceiver(server, this.localNode, this.dht);\n            default:\n                //System.out.println(\"No receiver found for message. Code: \" + code);\n                return new SimpleReceiver();\n        }\n    }\n}\nsrc/kademlia/util/serializer/JsonSerializer.java\npublic class JsonSerializer<T> implements KadSerializer<T>\n{\n\n    private final Gson gson;\n\n    \n    {\n        gson = new Gson();\n    }\n\n    @Override\n    public void write(T data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Store the content type */\n            gson.toJson(data.getClass().getName(), String.class, writer);\n\n            /* Now Store the content */\n            gson.toJson(data, data.getClass(), writer);\n\n            writer.endArray();\n        }\n    }\n\n    @Override\n    public T read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the class name */\n            String className = gson.fromJson(reader, String.class);\n\n            /* Read and return the Content*/\n            T ret = gson.fromJson(reader, Class.forName(className));\n            \n            reader.endArray();\n            \n            return ret;\n        }\n    }\n}\nsrc/kademlia/exceptions/RoutingException.java\npublic class RoutingException extends IOException\n{\n\n    public RoutingException()\n    {\n        super();\n    }\n\n    public RoutingException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/node/KademliaId.java\npublic class KademliaId implements Streamable, Serializable\n{\n\n    public final transient static int ID_LENGTH = 160;\n    private byte[] keyBytes;\n\n    /**\n     * Construct the NodeId from some string\n     *\n     * @param data The user generated key string\n     */\n    public KademliaId(String data)\n    {\n        keyBytes = data.getBytes();\n        if (keyBytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long.\");\n        }\n    }\n\n    /**\n     * Generate a random key\n     */\n    public KademliaId()\n    {\n        keyBytes = new byte[ID_LENGTH / 8];\n        new Random().nextBytes(keyBytes);\n    }\n\n    /**\n     * Generate the NodeId from a given byte[]\n     *\n     * @param bytes\n     */\n    public KademliaId(byte[] bytes)\n    {\n        if (bytes.length != ID_LENGTH / 8)\n        {\n            throw new IllegalArgumentException(\"Specified Data need to be \" + (ID_LENGTH / 8) + \" characters long. Data Given: '\" + new String(bytes) + \"'\");\n        }\n        this.keyBytes = bytes;\n    }\n\n    /**\n     * Load the NodeId from a DataInput stream\n     *\n     * @param in The stream from which to load the NodeId\n     *\n     * @throws IOException\n     */\n    public KademliaId(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n    }\n\n    public byte[] getBytes()\n    {\n        return this.keyBytes;\n    }\n\n    /**\n     * @return The BigInteger representation of the key\n     */\n    public BigInteger getInt()\n    {\n        return new BigInteger(1, this.getBytes());\n    }\n\n    /**\n     * Compares a NodeId to this NodeId\n     *\n     * @param o The NodeId to compare to this NodeId\n     *\n     * @return boolean Whether the 2 NodeIds are equal\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof KademliaId)\n        {\n            KademliaId nid = (KademliaId) o;\n            return this.hashCode() == nid.hashCode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash = 7;\n        hash = 83 * hash + Arrays.hashCode(this.keyBytes);\n        return hash;\n    }\n\n    /**\n     * Checks the distance between this and another NodeId\n     *\n     * @param nid\n     *\n     * @return The distance of this NodeId from the given NodeId\n     */\n    public KademliaId xor(KademliaId nid)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n        byte[] nidBytes = nid.getBytes();\n\n        for (int i = 0; i < ID_LENGTH / 8; i++)\n        {\n            result[i] = (byte) (this.keyBytes[i] ^ nidBytes[i]);\n        }\n\n        KademliaId resNid = new KademliaId(result);\n\n        return resNid;\n    }\n\n    /**\n     * Generates a NodeId that is some distance away from this NodeId\n     *\n     * @param distance in number of bits\n     *\n     * @return NodeId The newly generated NodeId\n     */\n    public KademliaId generateNodeIdByDistance(int distance)\n    {\n        byte[] result = new byte[ID_LENGTH / 8];\n\n        /* Since distance = ID_LENGTH - prefixLength, we need to fill that amount with 0's */\n        int numByteZeroes = (ID_LENGTH - distance) / 8;\n        int numBitZeroes = 8 - (distance % 8);\n\n        /* Filling byte zeroes */\n        for (int i = 0; i < numByteZeroes; i++)\n        {\n            result[i] = 0;\n        }\n\n        /* Filling bit zeroes */\n        BitSet bits = new BitSet(8);\n        bits.set(0, 8);\n\n        for (int i = 0; i < numBitZeroes; i++)\n        {\n            /* Shift 1 zero into the start of the value */\n            bits.clear(i);\n        }\n        bits.flip(0, 8);        // Flip the bits since they're in reverse order\n        result[numByteZeroes] = (byte) bits.toByteArray()[0];\n\n        /* Set the remaining bytes to Maximum value */\n        for (int i = numByteZeroes + 1; i < result.length; i++)\n        {\n            result[i] = Byte.MAX_VALUE;\n        }\n\n        return this.xor(new KademliaId(result));\n    }\n\n    /**\n     * Counts the number of leading 0's in this NodeId\n     *\n     * @return Integer The number of leading 0's\n     */\n    public int getFirstSetBitIndex()\n    {\n        int prefixLength = 0;\n\n        for (byte b : this.keyBytes)\n        {\n            if (b == 0)\n            {\n                prefixLength += 8;\n            }\n            else\n            {\n                /* If the byte is not 0, we need to count how many MSBs are 0 */\n                int count = 0;\n                for (int i = 7; i >= 0; i--)\n                {\n                    boolean a = (b & (1 << i)) == 0;\n                    if (a)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        break;   // Reset the count if we encounter a non-zero number\n                    }\n                }\n\n                /* Add the count of MSB 0s to the prefix length */\n                prefixLength += count;\n\n                /* Break here since we've now covered the MSB 0s */\n                break;\n            }\n        }\n        return prefixLength;\n    }\n\n    /**\n     * Gets the distance from this NodeId to another NodeId\n     *\n     * @param to\n     *\n     * @return Integer The distance\n     */\n    public int getDistance(KademliaId to)\n    {\n        /**\n         * Compute the xor of this and to\n         * Get the index i of the first set bit of the xor returned NodeId\n         * The distance between them is ID_LENGTH - i\n         */\n        return ID_LENGTH - this.xor(to).getFirstSetBitIndex();\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        out.write(this.getBytes());\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        byte[] input = new byte[ID_LENGTH / 8];\n        in.readFully(input);\n        this.keyBytes = input;\n    }\n\n    public String hexRepresentation()\n    {\n        /* Returns the hex format of this NodeId */\n        BigInteger bi = new BigInteger(1, this.keyBytes);\n        return String.format(\"%0\" + (this.keyBytes.length << 1) + \"X\", bi);\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hexRepresentation();\n    }\n\n}\nsrc/kademlia/dht/KademliaDHT.java\npublic interface KademliaDHT\n{\n\n    /**\n     * Initialize this DHT to it's default state\n     */\n    public void initialize();\n\n    /**\n     * Set a new configuration. Mainly used when we restore the DHT state from a file\n     *\n     * @param con The new configuration file\n     */\n    public void setConfiguration(KadConfiguration con);\n\n    /**\n     * Creates a new Serializer or returns an existing serializer\n     *\n     * @return The new ContentSerializer\n     */\n    public KadSerializer<JKademliaStorageEntry> getSerializer();\n\n    /**\n     * Handle storing content locally\n     *\n     * @param content The DHT content to store\n     *\n     * @return boolean true if we stored the content, false if the content already exists and is up to date\n     *\n     * @throws java.io.IOException\n     */\n    public boolean store(JKademliaStorageEntry content) throws IOException;\n\n    public boolean store(KadContent content) throws IOException;\n\n    /**\n     * Retrieves a Content from local storage\n     *\n     * @param key      The Key of the content to retrieve\n     * @param hashCode The hash code of the content to retrieve\n     *\n     * @return A KadContent object\n     *\n     * @throws java.io.FileNotFoundException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public JKademliaStorageEntry retrieve(KademliaId key, int hashCode) throws FileNotFoundException, IOException, ClassNotFoundException;\n\n    /**\n     * Check if any content for the given criteria exists in this DHT\n     *\n     * @param param The content search criteria\n     *\n     * @return boolean Whether any content exist that satisfy the criteria\n     */\n    public boolean contains(GetParameter param);\n\n    /**\n     * Retrieve and create a KadContent object given the StorageEntry object\n     *\n     * @param entry The StorageEntry used to retrieve this content\n     *\n     * @return KadContent The content object\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(KademliaStorageEntryMetadata entry) throws IOException, NoSuchElementException;\n\n    /**\n     * Get the StorageEntry for the content if any exist.\n     *\n     * @param param The parameters used to filter the content needed\n     *\n     * @return KadContent A KadContent found on the DHT satisfying the given criteria\n     *\n     * @throws java.io.IOException\n     */\n    public JKademliaStorageEntry get(GetParameter param) throws NoSuchElementException, IOException;\n\n    /**\n     * Delete a content from local storage\n     *\n     * @param content The Content to Remove\n     *\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public void remove(KadContent content) throws ContentNotFoundException;\n\n    public void remove(KademliaStorageEntryMetadata entry) throws ContentNotFoundException;\n\n    /**\n     * @return A List of all StorageEntries for this node\n     */\n    public List<KademliaStorageEntryMetadata> getStorageEntries();\n\n    /**\n     * Used to add a list of storage entries for existing content to the DHT.\n     * Mainly used when retrieving StorageEntries from a saved state file.\n     *\n     * @param ientries The entries to add\n     */\n    public void putStorageEntries(List<KademliaStorageEntryMetadata> ientries);\n\n}\nsrc/kademlia/operation/Operation.java\npublic interface Operation\n{\n\n    /**\n     * Starts an operation and returns when the operation is finished\n     *\n     * @throws kademlia.exceptions.RoutingException\n     */\n    public void execute() throws IOException, RoutingException;\n}\nsrc/kademlia/routing/JKademliaRoutingTable.java\npublic class JKademliaRoutingTable implements KademliaRoutingTable\n{\n\n    private final Node localNode;  // The current node\n    private transient KademliaBucket[] buckets;\n\n    private transient KadConfiguration config;\n\n    public JKademliaRoutingTable(Node localNode, KadConfiguration config)\n    {\n        this.localNode = localNode;\n        this.config = config;\n\n        /* Initialize all of the buckets to a specific depth */\n        this.initialize();\n\n        /* Insert the local node */\n        this.insert(localNode);\n    }\n\n    /**\n     * Initialize the JKademliaRoutingTable to it's default state\n     */\n    @Override\n    public final void initialize()\n    {\n        this.buckets = new KademliaBucket[KademliaId.ID_LENGTH];\n        for (int i = 0; i < KademliaId.ID_LENGTH; i++)\n        {\n            buckets[i] = new JKademliaBucket(i, this.config);\n        }\n    }\n\n    @Override\n    public void setConfiguration(KadConfiguration config)\n    {\n        this.config = config;\n    }\n\n    /**\n     * Adds a contact to the routing table based on how far it is from the LocalNode.\n     *\n     * @param c The contact to add\n     */\n    @Override\n    public synchronized final void insert(Contact c)\n    {\n        this.buckets[this.getBucketId(c.getNode().getNodeId())].insert(c);\n    }\n\n    /**\n     * Adds a node to the routing table based on how far it is from the LocalNode.\n     *\n     * @param n The node to add\n     */\n    @Override\n    public synchronized final void insert(Node n)\n    {\n        this.buckets[this.getBucketId(n.getNodeId())].insert(n);\n    }\n\n    /**\n     * Compute the bucket ID in which a given node should be placed; the bucketId is computed based on how far the node is away from the Local Node.\n     *\n     * @param nid The NodeId for which we want to find which bucket it belong to\n     *\n     * @return Integer The bucket ID in which the given node should be placed.\n     */\n    @Override\n    public final int getBucketId(KademliaId nid)\n    {\n        int bId = this.localNode.getNodeId().getDistance(nid) - 1;\n\n        /* If we are trying to insert a node into it's own routing table, then the bucket ID will be -1, so let's just keep it in bucket 0 */\n        return bId < 0 ? 0 : bId;\n    }\n\n    /**\n     * Find the closest set of contacts to a given NodeId\n     *\n     * @param target           The NodeId to find contacts close to\n     * @param numNodesRequired The number of contacts to find\n     *\n     * @return List A List of contacts closest to target\n     */\n    @Override\n    public synchronized final List<Node> findClosest(KademliaId target, int numNodesRequired)\n    {\n        TreeSet<Node> sortedSet = new TreeSet<>(new KeyComparator(target));\n        sortedSet.addAll(this.getAllNodes());\n\n        List<Node> closest = new ArrayList<>(numNodesRequired);\n\n        /* Now we have the sorted set, lets get the top numRequired */\n        int count = 0;\n        for (Node n : sortedSet)\n        {\n            closest.add(n);\n            if (++count == numNodesRequired)\n            {\n                break;\n            }\n        }\n        return closest;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public synchronized final List<Node> getAllNodes()\n    {\n        List<Node> nodes = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            for (Contact c : b.getContacts())\n            {\n                nodes.add(c.getNode());\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @return List A List of all Nodes in this JKademliaRoutingTable\n     */\n    @Override\n    public final List<Contact> getAllContacts()\n    {\n        List<Contact> contacts = new ArrayList<>();\n\n        for (KademliaBucket b : this.buckets)\n        {\n            contacts.addAll(b.getContacts());\n        }\n\n        return contacts;\n    }\n\n    /**\n     * @return Bucket[] The buckets in this Kad Instance\n     */\n    @Override\n    public final KademliaBucket[] getBuckets()\n    {\n        return this.buckets;\n    }\n\n    /**\n     * Set the KadBuckets of this routing table, mainly used when retrieving saved state\n     *\n     * @param buckets\n     */\n    public final void setBuckets(KademliaBucket[] buckets)\n    {\n        this.buckets = buckets;\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param contacts The set of unresponsive contacts\n     */\n    @Override\n    public void setUnresponsiveContacts(List<Node> contacts)\n    {\n        if (contacts.isEmpty())\n        {\n            return;\n        }\n        for (Node n : contacts)\n        {\n            this.setUnresponsiveContact(n);\n        }\n    }\n\n    /**\n     * Method used by operations to notify the routing table of any contacts that have been unresponsive.\n     *\n     * @param n\n     */\n    @Override\n    public synchronized void setUnresponsiveContact(Node n)\n    {\n        int bucketId = this.getBucketId(n.getNodeId());\n\n        /* Remove the contact from the bucket */\n        this.buckets[bucketId].removeNode(n);\n    }\n\n    @Override\n    public synchronized final String toString()\n    {\n        StringBuilder sb = new StringBuilder(\"\\nPrinting Routing Table Started ***************** \\n\");\n        int totalContacts = 0;\n        for (KademliaBucket b : this.buckets)\n        {\n            if (b.numContacts() > 0)\n            {\n                totalContacts += b.numContacts();\n                sb.append(\"# nodes in Bucket with depth \");\n                sb.append(b.getDepth());\n                sb.append(\": \");\n                sb.append(b.numContacts());\n                sb.append(\"\\n\");\n                sb.append(b.toString());\n                sb.append(\"\\n\");\n            }\n        }\n\n        sb.append(\"\\nTotal Contacts: \");\n        sb.append(totalContacts);\n        sb.append(\"\\n\\n\");\n\n        sb.append(\"Printing Routing Table Ended ******************** \");\n\n        return sb.toString();\n    }\n\n}\nsrc/kademlia/util/serializer/JsonDHTSerializer.java\npublic class JsonDHTSerializer implements KadSerializer<KademliaDHT>\n{\n\n    private final Gson gson;\n    private final Type storageEntriesCollectionType;\n\n    \n    {\n        gson = new Gson();\n\n        storageEntriesCollectionType = new TypeToken<List<KademliaStorageEntryMetadata>>()\n        {\n        }.getType();\n    }\n\n    @Override\n    public void write(KademliaDHT data, DataOutputStream out) throws IOException\n    {\n        try (JsonWriter writer = new JsonWriter(new OutputStreamWriter(out)))\n        {\n            writer.beginArray();\n\n            /* Write the basic DHT */\n            gson.toJson(data, DHT.class, writer);\n\n            /* Now Store the Entries  */\n            gson.toJson(data.getStorageEntries(), this.storageEntriesCollectionType, writer);\n\n            writer.endArray();\n        }\n\n    }\n\n    @Override\n    public KademliaDHT read(DataInputStream in) throws IOException, ClassNotFoundException\n    {\n        try (DataInputStream din = new DataInputStream(in);\n                JsonReader reader = new JsonReader(new InputStreamReader(in)))\n        {\n            reader.beginArray();\n\n            /* Read the basic DHT */\n            DHT dht = gson.fromJson(reader, DHT.class);\n            dht.initialize();\n\n            /* Now get the entries and add them back to the DHT */\n            List<KademliaStorageEntryMetadata> entries = gson.fromJson(reader, this.storageEntriesCollectionType);\n            dht.putStorageEntries(entries);\n\n            reader.endArray();\n            return dht;\n        }\n    }\n}\nsrc/kademlia/exceptions/ContentNotFoundException.java\npublic class ContentNotFoundException extends Exception\n{\n\n    public ContentNotFoundException()\n    {\n        super();\n    }\n\n    public ContentNotFoundException(String message)\n    {\n        super(message);\n    }\n}\nsrc/kademlia/dht/GetParameter.java\npublic class GetParameter\n{\n\n    private KademliaId key;\n    private String ownerId = null;\n    private String type = null;\n\n    /**\n     * Construct a GetParameter to search for data by NodeId and owner\n     *\n     * @param key\n     * @param type\n     */\n    public GetParameter(KademliaId key, String type)\n    {\n        this.key = key;\n        this.type = type;\n    }\n\n    /**\n     * Construct a GetParameter to search for data by NodeId, owner, type\n     *\n     * @param key\n     * @param type\n     * @param owner\n     */\n    public GetParameter(KademliaId key, String type, String owner)\n    {\n        this(key, type);\n        this.ownerId = owner;\n    }\n\n    /**\n     * Construct our get parameter from a Content\n     *\n     * @param c\n     */\n    public GetParameter(KadContent c)\n    {\n        this.key = c.getKey();\n\n        if (c.getType() != null)\n        {\n            this.type = c.getType();\n        }\n\n        if (c.getOwnerId() != null)\n        {\n            this.ownerId = c.getOwnerId();\n        }\n    }\n\n    /**\n     * Construct our get parameter from a StorageEntryMeta data\n     *\n     * @param md\n     */\n    public GetParameter(KademliaStorageEntryMetadata md)\n    {\n        this.key = md.getKey();\n\n        if (md.getType() != null)\n        {\n            this.type = md.getType();\n        }\n\n        if (md.getOwnerId() != null)\n        {\n            this.ownerId = md.getOwnerId();\n        }\n    }\n\n    public KademliaId getKey()\n    {\n        return this.key;\n    }\n\n    public void setOwnerId(String ownerId)\n    {\n        this.ownerId = ownerId;\n    }\n\n    public String getOwnerId()\n    {\n        return this.ownerId;\n    }\n\n    public void setType(String type)\n    {\n        this.type = type;\n    }\n\n    public String getType()\n    {\n        return this.type;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"GetParameter - [Key: \" + key + \"][Owner: \" + this.ownerId + \"][Type: \" + this.type + \"]\";\n    }\n}\nsrc/kademlia/operation/ContentLookupOperation.java\npublic class ContentLookupOperation implements Operation, Receiver\n{\n\n    /* Constants */\n    private static final Byte UNASKED = (byte) 0x00;\n    private static final Byte AWAITING = (byte) 0x01;\n    private static final Byte ASKED = (byte) 0x02;\n    private static final Byte FAILED = (byte) 0x03;\n\n    private final KadServer server;\n    private final JKademliaNode localNode;\n    private JKademliaStorageEntry contentFound = null;\n    private final KadConfiguration config;\n\n    private final ContentLookupMessage lookupMessage;\n\n    private boolean isContentFound;\n    private final SortedMap<Node, Byte> nodes;\n\n    /* Tracks messages in transit and awaiting reply */\n    private final Map<Integer, Node> messagesTransiting;\n\n    /* Used to sort nodes */\n    private final Comparator comparator;\n\n    /* Statistical information */\n    private final RouteLengthChecker routeLengthChecker;\n\n    \n    {\n        messagesTransiting = new HashMap<>();\n        isContentFound = false;\n        routeLengthChecker = new RouteLengthChecker();\n    }\n\n    /**\n     * @param server\n     * @param localNode\n     * @param params    The parameters to search for the content which we need to find\n     * @param config\n     */\n    public ContentLookupOperation(KadServer server, JKademliaNode localNode, GetParameter params, KadConfiguration config)\n    {\n        /* Construct our lookup message */\n        this.lookupMessage = new ContentLookupMessage(localNode.getNode(), params);\n\n        this.server = server;\n        this.localNode = localNode;\n        this.config = config;\n\n        /**\n         * We initialize a TreeMap to store nodes.\n         * This map will be sorted by which nodes are closest to the lookupId\n         */\n        this.comparator = new KeyComparator(params.getKey());\n        this.nodes = new TreeMap(this.comparator);\n    }\n\n    /**\n     * @throws java.io.IOException\n     * @throws kademlia.exceptions.RoutingException\n     */\n    @Override\n    public synchronized void execute() throws IOException, RoutingException\n    {\n        try\n        {\n            /* Set the local node as already asked */\n            nodes.put(this.localNode.getNode(), ASKED);\n\n            /**\n             * We add all nodes here instead of the K-Closest because there may be the case that the K-Closest are offline\n             * - The operation takes care of looking at the K-Closest.\n             */\n            List<Node> allNodes = this.localNode.getRoutingTable().getAllNodes();\n            this.addNodes(allNodes);\n            \n            /* Also add the initial set of nodes to the routeLengthChecker */\n            this.routeLengthChecker.addInitialNodes(allNodes);\n\n            /**\n             * If we haven't found the requested amount of content as yet,\n             * keey trying until config.operationTimeout() time has expired\n             */\n            int totalTimeWaited = 0;\n            int timeInterval = 10;     // We re-check every n milliseconds\n            while (totalTimeWaited < this.config.operationTimeout())\n            {\n                if (!this.askNodesorFinish() && !isContentFound)\n                {\n                    wait(timeInterval);\n                    totalTimeWaited += timeInterval;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        catch (InterruptedException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Add nodes from this list to the set of nodes to lookup\n     *\n     * @param list The list from which to add nodes\n     */\n    public void addNodes(List<Node> list)\n    {\n        for (Node o : list)\n        {\n            /* If this node is not in the list, add the node */\n            if (!nodes.containsKey(o))\n            {\n                nodes.put(o, UNASKED);\n            }\n        }\n    }\n\n    /**\n     * Asks some of the K closest nodes seen but not yet queried.\n     * Assures that no more than DefaultConfiguration.CONCURRENCY messages are in transit at a time\n     *\n     * This method should be called every time a reply is received or a timeout occurs.\n     *\n     * If all K closest nodes have been asked and there are no messages in transit,\n     * the algorithm is finished.\n     *\n     * @return <code>true</code> if finished OR <code>false</code> otherwise\n     */\n    private boolean askNodesorFinish() throws IOException\n    {\n        /* If >= CONCURRENCY nodes are in transit, don't do anything */\n        if (this.config.maxConcurrentMessagesTransiting() <= this.messagesTransiting.size())\n        {\n            return false;\n        }\n\n        /* Get unqueried nodes among the K closest seen that have not FAILED */\n        List<Node> unasked = this.closestNodesNotFailed(UNASKED);\n\n        if (unasked.isEmpty() && this.messagesTransiting.isEmpty())\n        {\n            /* We have no unasked nodes nor any messages in transit, we're finished! */\n            return true;\n        }\n\n        /* Sort nodes according to criteria */\n        Collections.sort(unasked, this.comparator);\n\n        /**\n         * Send messages to nodes in the list;\n         * making sure than no more than CONCURRENCY messsages are in transit\n         */\n        for (int i = 0; (this.messagesTransiting.size() < this.config.maxConcurrentMessagesTransiting()) && (i < unasked.size()); i++)\n        {\n            Node n = (Node) unasked.get(i);\n\n            int comm = server.sendMessage(n, lookupMessage, this);\n\n            this.nodes.put(n, AWAITING);\n            this.messagesTransiting.put(comm, n);\n        }\n\n        /* We're not finished as yet, return false */\n        return false;\n    }\n\n    /**\n     * Find The K closest nodes to the target lookupId given that have not FAILED.\n     * From those K, get those that have the specified status\n     *\n     * @param status The status of the nodes to return\n     *\n     * @return A List of the closest nodes\n     */\n    private List<Node> closestNodesNotFailed(Byte status)\n    {\n        List<Node> closestNodes = new ArrayList<>(this.config.k());\n        int remainingSpaces = this.config.k();\n\n        for (Map.Entry e : this.nodes.entrySet())\n        {\n            if (!FAILED.equals(e.getValue()))\n            {\n                if (status.equals(e.getValue()))\n                {\n                    /* We got one with the required status, now add it */\n                    closestNodes.add((Node) e.getKey());\n                }\n\n                if (--remainingSpaces == 0)\n                {\n                    break;\n                }\n            }\n        }\n\n        return closestNodes;\n    }\n\n    @Override\n    public synchronized void receive(Message incoming, int comm) throws IOException, RoutingException\n    {\n        if (this.isContentFound)\n        {\n            return;\n        }\n\n        if (incoming instanceof ContentMessage)\n        {\n            /* The reply received is a content message with the required content, take it in */\n            ContentMessage msg = (ContentMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            this.localNode.getRoutingTable().insert(msg.getOrigin());\n\n            /* Get the Content and check if it satisfies the required parameters */\n            JKademliaStorageEntry content = msg.getContent();\n            this.contentFound = content;\n            this.isContentFound = true;\n        }\n        else\n        {\n            /* The reply received is a NodeReplyMessage with nodes closest to the content needed */\n            NodeReplyMessage msg = (NodeReplyMessage) incoming;\n\n            /* Add the origin node to our routing table */\n            Node origin = msg.getOrigin();\n            this.localNode.getRoutingTable().insert(origin);\n\n            /* Set that we've completed ASKing the origin node */\n            this.nodes.put(origin, ASKED);\n\n            /* Remove this msg from messagesTransiting since it's completed now */\n            this.messagesTransiting.remove(comm);\n            \n            /* Add the received nodes to the routeLengthChecker */\n            this.routeLengthChecker.addNodes(msg.getNodes(), origin);\n\n            /* Add the received nodes to our nodes list to query */\n            this.addNodes(msg.getNodes());\n            this.askNodesorFinish();\n        }\n    }\n\n    /**\n     * A node does not respond or a packet was lost, we set this node as failed\n     *\n     * @param comm\n     *\n     * @throws java.io.IOException\n     */\n    @Override\n    public synchronized void timeout(int comm) throws IOException\n    {\n        /* Get the node associated with this communication */\n        Node n = this.messagesTransiting.get(new Integer(comm));\n\n        if (n == null)\n        {\n            throw new UnknownMessageException(\"Unknown comm: \" + comm);\n        }\n\n        /* Mark this node as failed and inform the routing table that it's unresponsive */\n        this.nodes.put(n, FAILED);\n        this.localNode.getRoutingTable().setUnresponsiveContact(n);\n        this.messagesTransiting.remove(comm);\n\n        this.askNodesorFinish();\n    }\n    \n    /**\n     * @return Whether the content was found or not.\n     */\n    public boolean isContentFound()\n    {\n        return this.isContentFound;\n    }\n\n    /**\n     * @return The list of all content found during the lookup operation\n     *\n     * @throws kademlia.exceptions.ContentNotFoundException\n     */\n    public JKademliaStorageEntry getContentFound() throws ContentNotFoundException\n    {\n        if (this.isContentFound)\n        {\n            return this.contentFound;\n        }\n        else\n        {\n            throw new ContentNotFoundException(\"No Value was found for the given key.\");\n        }\n    }\n\n    /**\n     * @return How many hops it took in order to get to the content.\n     */\n    public int routeLength()\n    {\n        return this.routeLengthChecker.getRouteLength();\n    }\n}\nsrc/kademlia/node/Node.java\npublic class Node implements Streamable, Serializable\n{\n\n    private KademliaId nodeId;\n    private InetAddress inetAddress;\n    private int port;\n    private final String strRep;\n\n    public Node(KademliaId nid, InetAddress ip, int port)\n    {\n        this.nodeId = nid;\n        this.inetAddress = ip;\n        this.port = port;\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Load the Node's data from a DataInput stream\n     *\n     * @param in\n     *\n     * @throws IOException\n     */\n    public Node(DataInputStream in) throws IOException\n    {\n        this.fromStream(in);\n        this.strRep = this.nodeId.toString();\n    }\n\n    /**\n     * Set the InetAddress of this node\n     *\n     * @param addr The new InetAddress of this node\n     */\n    public void setInetAddress(InetAddress addr)\n    {\n        this.inetAddress = addr;\n    }\n\n    /**\n     * @return The NodeId object of this node\n     */\n    public KademliaId getNodeId()\n    {\n        return this.nodeId;\n    }\n\n    /**\n     * Creates a SocketAddress for this node\n     *\n     * @return\n     */\n    public InetSocketAddress getSocketAddress()\n    {\n        return new InetSocketAddress(this.inetAddress, this.port);\n    }\n\n    @Override\n    public void toStream(DataOutputStream out) throws IOException\n    {\n        /* Add the NodeId to the stream */\n        this.nodeId.toStream(out);\n\n        /* Add the Node's IP address to the stream */\n        byte[] a = inetAddress.getAddress();\n        if (a.length != 4)\n        {\n            throw new RuntimeException(\"Expected InetAddress of 4 bytes, got \" + a.length);\n        }\n        out.write(a);\n\n        /* Add the port to the stream */\n        out.writeInt(port);\n    }\n\n    @Override\n    public final void fromStream(DataInputStream in) throws IOException\n    {\n        /* Load the NodeId */\n        this.nodeId = new KademliaId(in);\n\n        /* Load the IP Address */\n        byte[] ip = new byte[4];\n        in.readFully(ip);\n        this.inetAddress = InetAddress.getByAddress(ip);\n\n        /* Read in the port */\n        this.port = in.readInt();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof Node)\n        {\n            Node n = (Node) o;\n            if (n == this)\n            {\n                return true;\n            }\n            return this.getNodeId().equals(n.getNodeId());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return this.getNodeId().hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.getNodeId().toString();\n    }\n}\n", "answers": ["    private transient KademliaRoutingTable routingTable;"], "pred": "  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht;Next line of code:\n  KademliaDHT dht", "length": 6425, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "03b9c503110e4dc8f2d7690f56be9e9b2733744da1a855ff"}
{"prompt": "Please complete the code given below. \nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nimport android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;\n    private ImmersiveTouchNavigation mImmersiveTouchNavigation;\n\n    public EffectManager(Activity activity, int parameterListViewId, SpectaculumView glView) {\n        mActivity = activity;\n        mParameterListView = (ViewGroup) activity.findViewById(parameterListViewId);\n        mSpectaculumView = glView;\n        mEffects = new ArrayList<>();\n        mSpectaculumView.setEffectEventListener(this);\n\n        // Spectaculum-Core filtersNext line of code:\n", "input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;\n    private ImmersiveTouchNavigation mImmersiveTouchNavigation;\n\n    public EffectManager(Activity activity, int parameterListViewId, SpectaculumView glView) {\n        mActivity = activity;\n        mParameterListView = (ViewGroup) activity.findViewById(parameterListViewId);\n        mSpectaculumView = glView;\n        mEffects = new ArrayList<>();\n        mSpectaculumView.setEffectEventListener(this);\n\n        // Spectaculum-Core filters", "context": "Spectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\n", "answers": ["        mEffects.add(new NoEffect());"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 8194, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cb75af27199120a4d11be40c2968da895ebd2e8795dfc692"}
{"prompt": "Please complete the code given below. \narxpy/differential/characteristic.py\nclass RelatedKeyCh(object):\n    \"\"\"Represent related-key characteristics of block ciphers.\n\n    A related-key characteristic of a `Cipher` is a pair `BvCharacteristic`,\n    one over the `KeySchedule` of the cipher, and another one over the\n    the `Encryption` function of the cipher, where the output differences\n    of the key schedule characteristic are used as round key differences\n    in the encryption characteristic.\n\n    The master key differences start with the prefix ``\"dmk\"``,\n    the round key differences start with the prefix ``\"dk\"``,\n    the plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import RelatedKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives.lea import LeaCipher\n        >>> issubclass(LeaCipher, Cipher)\n        True\n        >>> LeaCipher.set_rounds(1)\n        >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n        >>> rkch .key_schedule_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dmk0, dmk1, dmk2, dmk3),\n        'output_vars': (dk1, dk3, dk5, dk3, dk7, dk3),\n        'assignments': ((dk0, 0xc3efe9db + dmk0), (dk1, dk0 <<< 1), (dk2, 0x87dfd3b7 + dmk1), (dk3, dk2 <<< 3),\n        (dk4, 0x0fbfa76f + dmk2), (dk5, dk4 <<< 6), (dk6, 0x1f7f4ede + dmk3), (dk7, dk6 <<< 11))}\n        >>> rkch.key_schedule_ch.input_diff\n        (XorDiff(dmk0), XorDiff(dmk1), XorDiff(dmk2), XorDiff(dmk3))\n        >>> rkch.key_schedule_ch.output_diff  # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dk1), XorDiff(dk0 <<< 1)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk5), XorDiff(dk4 <<< 6)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk7), XorDiff(dk6 <<< 11)], [XorDiff(dk3), XorDiff(dk2 <<< 3)]]\n        >>> rkch.key_schedule_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dk0), XDCA_0xc3efe9db(XorDiff(dmk0))),\n        (XorDiff(dk2), XDCA_0x87dfd3b7(XorDiff(dmk1))),\n        (XorDiff(dk4), XDCA_0x0fbfa76f(XorDiff(dmk2))),\n        (XorDiff(dk6), XDCA_0x1f7f4ede(XorDiff(dmk3)))])\n        >>> rkch.encryption_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1, dp2, dp3),\n        'output_vars': (dx3, dx7, dx11, dp0),\n        'assignments': ((dx0, dk1 ^ dp0), (dx1, dk3 ^ dp1), (dx2, dx0 + dx1), (dx3, dx2 <<< 9),\n        (dx4, dk5 ^ dp1), (dx5, dk3 ^ dp2), (dx6, dx4 + dx5), (dx7, dx6 >>> 5), (dx8, dk7 ^ dp2),\n        (dx9, dk3 ^ dp3), (dx10, dx8 + dx9), (dx11, dx10 >>> 3))}\n        >>> rkch.encryption_ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1), XorDiff(dp2), XorDiff(dp3))\n        >>> rkch.encryption_ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dx3), XorDiff(dx2 <<< 9)], [XorDiff(dx7), XorDiff(dx6 >>> 5)],\n        [XorDiff(dx11), XorDiff(dx10 >>> 3)], [XorDiff(dp0), XorDiff(dp0)]]\n        >>> rkch.encryption_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dx2), XDA(XorDiff(dp0 ^ (dk0 <<< 1)), XorDiff(dp1 ^ (dk2 <<< 3)))),\n        (XorDiff(dx6), XDA(XorDiff(dp1 ^ (dk4 <<< 6)), XorDiff(dp2 ^ (dk2 <<< 3)))),\n        (XorDiff(dx10), XDA(XorDiff(dp2 ^ (dk6 <<< 11)), XorDiff(dp3 ^ (dk2 <<< 3))))])\n\n    Attributes:\n        key_schedule_ch: the `BvCharacteristic` over the key schedule\n        encryption_ch: the `BvCharacteristic` over the encryption function\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        func = bv_cipher.key_schedule\n        prefix = \"dk\"\n        input_diff_names = tuple([\"dmk\" + str(i) for i in range(len(func.input_widths))])\n        ks_ch = BvCharacteristic(func, diff_type, input_diff_names, prefix)\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = ks_ch.ssa[\"output_vars\"]\n\n        func = Encryption\n        prefix = \"dx\"\n        input_diff_names = [\"dp\" + str(i) for i in range(len(func.input_widths))]\n        round_key_diff = {}\n        for var, diff in ks_ch.output_diff:\n            round_key_diff[var.val] = diff\n        encryption_ch = BvCharacteristic(func, diff_type, input_diff_names,\n                                         prefix, round_key_diff)\n\n        self.diff_type = diff_type\n        self.key_schedule_ch = ks_ch\n        self.encryption_ch = encryption_ch\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n        \"\"\"Return the empirical weight of a given differential for multiple keys.\n\n        This method returns the differential probability weight for the\n        key schedule characteristic (see `BvCharacteristic.empirical_weight`)\n        and the `collections.Counter` storing the distribution of weights for the encryption\n        characteristic (see `SingleKeyCh.empirical_weight`).\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> kid, kod = [zero]*4, [zero]*6\n            >>> eid, eod = [zero]*4, [zero]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (0.0, Counter({0.0: 10}))\n            >>> kid, kod = [zero]*4, [one]*6\n            >>> eid, eod = [zero]*4, [one]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (inf, Counter({inf: 10}))\n\n        \"\"\"\n        key_weight = self.key_schedule_ch.empirical_weight(key_input_diff, key_output_diff, key_samples)\n        # noinspection PyProtectedMember\n        enc_counter = self.encryption_ch._empirical_weight_distribution(self._cipher,\n                                                                        enc_input_diff, enc_output_diff, enc_samples,\n                                                                        key_samples, precision, key_output_diff)\n        return key_weight, enc_counter\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the related-key characteristic.\n\n        The signature of a related-key characteristic is the\n        concatenation of the key schedule and encryption signatures.\n\n        See also `BvCharacteristic.signature`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh, ChSignatureType\n            >>> from arxpy.primitives.primitives import Cipher\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> rkch.signature(ChSignatureType.Full)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk0, dk2, dk4, dk6, dp0, dp1, dp2, dp3, dx2, dx6, dx10]\n            >>> rkch.signature(ChSignatureType.InputOutput)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk1, dk3, dk5, dk3, dk7, dk3, dp0, dp1, dp2, dp3, dx3, dx7, dx11]\n\n        \"\"\"\n        return self.key_schedule_ch.signature(ch_signature_type) + self.encryption_ch.signature(ch_signature_type)\n\n    def _to_dict(self):\n        dict_ch = {\n            \"key_schedule_ch\": self.key_schedule_ch._to_dict(),\n            \"encryption_ch\": self.encryption_ch._to_dict(),\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/differential/difference.py\nclass XorDiff(Difference):\n    \"\"\"Represent XOR differences.\n\n    The XOR difference of two `Term` is given by the XOR\n    of the terms. In other words, the *difference operation*\n    of `XorDiff` is the `BvXor` (see `Difference`).\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b010, 3), Constant(0b101, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b111)\n        >>> alpha.get_pair_element(x)\n        0b101\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = XorDiff.from_pair(k, k)\n        >>> alpha\n        XorDiff(0x00)\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = operation.BvXor\n    inv_diff_op = operation.BvXor\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft, BvSub\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import XorDiff\n            >>> d1, d2 = XorDiff(Variable(\"d1\", 8)), XorDiff(Variable(\"d2\", 8))\n            >>> XorDiff.derivative(BvXor, [d1, d2])\n            XorDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(Xor1, d1)\n            XorDiff(d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> XorDiff.derivative(Rotate1, d1)\n            XorDiff(d1 <<< 1)\n            >>> XorDiff.derivative(BvAdd, [d1, d2])\n            XDA(XorDiff(d1), XorDiff(d2))\n            >>> XorDiff.derivative(BvSub, [d1, d2])\n            XDS(XorDiff(d1), XorDiff(d2))\n            >>> CteAdd1 = make_partial_operation(BvAdd, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(CteAdd1, d1)\n            XDCA_0x01(XorDiff(d1))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.Concat:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.XDA(input_diff)\n\n        if op == operation.BvSub:\n            from arxpy.differential import derivative\n            return derivative.XDS(input_diff)\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAnd:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                if isinstance(val, core.Constant):\n                    return cls(op.base_op(d1.val, val))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op in [operation.BvShl, operation.BvLshr]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Extract:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None and op.fixed_args[2] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1], op.fixed_args[2]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Concat:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                if op.fixed_args[0] is not None:\n                    val = op.fixed_args[0]\n                    input_diff = [cls.from_pair(val, val), d1]\n                else:\n                    val = op.fixed_args[1]\n                    input_diff = [d1, cls.from_pair(val, val)]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAdd:\n                assert len(input_diff) == 1\n                d = input_diff[0]\n                cte = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                from arxpy.differential import derivative\n                return derivative.XDCA(d, cte)\n            else:\n                raise ValueError(msg)\n\n        if hasattr(op, \"xor_derivative\"):\n            return op.xor_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\narxpy/differential/characteristic.py\nclass BvCharacteristic(object):\n    \"\"\"Represent characteristics of bit-vector functions.\n\n    Given a bit-vector function `BvFunction` :math:`f`,\n    a characteristic is a trail of differences obtained by\n    propagating an input difference over :math:`f`.\n\n    In particular, a characteristic is composed of the\n    input difference and the output difference of each\n    non-linear operation.\n\n    This class manages symbolic characteristics,\n    where the input difference is given symbolically\n    and the intermediate differences are `Term`\n    that depend on the input difference.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff, RXDiff\n        >>> from arxpy.differential.characteristic import BvCharacteristic\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi.set_rounds(1)\n        >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dv0, dv1, dv2, dv3),\n        'output_vars': (d7, d12, d13, d9),\n        'assignments': ((d0, dv0 + dv1), (d1, dv1 <<< 5), (d2, d0 ^ d1), (d3, d0 <<< 16), (d4, dv2 + dv3),\n        (d5, dv3 <<< 8), (d6, d4 ^ d5), (d7, d3 + d6), (d8, d6 <<< 13), (d9, d7 ^ d8), (d10, d2 + d4),\n        (d11, d2 <<< 7), (d12, d10 ^ d11), (d13, d10 <<< 16))}\n        >>> ch.input_diff\n        (XorDiff(dv0), XorDiff(dv1), XorDiff(dv2), XorDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(d0), XDA(XorDiff(dv0), XorDiff(dv1))),\n        (XorDiff(d4), XDA(XorDiff(dv2), XorDiff(dv3))),\n        (XorDiff(d7), XDA(XorDiff(d0 <<< 16), XorDiff(d4 ^ (dv3 <<< 8)))),\n        (XorDiff(d10), XDA(XorDiff(d0 ^ (dv1 <<< 5)), XorDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(d7), XorDiff(d7)],\n        [XorDiff(d12), XorDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [XorDiff(d13), XorDiff(d10 <<< 16)],\n        [XorDiff(d9), XorDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n        >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.input_diff\n        (RXDiff(dv0), RXDiff(dv1), RXDiff(dv2), RXDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(RXDiff(d0), RXDA(RXDiff(dv0), RXDiff(dv1))),\n        (RXDiff(d4), RXDA(RXDiff(dv2), RXDiff(dv3))),\n        (RXDiff(d7), RXDA(RXDiff(d0 <<< 16), RXDiff(d4 ^ (dv3 <<< 8)))),\n        (RXDiff(d10), RXDA(RXDiff(d0 ^ (dv1 <<< 5)), RXDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[RXDiff(d7), RXDiff(d7)],\n        [RXDiff(d12), RXDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [RXDiff(d13), RXDiff(d10 <<< 16)],\n        [RXDiff(d9), RXDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n\n    Attributes:\n        func: the `BvFunction`\n        diff_type: the `Difference` of the characteristic\n        input_diff: a list containing the input symbolic differences\n        nonlinear_diffs: an `collections.OrderedDict` mapping non-linear symbolic differences\n            to their corresponding `Derivative`\n        output_diff: a list, where the i-th element is a pair containing\n            the i-th output symbolic difference and its value\n    \"\"\"\n\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n        assert issubclass(func, primitives.BvFunction)\n        assert issubclass(diff_type, difference.Difference)\n\n        assert len(input_diff_names) == len(func.input_widths)\n        input_diff = []\n        for name, width in zip(input_diff_names, func.input_widths):\n            input_diff.append(diff_type(core.Variable(name, width)))\n        input_diff = tuple(input_diff)\n\n        self.func = func\n        self.diff_type = diff_type\n        self.input_diff = input_diff\n\n        # Propagate the input difference through the function\n\n        names = [d.val.name for d in self.input_diff]\n        ssa = self.func.ssa(names, id_prefix=prefix)\n        self.ssa = ssa\n        self._prefix = prefix\n        self._input_diff_names = input_diff_names\n\n        for var in ssa[\"output_vars\"]:\n            if isinstance(var, core.Constant):\n                raise ValueError(\"constant outputs (independent of the inputs) are not supported\")\n\n        var2diff = {}  # Variable to Difference\n        for var, diff in zip(ssa[\"input_vars\"], self.input_diff):\n            var2diff[var] = diff\n\n        if initial_var2diff is not None:\n            for var in initial_var2diff:\n                if str(var) in names:\n                    raise ValueError(\"the input differences cannot be replaced by initial_var2diff\")\n            var2diff.update(initial_var2diff)\n\n        self.nonlinear_diffs = collections.OrderedDict()\n        for var, expr in ssa[\"assignments\"]:\n            expr_args = []\n            for arg in expr.args:\n                if isinstance(arg, int):\n                    expr_args.append(arg)  # 'int' object has no attribute 'xreplace'\n                else:\n                    expr_args.append(arg.xreplace(var2diff))\n\n            if all(not isinstance(arg, diff_type) for arg in expr_args):\n                # symbolic computations with the key\n                var2diff[var] = expr\n                continue\n\n            if all(isinstance(arg, diff_type) for arg in expr_args):\n                der = self.diff_type.derivative(type(expr), expr_args)\n            else:\n                def contains_key_var(term):\n                    from sympy import basic\n                    for sub in basic.preorder_traversal(term):\n                        if sub in func.round_keys:\n                            return True\n                    else:\n                        return False\n\n                if type(expr) == operation.BvAdd and hasattr(func, 'round_keys') and \\\n                        all(isinstance(r, core.Variable) for r in func.round_keys) and \\\n                        any(contains_key_var(a) for a in expr_args):\n                    # temporary solution to Derivative(BvAddCte_k(x)) != Derivative(x + k)\n                    # with x a Diff and k a key variable\n                    keyed_indices = []\n                    for i, a in enumerate(expr_args):\n                        if contains_key_var(a):\n                            keyed_indices.append(i)\n                    if len(keyed_indices) != 1 or expr_args[keyed_indices[0]] not in func.round_keys:\n                        raise NotImplementedError(\"invalid expression: op={}, args={}\".format(\n                            type(expr).__name__, expr_args))\n                    # expr_args[keyed_indices[0]] replaced to the zero diff\n                    zero_diff = diff_type(core.Constant(0, expr_args[keyed_indices[0]].width))\n                    der = self.diff_type.derivative(type(expr), [expr_args[(keyed_indices[0] + 1) % 2], zero_diff])\n                elif hasattr(expr, \"xor_derivative\"):\n                    # temporary solution to operations containing a custom derivative\n                    input_diff_expr = []\n                    for i, arg in enumerate(expr_args):\n                        if isinstance(arg, diff_type):\n                            input_diff_expr.append(arg)\n                        else:\n                            assert isinstance(arg, core.Term)  # int arguments currently not supported\n                            input_diff_expr.append(diff_type.from_pair(arg, arg))\n                    der = self.diff_type.derivative(type(expr), input_diff_expr)\n                else:\n                    fixed_args = []\n                    for i, arg in enumerate(expr_args):\n                        if not isinstance(arg, diff_type):\n                            fixed_args.append(arg)\n                        else:\n                            fixed_args.append(None)\n                    new_op = extraop.make_partial_operation(type(expr), tuple(fixed_args))\n                    der = self.diff_type.derivative(new_op, [arg for arg in expr_args if isinstance(arg, diff_type)])\n\n            if isinstance(der, derivative.Derivative):\n                diff = self.diff_type(var)\n                var2diff[var] = diff\n                self.nonlinear_diffs[diff] = der\n            else:\n                var2diff[var] = der\n\n        self._var2diff = var2diff\n\n        self.output_diff = []\n        for var in ssa[\"output_vars\"]:\n            self.output_diff.append([self.diff_type(var), var2diff[var]])\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n        \"\"\"Return the empirical weight of a given differential.\n\n        Given a differential (a pair of input and output differences),\n        the differential probability is the fraction of input pairs\n        with the given input difference leading to output pairs\n        with the given output difference.\n\n        This method returns an approximation of the weight of the\n        differential probability by sampling a given number\n        of input pairs.\n\n        If no correct output pairs are found, `math.inf` is returned.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff, RXDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> ch.empirical_weight([zero, zero, zero, zero], [zero, zero, zero, zero], 100)\n            0.0\n            >>> ch.empirical_weight([zero, zero, zero, zero], [one, one, one, one], 100)\n            inf\n            >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = RXDiff(Constant(0, 32)), RXDiff(Constant(1, 32))\n            >>> 4 - 1 <= ch.empirical_weight([zero]*4, [zero]*4, 3 * 2**6) <= 8\n            True\n            >>> ch.empirical_weight([zero]*4, [one]*4, 3 * 2**6)\n            inf\n\n        \"\"\"\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            correct_pairs = 0\n\n            for index_input in range(pair_samples):\n                pt, other_pt = list_pairs[index_input]\n                ct = self.func(*pt)\n                other_ct = self.func(*other_pt)\n\n                assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                for i, diff in enumerate(output_diff):\n                    # noinspection PyUnresolvedReferences\n                    if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                        break\n                else:\n                    correct_pairs += 1\n\n            if correct_pairs == 0:\n                weight = math.inf\n            else:\n                weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n\n        return weight\n\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n        # this function is not part of SingleKeyCh since it must be accessible\n        # for the encryption characteristic of RelatedKeyCh (which is a\n        # plain BvCharacteristic)\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        old_round_keys = self.func.round_keys\n\n        empirical_weights = collections.Counter()\n\n        if rk_output_diff is not None:\n            class RelatedFunc(self.func):\n                pass\n        else:\n            RelatedFunc = self.func\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            for _ in range(key_samples):\n                master_key = []\n                for width in cipher.key_schedule.input_widths:\n                    master_key.append(core.Constant(random.randrange(2 ** width), width))\n                self.func.round_keys = cipher.key_schedule(*master_key)\n                assert all(isinstance(rk, core.Constant) for rk in self.func.round_keys), str(self.func.round_keys)\n\n                if rk_output_diff is not None:\n                    RelatedFunc.round_keys = [d.get_pair_element(r) for r, d in zip(self.func.round_keys, rk_output_diff)]\n                    assert all(isinstance(rk, core.Constant) for rk in RelatedFunc.round_keys), str(RelatedFunc.round_keys)\n\n                correct_pairs = 0\n\n                for index_input in range(pair_samples):\n                    pt, other_pt = list_pairs[index_input]\n                    ct = self.func(*pt)\n                    other_ct = RelatedFunc(*other_pt)\n\n                    assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                    assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                    for i, diff in enumerate(output_diff):\n                        # noinspection PyUnresolvedReferences\n                        if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                            break\n                    else:\n                        correct_pairs += 1\n\n                if correct_pairs == 0:\n                    weight = math.inf\n                else:\n                    weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n                # weight = float((\"{0:.\"+str(precision)+\"f}\").format(weight))\n                weight = round(weight, precision)\n                empirical_weights[weight] += 1\n\n        self.func.round_keys = old_round_keys\n\n        return empirical_weights\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the characteristic.\n\n        The signature is a \"hash\" of the characteristic used for comparing.\n\n        For the type of the signature, see `ChSignatureType`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic, ChSignatureType\n            >>> from arxpy.primitives.primitives import BvFunction\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> issubclass(ChaskeyPi, BvFunction)\n            True\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n            >>> ch.signature(ChSignatureType.Full)\n            [dv0, dv1, dv2, dv3, d0, d4, d7, d10]\n            >>> ch.signature(ChSignatureType.InputOutput)\n            [dv0, dv1, dv2, dv3, d7, d12, d13, d9]\n\n        \"\"\"\n        if ch_signature_type == ChSignatureType.Full:\n            return [d.val for d in self.input_diff] + [d.val for d in self.nonlinear_diffs]\n        elif ch_signature_type == ChSignatureType.InputOutput:\n            # sig = [d for d in self.input_diff]\n            sig_var = [d.val for d in self.input_diff]\n\n            for out_diff, _ in self.output_diff:\n                for aux_var in self._var2diff[out_diff.val].val.atoms(core.Variable):\n                    if aux_var not in sig_var:\n                        # sig.append(out_diff)\n                        sig_var.append(out_diff.val)\n                        break\n\n            return sig_var\n        else:\n            raise ValueError(\"invalid ch_signature_type: {}\".format(ch_signature_type))\n\n    def _to_dict(self):\n        dict_ch = {\n            \"ssa\": self.ssa,\n            \"input_diff\": self.input_diff,\n            \"output_diff\": self.output_diff,\n            \"nonlinear_diffs\": self.nonlinear_diffs,\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/primitives/primitives.py\nclass Encryption(BvFunction):\n    \"\"\"Represent encryption functions.\n\n    An encryption function is a `BvFunction` that takes\n    the plaintext as input and returns the ciphertext\n    for some fixed key.\n    See `BvFunction` for more information.\n\n    Attributes:\n        round_keys: a list of `Term` representing the round keys\n\n    \"\"\"\n    round_keys = None\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/differential/characteristic.py\nclass SingleKeyCh(BvCharacteristic):\n    \"\"\"Represent single-key characteristics of block ciphers.\n\n    A single-key characteristic of a `Cipher` is a `BvCharacteristic`\n    over the `Encryption` function of the cipher.\n\n    The plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import SingleKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> Speck32.set_rounds(1)\n        >>> ch = SingleKeyCh(Speck32, XorDiff)\n        >>> ch .ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1), 'output_vars': (dx2, dx4),\n        'assignments': ((dx0, dp0 >>> 7), (dx1, dp1 + dx0), (dx2, dx1 ^ k0), (dx3, dp1 <<< 2), (dx4, dx2 ^ dx3))}\n        >>> ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1))\n        >>> ch.nonlinear_diffs\n        OrderedDict([(XorDiff(dx1), XDA(XorDiff(dp1), XorDiff(dp0 >>> 7)))])\n        >>> ch.output_diff\n        [[XorDiff(dx2), XorDiff(dx1)], [XorDiff(dx4), XorDiff(dx1 ^ (dp1 <<< 2))]]\n\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        rk = []\n        for i, width in enumerate(bv_cipher.key_schedule.output_widths):\n            rk.append(core.Variable(\"k\" + str(i), width))\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = tuple(rk)\n\n        func = Encryption\n        num_inputs = len(func.input_widths)\n        input_diff_names = [\"dp\" + str(i) for i in range(num_inputs)]\n        prefix = \"dx\"\n        super().__init__(func, diff_type, input_diff_names, prefix)\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n        \"\"\"Return the empirical weight distribution of a given differential.\n\n        This method returns a `collections.Counter` storing the distribution of\n        differential probability weights over the given number of keys.\n\n        The weights are rounded to the given number of precision\n        digits after the decimal point.\n\n        See also `BvCharacteristic.empirical_weight`.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import SingleKeyCh\n            >>> from arxpy.primitives import speck\n            >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n            >>> Speck32.set_rounds(1)\n            >>> ch = SingleKeyCh(Speck32, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 16)), XorDiff(Constant(1, 16))\n            >>> ch.empirical_weight([zero, zero], [zero, zero], 100, 10)\n            Counter({0.0: 10})\n            >>> ch.empirical_weight([zero, zero], [one, one], 100, 10)\n            Counter({inf: 10})\n\n        \"\"\"\n        return self._empirical_weight_distribution(self._cipher, input_diff, output_diff, pair_samples, key_samples,\n                                                   precision, rk_diffs)\narxpy/differential/characteristic.py\nclass ChSignatureType(enum.Enum):\nclass BvCharacteristic(object):\n            class RelatedFunc(self.func):\nclass SingleKeyCh(BvCharacteristic):\n        class Encryption(bv_cipher.encryption):\nclass RelatedKeyCh(object):\n        class Encryption(bv_cipher.encryption):\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n                def contains_key_var(term):\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\narxpy/differential/difference.py\nclass RXDiff(Difference):\n    \"\"\"Represent rotational-XOR (RX) differences.\n\n    The pair ``(x, (x <<< 1) ^ d)`` has RX difference ``d``.\n    In other words,  the RX difference of two `Term` ``x`` and ``y``\n    is defined as ``(x <<< 1) ^ y``.\n\n    See `Difference` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import RXDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b000, 3), Constant(0b001, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b001)\n        >>> alpha.get_pair_element(x)\n        0b001\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = RXDiff.from_pair(k, k)\n        >>> alpha\n        RXDiff(k ^ (k <<< 1))\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = RXOp\n    inv_diff_op = RXInvOp\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import RXDiff\n            >>> d1, d2 = RXDiff(Variable(\"d1\", 8)), RXDiff(Variable(\"d2\", 8))\n            >>> RXDiff.derivative(BvXor, [d1, d2])\n            RXDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> RXDiff.derivative(Xor1, d1)\n            RXDiff(0x03 ^ d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> RXDiff.derivative(Rotate1, d1)\n            RXDiff(d1 <<< 1)\n            >>> RXDiff.derivative(BvAdd, [d1, d2])\n            RXDA(RXDiff(d1), RXDiff(d2))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.RXDA(input_diff)\n\n        # Concact, BvSub\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            # BvShl, Extract\n\n        if hasattr(op, \"rx_derivative\"):\n            return op.rx_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/primitives/primitives.py\nclass BvFunction(object):\n    \"\"\"Represent (iterated) fixed-width bit-vector functions.\n\n    A `BvFunction` takes fixed-width `Constant` operands and return a\n    tuple of fixed-width `Constant`. An iterated bit-vector function\n    contains a subroutine that is iterated a certain number of *rounds*,\n    which can be changed using `set_rounds`.\n\n    Similar to `Operation`, `BvFunction` is evaluated\n    using the operator ``()`` and provides *Automatic Constant Conversion*.\n    Note that `BvFunction` only accepts `Constant` operands and\n    always return a tuple, as opposed to `Operation` that accepts\n    `Term` and scalar operands and returns a single `Term`.\n\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi(0, 0, 0, 0)  # automatic conversion from int to Constant\n        (0x00000000, 0x00000000, 0x00000000, 0x00000000)\n\n    Attributes:\n        input_widths: a list containing the widths of the inputs\n        output_widths: a list containing the widths of the outputs\n        rounds: the number of iterations\n\n    \"\"\"\n    input_widths = None\n    output_widths = None\n    rounds = None\n\n    def __new__(cls, *args, **options):\n        if len(cls.input_widths) != len(args):\n            raise ValueError(\"{} requires {} inputs but {} were given: {}\".format(\n                cls.__name__, len(cls.input_widths), len(args), args))\n        newargs = []\n        for arg, width in zip(args, cls.input_widths):\n            newargs.append(core.bitvectify(arg, width))\n        args = newargs\n\n        if all(isinstance(arg, core.Constant) for arg in args) or \\\n                options.pop(\"symbolic_inputs\", False):\n            result = cls.eval(*args)\n        else:\n            raise TypeError(\"expected bit-vector constant arguments\")\n\n        assert isinstance(result, collections.abc.Sequence)\n        assert len(cls.output_widths) == len(result)\n\n        output = []\n        for r, width in zip(result, cls.output_widths):\n            output.append(core.bitvectify(r, width))\n\n        return tuple(output)\n\n    @classmethod\n    def eval(cls, *args):\n        \"\"\"Evaluate the function (internal method).\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    # noinspection PyArgumentList\n    @classmethod\n    def ssa(cls, input_names, id_prefix):\n        \"\"\"Return a static single assignment program representing the function.\n\n        Args:\n            input_names: the names  for the input variables\n            id_prefix: the prefix to denote the intermediate variables\n\n        Return:\n            : a dictionary with three keys\n\n            - *input_vars*: a list of `Variable` representing the inputs\n            - *output_vars*: a list of `Variable` representing the outputs\n            - *assignments*: an ordered sequence of pairs\n              (`Variable`, `Operation`) representing each assignment\n              of the SSA program.\n\n        ::\n\n                >>> from arxpy.primitives.chaskey import ChaskeyPi\n                >>> ChaskeyPi.set_rounds(1)\n                >>> ChaskeyPi.ssa([\"v0\", \"v1\", \"v2\", \"v3\"], \"x\")  # doctest: +NORMALIZE_WHITESPACE\n                {'input_vars': (v0, v1, v2, v3),\n                'output_vars': (x7, x12, x13, x9),\n                'assignments': ((x0, v0 + v1), (x1, v1 <<< 5), (x2, x0 ^ x1), (x3, x0 <<< 16), (x4, v2 + v3),\n                (x5, v3 <<< 8), (x6, x4 ^ x5), (x7, x3 + x6), (x8, x6 <<< 13), (x9, x7 ^ x8), (x10, x2 + x4),\n                (x11, x2 <<< 7), (x12, x10 ^ x11), (x13, x10 <<< 16))}\n\n        \"\"\"\n        input_vars = []\n        for name, width in zip(input_names, cls.input_widths):\n            input_vars.append(core.Variable(name, width))\n        input_vars = tuple(input_vars)\n\n        table = context.MemoizationTable(id_prefix=id_prefix)\n\n        with context.Memoization(table):\n            # noinspection PyArgumentList\n            output_vars = cls(*input_vars, symbolic_inputs=True)\n\n        ssa_dict = {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assignments\": tuple(table.items())\n        }\n\n        for var, expr in ssa_dict[\"assignments\"]:\n            for arg in expr.args:\n                if isinstance(arg, operation.Operation):\n                    raise ValueError(\"assignment {} <- {} was not decomposed\".format(var, expr))\n\n        to_delete = []\n        vars_needed = set()\n        for var in output_vars:\n            vars_needed.add(var)\n        for var, expr in reversed(ssa_dict[\"assignments\"]):\n            if var in vars_needed:\n                for arg in expr.atoms(core.Variable):\n                    vars_needed.add(arg)\n            else:\n                to_delete.append((var, expr))\n                # raise ValueError(\"assignment {} <- {} is redundant in \\n{}\".format(var, expr, ssa_dict))\n\n        if len(to_delete) > 0:\n            import warnings\n            warnings.warn(\"removing redundant assignments {} in \\n{}\".format(to_delete, ssa_dict))\n            ssa_dict[\"assignments\"] = list(ssa_dict[\"assignments\"])\n            for assignment in to_delete:\n                ssa_dict[\"assignments\"].remove(assignment)\n            ssa_dict[\"assignments\"] = tuple(ssa_dict[\"assignments\"])\n\n        return ssa_dict\narxpy/primitives/primitives.py\nclass KeySchedule(BvFunction):\n    \"\"\"Represent key schedule functions.\n\n    A key schedule function is a `BvFunction` that takes\n    the masterkey as input and returns the round keys.\n    See `BvFunction` for more information.\n    \"\"\"\narxpy/primitives/primitives.py\nclass Cipher(object):\n    \"\"\"Represent (iterated) block ciphers.\n\n    A (iterated) block cipher consists of `KeySchedule` function\n    that computes round keys from a master key and an `Encryption`\n    function that computes a ciphertext from a given plaintext\n    and the round keys.\n\n    Given a ``cipher``, it can be evaluated with the operator ``()``\n    by passing it as arguments the plaintext and the master key,\n    that is, ``cipher(plaintext, masterkey)`` returns the ciphertext.\n\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> plaintext = [0, 0]\n        >>> masterkey = [0, 0, 0, 0]\n        >>> Speck32(plaintext, masterkey)\n        (0x2bb9, 0xc642)\n\n    Attributes:\n        key_schedule: the `KeySchedule` function of the cipher\n        encryption: the `Encryption` function of the cipher\n\n    \"\"\"\n    key_schedule = None\n    encryption = None\n    rounds = None\n\n    _minimum_rounds = 1  # for testing\n\n    def __new__(cls, plaintext, masterkey, **options):\n        assert isinstance(plaintext, collections.abc.Sequence)\n        assert isinstance(masterkey, collections.abc.Sequence)\n        assert cls.rounds >= cls._minimum_rounds\n\n        previous_round_keys = cls.encryption.round_keys\n\n        round_keys = cls.key_schedule(*masterkey, **options)\n        cls.encryption.round_keys = round_keys\n        result = cls.encryption(*plaintext, **options)\n\n        cls.encryption.round_keys = previous_round_keys\n\n        return result\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\nimport doctest\nimport unittest\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\nfrom arxpy.bitvector.core import Variable, Constant\nfrom arxpy.bitvector.operation import RotateLeft, RotateRight\nfrom arxpy.primitives.primitives import BvFunction, KeySchedule, Encryption, Cipher\nfrom arxpy.differential.difference import XorDiff, RXDiff\nfrom arxpy.differential import characteristic\nfrom arxpy.differential.characteristic import BvCharacteristic, SingleKeyCh, RelatedKeyCh\n\"\"\"Tests for the Characteristic module.\"\"\"\n\n\n\n\n\n\nVERBOSE = False\n\n\n# 1st cipher: linear key schedule and encryption with modular addition (no ctes)\n\nclass MyFunction(BvFunction):  # noqa: D101\n    input_widths = [8, 8]\n    output_widths = [8]\n    rounds = 1\n\n    @classmethod\n    def eval(cls, x, y):\n        x = RotateLeft(x ^ Constant(1, 8), 1)\n        y = ~y\n        return tuple([x + y])\n\n\nclass KeySchedule1(KeySchedule):  # noqa: D101\n    input_widths = [8]\n    output_widths = [8, 8]\n\n    @classmethod\n    def eval(cls, mk):\n        return tuple([mk, mk ^ Constant(1, 8)])\n\n\nNext line of code:\n", "input": "import doctest\nimport unittest\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\nfrom arxpy.bitvector.core import Variable, Constant\nfrom arxpy.bitvector.operation import RotateLeft, RotateRight\nfrom arxpy.primitives.primitives import BvFunction, KeySchedule, Encryption, Cipher\nfrom arxpy.differential.difference import XorDiff, RXDiff\nfrom arxpy.differential import characteristic\nfrom arxpy.differential.characteristic import BvCharacteristic, SingleKeyCh, RelatedKeyCh\n\"\"\"Tests for the Characteristic module.\"\"\"\n\n\n\n\n\n\nVERBOSE = False\n\n\n# 1st cipher: linear key schedule and encryption with modular addition (no ctes)\n\nclass MyFunction(BvFunction):  # noqa: D101\n    input_widths = [8, 8]\n    output_widths = [8]\n    rounds = 1\n\n    @classmethod\n    def eval(cls, x, y):\n        x = RotateLeft(x ^ Constant(1, 8), 1)\n        y = ~y\n        return tuple([x + y])\n\n\nclass KeySchedule1(KeySchedule):  # noqa: D101\n    input_widths = [8]\n    output_widths = [8, 8]\n\n    @classmethod\n    def eval(cls, mk):\n        return tuple([mk, mk ^ Constant(1, 8)])\n\n\n", "context": "arxpy/differential/characteristic.py\nclass RelatedKeyCh(object):\n    \"\"\"Represent related-key characteristics of block ciphers.\n\n    A related-key characteristic of a `Cipher` is a pair `BvCharacteristic`,\n    one over the `KeySchedule` of the cipher, and another one over the\n    the `Encryption` function of the cipher, where the output differences\n    of the key schedule characteristic are used as round key differences\n    in the encryption characteristic.\n\n    The master key differences start with the prefix ``\"dmk\"``,\n    the round key differences start with the prefix ``\"dk\"``,\n    the plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import RelatedKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives.lea import LeaCipher\n        >>> issubclass(LeaCipher, Cipher)\n        True\n        >>> LeaCipher.set_rounds(1)\n        >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n        >>> rkch .key_schedule_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dmk0, dmk1, dmk2, dmk3),\n        'output_vars': (dk1, dk3, dk5, dk3, dk7, dk3),\n        'assignments': ((dk0, 0xc3efe9db + dmk0), (dk1, dk0 <<< 1), (dk2, 0x87dfd3b7 + dmk1), (dk3, dk2 <<< 3),\n        (dk4, 0x0fbfa76f + dmk2), (dk5, dk4 <<< 6), (dk6, 0x1f7f4ede + dmk3), (dk7, dk6 <<< 11))}\n        >>> rkch.key_schedule_ch.input_diff\n        (XorDiff(dmk0), XorDiff(dmk1), XorDiff(dmk2), XorDiff(dmk3))\n        >>> rkch.key_schedule_ch.output_diff  # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dk1), XorDiff(dk0 <<< 1)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk5), XorDiff(dk4 <<< 6)], [XorDiff(dk3), XorDiff(dk2 <<< 3)],\n        [XorDiff(dk7), XorDiff(dk6 <<< 11)], [XorDiff(dk3), XorDiff(dk2 <<< 3)]]\n        >>> rkch.key_schedule_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dk0), XDCA_0xc3efe9db(XorDiff(dmk0))),\n        (XorDiff(dk2), XDCA_0x87dfd3b7(XorDiff(dmk1))),\n        (XorDiff(dk4), XDCA_0x0fbfa76f(XorDiff(dmk2))),\n        (XorDiff(dk6), XDCA_0x1f7f4ede(XorDiff(dmk3)))])\n        >>> rkch.encryption_ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1, dp2, dp3),\n        'output_vars': (dx3, dx7, dx11, dp0),\n        'assignments': ((dx0, dk1 ^ dp0), (dx1, dk3 ^ dp1), (dx2, dx0 + dx1), (dx3, dx2 <<< 9),\n        (dx4, dk5 ^ dp1), (dx5, dk3 ^ dp2), (dx6, dx4 + dx5), (dx7, dx6 >>> 5), (dx8, dk7 ^ dp2),\n        (dx9, dk3 ^ dp3), (dx10, dx8 + dx9), (dx11, dx10 >>> 3))}\n        >>> rkch.encryption_ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1), XorDiff(dp2), XorDiff(dp3))\n        >>> rkch.encryption_ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(dx3), XorDiff(dx2 <<< 9)], [XorDiff(dx7), XorDiff(dx6 >>> 5)],\n        [XorDiff(dx11), XorDiff(dx10 >>> 3)], [XorDiff(dp0), XorDiff(dp0)]]\n        >>> rkch.encryption_ch.nonlinear_diffs  # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(dx2), XDA(XorDiff(dp0 ^ (dk0 <<< 1)), XorDiff(dp1 ^ (dk2 <<< 3)))),\n        (XorDiff(dx6), XDA(XorDiff(dp1 ^ (dk4 <<< 6)), XorDiff(dp2 ^ (dk2 <<< 3)))),\n        (XorDiff(dx10), XDA(XorDiff(dp2 ^ (dk6 <<< 11)), XorDiff(dp3 ^ (dk2 <<< 3))))])\n\n    Attributes:\n        key_schedule_ch: the `BvCharacteristic` over the key schedule\n        encryption_ch: the `BvCharacteristic` over the encryption function\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        func = bv_cipher.key_schedule\n        prefix = \"dk\"\n        input_diff_names = tuple([\"dmk\" + str(i) for i in range(len(func.input_widths))])\n        ks_ch = BvCharacteristic(func, diff_type, input_diff_names, prefix)\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = ks_ch.ssa[\"output_vars\"]\n\n        func = Encryption\n        prefix = \"dx\"\n        input_diff_names = [\"dp\" + str(i) for i in range(len(func.input_widths))]\n        round_key_diff = {}\n        for var, diff in ks_ch.output_diff:\n            round_key_diff[var.val] = diff\n        encryption_ch = BvCharacteristic(func, diff_type, input_diff_names,\n                                         prefix, round_key_diff)\n\n        self.diff_type = diff_type\n        self.key_schedule_ch = ks_ch\n        self.encryption_ch = encryption_ch\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n        \"\"\"Return the empirical weight of a given differential for multiple keys.\n\n        This method returns the differential probability weight for the\n        key schedule characteristic (see `BvCharacteristic.empirical_weight`)\n        and the `collections.Counter` storing the distribution of weights for the encryption\n        characteristic (see `SingleKeyCh.empirical_weight`).\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> kid, kod = [zero]*4, [zero]*6\n            >>> eid, eod = [zero]*4, [zero]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (0.0, Counter({0.0: 10}))\n            >>> kid, kod = [zero]*4, [one]*6\n            >>> eid, eod = [zero]*4, [one]*4\n            >>> rkch.empirical_weight(kid, kod, 10, eid, eod, 100)\n            (inf, Counter({inf: 10}))\n\n        \"\"\"\n        key_weight = self.key_schedule_ch.empirical_weight(key_input_diff, key_output_diff, key_samples)\n        # noinspection PyProtectedMember\n        enc_counter = self.encryption_ch._empirical_weight_distribution(self._cipher,\n                                                                        enc_input_diff, enc_output_diff, enc_samples,\n                                                                        key_samples, precision, key_output_diff)\n        return key_weight, enc_counter\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the related-key characteristic.\n\n        The signature of a related-key characteristic is the\n        concatenation of the key schedule and encryption signatures.\n\n        See also `BvCharacteristic.signature`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import RelatedKeyCh, ChSignatureType\n            >>> from arxpy.primitives.primitives import Cipher\n            >>> from arxpy.primitives.lea import LeaCipher\n            >>> LeaCipher.set_rounds(1)\n            >>> rkch = RelatedKeyCh(LeaCipher, XorDiff)\n            >>> rkch.signature(ChSignatureType.Full)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk0, dk2, dk4, dk6, dp0, dp1, dp2, dp3, dx2, dx6, dx10]\n            >>> rkch.signature(ChSignatureType.InputOutput)  # doctest:+NORMALIZE_WHITESPACE\n            [dmk0, dmk1, dmk2, dmk3, dk1, dk3, dk5, dk3, dk7, dk3, dp0, dp1, dp2, dp3, dx3, dx7, dx11]\n\n        \"\"\"\n        return self.key_schedule_ch.signature(ch_signature_type) + self.encryption_ch.signature(ch_signature_type)\n\n    def _to_dict(self):\n        dict_ch = {\n            \"key_schedule_ch\": self.key_schedule_ch._to_dict(),\n            \"encryption_ch\": self.encryption_ch._to_dict(),\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/bitvector/operation.py\nclass RotateLeft(Operation):\n    \"\"\"Circular left rotation operation.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateLeft\n        >>> RotateLeft(Constant(150, 8), 2)\n        0x5a\n        >>> RotateLeft(Variable(\"x\", 8), 2)\n        x <<< 2\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \"<<<\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Left cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val << r) & mask) | ((val & mask) >> (width - r))\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/bitvector/operation.py\nclass RotateRight(Operation):\n    \"\"\"Circular right rotation operation.\n\n    It provides Automatic Constant Conversion. See `Operation` for more\n    information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.bitvector.operation import RotateRight\n        >>> RotateRight(Constant(150, 8), 3)\n        0xd2\n        >>> RotateRight(Variable(\"x\", 8), 3)\n        x >>> 3\n\n    \"\"\"\n\n    arity = [1, 1]\n    is_symmetric = False\n    infix_symbol = \">>>\"\n    operand_types = [core.Term, int]\n\n    @classmethod\n    def condition(cls, x, r):\n        return x.width > r >= 0\n\n    @classmethod\n    def output_width(cls, x, r):\n        return x.width\n\n    @classmethod\n    def eval(cls, x, r):\n        def doit(val, r, width):\n            \"\"\"Right cyclic rotation operation when both operands are int.\"\"\"\n            mask = 2 ** width - 1\n            r = r % width\n            return ((val & mask) >> r) | (val << (width - r) & mask)\n\n        if isinstance(x, core.Constant):\n            return core.Constant(doit(int(x), r, x.width), x.width)\n        elif r == 0:\n            return x\n        elif isinstance(x, RotateRight):\n            return RotateRight(x.args[0], (x.args[1] + r) % x.args[0].width)\n        elif isinstance(x, RotateLeft):\n            return RotateLeft(x.args[0], (x.args[1] - r) % x.args[0].width)\narxpy/differential/difference.py\nclass XorDiff(Difference):\n    \"\"\"Represent XOR differences.\n\n    The XOR difference of two `Term` is given by the XOR\n    of the terms. In other words, the *difference operation*\n    of `XorDiff` is the `BvXor` (see `Difference`).\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b010, 3), Constant(0b101, 3)\n        >>> alpha = XorDiff.from_pair(x, y)\n        >>> alpha\n        XorDiff(0b111)\n        >>> alpha.get_pair_element(x)\n        0b101\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = XorDiff.from_pair(k, k)\n        >>> alpha\n        XorDiff(0x00)\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = operation.BvXor\n    inv_diff_op = operation.BvXor\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft, BvSub\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import XorDiff\n            >>> d1, d2 = XorDiff(Variable(\"d1\", 8)), XorDiff(Variable(\"d2\", 8))\n            >>> XorDiff.derivative(BvXor, [d1, d2])\n            XorDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(Xor1, d1)\n            XorDiff(d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> XorDiff.derivative(Rotate1, d1)\n            XorDiff(d1 <<< 1)\n            >>> XorDiff.derivative(BvAdd, [d1, d2])\n            XDA(XorDiff(d1), XorDiff(d2))\n            >>> XorDiff.derivative(BvSub, [d1, d2])\n            XDS(XorDiff(d1), XorDiff(d2))\n            >>> CteAdd1 = make_partial_operation(BvAdd, tuple([None, Constant(1, 8)]))\n            >>> XorDiff.derivative(CteAdd1, d1)\n            XDCA_0x01(XorDiff(d1))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.Concat:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.XDA(input_diff)\n\n        if op == operation.BvSub:\n            from arxpy.differential import derivative\n            return derivative.XDS(input_diff)\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAnd:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                if isinstance(val, core.Constant):\n                    return cls(op.base_op(d1.val, val))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op in [operation.BvShl, operation.BvLshr]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Extract:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None and op.fixed_args[2] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1], op.fixed_args[2]))\n                else:\n                    raise ValueError(msg)\n\n            if op.base_op == operation.Concat:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                if op.fixed_args[0] is not None:\n                    val = op.fixed_args[0]\n                    input_diff = [cls.from_pair(val, val), d1]\n                else:\n                    val = op.fixed_args[1]\n                    input_diff = [d1, cls.from_pair(val, val)]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op == operation.BvAdd:\n                assert len(input_diff) == 1\n                d = input_diff[0]\n                cte = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                from arxpy.differential import derivative\n                return derivative.XDCA(d, cte)\n            else:\n                raise ValueError(msg)\n\n        if hasattr(op, \"xor_derivative\"):\n            return op.xor_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/bitvector/core.py\nclass Constant(basic.Atom, Term):\n    \"\"\"Represent bit-vector constants.\n\n    Bit-vector constants are interpreted as unsigned integers in base 2,\n    that is, a bit-vector :math:`(x_{n-1}, \\dots, x_1, x_0)` represents\n    the non-negative integer :math:`x_0 + 2 x_1 + \\dots + 2^{n-1} x_{n-1}`.\n\n    Args:\n        val: the integer value.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Constant\n        >>> Constant(3, 12)\n        0x003\n        >>> Constant(0b11, 12)\n        0x003\n        >>> Constant(0x003, 12)\n        0x003\n        >>> Constant(3, 12).vrepr()\n        'Constant(0b000000000011, width=12)'\n\n    \"\"\"\n\n    def __int__(self):\n        return self.val\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"Override == operator.\"\"\"\n        if isinstance(other, int):\n            return self.val == other\n        elif isinstance(other, Constant) and self.width == other.width:\n            return self.val == other.val\n        else:\n            return False\n\n    # def __index__(self):\n    #     \"\"\"Return an int to be used inside a slice [ : : ].\"\"\"\n    #     return self.int\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute its hash.\"\"\"\n        return self.val, self.width\n\n    @classmethod\n    def class_key(cls):\n        \"\"\"Return the key (identifier) of the class for sorting.\"\"\"\n        return 1, 0, cls.__name__\n\n    # end Integer\n\n    __slots__ = [\"_val\"]\n\n    def __new__(cls, val, width):\n        assert isinstance(val, int) and 0 <= val < 2 ** width\n        obj = Term.__new__(cls, width=width)\n        obj._val = val\n        return obj\n\n    def __bool__(self):\n        if self.width == 1:\n            return self == Constant(1, 1)\n        else:\n            raise AttributeError(\"only 1-bit constants implement bool()\")\n\n    @property\n    def val(self):\n        \"\"\"The integer represented by the bit-vector constant.\"\"\"\n        return self._val\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the constant.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + log2(int(self) + 1) + bin_enc(self.width)\n\n    def bin(self):\n        \"\"\"Return the binary representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).bin())\n            0b0011\n            >>> print(Constant(4, 6).bin())\n            0b000100\n\n        \"\"\"\n        width = self.width + 2  # 2 due to '0b'\n        return format(self.val, r'0=#{}b'.format(width))\n\n    def hex(self):\n        \"\"\"Return the hexadecimal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(3, 4).hex())\n            0x3\n\n        \"\"\"\n        assert self.width % 4 == 0\n        width = (self.width // 4) + 2\n        return format(self.val, '0=#{}x'.format(width))\n\n    def oct(self):\n        \"\"\"Return the octal representation.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> print(Constant(4, 6).oct())\n            0o04\n\n        \"\"\"\n        assert self.width % 3 == 0\n        width = (self.width // 3) + 2\n        return format(self.val, '0=#{}o'.format(width))\narxpy/differential/characteristic.py\nclass BvCharacteristic(object):\n    \"\"\"Represent characteristics of bit-vector functions.\n\n    Given a bit-vector function `BvFunction` :math:`f`,\n    a characteristic is a trail of differences obtained by\n    propagating an input difference over :math:`f`.\n\n    In particular, a characteristic is composed of the\n    input difference and the output difference of each\n    non-linear operation.\n\n    This class manages symbolic characteristics,\n    where the input difference is given symbolically\n    and the intermediate differences are `Term`\n    that depend on the input difference.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff, RXDiff\n        >>> from arxpy.differential.characteristic import BvCharacteristic\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi.set_rounds(1)\n        >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dv0, dv1, dv2, dv3),\n        'output_vars': (d7, d12, d13, d9),\n        'assignments': ((d0, dv0 + dv1), (d1, dv1 <<< 5), (d2, d0 ^ d1), (d3, d0 <<< 16), (d4, dv2 + dv3),\n        (d5, dv3 <<< 8), (d6, d4 ^ d5), (d7, d3 + d6), (d8, d6 <<< 13), (d9, d7 ^ d8), (d10, d2 + d4),\n        (d11, d2 <<< 7), (d12, d10 ^ d11), (d13, d10 <<< 16))}\n        >>> ch.input_diff\n        (XorDiff(dv0), XorDiff(dv1), XorDiff(dv2), XorDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(XorDiff(d0), XDA(XorDiff(dv0), XorDiff(dv1))),\n        (XorDiff(d4), XDA(XorDiff(dv2), XorDiff(dv3))),\n        (XorDiff(d7), XDA(XorDiff(d0 <<< 16), XorDiff(d4 ^ (dv3 <<< 8)))),\n        (XorDiff(d10), XDA(XorDiff(d0 ^ (dv1 <<< 5)), XorDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[XorDiff(d7), XorDiff(d7)],\n        [XorDiff(d12), XorDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [XorDiff(d13), XorDiff(d10 <<< 16)],\n        [XorDiff(d9), XorDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n        >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n        >>> ch.input_diff\n        (RXDiff(dv0), RXDiff(dv1), RXDiff(dv2), RXDiff(dv3))\n        >>> ch.nonlinear_diffs # doctest: +NORMALIZE_WHITESPACE\n        OrderedDict([(RXDiff(d0), RXDA(RXDiff(dv0), RXDiff(dv1))),\n        (RXDiff(d4), RXDA(RXDiff(dv2), RXDiff(dv3))),\n        (RXDiff(d7), RXDA(RXDiff(d0 <<< 16), RXDiff(d4 ^ (dv3 <<< 8)))),\n        (RXDiff(d10), RXDA(RXDiff(d0 ^ (dv1 <<< 5)), RXDiff(d4)))])\n        >>> ch.output_diff # doctest: +NORMALIZE_WHITESPACE\n        [[RXDiff(d7), RXDiff(d7)],\n        [RXDiff(d12), RXDiff(d10 ^ ((d0 ^ (dv1 <<< 5)) <<< 7))],\n        [RXDiff(d13), RXDiff(d10 <<< 16)],\n        [RXDiff(d9), RXDiff(d7 ^ ((d4 ^ (dv3 <<< 8)) <<< 13))]]\n\n    Attributes:\n        func: the `BvFunction`\n        diff_type: the `Difference` of the characteristic\n        input_diff: a list containing the input symbolic differences\n        nonlinear_diffs: an `collections.OrderedDict` mapping non-linear symbolic differences\n            to their corresponding `Derivative`\n        output_diff: a list, where the i-th element is a pair containing\n            the i-th output symbolic difference and its value\n    \"\"\"\n\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n        assert issubclass(func, primitives.BvFunction)\n        assert issubclass(diff_type, difference.Difference)\n\n        assert len(input_diff_names) == len(func.input_widths)\n        input_diff = []\n        for name, width in zip(input_diff_names, func.input_widths):\n            input_diff.append(diff_type(core.Variable(name, width)))\n        input_diff = tuple(input_diff)\n\n        self.func = func\n        self.diff_type = diff_type\n        self.input_diff = input_diff\n\n        # Propagate the input difference through the function\n\n        names = [d.val.name for d in self.input_diff]\n        ssa = self.func.ssa(names, id_prefix=prefix)\n        self.ssa = ssa\n        self._prefix = prefix\n        self._input_diff_names = input_diff_names\n\n        for var in ssa[\"output_vars\"]:\n            if isinstance(var, core.Constant):\n                raise ValueError(\"constant outputs (independent of the inputs) are not supported\")\n\n        var2diff = {}  # Variable to Difference\n        for var, diff in zip(ssa[\"input_vars\"], self.input_diff):\n            var2diff[var] = diff\n\n        if initial_var2diff is not None:\n            for var in initial_var2diff:\n                if str(var) in names:\n                    raise ValueError(\"the input differences cannot be replaced by initial_var2diff\")\n            var2diff.update(initial_var2diff)\n\n        self.nonlinear_diffs = collections.OrderedDict()\n        for var, expr in ssa[\"assignments\"]:\n            expr_args = []\n            for arg in expr.args:\n                if isinstance(arg, int):\n                    expr_args.append(arg)  # 'int' object has no attribute 'xreplace'\n                else:\n                    expr_args.append(arg.xreplace(var2diff))\n\n            if all(not isinstance(arg, diff_type) for arg in expr_args):\n                # symbolic computations with the key\n                var2diff[var] = expr\n                continue\n\n            if all(isinstance(arg, diff_type) for arg in expr_args):\n                der = self.diff_type.derivative(type(expr), expr_args)\n            else:\n                def contains_key_var(term):\n                    from sympy import basic\n                    for sub in basic.preorder_traversal(term):\n                        if sub in func.round_keys:\n                            return True\n                    else:\n                        return False\n\n                if type(expr) == operation.BvAdd and hasattr(func, 'round_keys') and \\\n                        all(isinstance(r, core.Variable) for r in func.round_keys) and \\\n                        any(contains_key_var(a) for a in expr_args):\n                    # temporary solution to Derivative(BvAddCte_k(x)) != Derivative(x + k)\n                    # with x a Diff and k a key variable\n                    keyed_indices = []\n                    for i, a in enumerate(expr_args):\n                        if contains_key_var(a):\n                            keyed_indices.append(i)\n                    if len(keyed_indices) != 1 or expr_args[keyed_indices[0]] not in func.round_keys:\n                        raise NotImplementedError(\"invalid expression: op={}, args={}\".format(\n                            type(expr).__name__, expr_args))\n                    # expr_args[keyed_indices[0]] replaced to the zero diff\n                    zero_diff = diff_type(core.Constant(0, expr_args[keyed_indices[0]].width))\n                    der = self.diff_type.derivative(type(expr), [expr_args[(keyed_indices[0] + 1) % 2], zero_diff])\n                elif hasattr(expr, \"xor_derivative\"):\n                    # temporary solution to operations containing a custom derivative\n                    input_diff_expr = []\n                    for i, arg in enumerate(expr_args):\n                        if isinstance(arg, diff_type):\n                            input_diff_expr.append(arg)\n                        else:\n                            assert isinstance(arg, core.Term)  # int arguments currently not supported\n                            input_diff_expr.append(diff_type.from_pair(arg, arg))\n                    der = self.diff_type.derivative(type(expr), input_diff_expr)\n                else:\n                    fixed_args = []\n                    for i, arg in enumerate(expr_args):\n                        if not isinstance(arg, diff_type):\n                            fixed_args.append(arg)\n                        else:\n                            fixed_args.append(None)\n                    new_op = extraop.make_partial_operation(type(expr), tuple(fixed_args))\n                    der = self.diff_type.derivative(new_op, [arg for arg in expr_args if isinstance(arg, diff_type)])\n\n            if isinstance(der, derivative.Derivative):\n                diff = self.diff_type(var)\n                var2diff[var] = diff\n                self.nonlinear_diffs[diff] = der\n            else:\n                var2diff[var] = der\n\n        self._var2diff = var2diff\n\n        self.output_diff = []\n        for var in ssa[\"output_vars\"]:\n            self.output_diff.append([self.diff_type(var), var2diff[var]])\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n        \"\"\"Return the empirical weight of a given differential.\n\n        Given a differential (a pair of input and output differences),\n        the differential probability is the fraction of input pairs\n        with the given input difference leading to output pairs\n        with the given output difference.\n\n        This method returns an approximation of the weight of the\n        differential probability by sampling a given number\n        of input pairs.\n\n        If no correct output pairs are found, `math.inf` is returned.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff, RXDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = XorDiff(Constant(0, 32)), XorDiff(Constant(1, 32))\n            >>> ch.empirical_weight([zero, zero, zero, zero], [zero, zero, zero, zero], 100)\n            0.0\n            >>> ch.empirical_weight([zero, zero, zero, zero], [one, one, one, one], 100)\n            inf\n            >>> ch = BvCharacteristic(ChaskeyPi, RXDiff, [\"dv\" + str(i) for i in range(4)])\n            >>> zero, one = RXDiff(Constant(0, 32)), RXDiff(Constant(1, 32))\n            >>> 4 - 1 <= ch.empirical_weight([zero]*4, [zero]*4, 3 * 2**6) <= 8\n            True\n            >>> ch.empirical_weight([zero]*4, [one]*4, 3 * 2**6)\n            inf\n\n        \"\"\"\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            correct_pairs = 0\n\n            for index_input in range(pair_samples):\n                pt, other_pt = list_pairs[index_input]\n                ct = self.func(*pt)\n                other_ct = self.func(*other_pt)\n\n                assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                for i, diff in enumerate(output_diff):\n                    # noinspection PyUnresolvedReferences\n                    if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                        break\n                else:\n                    correct_pairs += 1\n\n            if correct_pairs == 0:\n                weight = math.inf\n            else:\n                weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n\n        return weight\n\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n        # this function is not part of SingleKeyCh since it must be accessible\n        # for the encryption characteristic of RelatedKeyCh (which is a\n        # plain BvCharacteristic)\n        assert isinstance(input_diff, collections.abc.Sequence)\n        assert isinstance(output_diff, collections.abc.Sequence)\n        assert all(isinstance(d, difference.Difference) for d in input_diff)\n        assert all(isinstance(d, difference.Difference) for d in output_diff)\n        assert all(isinstance(d.val, core.Constant) for d in input_diff)\n        assert all(isinstance(d.val, core.Constant) for d in output_diff)\n\n        assert len(input_diff) == len(self.input_diff)\n        assert len(output_diff) == len(self.output_diff)\n        assert len(self.ssa[\"input_vars\"]) == len(input_diff)\n        assert len(self.ssa[\"output_vars\"]) == len(output_diff)\n\n        old_round_keys = self.func.round_keys\n\n        empirical_weights = collections.Counter()\n\n        if rk_output_diff is not None:\n            class RelatedFunc(self.func):\n                pass\n        else:\n            RelatedFunc = self.func\n\n        with context.Simplification(False):\n            input_widths = [d.val.width for d in self.input_diff]\n            if pair_samples >= 2**sum(input_widths):\n                iterators = [range(2 ** w) for w in input_widths]\n                list_pairs = []\n                for x in itertools.product(*iterators):\n                    pt = [core.Constant(x_i, w) for x_i, w in zip(x, input_widths)]\n                    other_pt = [diff.get_pair_element(pt[i]) for i, diff in enumerate(input_diff)]\n                    list_pairs.append([pt, other_pt])\n                pair_samples = len(list_pairs)\n                assert pair_samples == 2**sum(input_widths)\n            else:\n                list_pairs = []\n                for _ in range(pair_samples):\n                    pt = []\n                    other_pt = []\n                    for diff in input_diff:\n                        random_int = random.randrange(2 ** diff.val.width)\n                        random_bv = core.Constant(random_int, diff.val.width)\n                        pt.append(random_bv)\n                        other_pt.append(diff.get_pair_element(random_bv))\n                    list_pairs.append([pt, other_pt])\n\n            for _ in range(key_samples):\n                master_key = []\n                for width in cipher.key_schedule.input_widths:\n                    master_key.append(core.Constant(random.randrange(2 ** width), width))\n                self.func.round_keys = cipher.key_schedule(*master_key)\n                assert all(isinstance(rk, core.Constant) for rk in self.func.round_keys), str(self.func.round_keys)\n\n                if rk_output_diff is not None:\n                    RelatedFunc.round_keys = [d.get_pair_element(r) for r, d in zip(self.func.round_keys, rk_output_diff)]\n                    assert all(isinstance(rk, core.Constant) for rk in RelatedFunc.round_keys), str(RelatedFunc.round_keys)\n\n                correct_pairs = 0\n\n                for index_input in range(pair_samples):\n                    pt, other_pt = list_pairs[index_input]\n                    ct = self.func(*pt)\n                    other_ct = RelatedFunc(*other_pt)\n\n                    assert all(isinstance(x, core.Constant) for x in ct), str(ct)\n                    assert all(isinstance(x, core.Constant) for x in other_ct), str(other_ct)\n\n                    for i, diff in enumerate(output_diff):\n                        # noinspection PyUnresolvedReferences\n                        if self.diff_type.from_pair(ct[i], other_ct[i]) != diff:\n                            break\n                    else:\n                        correct_pairs += 1\n\n                if correct_pairs == 0:\n                    weight = math.inf\n                else:\n                    weight = abs(-math.log(correct_pairs * 1.0 / pair_samples, 2))\n                # weight = float((\"{0:.\"+str(precision)+\"f}\").format(weight))\n                weight = round(weight, precision)\n                empirical_weights[weight] += 1\n\n        self.func.round_keys = old_round_keys\n\n        return empirical_weights\n\n    def signature(self, ch_signature_type):\n        \"\"\"Return the signature of the characteristic.\n\n        The signature is a \"hash\" of the characteristic used for comparing.\n\n        For the type of the signature, see `ChSignatureType`.\n\n            >>> from arxpy.bitvector.core import Variable\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import BvCharacteristic, ChSignatureType\n            >>> from arxpy.primitives.primitives import BvFunction\n            >>> from arxpy.primitives.chaskey import ChaskeyPi\n            >>> issubclass(ChaskeyPi, BvFunction)\n            True\n            >>> ChaskeyPi.set_rounds(1)\n            >>> ch = BvCharacteristic(ChaskeyPi, XorDiff, [\"dv0\", \"dv1\", \"dv2\", \"dv3\"])\n            >>> ch.signature(ChSignatureType.Full)\n            [dv0, dv1, dv2, dv3, d0, d4, d7, d10]\n            >>> ch.signature(ChSignatureType.InputOutput)\n            [dv0, dv1, dv2, dv3, d7, d12, d13, d9]\n\n        \"\"\"\n        if ch_signature_type == ChSignatureType.Full:\n            return [d.val for d in self.input_diff] + [d.val for d in self.nonlinear_diffs]\n        elif ch_signature_type == ChSignatureType.InputOutput:\n            # sig = [d for d in self.input_diff]\n            sig_var = [d.val for d in self.input_diff]\n\n            for out_diff, _ in self.output_diff:\n                for aux_var in self._var2diff[out_diff.val].val.atoms(core.Variable):\n                    if aux_var not in sig_var:\n                        # sig.append(out_diff)\n                        sig_var.append(out_diff.val)\n                        break\n\n            return sig_var\n        else:\n            raise ValueError(\"invalid ch_signature_type: {}\".format(ch_signature_type))\n\n    def _to_dict(self):\n        dict_ch = {\n            \"ssa\": self.ssa,\n            \"input_diff\": self.input_diff,\n            \"output_diff\": self.output_diff,\n            \"nonlinear_diffs\": self.nonlinear_diffs,\n        }\n        return dict_ch\n\n    def __str__(self):\n        return pprint.pformat(self._to_dict(), width=100, compact=True)\narxpy/primitives/primitives.py\nclass Encryption(BvFunction):\n    \"\"\"Represent encryption functions.\n\n    An encryption function is a `BvFunction` that takes\n    the plaintext as input and returns the ciphertext\n    for some fixed key.\n    See `BvFunction` for more information.\n\n    Attributes:\n        round_keys: a list of `Term` representing the round keys\n\n    \"\"\"\n    round_keys = None\narxpy/bitvector/core.py\nclass Variable(basic.Atom, Term):\n    \"\"\"Represent bit-vector variables.\n\n    Args:\n        name: the name of the variable.\n        width: the bit-width.\n\n    ::\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> Variable(\"x\", 12)\n        x\n        >>> Variable(\"x\", 12).vrepr()\n        \"Variable('x', width=12)\"\n\n    \"\"\"\n\n    def _hashable_content(self):\n        \"\"\"Return a tuple of information about self to compute hash.\"\"\"\n        return self.name, self.width\n\n    # def __call__(self, *args):\n    #     from sympy.core.function as function\n    #     return function.UndefinedFunction(self.name, self.width)(*args)\n\n    # end Symbol\n\n    __slots__ = ['_name']\n\n    def __new__(cls, name, width):\n        assert isinstance(name, str)\n        obj = Term.__new__(cls, width=width)\n        obj._name = name\n\n        return obj\n\n    @property\n    def name(self):\n        \"\"\"The name of the variable.\"\"\"\n        return self._name\n\n    @property\n    def formula_size(self):\n        \"\"\"The formula size of the variable.\"\"\"\n        def log2(n):\n            return int(math.ceil(math.log(n, 2)))\n\n        def bin_enc(n):\n            return 1 + log2(n + 1)\n\n        return 1 + bin_enc(self.width)\narxpy/differential/characteristic.py\nclass SingleKeyCh(BvCharacteristic):\n    \"\"\"Represent single-key characteristics of block ciphers.\n\n    A single-key characteristic of a `Cipher` is a `BvCharacteristic`\n    over the `Encryption` function of the cipher.\n\n    The plaintext differences start with the prefix ``\"dp\"``\n    and the non-linear differences start with the prefix ``\"dx\"``.\n\n        >>> from arxpy.bitvector.core import Variable\n        >>> from arxpy.differential.difference import XorDiff\n        >>> from arxpy.differential.characteristic import SingleKeyCh\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> Speck32.set_rounds(1)\n        >>> ch = SingleKeyCh(Speck32, XorDiff)\n        >>> ch .ssa  # doctest: +NORMALIZE_WHITESPACE\n        {'input_vars': (dp0, dp1), 'output_vars': (dx2, dx4),\n        'assignments': ((dx0, dp0 >>> 7), (dx1, dp1 + dx0), (dx2, dx1 ^ k0), (dx3, dp1 <<< 2), (dx4, dx2 ^ dx3))}\n        >>> ch.input_diff\n        (XorDiff(dp0), XorDiff(dp1))\n        >>> ch.nonlinear_diffs\n        OrderedDict([(XorDiff(dx1), XDA(XorDiff(dp1), XorDiff(dp0 >>> 7)))])\n        >>> ch.output_diff\n        [[XorDiff(dx2), XorDiff(dx1)], [XorDiff(dx4), XorDiff(dx1 ^ (dp1 <<< 2))]]\n\n    \"\"\"\n\n    def __init__(self, bv_cipher, diff_type):\n        assert issubclass(bv_cipher, primitives.Cipher)\n        assert issubclass(diff_type, difference.Difference)\n\n        rk = []\n        for i, width in enumerate(bv_cipher.key_schedule.output_widths):\n            rk.append(core.Variable(\"k\" + str(i), width))\n\n        class Encryption(bv_cipher.encryption):\n            round_keys = tuple(rk)\n\n        func = Encryption\n        num_inputs = len(func.input_widths)\n        input_diff_names = [\"dp\" + str(i) for i in range(num_inputs)]\n        prefix = \"dx\"\n        super().__init__(func, diff_type, input_diff_names, prefix)\n        self._cipher = bv_cipher\n\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n        \"\"\"Return the empirical weight distribution of a given differential.\n\n        This method returns a `collections.Counter` storing the distribution of\n        differential probability weights over the given number of keys.\n\n        The weights are rounded to the given number of precision\n        digits after the decimal point.\n\n        See also `BvCharacteristic.empirical_weight`.\n\n            >>> from arxpy.bitvector.core import Constant\n            >>> from arxpy.differential.difference import XorDiff\n            >>> from arxpy.differential.characteristic import SingleKeyCh\n            >>> from arxpy.primitives import speck\n            >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n            >>> Speck32.set_rounds(1)\n            >>> ch = SingleKeyCh(Speck32, XorDiff)\n            >>> zero, one = XorDiff(Constant(0, 16)), XorDiff(Constant(1, 16))\n            >>> ch.empirical_weight([zero, zero], [zero, zero], 100, 10)\n            Counter({0.0: 10})\n            >>> ch.empirical_weight([zero, zero], [one, one], 100, 10)\n            Counter({inf: 10})\n\n        \"\"\"\n        return self._empirical_weight_distribution(self._cipher, input_diff, output_diff, pair_samples, key_samples,\n                                                   precision, rk_diffs)\narxpy/differential/characteristic.py\nclass ChSignatureType(enum.Enum):\nclass BvCharacteristic(object):\n            class RelatedFunc(self.func):\nclass SingleKeyCh(BvCharacteristic):\n        class Encryption(bv_cipher.encryption):\nclass RelatedKeyCh(object):\n        class Encryption(bv_cipher.encryption):\n    def __init__(self, func, diff_type, input_diff_names, prefix=\"d\", initial_var2diff=None):\n                def contains_key_var(term):\n    def empirical_weight(self, input_diff, output_diff, pair_samples):\n    def _empirical_weight_distribution(self, cipher, input_diff, output_diff, pair_samples, key_samples,\n                                       precision=1, rk_output_diff=None):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, input_diff, output_diff, pair_samples, key_samples,\n                         precision=1, rk_diffs=None):\n    def __init__(self, bv_cipher, diff_type):\n    def empirical_weight(self, key_input_diff, key_output_diff, key_samples,\n                         enc_input_diff, enc_output_diff, enc_samples, precision=1):\n    def signature(self, ch_signature_type):\n    def _to_dict(self):\n    def __str__(self):\narxpy/differential/difference.py\nclass RXDiff(Difference):\n    \"\"\"Represent rotational-XOR (RX) differences.\n\n    The pair ``(x, (x <<< 1) ^ d)`` has RX difference ``d``.\n    In other words,  the RX difference of two `Term` ``x`` and ``y``\n    is defined as ``(x <<< 1) ^ y``.\n\n    See `Difference` for more information.\n\n        >>> from arxpy.bitvector.core import Constant, Variable\n        >>> from arxpy.differential.difference import RXDiff\n        >>> x, y = Constant(0b000, 3), Constant(0b000, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b000)\n        >>> alpha.get_pair_element(x)\n        0b000\n        >>> x, y = Constant(0b000, 3), Constant(0b001, 3)\n        >>> alpha = RXDiff.from_pair(x, y)\n        >>> alpha\n        RXDiff(0b001)\n        >>> alpha.get_pair_element(x)\n        0b001\n        >>> k = Variable(\"k\", 8)\n        >>> alpha = RXDiff.from_pair(k, k)\n        >>> alpha\n        RXDiff(k ^ (k <<< 1))\n        >>> alpha.get_pair_element(k)\n        k\n    \"\"\"\n\n    diff_op = RXOp\n    inv_diff_op = RXInvOp\n\n    @classmethod\n    def derivative(cls, op, input_diff):\n        \"\"\"Return the derivative of ``op`` at the point ``input_diff``.\n\n        See `Difference.derivative` for more information.\n\n            >>> from arxpy.bitvector.core import Variable, Constant\n            >>> from arxpy.bitvector.operation import BvAdd, BvXor, RotateLeft\n            >>> from arxpy.bitvector.extraop import make_partial_operation\n            >>> from arxpy.differential.difference import RXDiff\n            >>> d1, d2 = RXDiff(Variable(\"d1\", 8)), RXDiff(Variable(\"d2\", 8))\n            >>> RXDiff.derivative(BvXor, [d1, d2])\n            RXDiff(d1 ^ d2)\n            >>> Xor1 = make_partial_operation(BvXor, tuple([None, Constant(1, 8)]))\n            >>> RXDiff.derivative(Xor1, d1)\n            RXDiff(0x03 ^ d1)\n            >>> Rotate1 = make_partial_operation(RotateLeft, tuple([None, 1]))\n            >>> RXDiff.derivative(Rotate1, d1)\n            RXDiff(d1 <<< 1)\n            >>> RXDiff.derivative(BvAdd, [d1, d2])\n            RXDA(RXDiff(d1), RXDiff(d2))\n\n        \"\"\"\n        input_diff = _tuplify(input_diff)\n        assert len(input_diff) == sum(op.arity)\n\n        msg = \"invalid arguments: op={}, input_diff={}\".format(\n            op.__name__,\n            [d.vrepr() if isinstance(d, core.Term) else d for d in input_diff])\n\n        if not all(isinstance(diff, cls) for diff in input_diff):\n            raise ValueError(msg)\n\n        if op == operation.BvNot:\n            return input_diff[0]\n\n        if op == operation.BvXor:\n            return cls(op(*[d.val for d in input_diff]))\n\n        if op == operation.BvAdd:\n            from arxpy.differential import derivative\n            return derivative.RXDA(input_diff)\n\n        # Concact, BvSub\n\n        if issubclass(op, extraop.PartialOperation):\n            if op.base_op == operation.BvXor:\n                assert len(input_diff) == 1\n                d1 = input_diff[0]\n                val = op.fixed_args[0] if op.fixed_args[0] is not None else op.fixed_args[1]\n                d2 = cls.from_pair(val, val)\n                input_diff = [d1, d2]\n                return cls(op.base_op(*[d.val for d in input_diff]))\n\n            if op.base_op in [operation.RotateLeft, operation.RotateRight]:\n                if op.fixed_args[0] is None and op.fixed_args[1] is not None:\n                    assert len(input_diff) == 1\n                    d = input_diff[0]\n                    return cls(op.base_op(d.val, op.fixed_args[1]))\n                else:\n                    raise ValueError(msg)\n\n            # BvShl, Extract\n\n        if hasattr(op, \"rx_derivative\"):\n            return op.rx_derivative(input_diff)\n\n        raise ValueError(msg)\narxpy/primitives/primitives.py\nclass BvFunction(object):\n    \"\"\"Represent (iterated) fixed-width bit-vector functions.\n\n    A `BvFunction` takes fixed-width `Constant` operands and return a\n    tuple of fixed-width `Constant`. An iterated bit-vector function\n    contains a subroutine that is iterated a certain number of *rounds*,\n    which can be changed using `set_rounds`.\n\n    Similar to `Operation`, `BvFunction` is evaluated\n    using the operator ``()`` and provides *Automatic Constant Conversion*.\n    Note that `BvFunction` only accepts `Constant` operands and\n    always return a tuple, as opposed to `Operation` that accepts\n    `Term` and scalar operands and returns a single `Term`.\n\n        >>> from arxpy.primitives.primitives import BvFunction\n        >>> from arxpy.primitives.chaskey import ChaskeyPi\n        >>> issubclass(ChaskeyPi, BvFunction)\n        True\n        >>> ChaskeyPi(0, 0, 0, 0)  # automatic conversion from int to Constant\n        (0x00000000, 0x00000000, 0x00000000, 0x00000000)\n\n    Attributes:\n        input_widths: a list containing the widths of the inputs\n        output_widths: a list containing the widths of the outputs\n        rounds: the number of iterations\n\n    \"\"\"\n    input_widths = None\n    output_widths = None\n    rounds = None\n\n    def __new__(cls, *args, **options):\n        if len(cls.input_widths) != len(args):\n            raise ValueError(\"{} requires {} inputs but {} were given: {}\".format(\n                cls.__name__, len(cls.input_widths), len(args), args))\n        newargs = []\n        for arg, width in zip(args, cls.input_widths):\n            newargs.append(core.bitvectify(arg, width))\n        args = newargs\n\n        if all(isinstance(arg, core.Constant) for arg in args) or \\\n                options.pop(\"symbolic_inputs\", False):\n            result = cls.eval(*args)\n        else:\n            raise TypeError(\"expected bit-vector constant arguments\")\n\n        assert isinstance(result, collections.abc.Sequence)\n        assert len(cls.output_widths) == len(result)\n\n        output = []\n        for r, width in zip(result, cls.output_widths):\n            output.append(core.bitvectify(r, width))\n\n        return tuple(output)\n\n    @classmethod\n    def eval(cls, *args):\n        \"\"\"Evaluate the function (internal method).\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n\n    # noinspection PyArgumentList\n    @classmethod\n    def ssa(cls, input_names, id_prefix):\n        \"\"\"Return a static single assignment program representing the function.\n\n        Args:\n            input_names: the names  for the input variables\n            id_prefix: the prefix to denote the intermediate variables\n\n        Return:\n            : a dictionary with three keys\n\n            - *input_vars*: a list of `Variable` representing the inputs\n            - *output_vars*: a list of `Variable` representing the outputs\n            - *assignments*: an ordered sequence of pairs\n              (`Variable`, `Operation`) representing each assignment\n              of the SSA program.\n\n        ::\n\n                >>> from arxpy.primitives.chaskey import ChaskeyPi\n                >>> ChaskeyPi.set_rounds(1)\n                >>> ChaskeyPi.ssa([\"v0\", \"v1\", \"v2\", \"v3\"], \"x\")  # doctest: +NORMALIZE_WHITESPACE\n                {'input_vars': (v0, v1, v2, v3),\n                'output_vars': (x7, x12, x13, x9),\n                'assignments': ((x0, v0 + v1), (x1, v1 <<< 5), (x2, x0 ^ x1), (x3, x0 <<< 16), (x4, v2 + v3),\n                (x5, v3 <<< 8), (x6, x4 ^ x5), (x7, x3 + x6), (x8, x6 <<< 13), (x9, x7 ^ x8), (x10, x2 + x4),\n                (x11, x2 <<< 7), (x12, x10 ^ x11), (x13, x10 <<< 16))}\n\n        \"\"\"\n        input_vars = []\n        for name, width in zip(input_names, cls.input_widths):\n            input_vars.append(core.Variable(name, width))\n        input_vars = tuple(input_vars)\n\n        table = context.MemoizationTable(id_prefix=id_prefix)\n\n        with context.Memoization(table):\n            # noinspection PyArgumentList\n            output_vars = cls(*input_vars, symbolic_inputs=True)\n\n        ssa_dict = {\n            \"input_vars\": input_vars,\n            \"output_vars\": output_vars,\n            \"assignments\": tuple(table.items())\n        }\n\n        for var, expr in ssa_dict[\"assignments\"]:\n            for arg in expr.args:\n                if isinstance(arg, operation.Operation):\n                    raise ValueError(\"assignment {} <- {} was not decomposed\".format(var, expr))\n\n        to_delete = []\n        vars_needed = set()\n        for var in output_vars:\n            vars_needed.add(var)\n        for var, expr in reversed(ssa_dict[\"assignments\"]):\n            if var in vars_needed:\n                for arg in expr.atoms(core.Variable):\n                    vars_needed.add(arg)\n            else:\n                to_delete.append((var, expr))\n                # raise ValueError(\"assignment {} <- {} is redundant in \\n{}\".format(var, expr, ssa_dict))\n\n        if len(to_delete) > 0:\n            import warnings\n            warnings.warn(\"removing redundant assignments {} in \\n{}\".format(to_delete, ssa_dict))\n            ssa_dict[\"assignments\"] = list(ssa_dict[\"assignments\"])\n            for assignment in to_delete:\n                ssa_dict[\"assignments\"].remove(assignment)\n            ssa_dict[\"assignments\"] = tuple(ssa_dict[\"assignments\"])\n\n        return ssa_dict\narxpy/primitives/primitives.py\nclass KeySchedule(BvFunction):\n    \"\"\"Represent key schedule functions.\n\n    A key schedule function is a `BvFunction` that takes\n    the masterkey as input and returns the round keys.\n    See `BvFunction` for more information.\n    \"\"\"\narxpy/primitives/primitives.py\nclass Cipher(object):\n    \"\"\"Represent (iterated) block ciphers.\n\n    A (iterated) block cipher consists of `KeySchedule` function\n    that computes round keys from a master key and an `Encryption`\n    function that computes a ciphertext from a given plaintext\n    and the round keys.\n\n    Given a ``cipher``, it can be evaluated with the operator ``()``\n    by passing it as arguments the plaintext and the master key,\n    that is, ``cipher(plaintext, masterkey)`` returns the ciphertext.\n\n        >>> from arxpy.primitives.primitives import Cipher\n        >>> from arxpy.primitives import speck\n        >>> Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)\n        >>> issubclass(Speck32, Cipher)\n        True\n        >>> plaintext = [0, 0]\n        >>> masterkey = [0, 0, 0, 0]\n        >>> Speck32(plaintext, masterkey)\n        (0x2bb9, 0xc642)\n\n    Attributes:\n        key_schedule: the `KeySchedule` function of the cipher\n        encryption: the `Encryption` function of the cipher\n\n    \"\"\"\n    key_schedule = None\n    encryption = None\n    rounds = None\n\n    _minimum_rounds = 1  # for testing\n\n    def __new__(cls, plaintext, masterkey, **options):\n        assert isinstance(plaintext, collections.abc.Sequence)\n        assert isinstance(masterkey, collections.abc.Sequence)\n        assert cls.rounds >= cls._minimum_rounds\n\n        previous_round_keys = cls.encryption.round_keys\n\n        round_keys = cls.key_schedule(*masterkey, **options)\n        cls.encryption.round_keys = round_keys\n        result = cls.encryption(*plaintext, **options)\n\n        cls.encryption.round_keys = previous_round_keys\n\n        return result\n\n    @classmethod\n    def set_rounds(cls, new_rounds):\n        \"\"\"Change the number of rounds and adjust the input/output widths.\"\"\"\n        raise NotImplementedError(\"subclasses need to override this method\")\n", "answers": ["class Encryption1(Encryption):  # noqa: D101"], "pred": "  # 1\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8\n  # 8", "length": 5302, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "348e33db9dd7512c0d821c5d1fc6a5b74a412a1e9be012f7"}
{"prompt": "Please complete the code given below. \nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\nimport android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;Next line of code:\n", "input": "import android.app.Activity;\nimport android.graphics.BitmapFactory;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.SubMenu;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Toast;\nimport java.util.ArrayList;\nimport java.util.List;\nimport net.protyposis.android.spectaculum.SpectaculumView;\nimport net.protyposis.android.spectaculum.effects.Parameter;\nimport net.protyposis.android.spectaculum.effects.ImmersiveSensorNavigation;\nimport net.protyposis.android.spectaculum.effects.ContrastBrightnessAdjustmentEffect;\nimport net.protyposis.android.spectaculum.effects.EffectException;\nimport net.protyposis.android.spectaculum.effects.FlowAbsSubEffect;\nimport net.protyposis.android.spectaculum.effects.QrMarkerEffect;\nimport net.protyposis.android.spectaculum.effects.Effect;\nimport net.protyposis.android.spectaculum.effects.FlipEffect;\nimport net.protyposis.android.spectaculum.effects.FlowAbsEffect;\nimport net.protyposis.android.spectaculum.effects.KernelBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEdgeDetectEffect;\nimport net.protyposis.android.spectaculum.effects.KernelEmbossEffect;\nimport net.protyposis.android.spectaculum.effects.KernelGaussBlurEffect;\nimport net.protyposis.android.spectaculum.effects.KernelSharpenEffect;\nimport net.protyposis.android.spectaculum.effects.NoEffect;\nimport net.protyposis.android.spectaculum.effects.SimpleToonEffect;\nimport net.protyposis.android.spectaculum.effects.SobelEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveTouchNavigation;\nimport net.protyposis.android.spectaculum.effects.StackEffect;\nimport net.protyposis.android.spectaculum.effects.WatermarkEffect;\nimport net.protyposis.android.spectaculum.gles.GLUtils;\nimport net.protyposis.android.spectaculum.effects.ColorFilterEffect;\nimport net.protyposis.android.spectaculum.effects.ImmersiveEffect;\nimport net.protyposis.android.spectaculumdemo.testeffect.InterlaceEffect;\n/*\n * Copyright 2014 Mario Guggenberger <mg@protyposis.net>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage net.protyposis.android.spectaculumdemo;\n\n\n\n\n/**\n * Created by Mario on 18.07.2014.\n *\n * Helper class for easy effect handling in the various Spectaculum views in this demo.\n * Provides a list of effects for the actionbar and displays a parameter control panel for\n * selected effects with parameters that the demo user can player play with.\n */\npublic class EffectManager implements SpectaculumView.EffectEventListener, Effect.Listener {\n\n    private Activity mActivity;\n    private ViewGroup mParameterListView;\n    private EffectParameterListAdapter mParameterListAdapter;\n    private MenuItem mParameterToggleMenuItem;\n    private SpectaculumView mSpectaculumView;\n    private List<Effect> mEffects;\n    private Effect mSelectedEffect;\n    private ImmersiveSensorNavigation mImmersiveSensorNavigation;", "context": "Spectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/NoEffect.java\npublic class NoEffect extends ShaderEffect {\n\n    public NoEffect() {\n        super(\"None\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/StackEffect.java\npublic class StackEffect extends BaseEffect {\n\n    private List<Effect> mEffects;\n    private Framebuffer mFramebuffer;\n\n    public StackEffect(String name) {\n        super(name);\n        mEffects = new ArrayList<>();\n    }\n\n    public StackEffect(String name, Effect... effects) {\n        this(name);\n        addEffects(effects);\n    }\n\n    public StackEffect() {\n        this((String)null);\n    }\n\n    public StackEffect(Effect... effects) {\n        this(null, effects);\n    }\n\n    public void addEffects(Effect... effects) {\n        Collections.addAll(mEffects, effects);\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // Create an internal framebuffer which is required to apply a sequence of effects\n        mFramebuffer = new Framebuffer(width, height);\n\n        setEventBlocking(true);\n\n        // Initialize all effects\n        for (Effect e : mEffects) {\n            e.init(width, height);\n\n            // Add effect parameters\n            for(Parameter p : e.getParameters()) {\n                addParameter(p);\n            }\n        }\n\n        setEventBlocking(false);\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        Iterator<Effect> i = mEffects.iterator();\n\n        /*\n         * The first source texture must always be the passed in texture, the last output framebuffer\n         * must always be the passed in target framebuffer. In between, we need to switch source\n         * textures and target framebuffers between the passed in external framebuffer and the internal\n         * framebuffer, because we cannot read and write to the same framebuffer in one render pass.\n         * If the number of effects is even, we start by writing the internal framebuffer, else we\n         * start with the external framebuffer.\n         */\n        Framebuffer internalFB = mFramebuffer;\n        Framebuffer externalFB = target;\n        boolean useInternalFB = mEffects.size() % 2 == 0; // keeps track of which framebuffer to use as target\n\n        while(i.hasNext()) {\n            Effect e = i.next();\n\n            if(i.hasNext()) {\n                e.apply(source, useInternalFB ? internalFB : externalFB);\n                source = useInternalFB ? internalFB.getTexture() : externalFB.getTexture();\n                useInternalFB = !useInternalFB; // switch framebuffer flag\n            } else {\n                // Last effect; always write result to the target framebuffer\n                e.apply(source, target);\n            }\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveSensorNavigation.java\npublic class ImmersiveSensorNavigation implements SensorEventListener {\n\n    private static final String TAG = ImmersiveSensorNavigation.class.getSimpleName();\n\n    private Context mContext;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private SensorManager mSensorManager;\n    private Sensor mSensor;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n    private float[] mRemappedRotationMatrix = new float[16];\n    private float[] mInitialRotationMatrix = null;\n\n    /**\n     * Creates a sensor navigation instance for the immersive effect.\n     * @param context context providing the sensor manager\n     * @throws RuntimeException if no rotation sensor is available\n     */\n    public ImmersiveSensorNavigation(Context context) throws RuntimeException {\n        mContext = context;\n\n        // Get sensor\n        mSensorManager = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);\n        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);\n\n        if(mSensor == null) {\n            throw new RuntimeException(\"No rotation sensor available\");\n        }\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the sensor navigation on/off\n        mParameter = new BooleanParameter(\"SensorNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle sensor navigation on/off.\n     * @param effect the effect to attach sensor navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches sensor navigation from an effect.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates sensor input.\n     */\n    public void activate() {\n        mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_UI);\n        mActive = true;\n    }\n\n    /**\n     * Deactivates sensor input. Should be called when pausing a fragment or activity.\n     */\n    public void deactivate() {\n        mSensorManager.unregisterListener(this);\n        mInitialRotationMatrix = null; // reset matrix so it reinits on next activation\n        mActive = false;\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        if(mEffect != null && mActive) {\n            // TODO understand those sensor coordinate spaces\n            // TODO find out how the sensor rotation can be mapped to the sphere shader correctly\n            // TODO should we store the initial rotation value to set the zero rotation point to the current phone rotation?\n\n            // Get the rotation matrix from the sensor\n            SensorManager.getRotationMatrixFromVector(mRotationMatrix, event.values);\n\n            // When the first sensor data comes in, we set the initial rotation matrix as\n            // \"zero rotation point\" to be able to calculate the relative rotation from the initial\n            // device rotation, instead of the absolute rotation from true north.\n            // Later, we subtract the initial rotation from the rotation matrix to get the relative rotation\n            if(mInitialRotationMatrix == null) {\n                mInitialRotationMatrix = new float[16];\n                // Matrix subtraction works by multiplying the inverse (Mb - Ma == inv(Ma) * Mb),\n                // so we directly store the inverse\n                Matrix.invertM(mInitialRotationMatrix, 0, mRotationMatrix, 0);\n            }\n\n            // Remove initial rotation\n            Matrix.multiplyMM(mRotationMatrix, 0, mInitialRotationMatrix, 0, mRotationMatrix, 0);\n\n            // Some axes seem like they need to be exchanged\n            Matrix.invertM(mRemappedRotationMatrix, 0, mRotationMatrix, 0);\n            // FIXME this does not seem to remap axes at all!?\n            //SensorManager.remapCoordinateSystem(mRotationMatrix, SensorManager.AXIS_X, SensorManager.AXIS_Z, mRemappedRotationMatrix);\n\n            // Debug output\n            //float[] orientation = new float[3];\n            //SensorManager.getOrientation(mRemappedRotationMatrix, orientation);\n            //debugOutputOrientationInDegree(orientation);\n\n            // Update effect and thus the viewport too\n            mEffect.setRotationMatrix(mRemappedRotationMatrix);\n        }\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor sensor, int accuracy) {\n\n    }\n\n    private void debugOutputOrientationInDegree(float[] orientation) {\n        float azimuth = (float) Math.toDegrees(orientation[0]); // -z\n        float pitch = (float) Math.toDegrees(orientation[1]); // x\n        float roll = (float) Math.toDegrees(orientation[2]); // y\n        Log.d(TAG, azimuth + \", \" + pitch + \", \" + roll);\n    }\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsSubEffect.java\npublic abstract class FlowAbsSubEffect extends BaseEffect {\n\n    protected FlowAbsEffect mFlowAbsEffect;\n\n    FlowAbsSubEffect(String name) {\n        super(name);\n    }\n\n    FlowAbsSubEffect() {\n    }\n\n    @Override\n    public void init(int width, int height) {\n        if(!mFlowAbsEffect.isInitialized()) {\n            mFlowAbsEffect.init(width, height);\n        }\n    }\n\n    FlowAbsSubEffect init(FlowAbsEffect flowAbsEffect) {\n        mFlowAbsEffect = flowAbsEffect;\n        return this;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SobelEffect.java\npublic class SobelEffect extends ShaderEffect {\n\n    private float mLow, mHigh;\n    private float mR, mG, mB;\n\n    public SobelEffect() {\n        super(\"Sobel Edge Detect\");\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureSobelShaderProgram sobelShader = new TextureSobelShaderProgram();\n\n        mLow = 0.3f;\n        mHigh = 0.8f;\n        mR = 0.0f;\n        mG = 1.0f;\n        mB = 0.0f;\n\n        addParameter(new FloatParameter(\"Low\", 0.0f, 1.0f, mLow, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mLow = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"High\", 0.0f, 1.0f, mHigh, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mHigh = value;\n                sobelShader.setThreshold(mLow, mHigh);\n            }\n        }));\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                sobelShader.setColor(mR, mG, mB);\n            }\n        }));\n\n        return sobelShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/gles/GLUtils.java\npublic class GLUtils {\n\n    private static final String TAG = GLUtils.class.getSimpleName();\n\n    public static boolean HAS_GLES30;\n    public static boolean HAS_GL_OES_texture_half_float;\n    public static boolean HAS_GL_OES_texture_float;\n    public static boolean HAS_FLOAT_FRAMEBUFFER_SUPPORT;\n    public static boolean HAS_GPU_TEGRA;\n\n    /**\n     * Sets the static feature flags. Needs to be called from a GLES context.\n     */\n    public static void init() {\n        HAS_GLES30 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;\n        HAS_GL_OES_texture_half_float = checkExtension(\"GL_OES_texture_half_float\");\n        HAS_GL_OES_texture_float = checkExtension(\"GL_OES_texture_float\");\n        HAS_GPU_TEGRA = GLES20.glGetString(GLES20.GL_RENDERER).toLowerCase().contains(\"tegra\");\n\n        /* Try to create a framebuffer with an attached floating point texture. If this fails,\n         * the device does not support floating point FB attachments and needs to fall back to\n         * byte textures ... and possibly deactivate features that demand FP textures.\n         */\n        if(HAS_GL_OES_texture_half_float || HAS_GL_OES_texture_float) {\n            try {\n                // must be set to true before the check, otherwise the fallback kicks in\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = true;\n                new Framebuffer(8, 8);\n            } catch (RuntimeException e) {\n                Log.w(TAG, \"float framebuffer test failed\");\n                HAS_FLOAT_FRAMEBUFFER_SUPPORT = false;\n                GLUtils.clearError();\n            }\n        }\n    }\n\n    /**\n     * Checks if the system supports OpenGL ES 2.0.\n     */\n    public static boolean isGlEs2Supported(Context context) {\n        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);\n        ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();\n        return configurationInfo != null && configurationInfo.reqGlEsVersion >= 0x20000;\n    }\n\n    private static void checkError(String operation, boolean throwException) {\n        int errorCount = 0;\n        int error;\n        String msg = null;\n\n        while((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n            msg = \"GL ERROR \" + String.format(\"0x%X\", error) + \" @ \" + operation;\n            Log.e(TAG, msg);\n            errorCount++;\n        }\n\n        if(throwException && errorCount > 0) {\n            throw new RuntimeException(msg);\n        }\n    }\n\n    public static void checkError(String operation) {\n        checkError(operation, true);\n    }\n\n    public static void clearError() {\n        checkError(\"error clearance\", false);\n    }\n\n    public static String[] getExtensions() {\n        String extensionsString = GLES20.glGetString(GLES20.GL_EXTENSIONS);\n        if(extensionsString != null) {\n            return extensionsString.split(\" \");\n        }\n        return new String[0];\n    }\n\n    /**\n     * Checks if an extension is supported.\n     */\n    public static boolean checkExtension(String query) {\n        for(String ext : getExtensions()) {\n            if(ext.equals(query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void printSysConfig() {\n        for(String ext : GLUtils.getExtensions()) {\n            Log.d(TAG, ext);\n        }\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_SHADING_LANGUAGE_VERSION));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VENDOR));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_RENDERER));\n        Log.d(TAG, GLES20.glGetString(GLES20.GL_VERSION));\n    }\n\n    public static Bitmap getFrameBuffer(int width, int height) {\n        // read pixels from GLES context\n        long startTime = SystemClock.elapsedRealtime();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(width * height * 4).order(ByteOrder.LITTLE_ENDIAN);\n        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buffer);\n        GLUtils.checkError(\"glReadPixels\");\n        buffer.rewind();\n        Log.d(TAG, \"glReadPixels \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        // transfer pixels to bitmap\n        Bitmap bmp1 = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        bmp1.copyPixelsFromBuffer(buffer);\n\n        // horizontally flip bitmap to make it upright, since GL origin is at bottom left\n        android.graphics.Matrix matrix = new android.graphics.Matrix();\n        matrix.setRotate(180);\n        matrix.postScale(-1, 1);\n        Bitmap bmp2 = Bitmap.createBitmap(bmp1, 0, 0, bmp1.getWidth(), bmp1.getHeight(), matrix, true);\n        bmp1.recycle();\n        Log.d(TAG, \"glReadPixels+rotate \" + (SystemClock.elapsedRealtime() - startTime) + \"ms\");\n\n        return bmp2;\n    }\n\n    public static boolean saveBitmapToFile(Bitmap bmp, File file) {\n        try {\n            BufferedOutputStream bos = null;\n            try {\n                bos = new BufferedOutputStream(new FileOutputStream(file));\n\n                // compress to file\n                bmp.compress(Bitmap.CompressFormat.PNG, 90, bos);\n            } finally {\n                if (bos != null) bos.close();\n            }\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"failed to save frame\", e);\n        }\n        return false;\n    }\n\n    public static void saveFramebufferToFile(int width, int height, File file) {\n        Bitmap bmp = getFrameBuffer(width, height);\n        if(saveBitmapToFile(bmp, file)) {\n            Log.d(TAG, \"frame saved to \" + file.getName());\n        }\n        bmp.recycle();\n    }\n\n    public static class Matrix {\n        /**\n         * Android's {@link android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)}\n         * is broken and returns an invalid matrix when rotating around the Y axis.\n         *\n         * See comment #3 in https://code.google.com/p/android/issues/detail?id=12964 for fix\n         * @see android.opengl.Matrix#setRotateEulerM(float[], int, float, float, float)\n         */\n        public static void setRotateEulerM(float[] rm, int rmOffset, float x, float y, float z) {\n            x = x * 0.01745329f;\n            y = y * 0.01745329f;\n            z = z * 0.01745329f;\n            float sx = (float) Math.sin(x);\n            float sy = (float) Math.sin(y);\n            float sz = (float) Math.sin(z);\n            float cx = (float) Math.cos(x);\n            float cy = (float) Math.cos(y);\n            float cz = (float) Math.cos(z);\n            float cxsy = cx * sy;\n            float sxsy = sx * sy;\n\n            rm[rmOffset + 0] = cy * cz;\n            rm[rmOffset + 1] = -cy * sz;\n            rm[rmOffset + 2] = sy;\n            rm[rmOffset + 3] = 0.0f;\n\n            rm[rmOffset + 4] = sxsy * cz + cx * sz;\n            rm[rmOffset + 5] = -sxsy * sz + cx * cz;\n            rm[rmOffset + 6] = -sx * cy;\n            rm[rmOffset + 7] = 0.0f;\n\n            rm[rmOffset + 8] = -cxsy * cz + sx * sz;\n            rm[rmOffset + 9] = cxsy * sz + sx * cz;\n            rm[rmOffset + 10] = cx * cy;\n            rm[rmOffset + 11] = 0.0f;\n\n            rm[rmOffset + 12] = 0.0f;\n            rm[rmOffset + 13] = 0.0f;\n            rm[rmOffset + 14] = 0.0f;\n            rm[rmOffset + 15] = 1.0f;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveEffect.java\npublic class ImmersiveEffect extends ShaderEffect {\n\n    /**\n     * Image source render mode.\n     */\n    public enum Mode {\n        /**\n         * Monoscopic rendering of mono sources.\n         */\n        MONO,\n\n        /**\n         * Stereoscopic rendering of side-by-side (SBS) sources, where two pictures are packed\n         * horizontally in the image source.\n         */\n        STEREO_SBS,\n\n        /**\n         * Stereoscopic rendering of top-and-bottom (TAB) sources, where two pictures are packed\n         * vertically in the image source.\n         */\n        STEREO_TAB,\n    }\n\n    private EquirectangularSphereShaderProgram mShaderProgram;\n    private float mRotX, mRotY, mRotZ;\n    private float[] mRotationMatrix = new float[16];\n    private Mode mMode;\n\n    private FloatParameter mParameterRotX, mParameterRotY, mParameterRotZ;\n    private EnumParameter<Mode> mParameterMode;\n\n    public ImmersiveEffect() {\n        mRotX = 0.0f;\n        mRotY = 0.0f;\n        mRotZ = 0.0f;\n        Matrix.setIdentityM(mRotationMatrix, 0);\n        mMode = Mode.MONO;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new EquirectangularSphereShaderProgram();\n\n        mParameterRotX = new FloatParameter(\"RotX\", -360.0f, 360.0f, mRotX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotX = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the X-axis in degrees\");\n        mParameterRotY = new FloatParameter(\"RotY\", -360.0f, 360.0f, mRotY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotY = -value; // invert to rotate to the right with a positive value\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Y-axis in degrees\");\n        mParameterRotZ = new FloatParameter(\"RotZ\", -360.0f, 360.0f, mRotZ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mRotZ = value;\n                updateRotationMatrix();\n            }\n        }, \"Sets the rotation angle around the Z-axis in degrees\");\n        mParameterMode = new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                mShaderProgram.setMode(mMode.ordinal());\n            }\n        }, \"Sets the render mode\");\n\n        addParameter(mParameterRotX);\n        addParameter(mParameterRotY);\n        addParameter(mParameterRotZ);\n        addParameter(mParameterMode);\n\n        return mShaderProgram;\n    }\n\n    private void updateRotationMatrix() {\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, mRotX, mRotY, mRotZ);\n        mShaderProgram.setRotationMatrix(mRotationMatrix);\n    }\n\n    /**\n     * Sets the rotation matrix directly without going through the 3 parameters and provoking\n     * lots of function calls (rotation matrix can be updated very frequently).\n     * @param R a 4x4 rotation matrix\n     */\n    public void setRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Take a copy of the matrix into the local variable\n        System.arraycopy(R, 0, mRotationMatrix, 0, 16);\n\n        if(isInitialized()) {\n            // Update the shader rotation matrix on the correct thread\n            getParameterHandler().post(mRotationMatrixUpdateRunnable);\n\n            // Fire event to trigger a view update\n            fireEffectChanged();\n        }\n    }\n\n    /**\n     * Gets the rotation matrix. The rotation matrix will be written into the supplied\n     * parameter.\n     * @param R a 4x4 output matrix\n     */\n    public void getRotationMatrix(float[] R) {\n        if(R.length < 16) {\n            throw new RuntimeException(\"4x4 matrix expected\");\n        }\n\n        // Copy the local matrix into the output matrix\n        System.arraycopy(mRotationMatrix, 0, R, 0, 16);\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotX rotation in degrees\n     */\n    public void setRotationX(float rotX) {\n        if(isInitialized()) {\n            mParameterRotX.setValue(rotX);\n        } else {\n            mRotX = rotX;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Y-axis.\n     * @param rotY rotation in degrees\n     */\n    public void setRotationY(float rotY) {\n        if(isInitialized()) {\n            mParameterRotY.setValue(rotY);\n        } else {\n            mRotX = rotY;\n        }\n    }\n\n    /**\n     * Sets the rotation along the Z-axis.\n     * @param rotZ rotation in degrees\n     */\n    public void setRotationZ(float rotZ) {\n        if(isInitialized()) {\n            mParameterRotZ.setValue(rotZ);\n        } else {\n            mRotX = rotZ;\n        }\n    }\n\n    /**\n     * Sets the content render mode. Should be set to match the image source.\n     * @param mode the image source render mode\n     */\n    public void setMode(Mode mode) {\n        if(isInitialized()) {\n            mParameterMode.setValue(mode);\n        } else {\n            mMode = mode;\n        }\n    }\n\n    private Runnable mRotationMatrixUpdateRunnable = new Runnable() {\n        @Override\n        public void run() {\n            mShaderProgram.setRotationMatrix(mRotationMatrix);\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/SimpleToonEffect.java\npublic class SimpleToonEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureToonShaderProgram();\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ContrastBrightnessAdjustmentEffect.java\npublic class ContrastBrightnessAdjustmentEffect extends ShaderEffect {\n\n    private float mContrast;\n    private float mBrightness;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ContrastBrightnessAdjustmentShaderProgram adjustmentsShader = new ContrastBrightnessAdjustmentShaderProgram();\n\n        mContrast = 1.0f;\n        mBrightness = 1.0f;\n\n        addParameter(new FloatParameter(\"Contrast\", 0.0f, 5.0f, mContrast, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mContrast = value;\n                adjustmentsShader.setContrast(mContrast);\n            }\n        }));\n        addParameter(new FloatParameter(\"Brightness\", 0.0f, 5.0f, mBrightness, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBrightness = value;\n                adjustmentsShader.setBrightness(mBrightness);\n            }\n        }));\n\n        return adjustmentsShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/WatermarkEffect.java\npublic class WatermarkEffect extends ShaderEffect {\n\n    public enum Alignment {\n        LOWER_LEFT,\n        UPPER_LEFT,\n        UPPER_RIGHT,\n        LOWER_RIGHT,\n        CENTER\n    }\n\n    private WatermarkShaderProgram mShaderProgram;\n    private float mScale;\n    private float mOpacity;\n    private float mMarginX, mMarginY;\n    private Alignment mAlignment;\n\n    private Bitmap mWatermarkBitmap;\n    private Texture2D mWatermarkTexture;\n\n    private FloatParameter mScaleParameter;\n    private FloatParameter mOpacityParameter;\n    private FloatParameter mMarginXParameter;\n    private FloatParameter mMarginYParameter;\n    private EnumParameter<Alignment> mAlignmentParameter;\n\n    public WatermarkEffect() {\n        mScale = 1.0f;\n        mOpacity = 0.8f;\n        mMarginX = mMarginY = 0.5f;\n        mAlignment = Alignment.LOWER_RIGHT;\n    }\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        mShaderProgram = new WatermarkShaderProgram();\n\n        mScaleParameter = new FloatParameter(\"Scale\", 0f, 10f, mScale, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkScale(value);\n            }\n        });\n        addParameter(mScaleParameter);\n\n        mOpacityParameter = new FloatParameter(\"Opacity\", 0f, 1f, mOpacity, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mShaderProgram.setWatermarkOpacity(value);\n            }\n        });\n        addParameter(mOpacityParameter);\n\n        mMarginXParameter = new FloatParameter(\"Margin X\", -1f, 1f, mMarginX, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginX = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginXParameter);\n\n        mMarginYParameter = new FloatParameter(\"Margin Y\", -1f, 1f, mMarginY, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mMarginY = value;\n                mShaderProgram.setWatermarkMargin(mMarginX, mMarginY);\n            }\n        });\n        addParameter(mMarginYParameter);\n\n        mAlignmentParameter = new EnumParameter<>(\"Alignment\", Alignment.class, mAlignment, new EnumParameter.Delegate<Alignment>() {\n            @Override\n            public void setValue(Alignment value) {\n                mAlignment = value;\n                mShaderProgram.setWatermarkAlignment(mAlignment.ordinal());\n            }\n        });\n        addParameter(mAlignmentParameter);\n\n        if(mWatermarkBitmap != null) {\n            mWatermarkTexture = new Texture2D(mWatermarkBitmap);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n\n        return mShaderProgram;\n    }\n\n    public void setWatermark(Bitmap watermark) {\n        // TODO clear previous texture\n        mWatermarkBitmap = watermark;\n        if(isInitialized()) {\n            mWatermarkTexture = new Texture2D(watermark);\n            mShaderProgram.setWatermark(mWatermarkTexture);\n        }\n    }\n\n    public void setScale(float scale) {\n        if(isInitialized()) {\n            mScaleParameter.setValue(scale);\n        } else {\n            mScale = scale;\n        }\n    }\n\n    public void setOpacity(float opacity) {\n        if(isInitialized()) {\n            mOpacityParameter.setValue(opacity);\n        } else {\n            mOpacity = opacity;\n        }\n    }\n\n    public void setMargin(float x, float y) {\n        if(isInitialized()) {\n            mMarginXParameter.setValue(x);\n            mMarginYParameter.setValue(y);\n        } else {\n            mMarginX = x;\n            mMarginY = y;\n        }\n    }\n\n    public void setAlignment(Alignment alignment) {\n        if(isInitialized()) {\n            mAlignmentParameter.setValue(alignment);\n        } else {\n            mAlignment = alignment;\n        }\n    }\n}\nSpectaculum-Effect-Immersive/src/main/java/net/protyposis/android/spectaculum/effects/ImmersiveTouchNavigation.java\npublic class ImmersiveTouchNavigation {\n\n    private static final String TAG = ImmersiveTouchNavigation.class.getSimpleName();\n\n    private SpectaculumView mSpectaculumView;\n    private boolean mSpectaculumViewTouchEnabled;\n    private GestureDetector mGestureDetector;\n    private float mPanX;\n    private float mPanY;\n    private ImmersiveEffect mEffect;\n    private BooleanParameter mParameter;\n    private boolean mActive;\n    private float[] mRotationMatrix = new float[16];\n\n    /**\n     * Creates a touch navigation instance for the supplied view widget.\n     * @param spectaculumView the view widget where the touch gestures should be read from\n     */\n    public ImmersiveTouchNavigation(SpectaculumView spectaculumView) {\n        mSpectaculumView = spectaculumView;\n\n        mGestureDetector = new GestureDetector(mSpectaculumView.getContext(), mOnGestureListener);\n\n        // Make a UI handler for activation state toggling\n        final Handler h = new Handler();\n\n        // Create an effect parameter to toggle the touch navigation on/off\n        mParameter = new BooleanParameter(\"TouchNav\", false, new BooleanParameter.Delegate() {\n            @Override\n            public void setValue(final Boolean value) {\n                // Activate/deactivate on UI thread\n                // Parameters are usually set on the GL thread, so we need to transfer this back to the UI thread\n                h.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mActive = value;\n                        if(mActive) {\n                            activate();\n                        } else {\n                            deactivate();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Attaches to the effect and adds parameter to toggle touch navigation on/off.\n     * @param effect the effect to attach touch navigation to\n     * @throws RuntimeException thrown if there is already an effect attached\n     */\n    public void attachTo(ImmersiveEffect effect) throws RuntimeException {\n        if(mEffect != null) {\n            throw new RuntimeException(\"Previous effect is still attached, call detach() first\");\n        }\n        mEffect = effect;\n        mEffect.addParameter(mParameter);\n    }\n\n    /**\n     * Detaches touch navigation from the effect it is attached to and removes the toggle parameter.\n     */\n    public void detach() {\n        mEffect.removeParameter(mParameter);\n        mEffect = null;\n    }\n\n    /**\n     * Activates touch navigation.\n     */\n    public void activate() {\n        mSpectaculumView.setOnTouchListener(mOnTouchListener);\n\n        // Store touch enabled state and enable touch which is required for this to work\n        mSpectaculumViewTouchEnabled = mSpectaculumView.isTouchEnabled();\n        mSpectaculumView.setTouchEnabled(true);\n\n        mActive = true;\n    }\n\n    /**\n     * Deactivates touch navigation.\n     */\n    public void deactivate() {\n        mSpectaculumView.setOnTouchListener(null);\n        mSpectaculumView.setTouchEnabled(mSpectaculumViewTouchEnabled);\n        mActive = false;\n    }\n\n    private void setRotation(float x, float y) {\n        // Set rotation matrix\n        GLUtils.Matrix.setRotateEulerM(mRotationMatrix, 0, x, y, 0);\n\n        // Update effect and thus the viewport too\n        mEffect.setRotationMatrix(mRotationMatrix);\n    }\n\n    private View.OnTouchListener mOnTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View v, MotionEvent event) {\n            return mActive && mGestureDetector.onTouchEvent(event);\n        }\n    };\n\n    private GestureDetector.SimpleOnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() {\n\n        @Override\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n            // Scale the scroll/panning distance to rotation degrees\n            // The view's with and height are mapped to 180 degree each\n            // TODO map motion event positions from view to the rendered sphere and derive rotation\n            //      angles to keep touchscreen positions and sphere positions in sync\n            mPanX += distanceX / mSpectaculumView.getWidth() * 180f;\n            mPanY += distanceY / mSpectaculumView.getHeight() * 180f;\n\n            // Clamp horizontal rotation to avoid rotations beyond 90 degree which inverts the vertical\n            // rotation and makes rotation handling more complicated\n            mPanY = LibraryHelper.clamp(mPanY, -90, 90);\n\n            // Apply the panning to the viewport\n            // Horizontal panning along the view's X axis translates to a rotation around the viewport's Y axis\n            // Vertical panning along the view's Y axis translates to a rotation around the viewport's X axis\n            setRotation(-mPanY, -mPanX);\n            return true;\n        }\n\n        @Override\n        public boolean onDoubleTap(MotionEvent e) {\n            // Reset rotation/viewport to initial value\n            mPanX = 0;\n            mPanY = 0;\n            setRotation(0, 0);\n            return true;\n        }\n    };\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/SpectaculumView.java\npublic class SpectaculumView extends GLSurfaceView implements\n        SurfaceTexture.OnFrameAvailableListener,\n        Effect.Listener, GLRenderer.EffectEventListener,\n        GLRenderer.OnFrameCapturedCallback {\n\n    private static final String TAG = SpectaculumView.class.getSimpleName();\n\n    public interface EffectEventListener extends GLRenderer.EffectEventListener {}\n    public interface OnFrameCapturedCallback extends GLRenderer.OnFrameCapturedCallback {}\n\n    private GLRenderer mRenderer;\n    private InputSurfaceHolder mInputSurfaceHolder;\n    private Handler mRunOnUiThreadHandler = new Handler();\n    private ScaleGestureDetector mScaleGestureDetector;\n    private GestureDetector mGestureDetector;\n\n    private EffectEventListener mEffectEventListener;\n    private OnFrameCapturedCallback mOnFrameCapturedCallback;\n\n    private PipelineResolution mPipelineResolution = PipelineResolution.SOURCE;\n\n    private float mZoomLevel = 1.0f;\n    private float mZoomSnappingRange = 0.02f;\n    private float mPanX;\n    private float mPanY;\n    private float mPanSnappingRange = 0.02f;\n    private boolean mTouchEnabled = false;\n\n    protected int mImageWidth;\n    protected int mImageHeight;\n\n    public SpectaculumView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public SpectaculumView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    private void init(Context context) {\n        if(isInEditMode()) {\n            // do not start renderer in layout editor\n            return;\n        }\n        if(!net.protyposis.android.spectaculum.gles.GLUtils.isGlEs2Supported(context)) {\n            Log.e(TAG, \"GLES 2.0 is not supported\");\n            return;\n        }\n\n        LibraryHelper.setContext(context);\n\n        mRenderer = new GLRenderer();\n        mRenderer.setOnExternalSurfaceTextureCreatedListener(mExternalSurfaceTextureCreatedListener);\n        mRenderer.setEffectEventListener(mRendererEffectEventListener);\n\n        mInputSurfaceHolder = new InputSurfaceHolder();\n\n        setEGLContextClientVersion(2);\n        setRenderer(mRenderer);\n        setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n        // TODO setPreserveEGLContextOnPause(true);\n\n        mScaleGestureDetector = new ScaleGestureDetector(context,\n                new ScaleGestureDetector.SimpleOnScaleGestureListener() {\n                    @Override\n                    public boolean onScale(ScaleGestureDetector detector) {\n                        mZoomLevel *= detector.getScaleFactor();\n\n                        if(LibraryHelper.isBetween(mZoomLevel, 1-mZoomSnappingRange, 1+mZoomSnappingRange)) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        // limit zooming to magnification zooms (zoom-ins)\n                        if(mZoomLevel < 1.0f) {\n                            mZoomLevel = 1.0f;\n                        }\n\n                        setZoom(mZoomLevel);\n                        return true;\n                    }\n                });\n\n        mGestureDetector = new GestureDetector(context,\n                new GestureDetector.SimpleOnGestureListener() {\n                    @Override\n                    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\n                        // divide by zoom level to adjust panning speed to zoomed picture size\n                        // multiply by fixed scaling factor to compensate for panning lag\n                        mPanX += distanceX / getWidth() / mZoomLevel * 1.2f;\n                        mPanY += distanceY / getHeight() / mZoomLevel * 1.2f;\n\n                        float panSnappingRange = mPanSnappingRange / mZoomLevel;\n                        if(LibraryHelper.isBetween(mPanX, -panSnappingRange, +panSnappingRange)) {\n                            mPanX = 0;\n                        }\n                        if(LibraryHelper.isBetween(mPanY, -panSnappingRange, +panSnappingRange)) {\n                            mPanY = 0;\n                        }\n\n                        // limit panning to the texture bounds so it always covers the complete view\n                        float maxPanX = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        float maxPanY = Math.abs((1.0f / mZoomLevel) - 1.0f);\n                        mPanX = LibraryHelper.clamp(mPanX, -maxPanX, maxPanX);\n                        mPanY = LibraryHelper.clamp(mPanY, -maxPanY, maxPanY);\n\n                        setPan(mPanX, mPanY);\n                        return true;\n                    }\n\n                    @Override\n                    public boolean onDoubleTap(MotionEvent e) {\n                        mZoomLevel = 1;\n                        mPanX = 0;\n                        mPanY = 0;\n\n                        setZoom(mZoomLevel);\n                        setPan(mPanX, mPanY);\n\n                        return true;\n                    }\n                });\n    }\n\n    /**\n     * Sets the zoom factor of the texture in the view. 1.0 means no zoom, 2.0 2x zoom, etc.\n     */\n    public void setZoom(float zoomFactor) {\n        mZoomLevel = zoomFactor;\n        mRenderer.setZoomLevel(mZoomLevel);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the zoom level.\n     * @see #setZ(float) for an explanation if the value\n     * @return\n     */\n    public float getZoomLevel() {\n        return mZoomLevel;\n    }\n\n    /**\n     * Sets the panning of the texture in the view. (0.0, 0.0) centers the texture and means no\n     * panning, (-1.0, -1.0) moves the texture to the lower right quarter.\n     */\n    public void setPan(float x, float y) {\n        mPanX = x;\n        mPanY = y;\n        mRenderer.setPan(-mPanX, mPanY);\n        requestRender(GLRenderer.RenderRequest.GEOMETRY);\n    }\n\n    /**\n     * Gets the horizontal panning. Zero means centered, positive is to the left.\n     */\n    public float getPanX() {\n        return mPanX;\n    }\n\n    /**\n     * Gets the vertical panning. Zero means centered, positive is to the bottom.\n     */\n    public float getPanY() {\n        return mPanY;\n    }\n\n    /**\n     * Enables or disables touch zoom/pan gestures. When disabled, a parent container (e.g. an activity)\n     * can still pass touch events to this view's {@link #onTouchEvent(MotionEvent)} to process\n     * zoom/pan gestures.\n     * @see #isTouchEnabled()\n     */\n    public void setTouchEnabled(boolean enabled) {\n        mTouchEnabled = enabled;\n    }\n\n    /**\n     * Checks if touch gestures are enabled. Touch gestures are disabled by default.\n     * @see #setTouchEnabled(boolean)\n     */\n    public boolean isTouchEnabled() {\n        return mTouchEnabled;\n    }\n\n    /**\n     * Resizes the video view according to the video size to keep aspect ratio.\n     * Code copied from {@link android.widget.VideoView#onMeasure(int, int)}.\n     */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        Log.i(\"@@@@\", \"onMeasure(\" + MeasureSpec.toString(widthMeasureSpec) + \", \"\n                + MeasureSpec.toString(heightMeasureSpec) + \")\");\n\n        int width = getDefaultSize(mImageWidth, widthMeasureSpec);\n        int height = getDefaultSize(mImageHeight, heightMeasureSpec);\n        if (mImageWidth > 0 && mImageHeight > 0) {\n\n            int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);\n            int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);\n            int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);\n            int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);\n\n            if (widthSpecMode == MeasureSpec.EXACTLY && heightSpecMode == MeasureSpec.EXACTLY) {\n                // the size is fixed\n                width = widthSpecSize;\n                height = heightSpecSize;\n\n                // for compatibility, we adjust size based on aspect ratio\n                if ( mImageWidth * height  < width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too wide, correcting\");\n                    width = height * mImageWidth / mImageHeight;\n                } else if ( mImageWidth * height  > width * mImageHeight) {\n                    //Log.i(\"@@@\", \"image too tall, correcting\");\n                    height = width * mImageHeight / mImageWidth;\n                }\n            } else if (widthSpecMode == MeasureSpec.EXACTLY) {\n                // only the width is fixed, adjust the height to match aspect ratio if possible\n                width = widthSpecSize;\n                height = width * mImageHeight / mImageWidth;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    height = heightSpecSize;\n                }\n            } else if (heightSpecMode == MeasureSpec.EXACTLY) {\n                // only the height is fixed, adjust the width to match aspect ratio if possible\n                height = heightSpecSize;\n                width = height * mImageWidth / mImageHeight;\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // couldn't match aspect ratio within the constraints\n                    width = widthSpecSize;\n                }\n            } else {\n                // neither the width nor the height are fixed, try to use actual video size\n                width = mImageWidth;\n                height = mImageHeight;\n                if (heightSpecMode == MeasureSpec.AT_MOST && height > heightSpecSize) {\n                    // too tall, decrease both width and height\n                    height = heightSpecSize;\n                    width = height * mImageWidth / mImageHeight;\n                }\n                if (widthSpecMode == MeasureSpec.AT_MOST && width > widthSpecSize) {\n                    // too wide, decrease both width and height\n                    width = widthSpecSize;\n                    height = width * mImageHeight / mImageWidth;\n                }\n            }\n        } else {\n            // no size yet, just adopt the given spec sizes\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        /*\n         * NOTE: These calls should not be simplified to a logical chain, because the evaluation\n         * would stop at the first true value and not execute the following functions.\n         */\n        boolean event1 = mScaleGestureDetector.onTouchEvent(event);\n        boolean event2 = mGestureDetector.onTouchEvent(event);\n        return event1 || event2;\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        if(!mTouchEnabled) {\n            // Touch events are disabled and we return false to route all events to the parent\n            return false;\n        }\n        return super.dispatchTouchEvent(event);\n    }\n\n    /**\n     * Implement this method to receive the input surface holder when it is ready to be used.\n     * The input surface holder holds the surface and surface texture to which input data, i.e. image\n     * data from some source that should be processed and displayed, should be written to display\n     * it in the view.\n     *\n     * External callers should add a callback to the holder through {@link InputSurfaceHolder#addCallback(InputSurfaceHolder.Callback)}\n     * to be notified about this event in {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)}.\n     *\n     * @param inputSurfaceHolder the input surface holder which holds the surface where image data should be written to\n     */\n    public void onInputSurfaceCreated(InputSurfaceHolder inputSurfaceHolder) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets the input surface holder that holds the surface where image data should be written to\n     * for processing and display. The holder is always available but only holds an actual surface\n     * after {@link #onInputSurfaceCreated(InputSurfaceHolder)} respectively\n     * {@link InputSurfaceHolder.Callback#surfaceCreated(InputSurfaceHolder)} have been called.\n     *\n     * The input surface holder holds the input surface (texture) that is used to write image data\n     * into the processing pipeline, opposed to the surface holder from {@link #getHolder()} that holds\n     * the surface to which the final result of the processing pipeline will be written to for display.\n     *\n     * @return the input surface holder or null if it is not available yet\n     */\n    public InputSurfaceHolder getInputHolder() {\n        return mInputSurfaceHolder;\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // Delete the external texture, else it stays in RAM\n        if(getInputHolder().getExternalSurfaceTexture() != null) {\n            getInputHolder().getExternalSurfaceTexture().delete();\n            getInputHolder().update(null);\n        }\n        super.surfaceDestroyed(holder);\n    }\n\n    /**\n     * Adds one or more effects to the view. Added effects can then be activated/selected by calling\n     * {@link #selectEffect(int)}. The effect indices start at zero and are in the order that they\n     * are added to the view.\n     * @param effects effects to add\n     */\n    public void addEffect(final Effect... effects) {\n        for(Effect effect : effects) {\n            effect.addListener(this);\n            effect.setParameterHandler(new ParameterHandler(this));\n        }\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.addEffect(effects);\n            }\n        });\n    }\n\n    /**\n     * Selects/activates the effect with the given index as it has been added through {@link #addEffect(Effect...)}.\n     * @param index the index of the effect to activate\n     */\n    public void selectEffect(final int index) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.selectEffect(index);\n                requestRender(GLRenderer.RenderRequest.EFFECT);\n            }\n        });\n    }\n\n    /**\n     * Gets called when an effect has been initialized after being selected for the first time\n     * with {@link #selectEffect(int)}. Effect initialization happens asynchronously and can take\n     * some time when a lot of data (framebuffers, textures, ...) is loaded.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the initialized effect\n     * @param effect the initialized effect\n     */\n    @Override\n    public void onEffectInitialized(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectInitialized(index, effect);\n        }\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when an effect has been successfully selected with {@link #selectEffect(int)}.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the selected effect\n     * @param effect the selected effect\n     */\n    @Override\n    public void onEffectSelected(int index, Effect effect) {\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectSelected(index, effect);\n        }\n    }\n\n    /**\n     * Gets called when an effect selection with {@link #selectEffect(int)} fails.\n     * Can be overwritten in subclasses but must be called through. External callers should use\n     * {@link #setEffectEventListener(EffectEventListener)}.\n     * @param index the index of the failed effect\n     * @param effect the failed effect\n     */\n    @Override\n    public void onEffectError(int index, Effect effect, EffectException e) {\n        Log.e(TAG, \"effect error\", e);\n        if(mEffectEventListener != null) {\n            mEffectEventListener.onEffectError(index, effect, e);\n        }\n    }\n\n    /**\n     * Sets an event listener that gets called when effect-related event happens.\n     * @param listener the event listener to be called on an event\n     */\n    public void setEffectEventListener(EffectEventListener listener) {\n        mEffectEventListener = listener;\n    }\n\n    /**\n     * Gets called when a parameter of an effect has changed. This method then triggers a fresh\n     * rendering of the effect. Can be overridden in subclasses but must be called through.\n     * @param effect the effect of which a parameter value has changed\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onEffectChanged(Effect effect) {\n        requestRender(GLRenderer.RenderRequest.EFFECT);\n    }\n\n    /**\n     * Gets called when a parameter is added to an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect to which a parameter was added\n     * @param parameter the added parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterAdded(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a parameter is removed from an effect.\n     * Can be overridden in subclasses but must be called through.\n     * @param effect the effect from which a parameter was removed\n     * @param parameter the removed parameter\n     * @see net.protyposis.android.spectaculum.effects.Effect.Listener\n     */\n    @Override\n    public void onParameterRemoved(Effect effect, Parameter parameter) {\n        // nothing to do here\n    }\n\n    /**\n     * Gets called when a new image frame has been written to the surface texture and requests a\n     * fresh rendering of the view. The texture can be obtained through {@link #onInputSurfaceCreated(InputSurfaceHolder)}\n     * or {@link #getInputHolder()}.\n     * Can be overridden in subclasses but must be called through.\n     * @param surfaceTexture the updated surface texture\n     */\n    @Override\n    public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n        requestRender(GLRenderer.RenderRequest.ALL);\n    }\n\n    /**\n     * Requests a render pass of the specified render pipeline section.\n     * @param renderRequest specifies the pipeline section to be rendered\n     */\n    protected void requestRender(final GLRenderer.RenderRequest renderRequest) {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.setRenderRequest(renderRequest);\n                requestRender();\n            }\n        });\n    }\n\n    /**\n     * Requests a capture of the current frame on the view. The frame is asynchronously requested\n     * from the renderer and will be passed back on the UI thread to {@link #onFrameCaptured(Bitmap)}\n     * and the event listener that can be set with {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    public void captureFrame() {\n        queueEvent(new Runnable() {\n            @Override\n            public void run() {\n                mRenderer.saveCurrentFrame(new GLRenderer.OnFrameCapturedCallback() {\n                    @Override\n                    public void onFrameCaptured(final Bitmap bitmap) {\n                        mRunOnUiThreadHandler.post(new Runnable() {\n                            @Override\n                            public void run() {\n                                SpectaculumView.this.onFrameCaptured(bitmap);\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Receives a captured frame from the renderer. Can be overwritten in subclasses but must be\n     * called through. External callers should use {@link #setOnFrameCapturedCallback(OnFrameCapturedCallback)}.\n     */\n    @Override\n    public void onFrameCaptured(Bitmap bitmap) {\n        if(mOnFrameCapturedCallback != null) {\n            mOnFrameCapturedCallback.onFrameCaptured(bitmap);\n        }\n    }\n\n    /**\n     * Sets a callback event handler that receives a bitmap of the captured frame.\n     */\n    public void setOnFrameCapturedCallback(OnFrameCapturedCallback callback) {\n        mOnFrameCapturedCallback = callback;\n    }\n\n    /**\n     * Sets the resolution mode of the processing pipeline.\n     * @see PipelineResolution\n     */\n    public void setPipelineResolution(PipelineResolution resolution) {\n        mPipelineResolution = resolution;\n    }\n\n    /**\n     * Gets the configured resolution mode of the processing pipeline.\n     */\n    public PipelineResolution getPipelineResolution() {\n        return mPipelineResolution;\n    }\n\n    /**\n     * Sets the resolution of the source data and recomputes the layout. This implicitly also sets\n     * the resolution of the view output surface if pipeline resolution mode {@link PipelineResolution#SOURCE}\n     * is set. In SOURCE mode, output will therefore be computed in the input resolution and then\n     * at the very end scaled (most often downscaled) to fit the view in the layout.\n     *\n     * TODO decouple input, processing and output resolution\n     *\n     * @param width the width of the input image data\n     * @param height the height of the input image data\n     */\n    public void updateResolution(int width, int height) {\n        if(width == mImageWidth && height == mImageHeight) {\n            // Don't do anything if resolution has stayed the same\n            return;\n        }\n\n        mImageWidth = width;\n        mImageHeight = height;\n\n        // If desired, set output resolution to source resolution\n        if (width != 0 && height != 0 && mPipelineResolution == PipelineResolution.SOURCE) {\n            getHolder().setFixedSize(width, height);\n        }\n\n        // Resize view according to the new size to fit the layout\n        requestLayout();\n    }\n\n    private GLRenderer.OnExternalSurfaceTextureCreatedListener mExternalSurfaceTextureCreatedListener =\n            new GLRenderer.OnExternalSurfaceTextureCreatedListener() {\n        @Override\n        public void onExternalSurfaceTextureCreated(final ExternalSurfaceTexture surfaceTexture) {\n            // dispatch event to UI thread\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    // Create an input surface holder and call the event handler\n                    mInputSurfaceHolder.update(surfaceTexture);\n                    onInputSurfaceCreated(mInputSurfaceHolder);\n                }\n            });\n\n            surfaceTexture.setOnFrameAvailableListener(SpectaculumView.this);\n        }\n    };\n\n    /**\n     * Effect event listener that transfers the events to the UI thread.\n     */\n    private EffectEventListener mRendererEffectEventListener = new EffectEventListener() {\n        @Override\n        public void onEffectInitialized(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectInitialized(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectSelected(final int index, final Effect effect) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectSelected(index, effect);\n                }\n            });\n        }\n\n        @Override\n        public void onEffectError(final int index, final Effect effect, final EffectException e) {\n            mRunOnUiThreadHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    SpectaculumView.this.onEffectError(index, effect, e);\n                }\n            });\n        }\n    };\n}\nSpectaculum-Effect-FlowAbs/src/main/java/net/protyposis/android/spectaculum/effects/FlowAbsEffect.java\npublic class FlowAbsEffect extends BaseEffect {\n\n    protected FlowAbs mFlowAbs;\n\n    private float mSstSigma;\n\n    private int mBfNE;\n    private int mBfNA;\n    private float mBfSigmaD;\n    private float mBfSigmaR;\n\n    private int mFDogType;\n    private int mFDogN;\n    private float mFDogSigmaE;\n    private float mFDogSigmaR;\n    private float mFDogSigmaM;\n    private float mFDogTau;\n    private float mFDogPhi;\n\n    private int mCqFilter;\n    private int mCqNumBins;\n    private float mCqPhiQ;\n\n    private float[] mEdgeColor;\n\n    private int mFsType;\n    private float mFsSigma;\n\n    public FlowAbsEffect() {\n        super();\n\n        mSstSigma = 2.0f;\n\n        mBfNE = 0; // TODO default to 1 once the bilateral filter is working correctly\n        mBfNA = 0; // TODO default to 4 once the bilateral filter is working correctly\n        mBfSigmaD = 3.0f;\n        mBfSigmaR = 4.25f;\n\n        mFDogType = 0;\n        mFDogN = 1;\n        mFDogSigmaE = 1.0f;\n        mFDogSigmaR = 1.6f;\n        mFDogSigmaM = 3.0f;\n        mFDogTau = 0.99f;\n        mFDogPhi = 2.0f;\n\n        mCqFilter = 1;\n        mCqNumBins = 8;\n        mCqPhiQ = 3.4f;\n\n        mEdgeColor = new float[] { 0.0f, 0.0f, 0.0f };\n\n        mFsType = 1;\n        mFsSigma = 1.0f;\n\n        addParameter(new FloatParameter(\"SST Sigma\", 0f, 10f, mSstSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mSstSigma = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"BF N E\", 0, 10, mBfNE, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNE = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"BF N A\", 0, 10, mBfNA, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mBfNA = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaD\", 0f, 10f, mBfSigmaD, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaD = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"BF sigmaR\", 0f, 10f, mBfSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mBfSigmaR = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"(F)DOG Type\", 0, 1, mFDogType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogType = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"(F)DOG N\", 0, 10, mFDogN, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFDogN = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaE\", 0f, 10f, mFDogSigmaE, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaE = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG sigmaR\", 0f, 10f, mFDogSigmaR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaR = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FDOG sigmaM\", 0f, 10f, mFDogSigmaM, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogSigmaM = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG tau\", 0f, 10f, mFDogTau, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogTau = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"(F)DOG phi\", 0f, 10f, mFDogPhi, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFDogPhi = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"CQ Filter\", 0, 2, mCqFilter, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqFilter = value;\n            }\n        }));\n        addParameter(new IntegerParameter(\"CQ Bins\", 0, 20, mCqNumBins, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mCqNumBins = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"CQ phiQ\", 0f, 10f, mCqPhiQ, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mCqPhiQ = value;\n            }\n        }));\n\n        addParameter(new FloatParameter(\"Edge R\", 0f, 1f, mEdgeColor[0], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[0] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge G\", 0f, 1f, mEdgeColor[1], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[1] = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"Edge B\", 0f, 1f, mEdgeColor[2], new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mEdgeColor[2] = value;\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"FS Type\", 0, 3, mFsType, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                mFsType = value;\n            }\n        }));\n        addParameter(new FloatParameter(\"FS Sigma\", 0f, 10f, mFsSigma, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mFsSigma = value;\n            }\n        }));\n    }\n\n    @Override\n    public void init(int width, int height) {\n        mFlowAbs = new FlowAbs(width, height);\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        mFlowAbs.flowAbs(source, target,\n                mSstSigma,\n                mBfNE, mBfNA, mBfSigmaD, mBfSigmaR,\n                mFDogType, mFDogN, mFDogSigmaE, mFDogSigmaR, mFDogSigmaM, mFDogTau, mFDogPhi,\n                mCqFilter, mCqNumBins, mCqPhiQ,\n                mEdgeColor,\n                mFsType, mFsSigma);\n    }\n\n    public FlowAbsGaussEffect getGaussEffect() {\n        return (FlowAbsGaussEffect) new FlowAbsGaussEffect().init(this);\n    }\n\n    public FlowAbsSmoothEffect getSmoothEffect() {\n        return (FlowAbsSmoothEffect) new FlowAbsSmoothEffect().init(this);\n    }\n\n    public FlowAbsBilateralFilterEffect getBilateralFilterEffect() {\n        return (FlowAbsBilateralFilterEffect) new FlowAbsBilateralFilterEffect().init(this);\n    }\n\n    public FlowAbsColorQuantizationEffect getColorQuantizationEffect() {\n        return (FlowAbsColorQuantizationEffect) new FlowAbsColorQuantizationEffect().init(this);\n    }\n\n    public FlowAbsDOGEffect getDOGEffect() {\n        return (FlowAbsDOGEffect) new FlowAbsDOGEffect().init(this);\n    }\n\n    public FlowAbsFDOGEffect getFDOGEffect() {\n        return (FlowAbsFDOGEffect) new FlowAbsFDOGEffect().init(this);\n    }\n\n    public FlowAbsTangentFlowMapEffect getTangentFlowMapEffect() {\n        return (FlowAbsTangentFlowMapEffect) new FlowAbsTangentFlowMapEffect().init(this);\n    }\n\n    public FlowAbsNoiseTextureEffect getNoiseTextureEffect() {\n        return (FlowAbsNoiseTextureEffect) new FlowAbsNoiseTextureEffect().init(this);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Effect.java\npublic interface Effect {\n\n    /**\n     * Callback interface for effect events.\n     */\n    interface Listener {\n        /**\n         * Gets called when a parameter of the effect has changed.\n         * @param effect the effect whose parameter has changed\n         */\n        void onEffectChanged(Effect effect);\n\n        /**\n         * Gets called when a parameter is added to an effect.\n         * @param effect the effect to which the parameter was added\n         * @param parameter the added parameter\n         */\n        void onParameterAdded(Effect effect, Parameter parameter);\n\n        /**\n         * Gets called when a parameter is removed from an effect.\n         * @param effect the effect from which the parameter was removed\n         * @param parameter the removed parameter\n         */\n        void onParameterRemoved(Effect effect, Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the effect.\n     * @return the name of the effect\n     */\n    String getName();\n\n    /**\n     * Initializes the effect by loading all required resources (shaders, framebuffers, textures,\n     * subeffects, ...) and preparing it for usage. The resolution of the render pipeline respectively\n     * the texture resolution for internal processing must be supplied.\n     * @param width the texture width\n     * @param height the texture height\n     */\n    void init(int width, int height);\n\n    /**\n     * Returns the initialization status of the effect.\n     * @return true if the effect is initialized and ready to use, else false\n     */\n    boolean isInitialized();\n\n    /**\n     * Applies the effect to a source texture and writes it to the target framebuffer. The source\n     * texture is the input image data that the effect is applied to, and the target can be an\n     * intermediate framebuffer (for chaining to another effect) or the screen for direct output.\n     * @param source the source texture where the input image is read from\n     * @param target the target framebuffer where the result with the applied effect is written to\n     */\n    void apply(Texture2D source, Framebuffer target);\n\n    /**\n     * Sets a parameter handler for the parameters of this effect. The parameter handler takes\n     * care that the parameter values are set on the correct thread (i.e. the GL thread).\n     * Setting the handler on the effect makes sure that it is automatically set on its parameters.\n     * @see Parameter#setHandler(ParameterHandler)\n     * @param handler a handler to set, or null to unset\n     */\n    void setParameterHandler(ParameterHandler handler);\n\n    /**\n     * Adds a parameter to the effect. Parameters can be used to parameterize parameters of the effect :)\n     * Triggers {@link Listener#onParameterAdded(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to add\n     */\n    void addParameter(Parameter parameter);\n\n    /**\n     * Removes a parameter from the effect.\n     * Triggers {@link Listener#onParameterRemoved(Effect, Parameter)} on an attached listener.\n     * @see Parameter\n     * @param parameter the parameter to remove\n     */\n    void removeParameter(Parameter parameter);\n\n    /**\n     * Gets a list of available parameters of the effect.\n     * @return list of effect parameters\n     */\n    List<Parameter> getParameters();\n\n    /**\n     * Checks if this effect has any parameters.\n     * @return true if there are parameters attached, else false\n     */\n    boolean hasParameters();\n\n    /**\n     * Resets all settings and parameters to their initial state.\n     */\n    void reset();\n\n    /**\n     * Sets a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds a listener that gets called when any parameter value of the effect has changed.\n     * @see Listener#onEffectChanged(Effect)\n     * @param listener the listener to call back\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes a listener that has been added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEmbossEffect.java\npublic class KernelEmbossEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EMBOSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelEdgeDetectEffect.java\npublic class KernelEdgeDetectEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.EDGE_DETECT);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/EffectException.java\npublic class EffectException extends Exception {\n    public EffectException() {\n    }\n\n    public EffectException(String detailMessage) {\n        super(detailMessage);\n    }\n\n    public EffectException(String detailMessage, Throwable throwable) {\n        super(detailMessage, throwable);\n    }\n\n    public EffectException(Throwable throwable) {\n        super(throwable);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelBlurEffect.java\npublic class KernelBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/Parameter.java\npublic interface Parameter<T> {\n\n    interface Delegate<T> {\n        void setValue(T value);\n    }\n\n    /**\n     * Callback interface for parameter events.\n     */\n    interface Listener {\n        /**\n         * Gets called when the value of a parameter has changed.\n         * @param parameter the parameter whose value has changed\n         */\n        void onParameterChanged(Parameter parameter);\n    }\n\n    /**\n     * Gets the name of the parameter.\n     */\n    String getName();\n\n    /**\n     * Gets the description of the parameter. Returns null if no description has been set.\n     */\n    String getDescription();\n\n    /**\n     * Resets the parameter to its default value.\n     */\n    void reset();\n\n    /**\n     * Sets an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     * @deprecated Will be removed in next major version, use {@link #addListener} instead\n     */\n    void setListener(Listener listener);\n\n    /**\n     * Adds an event listener to listen for parameter value change events.\n     * @see Listener#onParameterChanged(Parameter)\n     * @param listener the listener to notify of events\n     */\n    void addListener(Listener listener);\n\n    /**\n     * Removes an event listener added with {@link #addListener}.\n     * @param listener the listener to remove\n     */\n    void removeListener(Listener listener);\n\n    /**\n     * Sets a ParameterHandler on which parameter value changes will be executed. Parameter values\n     * need to be set on the GL thread where the effect that the parameter belongs is active, and\n     * this handler can be used to hand the parameter setting over to the GL thread.\n     * If no handler is set, parameters will be set on the caller thread.\n     * @param handler the parameter handler to set, or null to unset\n     */\n    void setHandler(ParameterHandler handler);\n}\nSpectaculum-Effect-QrMarker/src/main/java/net/protyposis/android/spectaculum/effects/QrMarkerEffect.java\npublic class QrMarkerEffect extends BaseEffect {\n\n    private GaussShaderProgram mGaussShader;\n    private GradientShaderProgram mGradientShader;\n    private CannyShaderProgram mCannyShader;\n    private QrResponseShaderProgram mQrResponseShader;\n    private ConsenseShaderProgram mConsensusShader;\n\n    private Framebuffer mFramebuffer1;\n    private Framebuffer mFramebuffer2;\n\n    private TexturedRectangle mTexturedRectangle;\n\n    private CannyEdgeEffect mCannyEdgeEffect;\n\n    public QrMarkerEffect() {\n        mCannyEdgeEffect = new CannyEdgeEffect();\n    }\n\n    @Override\n    public void init(int width, int height) {\n        // PART OF THE UGLY HACK described in setTextureSizeHack\n        // Cannot call it on base class QrMarkerShaderProgram because it is hidden outside its package\n        GaussShaderProgram.setTextureSizeHack(width, height);\n\n        mGaussShader = new GaussShaderProgram();\n        mGaussShader.setTextureSize(width, height);\n\n        mGradientShader = new GradientShaderProgram();\n        mGradientShader.setTextureSize(width, height);\n\n        mCannyShader = new CannyShaderProgram();\n        mCannyShader.setTextureSize(width, height);\n\n        mQrResponseShader = new QrResponseShaderProgram();\n        mQrResponseShader.setTextureSize(width, height);\n\n        mConsensusShader = new ConsenseShaderProgram();\n        mConsensusShader.setTextureSize(width, height);\n\n        mFramebuffer1 = new Framebuffer(width, height);\n        mFramebuffer2 = new Framebuffer(width, height);\n\n        mTexturedRectangle = new TexturedRectangle();\n        mTexturedRectangle.reset();\n\n        setInitialized();\n    }\n\n    @Override\n    public void apply(Texture2D source, Framebuffer target) {\n        applyCannyEdge(source, mFramebuffer1);\n\n        mFramebuffer2.bind();\n        mQrResponseShader.use();\n        mQrResponseShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mQrResponseShader);\n\n        target.bind();\n        mConsensusShader.use();\n        mConsensusShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mConsensusShader);\n    }\n\n    private void applyCannyEdge(Texture2D source, Framebuffer target) {\n        mFramebuffer1.bind();\n        mGaussShader.use();\n        mGaussShader.setTexture(source);\n        mTexturedRectangle.draw(mGaussShader);\n\n        mFramebuffer2.bind();\n        mGradientShader.use();\n        mGradientShader.setTexture(mFramebuffer1.getTexture());\n        mTexturedRectangle.draw(mGradientShader);\n\n        target.bind();\n        mCannyShader.use();\n        mCannyShader.setTexture(mFramebuffer2.getTexture());\n        mTexturedRectangle.draw(mCannyShader);\n    }\n\n    public CannyEdgeEffect getCannyEdgeEffect() {\n        return mCannyEdgeEffect;\n    }\n\n    /**\n     * The CannyEdge Effect is a subeffect of the QrMarker Effect, it is therefore more efficient\n     * to share the resources and reuse a common cannyedge subroutine than to instantiate it as\n     * a separate effect. If one of the two effects is needed, the other comes with it for free.\n     */\n    public class CannyEdgeEffect extends BaseEffect {\n\n        @Override\n        public void init(int width, int height) {\n            if(!QrMarkerEffect.this.isInitialized()) {\n                QrMarkerEffect.this.init(width, height);\n            }\n        }\n\n        @Override\n        public void apply(Texture2D source, Framebuffer target) {\n            applyCannyEdge(source, target);\n        }\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelGaussBlurEffect.java\npublic class KernelGaussBlurEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.BLUR_GAUSS);\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/FlipEffect.java\npublic class FlipEffect extends ShaderEffect {\n\n    public enum Mode {\n        NONE,\n        VERTICAL,\n        HORIZONTAL,\n        BOTH\n    }\n\n    private Mode mMode;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final TextureFlipShaderProgram flipShader = new TextureFlipShaderProgram();\n        mMode = Mode.VERTICAL;\n\n        addParameter(new EnumParameter<>(\"Mode\", Mode.class, mMode, new EnumParameter.Delegate<Mode>() {\n            @Override\n            public void setValue(Mode value) {\n                mMode = value;\n                flipShader.setMode(mMode.ordinal());\n            }\n        }));\n\n        return flipShader;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/KernelSharpenEffect.java\npublic class KernelSharpenEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        return new TextureKernelShaderProgram(TextureKernelShaderProgram.Kernel.SHARPEN);\n    }\n}\nSpectaculum-Demo/src/main/java/net/protyposis/android/spectaculumdemo/testeffect/InterlaceEffect.java\npublic class InterlaceEffect extends ShaderEffect {\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final InterlaceShaderProgram shaderProgram = new InterlaceShaderProgram();\n\n        addParameter(new FloatParameter(\"Opacity\", 0f, 1f, 0.5f, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                shaderProgram.setOpacity(value);\n            }\n        }));\n\n        addParameter(new IntegerParameter(\"Distance\", 1, 10, 5, new IntegerParameter.Delegate() {\n            @Override\n            public void setValue(Integer value) {\n                shaderProgram.setDistance(value);\n            }\n        }));\n\n        return shaderProgram;\n    }\n}\nSpectaculum-Core/src/main/java/net/protyposis/android/spectaculum/effects/ColorFilterEffect.java\npublic class ColorFilterEffect extends ShaderEffect {\n\n    private float mR, mG, mB, mA;\n\n    @Override\n    protected TextureShaderProgram initShaderProgram() {\n        final ColorFilterShaderProgram colorFilterShader = new ColorFilterShaderProgram();\n\n        mR = 1.0f;\n        mG = 0.0f;\n        mB = 0.0f;\n        mA = 1.0f;\n\n        addParameter(new FloatParameter(\"Red\", 0.0f, 1.0f, mR, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mR = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Green\", 0.0f, 1.0f, mG, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mG = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Blue\", 0.0f, 1.0f, mB, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mB = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n        addParameter(new FloatParameter(\"Alpha\", 0.0f, 1.0f, mA, new FloatParameter.Delegate() {\n            @Override\n            public void setValue(Float value) {\n                mA = value;\n                colorFilterShader.setColor(mR, mG, mB, mA);\n            }\n        }));\n\n        return colorFilterShader;\n    }\n}\n", "answers": ["    private ImmersiveTouchNavigation mImmersiveTouchNavigation;"], "pred": "  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m", "length": 8166, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "cf3d37ae2215d5f5123fcc3ad041ba23b56d19a3abad67e6"}
{"prompt": "Please complete the code given below. \nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusCommand.java\n@JsonTypeName(\"SetStatus\")\npublic final class SetStatusCommand extends Command {\n    private final Status status;\n\n    public SetStatusCommand(Status status) {\n        super();\n        this.status = status;\n    }\n\n    @JsonCreator\n    private SetStatusCommand(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\") Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetUpdateFrequencyCommand.java\n@JsonTypeName(\"SetUpdateFrequency\")\npublic final class SetUpdateFrequencyCommand extends Command {\n    private final int updateFrequency;\n\n    public SetUpdateFrequencyCommand(int updateFrequency) {\n        super();\n        this.updateFrequency = updateFrequency;\n    }\n\n    @JsonCreator\n    private SetUpdateFrequencyCommand(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusMessageCommand.java\n@JsonTypeName(\"SetStatusMessage\")\npublic class SetStatusMessageCommand extends Command {\n    private final String message;\n\n    public SetStatusMessageCommand(String message) {\n        super();\n        this.message = message;\n    }\n\n    public SetStatusMessageCommand(Instant time, String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @JsonCreator\n    private SetStatusMessageCommand(@JsonProperty(\"commandId\") String commandId,\n                                    @JsonProperty(\"time\") Instant time,\n                                    @JsonProperty(\"message\") String message) {\n        super(commandId, time);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusReporter.java\npublic final class StatusReporter {\n    private static final Logger LOG = LogManager.getLogger(StatusReporter.class);\n    \n    private final Jedis jedis;\n    private final String statusChannel;\n\n    /**\n     * Create a new status reporter for the given Redis URI and status channel.\n     *\n     * @param redisURI\n     *        The URI for the Redis instance to report the status on. This should\n     *        be the \"own\" Redis instance.\n     * @param statusChannel\n     *        The channel to broadcast the status messages to. This channel is\n     *        made specific to the database, so if the `redisUri`\n     *        contains database `N`, and the channel is `status`,\n     *        then messages will be broadcast on channel `status:N`.\n     * @see org.ulyssis.ipp.utils.JedisHelper#dbLocalChannel(String, java.net.URI)\n     */\n    public StatusReporter(URI redisURI, String statusChannel) {\n        this.jedis = JedisHelper.get(redisURI);\n        this.statusChannel = JedisHelper.dbLocalChannel(statusChannel, redisURI);\n    }\n\n    /**\n     * Broadcast a status message.\n     *\n     * @param message\n     *        The message to broadcast\n     * @return True if the broadcast was successful, false if the broadcast was unsuccessful.\n     *         Failure to broadcast will be logged.\n     */\n    public synchronized boolean broadcast(StatusMessage message) {\n        if (jedis == null)\n            return false;\n        try {\n            jedis.publish(statusChannel.getBytes(), Serialization.getJsonMapper().writeValueAsBytes(message));\n            return true;\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error processing message {}\", message.getDetails(), e);\n            return false;\n        } catch (JedisConnectionException e) {\n            LOG.error(\"Couldn't connect to Redis when sending: {}\", message.getDetails(), e);\n            return false;\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/handlers/PingHandler.java\npublic final class PingHandler implements CommandHandler {\n\n    /**\n     * Handles the given command, which should be a PingCommand.\n     *\n     * @param command\n     *        The ping command to handle.\n     * @param callback\n     *        The ping callback, which is always invoked with true.\n     */\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        callback.accept(true);\n    }\n\n    /**\n     * Returns PingCommand.class\n     *\n     * @return PingCommand.class\n     */\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return PingCommand.class;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/ReaderConfig.java\npublic class ReaderConfig {\n    private URI uri;\n    private Type type = Type.LLRP;\n    private double position;\n    private List<SimulatedTeam> simulatedTeams = new ArrayList<>();\n\n    public static class SimulatedTeam {\n        private final TagId tag;\n        private final long lapTime;\n\n        @JsonCreator\n        public SimulatedTeam(\n                @JsonProperty(\"tag\") TagId tag,\n                @JsonProperty(\"lapTime\") long lapTime) {\n            this.tag = tag;\n            this.lapTime = lapTime;\n        }\n\n        public TagId getTag() {\n            return tag;\n        }\n\n        public long getLapTime() {\n            return lapTime;\n        }\n    }\n\n    public enum Type {\n        LLRP,\n        SIMULATOR\n    }\n\n    /**\n     * Private constructor used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private ReaderConfig() {\n    }\n\n    public URI getURI() {\n        return uri;\n    }\n    \n    /**\n     * Private setter used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private void setURI(URI uri) {\n        this.uri = uri;\n    }\n\n    public double getPosition() {\n        return position;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setPosition(double position) {\n        this.position = position;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setType(Type type) {\n        this.type = type;\n    }\n\n    public List<SimulatedTeam> getSimulatedTeams() {\n        return Collections.unmodifiableList(simulatedTeams);\n    }\n\n    public SimulatedTeam getSimulatedTeam(int id) {\n        return simulatedTeams.get(id);\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSimulatedTeams(List<SimulatedTeam> simulatedTeams) {\n        this.simulatedTeams = simulatedTeams;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/RemoveTagCommand.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagCommand extends TagCommand {\n    public RemoveTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    public RemoveTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @JsonCreator\n    private RemoveTagCommand(@JsonProperty(\"commandId\") String commandId,\n                             @JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"tag\") TagId tag,\n                             @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StartEvent.java\n@JsonTypeName(\"Start\")\npublic final class StartEvent extends Event {\n    /**\n     * Private constructor for Jackson\n     */\n    private StartEvent() {\n        super(Instant.MIN);\n    }\n\n    public StartEvent(Instant time) {\n        super(time);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withStartTime(getTime()).build();\n    }\n\n    public static StartEvent fromCommand(Command command) {\n        assert(command instanceof SetStartTimeCommand);\n        SetStartTimeCommand cmd = (SetStartTimeCommand) command;\n        return new StartEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/JedisHelper.java\npublic final class JedisHelper {\n\n    // Static methods only! No instances!\n    private JedisHelper() {\n    }\n\n    /**\n     * Get a new Jedis instance from the given URI\n     *\n     * The URI is formed as such:\n     * `new URI(\"redis://:password@host:port/database\")`\n     * for example:\n     * `new URI(\"redis://:hunter2@10.0.0.1:6379/0\")}`.\n     * The port, password and path can be omitted. If no path is\n     * supplied, database +0+ is selected. If no user\n     * info is supplied, then no authorization is performed.\n     * If no port is supplied, the default port +6379+\n     * is used.\n     *\n     * Use this instead of `new Jedis(uri)`, because\n     * that method does not allow to omit anything.\n     *\n     * @param uri\n     *        The URI for the Jedis instance.\n     * @return A new Jedis instance.\n     */\n    // TODO: Exceptions for wrong password, failing to parse database,...\n    public static Jedis get(URI uri) throws IllegalArgumentException {\n        int port = uri.getPort() != -1 ? uri.getPort() : 6379;\n        String host = uri.getHost();\n        Jedis result = new Jedis(host, port);\n        if (uri.getUserInfo() != null) {\n            String password = uri.getUserInfo().split(\":\")[1];\n            result.auth(password);\n        }\n        result.select(getDb(uri));\n        return result;\n    }\n\n    /**\n     * Extract the database number from the given Redis URI\n     *\n     * If the URI has the path +/N+, then +N+\n     * is returned. If the path is empty, +0+ is returned.\n     *\n     * @param uri\n     *        The URI\n     * @throws java.lang.IllegalArgumentException\n     *         The supplied path could not be parsed as an int\n     * @return The database number (+0+ for no path, +N+\n     *         if the path is +/N+)\n     */\n    public static int getDb(URI uri) throws IllegalArgumentException {\n        if (!Objects.equals(uri.getPath(), \"\")) {\n            try {\n                return Integer.parseInt(uri.getPath().split(\"/\", 2)[1]);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"The supplied path could not be parsed as an int\", e);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Generates a channel name that is local to a database.\n     *\n     * Redis channels are not tied to a single database, but are\n     * global to the instance of Redis. We, however, want to tie\n     * these to a certain database, so we have to add some information\n     * that does that. For this reason, if the channel name is\n     * +channel+, the database number +N+ is added to it\n     * to form +channel:N+. The database number is extracted\n     * using `getDb(uri)`.\n     *\n     * @param channel\n     *        The base channel name\n     * @param uri\n     *        The URI containing the database info\n     * @return +channel:N+, where +N+ is the database number\n     * @see org.ulyssis.ipp.utils.JedisHelper#getDb(java.net.URI)\n     */\n    public static String dbLocalChannel(String channel, URI uri) {\n        return channel + \":\" + getDb(uri);\n    }\n\n    /**\n     * A helper class that implements +BinaryJedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class BinaryCallBackPubSub extends BinaryJedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(byte[] pattern, byte[] channel, byte[] message);\n        }\n\n        private final List<BiConsumer<byte[],byte[]>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(byte[] channel, byte[] message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onMessage(byte[], byte[])\n         */\n        public void addOnMessageListener(BiConsumer<byte[],byte[]> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPMessage(byte[], byte[], byte[])\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(byte[] channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onSubscribe(byte[], int)\n         */\n        public void addOnSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(byte[] channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onUnsubscribe(byte[], int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(byte[] pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPSubscribe(byte[], int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPUnsubscribe(byte[], int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * A helper class that implements +JedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class CallBackPubSub extends JedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(String pattern, String channel, String message);\n        }\n\n        private final List<BiConsumer<String,String>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(String channel, String message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onMessage(String, String)\n         */\n        public void addOnMessageListener(BiConsumer<String, String> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(String pattern, String channel, String message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPMessage(String, String, String)\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onSubscribe(String, int)\n         */\n        public void addOnSubscribeListener(BiConsumer<String, Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onUnsubscribe(String, int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(String pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPSubscribe(String, int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<String, Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(String pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPUnsubscribe(String, int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Snapshot.java\npublic final class Snapshot {\n    private static final Logger LOG = LogManager.getLogger(Snapshot.class);\n\n    public static class Builder {\n        private Snapshot snapshot;\n\n        private Builder(Instant time, Snapshot other) {\n            snapshot = new Snapshot(time);\n            if (other != null) {\n                snapshot.teamTagMap = other.teamTagMap;\n                snapshot.startTime = other.startTime;\n                snapshot.endTime = other.endTime;\n                snapshot.teamStates = other.teamStates;\n                snapshot.publicTeamStates = other.publicTeamStates;\n                snapshot.statusMessage = other.statusMessage;\n                snapshot.status = other.status;\n                snapshot.updateFrequency = other.updateFrequency;\n            }\n        }\n\n        public Builder withTeamTagMap(TeamTagMap teamTagMap) {\n            this.snapshot.teamTagMap = teamTagMap;\n            return this;\n        }\n\n        public Builder withStartTime(Instant time) {\n            this.snapshot.startTime = time;\n            return this;\n        }\n\n        public Builder withEndTime(Instant time) {\n            this.snapshot.endTime = time;\n            return this;\n        }\n\n        public Builder withTeamStates(TeamStates teamStates) {\n            this.snapshot.teamStates = teamStates;\n            return this;\n        }\n\n        public Builder withPublicTeamStates(TeamStates teamStates) {\n            this.snapshot.publicTeamStates = teamStates;\n            return this;\n        }\n\n        public Builder withStatusMessage(String message) {\n            this.snapshot.statusMessage = message;\n            return this;\n        }\n\n        public Builder withStatus(Status status) {\n            this.snapshot.status = status;\n            return this;\n        }\n\n        public Builder withUpdateFrequency(int updateFrequency) {\n            this.snapshot.updateFrequency = updateFrequency;\n            return this;\n        }\n\n        public Snapshot build() {\n            return snapshot;\n        }\n    }\n\n    @JsonIgnore\n    private long id = -1;\n\n    @JsonIgnore\n    long eventId = -1;\n\n    public Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    public Optional<Long> getEventId() {\n        if (eventId != -1) return Optional.of(eventId);\n        else return Optional.empty();\n    }\n\n    /**\n     * Default constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private Snapshot() {\n    }\n\n    public Snapshot(Instant time) {\n        snapshotTime = time;\n    }\n\n    public Instant getSnapshotTime() {\n        return snapshotTime;\n    }\n\n    public TeamTagMap getTeamTagMap() {\n        return teamTagMap;\n    }\n\n    public Instant getStartTime() {\n        return startTime;\n    }\n\n    public Instant getEndTime() {\n        return endTime;\n    }\n\n    public TeamStates getTeamStates() {\n        return teamStates;\n    }\n\n    public TeamStates getPublicTeamStates() {\n        return publicTeamStates;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    private Instant snapshotTime = Instant.MIN;\n    private Instant startTime = Instant.MAX;\n    private Instant endTime = Instant.MAX;\n    private TeamTagMap teamTagMap = new TeamTagMap();\n    private TeamStates teamStates;\n    private TeamStates publicTeamStates;\n    {\n        teamStates = new TeamStates();\n        publicTeamStates = teamStates;\n    }\n    private String statusMessage = \"\";\n    private Status status = Status.NoResults;\n    private int updateFrequency = 3;\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"snapshots\\\" WHERE \\\"event\\\" = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setLong(1, event.getId().get());\n            LOG.debug(\"executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = event.getId().get();\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadLatest(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" ORDER BY \\\"time\\\" DESC FETCH FIRST ROW ONLY\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(statement)) {\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" \" +\n                \"WHERE \\\"time\\\" < ? ORDER BY \\\"time\\\" DESC, \\\"event\\\" DESC FETCH FIRST ROW ONLY\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                \"INSERT INTO \\\"snapshots\\\" (\\\"time\\\",\\\"data\\\",\\\"event\\\") VALUES (?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(snapshotTime));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false; // TODO(Roel): Programming error\n                return;\n            }\n            statement.setString(2, serialized);\n            statement.setLong(3, eventId);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public static void deleteAfter(Connection connection, Snapshot snapshot) throws SQLException {\n        String statement =\n                \"DELETE FROM \\\"snapshots\\\" WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"event\\\" > ?)\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            Timestamp timestamp = Timestamp.from(snapshot.getSnapshotTime());\n            stmt.setTimestamp(1, timestamp);\n            stmt.setTimestamp(2, timestamp);\n            stmt.setLong(3, snapshot.getEventId().orElse(-1L));\n            LOG.debug(\"Executing query: {}\", stmt);\n            int affectedRows = stmt.executeUpdate();\n            LOG.debug(\"deleteAfter affected {} rows\", affectedRows);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/MessageEvent.java\n@JsonTypeName(\"Message\")\npublic final class MessageEvent extends Event {\n    private final String message;\n\n    @JsonCreator\n    public MessageEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"message\") String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withStatusMessage(message).build();\n    }\n\n    public static MessageEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusMessageCommand);\n        SetStatusMessageCommand cmd = (SetStatusMessageCommand) command;\n        return new MessageEvent(cmd.getTime(), cmd.getMessage());\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/CorrectionEvent.java\n@JsonTypeName(\"Correction\")\npublic final class CorrectionEvent extends Event {\n    private int teamNb;\n    private int correction;\n\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private CorrectionEvent() {\n        super(Instant.MIN);\n    }\n\n    /**\n     * Create an event representing a correction of score.\n     *\n     * @param time\n     *        The time at which the corection is performed.\n     * @param teamNb\n     *        The number of the team to correct the score of.\n     * @param correction\n     *        The number of laps that should be added (positive)\n     *        or removed (negative)\n     */\n    public CorrectionEvent(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getCorrection() {\n        return correction;\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamStates oldTeamStates = snapshot.getTeamStates();\n        Optional<TeamState> oldTeamState = oldTeamStates.getStateForTeam(teamNb);\n        TeamState newTeamState;\n        if (oldTeamState.isPresent()) {\n            newTeamState = oldTeamState.get().addCorrection(correction);\n        } else {\n            newTeamState = new TeamState().addCorrection(correction);\n        }\n        return Snapshot.builder(getTime(), snapshot)\n                .withTeamStates(snapshot.getTeamStates().setStateForTeam(teamNb, newTeamState))\n                .build();\n    }\n\n    public static CorrectionEvent fromCommand(Command command) {\n        assert(command instanceof CorrectionCommand);\n        CorrectionCommand cmd = (CorrectionCommand) command;\n        return new CorrectionEvent(cmd.getTime(), cmd.getTeamNb(), cmd.getCorrection());\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Event.java\n@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n@JsonSubTypes({ @JsonSubTypes.Type(value=StartEvent.class),\n                @JsonSubTypes.Type(value=EndEvent.class),\n                @JsonSubTypes.Type(value=AddTagEvent.class),\n                @JsonSubTypes.Type(value=RemoveTagEvent.class),\n                @JsonSubTypes.Type(value=CorrectionEvent.class),\n                @JsonSubTypes.Type(value=TagSeenEvent.class),\n                @JsonSubTypes.Type(value=IdentityEvent.class),\n                @JsonSubTypes.Type(value=MessageEvent.class),\n                @JsonSubTypes.Type(value=StatusChangeEvent.class)})\npublic abstract class Event {\n    private static final Logger LOG = LogManager.getLogger(Event.class);\n\n    @JsonIgnore\n    private long id = -1;\n    @JsonIgnore\n    private boolean removed = false;\n\n    private Instant time;\n\n    protected Event(Instant time) {\n        this.time = time;\n    }\n\n    @JsonIgnore\n    public final Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    @JsonIgnore\n    public final boolean isRemoved() {\n        if (id == -1) throw new IllegalStateException(\"Trying to request removed state of event not in db\");\n        return removed;\n    }\n\n    public final Instant getTime() {\n        return time;\n    }\n\n    /**\n     * Determines whether this event should be isUnique, defaults to false\n     *\n     * @return whether this event should be isUnique (default implementation = false)\n     */\n    @JsonIgnore\n    public boolean isUnique() {\n        return false;\n    }\n\n    /**\n     * Determines whether this event can be removed or undone.\n     *\n     * @return whether this event can be removed or undone (default implementation = isUnique())\n     */\n    @JsonIgnore\n    public boolean isRemovable() {\n        return isUnique();\n    }\n\n    /**\n     * Apply this event to a snapshot, yielding the new snapshot\n     */\n    protected abstract Snapshot doApply(Snapshot before);\n\n    public final Snapshot apply(Snapshot before) {\n        assert !removed;\n        Snapshot result = doApply(before);\n        if (result == before && before.getEventId().isPresent()) {\n            // We need to copy it anyway\n            result = Snapshot.builder(getTime(), before).build();\n        }\n        result.eventId = this.id;\n        return result;\n    }\n\n    // TODO: How to deal with deserialization problem?\n    public static List<Event> loadAll(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"removed\\\" FROM \\\"events\\\" ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet result = stmt.executeQuery(statement)) {\n            while (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = result.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static Optional<Event> loadUnique(Connection connection, Class<? extends Event> eventType) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"events\\\" WHERE \\\"type\\\" = ? AND \\\"removed\\\" = false\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setString(1, eventType.getSimpleName());\n            ResultSet result = stmt.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = false;\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Event> load(Connection connection, long id) throws SQLException, IOException {\n        try (PreparedStatement statement =\n                connection.prepareStatement(\n                        \"SELECT \\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" WHERE \\\"id\\\"=?\")) {\n            statement.setLong(1, id);\n            ResultSet result = statement.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = id;\n                event.removed = result.getBoolean(\"removed\");\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static List<Event> loadFrom(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" >= ? ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static List<Event> loadAfter(Connection connection, Instant time, long id) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"id\\\" > ?) ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            stmt.setTimestamp(2, Timestamp.from(time));\n            stmt.setLong(3, id);\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        LOG.debug(\"Loaded {} events\", events.size());\n        return events;\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                    \"INSERT INTO \\\"events\\\" (\\\"time\\\",\\\"type\\\",\\\"data\\\",\\\"removed\\\") \" +\n                            \"VALUES (?,?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(time));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false;\n                throw new IllegalStateException(e); // TODO(Roel): is this appropriate?\n            }\n            statement.setString(2, this.getClass().getSimpleName());\n            statement.setString(3, serialized);\n            statement.setBoolean(4, removed);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public void setRemoved(Connection connection, boolean removed) throws SQLException {\n        if (!isRemovable()) {\n            assert false; // This is a programming error\n            return;\n        }\n        PreparedStatement statement =\n                connection.prepareStatement(\n                        \"UPDATE \\\"events\\\" SET \\\"removed\\\"=? WHERE \\\"id\\\"=?\");\n        statement.setBoolean(1, removed);\n        statement.setLong(2, id);\n        boolean result = statement.execute();\n        assert(!result);\n        this.removed = true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/UpdateFrequencyChangeEvent.java\n@JsonTypeName(\"UpdateFrequencyChange\")\npublic final class UpdateFrequencyChangeEvent extends Event {\n    private final int updateFrequency;\n\n    @JsonCreator\n    public UpdateFrequencyChangeEvent(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withUpdateFrequency(updateFrequency).build();\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    public static UpdateFrequencyChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetUpdateFrequencyCommand);\n        SetUpdateFrequencyCommand cmd = (SetUpdateFrequencyCommand) command;\n        return new UpdateFrequencyChangeEvent(cmd.getTime(), cmd.getUpdateFrequency());\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/Serialization.java\npublic final class Serialization {\n    private static final ObjectMapper jsonMapper;\n\n    static {\n        jsonMapper = new ObjectMapper();\n        jsonMapper.findAndRegisterModules();\n    }\n\n    // Static methods only! No instances!\n    private Serialization() {\n    }\n\n    /**\n     * Get a JSON mapper, with all modules registered.\n     *\n     * This is equivalent to:\n     *\n     * [source,java]\n     * --\n     * jsonMapper = new ObjectMapper();\n     * jsonMapper.findAndRegisterModules();\n     * --\n     *\n     * @return A JSON ObjectMapper\n     */\n    public static ObjectMapper getJsonMapper() {\n        return jsonMapper;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Team.java\npublic final class Team {\n    private static final Logger LOG = LogManager.getLogger(Team.class);\n\n    private int teamNb;\n    private String name;\n    private ImmutableList<TagId> tags;\n\n    @SuppressWarnings(\"unused\")\n    private Team() {\n        this.teamNb = 0;\n        this.name = \"\";\n        tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name, ImmutableList<TagId> tags) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = tags;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public ImmutableList<TagId> getTags() {\n        return tags;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/EndEvent.java\n@JsonTypeName(\"End\")\npublic final class EndEvent extends Event {\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private EndEvent() {\n        super(Instant.MIN);\n    }\n\n    public EndEvent(Instant time) {\n        super(time);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withEndTime(getTime()).build();\n    }\n\n    public static EndEvent fromCommand(Command command) {\n        assert(command instanceof SetEndTimeCommand);\n        SetEndTimeCommand cmd = (SetEndTimeCommand) command;\n        return new EndEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/AddTagEvent.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagEvent extends TagEvent {\n    @JsonCreator\n    public AddTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().addTagToTeam(getTag(), getTeamNb());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static AddTagEvent fromCommand(Command command) {\n        assert(command instanceof AddTagCommand);\n        AddTagCommand addTagCommand = (AddTagCommand) command;\n        return new AddTagEvent(\n            addTagCommand.getTime(),\n            addTagCommand.getTag(),\n            addTagCommand.getTeamNb()\n        );\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/CommandProcessor.java\npublic final class CommandProcessor implements Runnable {\n    private static final Logger LOG = LogManager.getLogger(CommandProcessor.class);\n\n    private final Map<Class<? extends Command>, CommandHandler> commandHandlers = new HashMap<>();\n    private final Jedis jedis;\n    private final StatusReporter reporter;\n    private final String channel;\n\n    private BinaryJedisPubSub listener;\n\n    public CommandProcessor(URI redisUri, String commandChannel, String statusChannel) {\n        this(redisUri, JedisHelper.dbLocalChannel(commandChannel, redisUri),\n                new StatusReporter(redisUri, statusChannel));\n    }\n\n    public CommandProcessor(URI redisUri, String channel, StatusReporter statusReporter) {\n        this.jedis = JedisHelper.get(redisUri);\n        this.channel = JedisHelper.dbLocalChannel(channel, redisUri);\n        this.reporter = statusReporter;\n    }\n\n    public void run() {\n        jedis.subscribe(createCommandListener(), channel.getBytes());\n    }\n\n    private BinaryJedisPubSub createCommandListener() {\n        JedisHelper.BinaryCallBackPubSub pubSub = new JedisHelper.BinaryCallBackPubSub();\n        listener = pubSub;\n        pubSub.addOnMessageListener(this::onCommandMessage);\n        return pubSub;\n    }\n\n    private void onCommandMessage(byte[] channel, byte[] message) {\n        assert (Arrays.equals(channel, this.channel.getBytes()));\n        try {\n            Command command = Serialization.getJsonMapper().readValue(message, Command.class);\n            handleCommand(command);\n        } catch (IOException e) {\n            LOG.error(\"Couldn't parse command: {}\", new String(message), e);\n        }\n    }\n\n    public void addHandler(CommandHandler handler) {\n        commandHandlers.put(handler.getCommandClass(), handler);\n    }\n\n    private void handleCommand(Command command) {\n        LOG.debug(\"Handing command {}: {}\", command.getCommandId(), command.getClass().toString());\n        if (commandHandlers.containsKey(command.getClass())) {\n            commandHandlers.get(command.getClass()).handle(command, notifyCommandExecuted(command));\n        } else {\n            notifyCommandUnsupported(command);\n        }\n    }\n\n    private Consumer<Boolean> notifyCommandExecuted(Command command) {\n        return (result) -> {\n            if (result) {\n                notifySuccess(command);\n            } else {\n                notifyFailure(command);\n            }\n        };\n    }\n\n    private void notifySuccess(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_COMPLETE, command.getCommandId()));\n    }\n\n    private void notifyFailure(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_FAILED, command.getCommandId()));\n    }\n\n    private void notifyCommandUnsupported(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_UNSUPPORTED, command.getCommandId()));\n    }\n\n    public void stop() {\n        try {\n            listener.unsubscribe();\n        } catch (JedisConnectionException ignored) {\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusMessage.java\npublic final class StatusMessage {\n    private MessageType type;\n    private String details;\n\n    public enum MessageType {\n        /**\n         * The reader sends this message when no updates have been received for a while\n         */\n        NO_UPDATES,\n        /**\n         * Notifies that the system has started up\n         */\n        STARTED_UP,\n        /**\n         * Notifies that the startup has failed\n         */\n        STARTUP_FAILURE,\n        /**\n         * Notifies that the system is being shut down\n         */\n        SHUTDOWN,\n        /**\n         * Signals that the command given executed successfully.\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_COMPLETE,\n        /**\n         * Signals that no command handler is installed for the given command\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_UNSUPPORTED,\n        /**\n         * Signals that the command failed to execute\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_FAILED,\n        /**\n         * Signals that the processor's snapshot has been updated\n         */\n        NEW_SNAPSHOT,\n        /**\n         * Signals a miscellaneous error. The details field will contain more information\n         * about the error.\n         */\n        MISC_ERROR\n    }\n\n    /**\n     * Create a new status message with the given type and details.\n     *\n     * This message is to be broadcast by a StatusReporter to the\n     * status channel.\n     *\n     * @param type\n     *        The type of the status\n     * @param details\n     *        The details. The form of this field depends\n     *        on the type of message.\n     * @see org.ulyssis.ipp.status.StatusReporter\n     */\n    @JsonCreator\n    public StatusMessage(@JsonProperty(\"type\") MessageType type,\n                         @JsonProperty(\"details\") String details) {\n        this.type = type;\n        this.details = details;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/AddTagCommand.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagCommand extends TagCommand {\n\n    /**\n     * Create an AddTagCommand for the given tag and team number.\n     *\n     * The time is set to be the current time.\n     *\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    /**\n     * Create an AddTagCommand for the given tag and team number at the given time.\n     *\n     * @param time\n     *        The time when to add the tag, this can be in the future for\n     *        an anticipated adding of a tag, or in the past, to add a tag\n     *        afterwards (e.g. as a correction)\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    /*\n     * Only for deserialization.\n     */\n    @JsonCreator\n    private AddTagCommand(@JsonProperty(\"commandId\") String commandId,\n                          @JsonProperty(\"time\") Instant time,\n                          @JsonProperty(\"tag\") TagId tag,\n                          @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetEndTimeCommand.java\n@JsonTypeName(\"SetEndTime\")\npublic final class SetEndTimeCommand extends Command {\n    public SetEndTimeCommand() {\n        super();\n    }\n\n    public SetEndTimeCommand(Instant endTime) {\n        super(endTime);\n    }\n\n    @JsonCreator\n    private SetEndTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/RemoveTagEvent.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagEvent extends TagEvent {\n    @JsonCreator\n    public RemoveTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().removeTag(getTag());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static RemoveTagEvent fromCommand(Command command) {\n        assert(command instanceof RemoveTagCommand);\n        RemoveTagCommand cmd = (RemoveTagCommand) command;\n        return new RemoveTagEvent(cmd.getTime(), cmd.getTag(), cmd.getTeamNb());\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/control/handlers/EventCommandHandler.java\npublic final class EventCommandHandler<EventT extends Event> implements CommandHandler {\n    private final Class<? extends Command> clazz;\n    private final Function<Command, EventT> toEvent;\n    private final BiConsumer<Event, Consumer<Boolean>> processCallback;\n\n    public EventCommandHandler(Class<? extends Command> clazz,\n                               Function<Command, EventT> toEvent,\n                               BiConsumer<Event, Consumer<Boolean>> processCallback) {\n        this.clazz = clazz;\n        this.toEvent = toEvent;\n        this.processCallback = processCallback;\n    }\n\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        Event event = toEvent.apply(command);\n        processCallback.accept(event, callback);\n    }\n\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return clazz;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/CorrectionCommand.java\n@JsonTypeName(\"Correction\")\npublic class CorrectionCommand extends Command {\n    private final int teamNb;\n    private final int correction;\n\n    /**\n     * Create a CorrectionCommand\n     * @param teamNb\n     *        The team number to correct\n     * @param correction\n     *        The correction in nb. of laps. Positive adds laps,\n     *        negative removes laps.\n     */\n    public CorrectionCommand(int teamNb, int correction) {\n        super();\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public CorrectionCommand(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @JsonCreator\n    private CorrectionCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time,\n                              @JsonProperty(\"teamNb\") int teamNb,\n                              @JsonProperty(\"correction\") int correction) {\n        super(commandId, time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public int getCorrection() {\n        return correction;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/TagId.java\n@JsonSerialize(using=TagId.Serializer.class)\n@JsonDeserialize(using=TagId.Deserializer.class)\npublic final class TagId {\n    private final String id;\n    private final String lowerCaseId;\n    private final int hashCode;\n\n    static class Serializer extends JsonSerializer<TagId> {\n        @Override\n        public void serialize(TagId value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n            jgen.writeString(value.toString());\n        }\n    }\n\n    static class Deserializer extends JsonDeserializer<TagId> {\n        @Override\n        public TagId deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return new TagId(jp.getValueAsString());\n        }\n    }\n\n    /**\n     * = Create a new TagId from the given byte array.\n     *\n     * @param id\n     *        The tag id in byte array form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(byte[] id) {\n        this(BaseEncoding.base16().lowerCase().encode(id));\n    }\n\n    /**\n     * = Create a new TagId from the given byte list.\n     *\n     * @param id\n     *        The tag id in byte list form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(List<Byte> id) {\n        this(BaseEncoding.base16().lowerCase().encode(Bytes.toArray(id)));\n    }\n\n    /**\n     * = Create a new TagId\n     *\n     * @param id\n     *        A string that uniquely identifies the tag\n     * @throws java.lang.NullPointerException\n     *         A NullPointerException will be thrown if the given id is null.\n     */\n    public TagId(String id) throws NullPointerException {\n        if (id == null) throw new NullPointerException(\"The tag id is not allowed to be null!\");\n        this.id = id;\n        this.lowerCaseId = id.toLowerCase();\n        this.hashCode = this.lowerCaseId.hashCode();\n    }\n\n    /**\n     * = Get the tag id as a string\n     *\n     * @return This tag id as a string\n     */\n    @Override\n    public String toString() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (!(other instanceof TagId)) return false;\n        return this.lowerCaseId.equals(((TagId) other).lowerCaseId);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hashCode;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStartTimeCommand.java\n@JsonTypeName(\"SetStartTime\")\npublic final class SetStartTimeCommand extends Command {\n    public SetStartTimeCommand() {\n        super();\n    }\n\n    public SetStartTimeCommand(Instant startTime) {\n        super(startTime);\n    }\n\n    @JsonCreator\n    private SetStartTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                                @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Config.java\npublic class Config {\n    private static final Logger LOG = LogManager.getLogger(Config.class);\n\n    private double trackLength;\n    private ImmutableList<ReaderConfig> readers = ImmutableList.of();\n    private ImmutableList<URI> speedwayURIs = ImmutableList.of();\n    private ImmutableList<Team> teams = ImmutableList.of();\n    private long retryInterval = 5000L;\n    private long minUpdateInterval = 5000L;\n    private long maxUpdateInterval = 30000L;\n    private String statusChannel = \"status\";\n    private String updateChannel = \"update\";\n    private String updatesList = \"updates\";\n    private String updatesSet = \"updates\";\n    private String controlChannel = \"control\";\n\n    /**\n     * Private constructor used by Jackson\n     */\n    private Config() {\n    }\n    \n    /**\n     * Create a configuration from the given configuration file.\n     * \n     * Expects the configuration file to be UTF-8 formatted.\n     */\n    public static Optional<Config> fromConfigurationFile(Path configFile) {\n        try {\n            byte[] config = Files.readAllBytes(configFile);\n            Charset charset = Charset.forName(\"utf-8\");\n            String configString = charset.decode(ByteBuffer.wrap(config)).toString();\n            return fromConfigurationString(configString);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration file: {}\", configFile, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Create a configuration from the given JSON configuration string.\n     */\n    public static Optional<Config> fromConfigurationString(String configuration) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.findAndRegisterModules();\n        try {\n            Config result = mapper.readValue(configuration, Config.class);\n            return Optional.of(result);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration\", e);\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Get the track length in meters.\n     */\n    public double getTrackLength() {\n        return trackLength;\n    }\n\n    public ImmutableList<ReaderConfig> getReaders() {\n        return readers;\n    }\n    public ReaderConfig getReader(int readerId) {\n        return this.readers.get(readerId);\n    }\n    public int getNbReaders() {\n        return readers.size();\n    }\n\n    public ImmutableList<URI> getSpeedwayURIs() {\n        return speedwayURIs;\n    }\n    /**\n     * Get the URI of the Impinj Speedway corresponding\n     * to the reader with the given id. This id ranges from 0 to\n     * getSpeedwayURIs.size() - 1\n     */\n    public URI getSpeedwayURI(int readerId) {\n        return speedwayURIs.get(readerId);\n    }\n    public int getNbSpeedways() {\n        return speedwayURIs.size();\n    }\n\n    /**\n     * The retry interval for connections in ms.\n     */\n    public long getRetryInterval() {\n        return retryInterval;\n    }\n    \n    /**\n     * The minimum amount of time in ms between two updates, any\n     * update within this amount of time is ignored.\n     */\n    public long getMinUpdateInterval() {\n        return minUpdateInterval;\n    }\n    \n    /**\n     * The maximum time in ms to wait for an update before issuing a warning.\n     */\n    public long getMaxUpdateInterval() {\n        return maxUpdateInterval;\n    }\n    \n    /**\n     * Gets the Redis channel name on which status updates are posted.\n     *\n     * Defaults to \"status\".\n     *\n     * Generally, the db id will be added to the prefix, because\n     * pubsub channels are not database-specific in Redis.\n     */\n    public String getStatusChannel() {\n        return statusChannel;\n    }\n    \n    /**\n     * The prefix of the channel where the reader announces new updates.\n     *\n     * This prefix defaults to \"update\". Generally, the db id will be added\n     * to the prefix, because if multiple readers would use the same Redis\n     * instance (e.g. for testing purposes), these would collide, because\n     * pubsub channels are not database-specific.\n     */\n    public String getUpdateChannel() {\n        return updateChannel;\n    }\n\n    /**\n     * The prefix of the channel where an entity in the system receives control messages.\n     *\n     * This defaults to \"control\". Generally, the db id will be added to this prefix,\n     * because pubsub channels are not database-specific in Redis.\n     */\n    public String getControlChannel() {\n        return controlChannel;\n    }\n\n    /**\n     * The name of the list where readers push their updates on.\n     *\n     * Defaults to \"updates\".\n     */\n    public String getUpdatesList() {\n        return updatesList;\n    }\n\n    /**\n     * The name of the set in which updates are stored in the processor.\n     */\n    public String getUpdatesSet() {\n        return updatesSet;\n    }\n\n    /**\n     * The teams, with team number and name.\n     */\n    public ImmutableList<Team> getTeams() {\n        return teams;\n    }\n\n    // TODO: Maybe find some other solution?\n    private static Config currentConfig;\n\n    public static void setCurrentConfig(Config config) {\n        currentConfig = config;\n    }\n\n    public static Config getCurrentConfig() {\n        return currentConfig;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StatusChangeEvent.java\n@JsonTypeName(\"StatusChange\")\npublic final class StatusChangeEvent extends Event {\n    private final Status status;\n\n    @JsonCreator\n    public StatusChangeEvent(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\")Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public static StatusChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusCommand);\n        SetStatusCommand cmd = (SetStatusCommand) command;\n        return new StatusChangeEvent(cmd.getTime(), cmd.getStatus());\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        Snapshot.Builder builder = Snapshot.builder(getTime(), before).withStatus(status);\n        if (!before.getStatus().isPublic() && status.isPublic()) {\n            builder.withPublicTeamStates(before.getTeamStates());\n        }\n        return builder.build();\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.ulyssis.ipp.config.Config;\nimport org.ulyssis.ipp.config.ReaderConfig;\nimport org.ulyssis.ipp.config.Team;\nimport org.ulyssis.ipp.control.CommandProcessor;\nimport org.ulyssis.ipp.control.commands.AddTagCommand;\nimport org.ulyssis.ipp.control.commands.CorrectionCommand;\nimport org.ulyssis.ipp.control.commands.RemoveTagCommand;\nimport org.ulyssis.ipp.control.commands.SetEndTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStartTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusMessageCommand;\nimport org.ulyssis.ipp.control.commands.SetUpdateFrequencyCommand;\nimport org.ulyssis.ipp.control.handlers.EventCommandHandler;\nimport org.ulyssis.ipp.control.handlers.PingHandler;\nimport org.ulyssis.ipp.snapshot.Snapshot;\nimport org.ulyssis.ipp.snapshot.AddTagEvent;\nimport org.ulyssis.ipp.snapshot.CorrectionEvent;\nimport org.ulyssis.ipp.snapshot.EndEvent;\nimport org.ulyssis.ipp.snapshot.Event;\nimport org.ulyssis.ipp.snapshot.MessageEvent;\nimport org.ulyssis.ipp.snapshot.RemoveTagEvent;\nimport org.ulyssis.ipp.snapshot.StartEvent;\nimport org.ulyssis.ipp.snapshot.StatusChangeEvent;\nimport org.ulyssis.ipp.snapshot.UpdateFrequencyChangeEvent;\nimport org.ulyssis.ipp.status.StatusMessage;\nimport org.ulyssis.ipp.status.StatusReporter;\nimport org.ulyssis.ipp.utils.JedisHelper;\nimport org.ulyssis.ipp.utils.Serialization;\nimport org.ulyssis.ipp.TagId;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.sql.*;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_ONLY;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_WRITE;\n        }\n        URI uri = options.getRedisUri();\n        this.eventQueue = new LinkedBlockingQueue<>();\n        this.eventCallbacks  = new ConcurrentHashMap<>();\n        this.onStartedCallbacks = new CopyOnWriteArrayList<>();\n        this.readerListeners = new ArrayList<>();\n        this.threads = new ArrayList<>();\n        // TODO: Move status reporting and processing of commands to ZeroMQ?\n        // Also: post some stuff to a log in the db?\n        this.statusReporter = new StatusReporter(uri, Config.getCurrentConfig().getStatusChannel());\n        this.commandProcessor = new CommandProcessor(uri, Config.getCurrentConfig().getControlChannel(), statusReporter);\n        initCommandProcessor();\n        snapshot = new Snapshot(Instant.EPOCH);\n        if (!restoreFromDb()) {\n            registerInitialTags();\n        }\n    }\n\n    /**\n     * Restore the state from the database\n     *\n     * @return Whether we could restore from db, if false, we're starting from a clean slate\n     */\n    private boolean restoreFromDb() {\n        Connection connection = null;\n        Snapshot oldSnapshot = this.snapshot;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            Optional<Snapshot> snapshot = Snapshot.loadLatest(connection);\n            if (snapshot.isPresent()) {\n                this.snapshot = snapshot.get();\n                connection.commit();\n                return true;\n            } else {\n                List<Event> events = Event.loadAll(connection);\n                Snapshot snapshotBefore = this.snapshot;\n                // Instant now = Instant.now(); // TODO: Handle future events later!\n                for (Event event : events) {\n                    if (!event.isRemoved()/* && event.getTime().isBefore(now)*/) { // TODO: Future events later!\n                        this.snapshot = event.apply(this.snapshot);\n                        this.snapshot.save(connection);\n                    }\n                }\n                connection.commit();\n                return !Objects.equals(this.snapshot, snapshotBefore);\n            }\n        } catch (SQLException | IOException e) {\n            LOG.error(\"An error occurred when restoring from database!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void registerInitialTags() {\n        Snapshot oldSnapshot = this.snapshot;\n        Connection connection = null;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            for (Team team : Config.getCurrentConfig().getTeams()) {\n                for (TagId tag : team.getTags()) {\n                    AddTagEvent e = new AddTagEvent(Instant.EPOCH, tag, team.getTeamNb());\n                    e.save(connection);\n                    this.snapshot = e.apply(this.snapshot);\n                    this.snapshot.save(connection);\n                }\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            LOG.error(\"An error occurred when registering initial tags!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void initCommandProcessor() {\n        commandProcessor.addHandler(new PingHandler());\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(AddTagCommand.class, AddTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(RemoveTagCommand.class, RemoveTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(CorrectionCommand.class, CorrectionEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStartTimeCommand.class, StartEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetEndTimeCommand.class, EndEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusCommand.class, StatusChangeEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusMessageCommand.class, MessageEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(Next line of code:\n", "input": "import com.fasterxml.jackson.core.JsonProcessingException;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.ulyssis.ipp.config.Config;\nimport org.ulyssis.ipp.config.ReaderConfig;\nimport org.ulyssis.ipp.config.Team;\nimport org.ulyssis.ipp.control.CommandProcessor;\nimport org.ulyssis.ipp.control.commands.AddTagCommand;\nimport org.ulyssis.ipp.control.commands.CorrectionCommand;\nimport org.ulyssis.ipp.control.commands.RemoveTagCommand;\nimport org.ulyssis.ipp.control.commands.SetEndTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStartTimeCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusCommand;\nimport org.ulyssis.ipp.control.commands.SetStatusMessageCommand;\nimport org.ulyssis.ipp.control.commands.SetUpdateFrequencyCommand;\nimport org.ulyssis.ipp.control.handlers.EventCommandHandler;\nimport org.ulyssis.ipp.control.handlers.PingHandler;\nimport org.ulyssis.ipp.snapshot.Snapshot;\nimport org.ulyssis.ipp.snapshot.AddTagEvent;\nimport org.ulyssis.ipp.snapshot.CorrectionEvent;\nimport org.ulyssis.ipp.snapshot.EndEvent;\nimport org.ulyssis.ipp.snapshot.Event;\nimport org.ulyssis.ipp.snapshot.MessageEvent;\nimport org.ulyssis.ipp.snapshot.RemoveTagEvent;\nimport org.ulyssis.ipp.snapshot.StartEvent;\nimport org.ulyssis.ipp.snapshot.StatusChangeEvent;\nimport org.ulyssis.ipp.snapshot.UpdateFrequencyChangeEvent;\nimport org.ulyssis.ipp.status.StatusMessage;\nimport org.ulyssis.ipp.status.StatusReporter;\nimport org.ulyssis.ipp.utils.JedisHelper;\nimport org.ulyssis.ipp.utils.Serialization;\nimport org.ulyssis.ipp.TagId;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.sql.*;\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Consumer;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_ONLY;\nimport static org.ulyssis.ipp.processor.Database.ConnectionFlags.READ_WRITE;\n        }\n        URI uri = options.getRedisUri();\n        this.eventQueue = new LinkedBlockingQueue<>();\n        this.eventCallbacks  = new ConcurrentHashMap<>();\n        this.onStartedCallbacks = new CopyOnWriteArrayList<>();\n        this.readerListeners = new ArrayList<>();\n        this.threads = new ArrayList<>();\n        // TODO: Move status reporting and processing of commands to ZeroMQ?\n        // Also: post some stuff to a log in the db?\n        this.statusReporter = new StatusReporter(uri, Config.getCurrentConfig().getStatusChannel());\n        this.commandProcessor = new CommandProcessor(uri, Config.getCurrentConfig().getControlChannel(), statusReporter);\n        initCommandProcessor();\n        snapshot = new Snapshot(Instant.EPOCH);\n        if (!restoreFromDb()) {\n            registerInitialTags();\n        }\n    }\n\n    /**\n     * Restore the state from the database\n     *\n     * @return Whether we could restore from db, if false, we're starting from a clean slate\n     */\n    private boolean restoreFromDb() {\n        Connection connection = null;\n        Snapshot oldSnapshot = this.snapshot;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            Optional<Snapshot> snapshot = Snapshot.loadLatest(connection);\n            if (snapshot.isPresent()) {\n                this.snapshot = snapshot.get();\n                connection.commit();\n                return true;\n            } else {\n                List<Event> events = Event.loadAll(connection);\n                Snapshot snapshotBefore = this.snapshot;\n                // Instant now = Instant.now(); // TODO: Handle future events later!\n                for (Event event : events) {\n                    if (!event.isRemoved()/* && event.getTime().isBefore(now)*/) { // TODO: Future events later!\n                        this.snapshot = event.apply(this.snapshot);\n                        this.snapshot.save(connection);\n                    }\n                }\n                connection.commit();\n                return !Objects.equals(this.snapshot, snapshotBefore);\n            }\n        } catch (SQLException | IOException e) {\n            LOG.error(\"An error occurred when restoring from database!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n            return false;\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void registerInitialTags() {\n        Snapshot oldSnapshot = this.snapshot;\n        Connection connection = null;\n        try {\n            connection = Database.createConnection(EnumSet.of(READ_WRITE));\n            for (Team team : Config.getCurrentConfig().getTeams()) {\n                for (TagId tag : team.getTags()) {\n                    AddTagEvent e = new AddTagEvent(Instant.EPOCH, tag, team.getTeamNb());\n                    e.save(connection);\n                    this.snapshot = e.apply(this.snapshot);\n                    this.snapshot.save(connection);\n                }\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            LOG.error(\"An error occurred when registering initial tags!\", e);\n            this.snapshot = oldSnapshot;\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e2) {\n                LOG.error(\"Error in rollback after previous error\", e2);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    LOG.error(\"Error while closing connection\", e);\n                }\n            }\n        }\n    }\n\n    private void initCommandProcessor() {\n        commandProcessor.addHandler(new PingHandler());\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(AddTagCommand.class, AddTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(RemoveTagCommand.class, RemoveTagEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(CorrectionCommand.class, CorrectionEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStartTimeCommand.class, StartEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetEndTimeCommand.class, EndEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusCommand.class, StatusChangeEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(\n                new EventCommandHandler<>(SetStatusMessageCommand.class, MessageEvent::fromCommand, this::queueEvent));\n        commandProcessor.addHandler(", "context": "shared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusCommand.java\n@JsonTypeName(\"SetStatus\")\npublic final class SetStatusCommand extends Command {\n    private final Status status;\n\n    public SetStatusCommand(Status status) {\n        super();\n        this.status = status;\n    }\n\n    @JsonCreator\n    private SetStatusCommand(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\") Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetUpdateFrequencyCommand.java\n@JsonTypeName(\"SetUpdateFrequency\")\npublic final class SetUpdateFrequencyCommand extends Command {\n    private final int updateFrequency;\n\n    public SetUpdateFrequencyCommand(int updateFrequency) {\n        super();\n        this.updateFrequency = updateFrequency;\n    }\n\n    @JsonCreator\n    private SetUpdateFrequencyCommand(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStatusMessageCommand.java\n@JsonTypeName(\"SetStatusMessage\")\npublic class SetStatusMessageCommand extends Command {\n    private final String message;\n\n    public SetStatusMessageCommand(String message) {\n        super();\n        this.message = message;\n    }\n\n    public SetStatusMessageCommand(Instant time, String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @JsonCreator\n    private SetStatusMessageCommand(@JsonProperty(\"commandId\") String commandId,\n                                    @JsonProperty(\"time\") Instant time,\n                                    @JsonProperty(\"message\") String message) {\n        super(commandId, time);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusReporter.java\npublic final class StatusReporter {\n    private static final Logger LOG = LogManager.getLogger(StatusReporter.class);\n    \n    private final Jedis jedis;\n    private final String statusChannel;\n\n    /**\n     * Create a new status reporter for the given Redis URI and status channel.\n     *\n     * @param redisURI\n     *        The URI for the Redis instance to report the status on. This should\n     *        be the \"own\" Redis instance.\n     * @param statusChannel\n     *        The channel to broadcast the status messages to. This channel is\n     *        made specific to the database, so if the `redisUri`\n     *        contains database `N`, and the channel is `status`,\n     *        then messages will be broadcast on channel `status:N`.\n     * @see org.ulyssis.ipp.utils.JedisHelper#dbLocalChannel(String, java.net.URI)\n     */\n    public StatusReporter(URI redisURI, String statusChannel) {\n        this.jedis = JedisHelper.get(redisURI);\n        this.statusChannel = JedisHelper.dbLocalChannel(statusChannel, redisURI);\n    }\n\n    /**\n     * Broadcast a status message.\n     *\n     * @param message\n     *        The message to broadcast\n     * @return True if the broadcast was successful, false if the broadcast was unsuccessful.\n     *         Failure to broadcast will be logged.\n     */\n    public synchronized boolean broadcast(StatusMessage message) {\n        if (jedis == null)\n            return false;\n        try {\n            jedis.publish(statusChannel.getBytes(), Serialization.getJsonMapper().writeValueAsBytes(message));\n            return true;\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error processing message {}\", message.getDetails(), e);\n            return false;\n        } catch (JedisConnectionException e) {\n            LOG.error(\"Couldn't connect to Redis when sending: {}\", message.getDetails(), e);\n            return false;\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/handlers/PingHandler.java\npublic final class PingHandler implements CommandHandler {\n\n    /**\n     * Handles the given command, which should be a PingCommand.\n     *\n     * @param command\n     *        The ping command to handle.\n     * @param callback\n     *        The ping callback, which is always invoked with true.\n     */\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        callback.accept(true);\n    }\n\n    /**\n     * Returns PingCommand.class\n     *\n     * @return PingCommand.class\n     */\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return PingCommand.class;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/ReaderConfig.java\npublic class ReaderConfig {\n    private URI uri;\n    private Type type = Type.LLRP;\n    private double position;\n    private List<SimulatedTeam> simulatedTeams = new ArrayList<>();\n\n    public static class SimulatedTeam {\n        private final TagId tag;\n        private final long lapTime;\n\n        @JsonCreator\n        public SimulatedTeam(\n                @JsonProperty(\"tag\") TagId tag,\n                @JsonProperty(\"lapTime\") long lapTime) {\n            this.tag = tag;\n            this.lapTime = lapTime;\n        }\n\n        public TagId getTag() {\n            return tag;\n        }\n\n        public long getLapTime() {\n            return lapTime;\n        }\n    }\n\n    public enum Type {\n        LLRP,\n        SIMULATOR\n    }\n\n    /**\n     * Private constructor used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private ReaderConfig() {\n    }\n\n    public URI getURI() {\n        return uri;\n    }\n    \n    /**\n     * Private setter used by Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private void setURI(URI uri) {\n        this.uri = uri;\n    }\n\n    public double getPosition() {\n        return position;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setPosition(double position) {\n        this.position = position;\n    }\n\n    public Type getType() {\n        return type;\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setType(Type type) {\n        this.type = type;\n    }\n\n    public List<SimulatedTeam> getSimulatedTeams() {\n        return Collections.unmodifiableList(simulatedTeams);\n    }\n\n    public SimulatedTeam getSimulatedTeam(int id) {\n        return simulatedTeams.get(id);\n    }\n\n    /**\n     * Private setter used by Jackson.\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSimulatedTeams(List<SimulatedTeam> simulatedTeams) {\n        this.simulatedTeams = simulatedTeams;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/RemoveTagCommand.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagCommand extends TagCommand {\n    public RemoveTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    public RemoveTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @JsonCreator\n    private RemoveTagCommand(@JsonProperty(\"commandId\") String commandId,\n                             @JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"tag\") TagId tag,\n                             @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StartEvent.java\n@JsonTypeName(\"Start\")\npublic final class StartEvent extends Event {\n    /**\n     * Private constructor for Jackson\n     */\n    private StartEvent() {\n        super(Instant.MIN);\n    }\n\n    public StartEvent(Instant time) {\n        super(time);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withStartTime(getTime()).build();\n    }\n\n    public static StartEvent fromCommand(Command command) {\n        assert(command instanceof SetStartTimeCommand);\n        SetStartTimeCommand cmd = (SetStartTimeCommand) command;\n        return new StartEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/JedisHelper.java\npublic final class JedisHelper {\n\n    // Static methods only! No instances!\n    private JedisHelper() {\n    }\n\n    /**\n     * Get a new Jedis instance from the given URI\n     *\n     * The URI is formed as such:\n     * `new URI(\"redis://:password@host:port/database\")`\n     * for example:\n     * `new URI(\"redis://:hunter2@10.0.0.1:6379/0\")}`.\n     * The port, password and path can be omitted. If no path is\n     * supplied, database +0+ is selected. If no user\n     * info is supplied, then no authorization is performed.\n     * If no port is supplied, the default port +6379+\n     * is used.\n     *\n     * Use this instead of `new Jedis(uri)`, because\n     * that method does not allow to omit anything.\n     *\n     * @param uri\n     *        The URI for the Jedis instance.\n     * @return A new Jedis instance.\n     */\n    // TODO: Exceptions for wrong password, failing to parse database,...\n    public static Jedis get(URI uri) throws IllegalArgumentException {\n        int port = uri.getPort() != -1 ? uri.getPort() : 6379;\n        String host = uri.getHost();\n        Jedis result = new Jedis(host, port);\n        if (uri.getUserInfo() != null) {\n            String password = uri.getUserInfo().split(\":\")[1];\n            result.auth(password);\n        }\n        result.select(getDb(uri));\n        return result;\n    }\n\n    /**\n     * Extract the database number from the given Redis URI\n     *\n     * If the URI has the path +/N+, then +N+\n     * is returned. If the path is empty, +0+ is returned.\n     *\n     * @param uri\n     *        The URI\n     * @throws java.lang.IllegalArgumentException\n     *         The supplied path could not be parsed as an int\n     * @return The database number (+0+ for no path, +N+\n     *         if the path is +/N+)\n     */\n    public static int getDb(URI uri) throws IllegalArgumentException {\n        if (!Objects.equals(uri.getPath(), \"\")) {\n            try {\n                return Integer.parseInt(uri.getPath().split(\"/\", 2)[1]);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"The supplied path could not be parsed as an int\", e);\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Generates a channel name that is local to a database.\n     *\n     * Redis channels are not tied to a single database, but are\n     * global to the instance of Redis. We, however, want to tie\n     * these to a certain database, so we have to add some information\n     * that does that. For this reason, if the channel name is\n     * +channel+, the database number +N+ is added to it\n     * to form +channel:N+. The database number is extracted\n     * using `getDb(uri)`.\n     *\n     * @param channel\n     *        The base channel name\n     * @param uri\n     *        The URI containing the database info\n     * @return +channel:N+, where +N+ is the database number\n     * @see org.ulyssis.ipp.utils.JedisHelper#getDb(java.net.URI)\n     */\n    public static String dbLocalChannel(String channel, URI uri) {\n        return channel + \":\" + getDb(uri);\n    }\n\n    /**\n     * A helper class that implements +BinaryJedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class BinaryCallBackPubSub extends BinaryJedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(byte[] pattern, byte[] channel, byte[] message);\n        }\n\n        private final List<BiConsumer<byte[],byte[]>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<byte[],Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(byte[] channel, byte[] message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onMessage(byte[], byte[])\n         */\n        public void addOnMessageListener(BiConsumer<byte[],byte[]> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(byte[] pattern, byte[] channel, byte[] message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPMessage(byte[], byte[], byte[])\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(byte[] channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onSubscribe(byte[], int)\n         */\n        public void addOnSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(byte[] channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onUnsubscribe(byte[], int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(byte[] pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPSubscribe(byte[], int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(byte[] pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.BinaryCallBackPubSub#onPUnsubscribe(byte[], int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<byte[], Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * A helper class that implements +JedisPubSub+ using callbacks\n     * that can be registered.\n     *\n     * Instead of having to implement six methods where you probably\n     * only need one, you only need to supply callbacks for the ones you're\n     * interested in. This becomes extra useful when using Java 8, because\n     * function references or lambda functions can be used.\n     *\n     * Adding a callback is thread safe. +CopyOnWriteArrayList+ is used,\n     * because this class is optimized for frequent calling of callbacks,\n     * not for registering callback functions.\n     *\n     * All callbacks are called from the thread currently blocking on\n     * a +subscribe()+ (or similar) call.\n     *\n     * Currently, callbacks can only be added, not removed.\n     */\n    public static class CallBackPubSub extends JedisPubSub {\n        /**\n         * This is necessary, because there is no triconsumer.\n         */\n        @FunctionalInterface\n        public interface OnPMessageCallback {\n            public void accept(String pattern, String channel, String message);\n        }\n\n        private final List<BiConsumer<String,String>> onMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<OnPMessageCallback> onPMessageCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPSubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n        private final List<BiConsumer<String,Integer>> onPUnsubscribeCallbacks\n                = new CopyOnWriteArrayList<>();\n\n        /**\n         * Implementation of +onMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnMessageListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onMessage(String channel, String message) {\n            onMessageCallbacks.stream().forEach(callback -> callback.accept(channel, message));\n        }\n\n        /**\n         * Add a callback for +onMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        channel, the second is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onMessage(String, String)\n         */\n        public void addOnMessageListener(BiConsumer<String, String> callback) {\n            onMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPMessage+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPMessageListener(org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub.OnPMessageCallback)\n         */\n        @Override\n        public void onPMessage(String pattern, String channel, String message) {\n            onPMessageCallbacks.stream().forEach(callback -> callback.accept(pattern, channel, message));\n        }\n\n        /**\n         * Add a callback for +onPMessage+.\n         *\n         * @param callback\n         *        The callback to add. The first argument is the\n         *        pattern is the channel, the second is the channel,\n         *        and the third is the message.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPMessage(String, String, String)\n         */\n        public void addOnPMessageListener(OnPMessageCallback callback) {\n            onPMessageCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onSubscribe(String channel, int subscribedChannels) {\n            onSubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onSubscribe(String, int)\n         */\n        public void addOnSubscribeListener(BiConsumer<String, Integer> callback) {\n            onSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onUnsubscribe(String channel, int subscribedChannels) {\n            onUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(channel, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the channel,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onUnsubscribe(String, int)\n         */\n        public void addOnUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onUnsubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPSubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPSubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPSubscribe(String pattern, int subscribedChannels) {\n            onPSubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPSubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPSubscribe(String, int)\n         */\n        public void addOnPSubscribeListener(BiConsumer<String, Integer> callback) {\n            onPSubscribeCallbacks.add(callback);\n        }\n\n        /**\n         * Implementation of +onPUnsubscribe+. Forwards the call to the registered callbacks.\n         *\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#addOnPUnsubscribeListener(java.util.function.BiConsumer)\n         */\n        @Override\n        public void onPUnsubscribe(String pattern, int subscribedChannels) {\n            onPUnsubscribeCallbacks.stream().forEach(callback -> callback.accept(pattern, subscribedChannels));\n        }\n\n        /**\n         * Add a callback for +onPUnsubscribe+\n         *\n         * @param callback\n         *        The callback to add. The first argument is the pattern,\n         *        the second is the number of subscribed channels.\n         * @see org.ulyssis.ipp.utils.JedisHelper.CallBackPubSub#onPUnsubscribe(String, int)\n         */\n        public void addOnPUnsubscribeListener(BiConsumer<String, Integer> callback) {\n            onPUnsubscribeCallbacks.add(callback);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Snapshot.java\npublic final class Snapshot {\n    private static final Logger LOG = LogManager.getLogger(Snapshot.class);\n\n    public static class Builder {\n        private Snapshot snapshot;\n\n        private Builder(Instant time, Snapshot other) {\n            snapshot = new Snapshot(time);\n            if (other != null) {\n                snapshot.teamTagMap = other.teamTagMap;\n                snapshot.startTime = other.startTime;\n                snapshot.endTime = other.endTime;\n                snapshot.teamStates = other.teamStates;\n                snapshot.publicTeamStates = other.publicTeamStates;\n                snapshot.statusMessage = other.statusMessage;\n                snapshot.status = other.status;\n                snapshot.updateFrequency = other.updateFrequency;\n            }\n        }\n\n        public Builder withTeamTagMap(TeamTagMap teamTagMap) {\n            this.snapshot.teamTagMap = teamTagMap;\n            return this;\n        }\n\n        public Builder withStartTime(Instant time) {\n            this.snapshot.startTime = time;\n            return this;\n        }\n\n        public Builder withEndTime(Instant time) {\n            this.snapshot.endTime = time;\n            return this;\n        }\n\n        public Builder withTeamStates(TeamStates teamStates) {\n            this.snapshot.teamStates = teamStates;\n            return this;\n        }\n\n        public Builder withPublicTeamStates(TeamStates teamStates) {\n            this.snapshot.publicTeamStates = teamStates;\n            return this;\n        }\n\n        public Builder withStatusMessage(String message) {\n            this.snapshot.statusMessage = message;\n            return this;\n        }\n\n        public Builder withStatus(Status status) {\n            this.snapshot.status = status;\n            return this;\n        }\n\n        public Builder withUpdateFrequency(int updateFrequency) {\n            this.snapshot.updateFrequency = updateFrequency;\n            return this;\n        }\n\n        public Snapshot build() {\n            return snapshot;\n        }\n    }\n\n    @JsonIgnore\n    private long id = -1;\n\n    @JsonIgnore\n    long eventId = -1;\n\n    public Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    public Optional<Long> getEventId() {\n        if (eventId != -1) return Optional.of(eventId);\n        else return Optional.empty();\n    }\n\n    /**\n     * Default constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private Snapshot() {\n    }\n\n    public Snapshot(Instant time) {\n        snapshotTime = time;\n    }\n\n    public Instant getSnapshotTime() {\n        return snapshotTime;\n    }\n\n    public TeamTagMap getTeamTagMap() {\n        return teamTagMap;\n    }\n\n    public Instant getStartTime() {\n        return startTime;\n    }\n\n    public Instant getEndTime() {\n        return endTime;\n    }\n\n    public TeamStates getTeamStates() {\n        return teamStates;\n    }\n\n    public TeamStates getPublicTeamStates() {\n        return publicTeamStates;\n    }\n\n    public String getStatusMessage() {\n        return statusMessage;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    private Instant snapshotTime = Instant.MIN;\n    private Instant startTime = Instant.MAX;\n    private Instant endTime = Instant.MAX;\n    private TeamTagMap teamTagMap = new TeamTagMap();\n    private TeamStates teamStates;\n    private TeamStates publicTeamStates;\n    {\n        teamStates = new TeamStates();\n        publicTeamStates = teamStates;\n    }\n    private String statusMessage = \"\";\n    private Status status = Status.NoResults;\n    private int updateFrequency = 3;\n\n    public static Builder builder(Instant time, Snapshot other) {\n        return new Builder(time, other);\n    }\n\n    public static Optional<Snapshot> loadForEvent(Connection connection, Event event) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"snapshots\\\" WHERE \\\"event\\\" = ?\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setLong(1, event.getId().get());\n            LOG.debug(\"executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = event.getId().get();\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadLatest(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" ORDER BY \\\"time\\\" DESC FETCH FIRST ROW ONLY\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(statement)) {\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Snapshot> loadBefore(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"event\\\" FROM \\\"snapshots\\\" \" +\n                \"WHERE \\\"time\\\" < ? ORDER BY \\\"time\\\" DESC, \\\"event\\\" DESC FETCH FIRST ROW ONLY\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                String data = rs.getString(\"data\");\n                Snapshot result = Serialization.getJsonMapper().readValue(data, Snapshot.class);\n                result.id = rs.getLong(\"id\");\n                result.eventId = rs.getLong(\"event\");\n                return Optional.of(result);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                \"INSERT INTO \\\"snapshots\\\" (\\\"time\\\",\\\"data\\\",\\\"event\\\") VALUES (?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(snapshotTime));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false; // TODO(Roel): Programming error\n                return;\n            }\n            statement.setString(2, serialized);\n            statement.setLong(3, eventId);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public static void deleteAfter(Connection connection, Snapshot snapshot) throws SQLException {\n        String statement =\n                \"DELETE FROM \\\"snapshots\\\" WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"event\\\" > ?)\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            Timestamp timestamp = Timestamp.from(snapshot.getSnapshotTime());\n            stmt.setTimestamp(1, timestamp);\n            stmt.setTimestamp(2, timestamp);\n            stmt.setLong(3, snapshot.getEventId().orElse(-1L));\n            LOG.debug(\"Executing query: {}\", stmt);\n            int affectedRows = stmt.executeUpdate();\n            LOG.debug(\"deleteAfter affected {} rows\", affectedRows);\n        }\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/MessageEvent.java\n@JsonTypeName(\"Message\")\npublic final class MessageEvent extends Event {\n    private final String message;\n\n    @JsonCreator\n    public MessageEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"message\") String message) {\n        super(time);\n        this.message = message;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withStatusMessage(message).build();\n    }\n\n    public static MessageEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusMessageCommand);\n        SetStatusMessageCommand cmd = (SetStatusMessageCommand) command;\n        return new MessageEvent(cmd.getTime(), cmd.getMessage());\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/CorrectionEvent.java\n@JsonTypeName(\"Correction\")\npublic final class CorrectionEvent extends Event {\n    private int teamNb;\n    private int correction;\n\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private CorrectionEvent() {\n        super(Instant.MIN);\n    }\n\n    /**\n     * Create an event representing a correction of score.\n     *\n     * @param time\n     *        The time at which the corection is performed.\n     * @param teamNb\n     *        The number of the team to correct the score of.\n     * @param correction\n     *        The number of laps that should be added (positive)\n     *        or removed (negative)\n     */\n    public CorrectionEvent(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    @SuppressWarnings(\"unused\")\n    public int getCorrection() {\n        return correction;\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamStates oldTeamStates = snapshot.getTeamStates();\n        Optional<TeamState> oldTeamState = oldTeamStates.getStateForTeam(teamNb);\n        TeamState newTeamState;\n        if (oldTeamState.isPresent()) {\n            newTeamState = oldTeamState.get().addCorrection(correction);\n        } else {\n            newTeamState = new TeamState().addCorrection(correction);\n        }\n        return Snapshot.builder(getTime(), snapshot)\n                .withTeamStates(snapshot.getTeamStates().setStateForTeam(teamNb, newTeamState))\n                .build();\n    }\n\n    public static CorrectionEvent fromCommand(Command command) {\n        assert(command instanceof CorrectionCommand);\n        CorrectionCommand cmd = (CorrectionCommand) command;\n        return new CorrectionEvent(cmd.getTime(), cmd.getTeamNb(), cmd.getCorrection());\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/Event.java\n@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n@JsonSubTypes({ @JsonSubTypes.Type(value=StartEvent.class),\n                @JsonSubTypes.Type(value=EndEvent.class),\n                @JsonSubTypes.Type(value=AddTagEvent.class),\n                @JsonSubTypes.Type(value=RemoveTagEvent.class),\n                @JsonSubTypes.Type(value=CorrectionEvent.class),\n                @JsonSubTypes.Type(value=TagSeenEvent.class),\n                @JsonSubTypes.Type(value=IdentityEvent.class),\n                @JsonSubTypes.Type(value=MessageEvent.class),\n                @JsonSubTypes.Type(value=StatusChangeEvent.class)})\npublic abstract class Event {\n    private static final Logger LOG = LogManager.getLogger(Event.class);\n\n    @JsonIgnore\n    private long id = -1;\n    @JsonIgnore\n    private boolean removed = false;\n\n    private Instant time;\n\n    protected Event(Instant time) {\n        this.time = time;\n    }\n\n    @JsonIgnore\n    public final Optional<Long> getId() {\n        if (id != -1) return Optional.of(id);\n        else return Optional.empty();\n    }\n\n    @JsonIgnore\n    public final boolean isRemoved() {\n        if (id == -1) throw new IllegalStateException(\"Trying to request removed state of event not in db\");\n        return removed;\n    }\n\n    public final Instant getTime() {\n        return time;\n    }\n\n    /**\n     * Determines whether this event should be isUnique, defaults to false\n     *\n     * @return whether this event should be isUnique (default implementation = false)\n     */\n    @JsonIgnore\n    public boolean isUnique() {\n        return false;\n    }\n\n    /**\n     * Determines whether this event can be removed or undone.\n     *\n     * @return whether this event can be removed or undone (default implementation = isUnique())\n     */\n    @JsonIgnore\n    public boolean isRemovable() {\n        return isUnique();\n    }\n\n    /**\n     * Apply this event to a snapshot, yielding the new snapshot\n     */\n    protected abstract Snapshot doApply(Snapshot before);\n\n    public final Snapshot apply(Snapshot before) {\n        assert !removed;\n        Snapshot result = doApply(before);\n        if (result == before && before.getEventId().isPresent()) {\n            // We need to copy it anyway\n            result = Snapshot.builder(getTime(), before).build();\n        }\n        result.eventId = this.id;\n        return result;\n    }\n\n    // TODO: How to deal with deserialization problem?\n    public static List<Event> loadAll(Connection connection) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\", \\\"removed\\\" FROM \\\"events\\\" ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet result = stmt.executeQuery(statement)) {\n            while (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = result.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static Optional<Event> loadUnique(Connection connection, Class<? extends Event> eventType) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\", \\\"data\\\" FROM \\\"events\\\" WHERE \\\"type\\\" = ? AND \\\"removed\\\" = false\";\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setString(1, eventType.getSimpleName());\n            ResultSet result = stmt.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = result.getLong(\"id\");\n                event.removed = false;\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static Optional<Event> load(Connection connection, long id) throws SQLException, IOException {\n        try (PreparedStatement statement =\n                connection.prepareStatement(\n                        \"SELECT \\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" WHERE \\\"id\\\"=?\")) {\n            statement.setLong(1, id);\n            ResultSet result = statement.executeQuery();\n            if (result.next()) {\n                String evString = result.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = id;\n                event.removed = result.getBoolean(\"removed\");\n                return Optional.of(event);\n            } else {\n                return Optional.empty();\n            }\n        }\n    }\n\n    public static List<Event> loadFrom(Connection connection, Instant time) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" >= ? ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        return events;\n    }\n\n    public static List<Event> loadAfter(Connection connection, Instant time, long id) throws SQLException, IOException {\n        String statement = \"SELECT \\\"id\\\",\\\"data\\\",\\\"removed\\\" FROM \\\"events\\\" \" +\n                \"WHERE \\\"time\\\" > ? OR (\\\"time\\\" = ? AND \\\"id\\\" > ?) ORDER BY \\\"time\\\" ASC, \\\"id\\\" ASC\";\n        List<Event> events = new ArrayList<>();\n        try (PreparedStatement stmt = connection.prepareStatement(statement)) {\n            stmt.setTimestamp(1, Timestamp.from(time));\n            stmt.setTimestamp(2, Timestamp.from(time));\n            stmt.setLong(3, id);\n            LOG.debug(\"Executing query: {}\", stmt);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                String evString = rs.getString(\"data\");\n                Event event = Serialization.getJsonMapper().readValue(evString, Event.class);\n                event.id = rs.getLong(\"id\");\n                event.removed = rs.getBoolean(\"removed\");\n                events.add(event);\n            }\n        }\n        LOG.debug(\"Loaded {} events\", events.size());\n        return events;\n    }\n\n    public void save(Connection connection) throws SQLException {\n        if (id != -1) return;\n        try (PreparedStatement statement = connection.prepareStatement(\n                    \"INSERT INTO \\\"events\\\" (\\\"time\\\",\\\"type\\\",\\\"data\\\",\\\"removed\\\") \" +\n                            \"VALUES (?,?,?,?)\", Statement.RETURN_GENERATED_KEYS)) {\n            statement.setTimestamp(1, Timestamp.from(time));\n            String serialized;\n            try {\n                serialized = Serialization.getJsonMapper().writeValueAsString(this);\n            } catch (JsonProcessingException e) {\n                assert false;\n                throw new IllegalStateException(e); // TODO(Roel): is this appropriate?\n            }\n            statement.setString(2, this.getClass().getSimpleName());\n            statement.setString(3, serialized);\n            statement.setBoolean(4, removed);\n            statement.executeUpdate();\n            ResultSet keys = statement.getGeneratedKeys();\n            keys.next();\n            this.id = keys.getLong(1);\n        }\n    }\n\n    public void setRemoved(Connection connection, boolean removed) throws SQLException {\n        if (!isRemovable()) {\n            assert false; // This is a programming error\n            return;\n        }\n        PreparedStatement statement =\n                connection.prepareStatement(\n                        \"UPDATE \\\"events\\\" SET \\\"removed\\\"=? WHERE \\\"id\\\"=?\");\n        statement.setBoolean(1, removed);\n        statement.setLong(2, id);\n        boolean result = statement.execute();\n        assert(!result);\n        this.removed = true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/UpdateFrequencyChangeEvent.java\n@JsonTypeName(\"UpdateFrequencyChange\")\npublic final class UpdateFrequencyChangeEvent extends Event {\n    private final int updateFrequency;\n\n    @JsonCreator\n    public UpdateFrequencyChangeEvent(Instant time, int updateFrequency) {\n        super(time);\n        this.updateFrequency = updateFrequency;\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        return Snapshot.builder(getTime(), before).withUpdateFrequency(updateFrequency).build();\n    }\n\n    public int getUpdateFrequency() {\n        return updateFrequency;\n    }\n\n    public static UpdateFrequencyChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetUpdateFrequencyCommand);\n        SetUpdateFrequencyCommand cmd = (SetUpdateFrequencyCommand) command;\n        return new UpdateFrequencyChangeEvent(cmd.getTime(), cmd.getUpdateFrequency());\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/utils/Serialization.java\npublic final class Serialization {\n    private static final ObjectMapper jsonMapper;\n\n    static {\n        jsonMapper = new ObjectMapper();\n        jsonMapper.findAndRegisterModules();\n    }\n\n    // Static methods only! No instances!\n    private Serialization() {\n    }\n\n    /**\n     * Get a JSON mapper, with all modules registered.\n     *\n     * This is equivalent to:\n     *\n     * [source,java]\n     * --\n     * jsonMapper = new ObjectMapper();\n     * jsonMapper.findAndRegisterModules();\n     * --\n     *\n     * @return A JSON ObjectMapper\n     */\n    public static ObjectMapper getJsonMapper() {\n        return jsonMapper;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Team.java\npublic final class Team {\n    private static final Logger LOG = LogManager.getLogger(Team.class);\n\n    private int teamNb;\n    private String name;\n    private ImmutableList<TagId> tags;\n\n    @SuppressWarnings(\"unused\")\n    private Team() {\n        this.teamNb = 0;\n        this.name = \"\";\n        tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = ImmutableList.of();\n    }\n\n    public Team(int teamNb, String name, ImmutableList<TagId> tags) {\n        this.teamNb = teamNb;\n        this.name = name;\n        this.tags = tags;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public ImmutableList<TagId> getTags() {\n        return tags;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/EndEvent.java\n@JsonTypeName(\"End\")\npublic final class EndEvent extends Event {\n    /**\n     * Constructor for Jackson\n     */\n    @SuppressWarnings(\"unused\")\n    private EndEvent() {\n        super(Instant.MIN);\n    }\n\n    public EndEvent(Instant time) {\n        super(time);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        return Snapshot.builder(getTime(), snapshot).withEndTime(getTime()).build();\n    }\n\n    public static EndEvent fromCommand(Command command) {\n        assert(command instanceof SetEndTimeCommand);\n        SetEndTimeCommand cmd = (SetEndTimeCommand) command;\n        return new EndEvent(cmd.getTime());\n    }\n\n    @Override\n    public boolean isUnique() {\n        return true;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/AddTagEvent.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagEvent extends TagEvent {\n    @JsonCreator\n    public AddTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().addTagToTeam(getTag(), getTeamNb());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static AddTagEvent fromCommand(Command command) {\n        assert(command instanceof AddTagCommand);\n        AddTagCommand addTagCommand = (AddTagCommand) command;\n        return new AddTagEvent(\n            addTagCommand.getTime(),\n            addTagCommand.getTag(),\n            addTagCommand.getTeamNb()\n        );\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/CommandProcessor.java\npublic final class CommandProcessor implements Runnable {\n    private static final Logger LOG = LogManager.getLogger(CommandProcessor.class);\n\n    private final Map<Class<? extends Command>, CommandHandler> commandHandlers = new HashMap<>();\n    private final Jedis jedis;\n    private final StatusReporter reporter;\n    private final String channel;\n\n    private BinaryJedisPubSub listener;\n\n    public CommandProcessor(URI redisUri, String commandChannel, String statusChannel) {\n        this(redisUri, JedisHelper.dbLocalChannel(commandChannel, redisUri),\n                new StatusReporter(redisUri, statusChannel));\n    }\n\n    public CommandProcessor(URI redisUri, String channel, StatusReporter statusReporter) {\n        this.jedis = JedisHelper.get(redisUri);\n        this.channel = JedisHelper.dbLocalChannel(channel, redisUri);\n        this.reporter = statusReporter;\n    }\n\n    public void run() {\n        jedis.subscribe(createCommandListener(), channel.getBytes());\n    }\n\n    private BinaryJedisPubSub createCommandListener() {\n        JedisHelper.BinaryCallBackPubSub pubSub = new JedisHelper.BinaryCallBackPubSub();\n        listener = pubSub;\n        pubSub.addOnMessageListener(this::onCommandMessage);\n        return pubSub;\n    }\n\n    private void onCommandMessage(byte[] channel, byte[] message) {\n        assert (Arrays.equals(channel, this.channel.getBytes()));\n        try {\n            Command command = Serialization.getJsonMapper().readValue(message, Command.class);\n            handleCommand(command);\n        } catch (IOException e) {\n            LOG.error(\"Couldn't parse command: {}\", new String(message), e);\n        }\n    }\n\n    public void addHandler(CommandHandler handler) {\n        commandHandlers.put(handler.getCommandClass(), handler);\n    }\n\n    private void handleCommand(Command command) {\n        LOG.debug(\"Handing command {}: {}\", command.getCommandId(), command.getClass().toString());\n        if (commandHandlers.containsKey(command.getClass())) {\n            commandHandlers.get(command.getClass()).handle(command, notifyCommandExecuted(command));\n        } else {\n            notifyCommandUnsupported(command);\n        }\n    }\n\n    private Consumer<Boolean> notifyCommandExecuted(Command command) {\n        return (result) -> {\n            if (result) {\n                notifySuccess(command);\n            } else {\n                notifyFailure(command);\n            }\n        };\n    }\n\n    private void notifySuccess(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_COMPLETE, command.getCommandId()));\n    }\n\n    private void notifyFailure(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_FAILED, command.getCommandId()));\n    }\n\n    private void notifyCommandUnsupported(Command command) {\n        reporter.broadcast(new StatusMessage(StatusMessage.MessageType.COMMAND_UNSUPPORTED, command.getCommandId()));\n    }\n\n    public void stop() {\n        try {\n            listener.unsubscribe();\n        } catch (JedisConnectionException ignored) {\n        }\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/status/StatusMessage.java\npublic final class StatusMessage {\n    private MessageType type;\n    private String details;\n\n    public enum MessageType {\n        /**\n         * The reader sends this message when no updates have been received for a while\n         */\n        NO_UPDATES,\n        /**\n         * Notifies that the system has started up\n         */\n        STARTED_UP,\n        /**\n         * Notifies that the startup has failed\n         */\n        STARTUP_FAILURE,\n        /**\n         * Notifies that the system is being shut down\n         */\n        SHUTDOWN,\n        /**\n         * Signals that the command given executed successfully.\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_COMPLETE,\n        /**\n         * Signals that no command handler is installed for the given command\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_UNSUPPORTED,\n        /**\n         * Signals that the command failed to execute\n         *\n         * The details field will contain the command id.\n         *\n         * @see org.ulyssis.ipp.control\n         */\n        COMMAND_FAILED,\n        /**\n         * Signals that the processor's snapshot has been updated\n         */\n        NEW_SNAPSHOT,\n        /**\n         * Signals a miscellaneous error. The details field will contain more information\n         * about the error.\n         */\n        MISC_ERROR\n    }\n\n    /**\n     * Create a new status message with the given type and details.\n     *\n     * This message is to be broadcast by a StatusReporter to the\n     * status channel.\n     *\n     * @param type\n     *        The type of the status\n     * @param details\n     *        The details. The form of this field depends\n     *        on the type of message.\n     * @see org.ulyssis.ipp.status.StatusReporter\n     */\n    @JsonCreator\n    public StatusMessage(@JsonProperty(\"type\") MessageType type,\n                         @JsonProperty(\"details\") String details) {\n        this.type = type;\n        this.details = details;\n    }\n\n    public MessageType getType() {\n        return type;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/AddTagCommand.java\n@JsonTypeName(\"AddTag\")\npublic final class AddTagCommand extends TagCommand {\n\n    /**\n     * Create an AddTagCommand for the given tag and team number.\n     *\n     * The time is set to be the current time.\n     *\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(TagId tag, int teamNb) {\n        super(tag, teamNb);\n    }\n\n    /**\n     * Create an AddTagCommand for the given tag and team number at the given time.\n     *\n     * @param time\n     *        The time when to add the tag, this can be in the future for\n     *        an anticipated adding of a tag, or in the past, to add a tag\n     *        afterwards (e.g. as a correction)\n     * @param tag\n     *        The tag to add.\n     * @param teamNb\n     *        The team number to add the tag for.\n     */\n    public AddTagCommand(Instant time, TagId tag, int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    /*\n     * Only for deserialization.\n     */\n    @JsonCreator\n    private AddTagCommand(@JsonProperty(\"commandId\") String commandId,\n                          @JsonProperty(\"time\") Instant time,\n                          @JsonProperty(\"tag\") TagId tag,\n                          @JsonProperty(\"teamNb\") int teamNb) {\n        super(commandId, time, tag, teamNb);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetEndTimeCommand.java\n@JsonTypeName(\"SetEndTime\")\npublic final class SetEndTimeCommand extends Command {\n    public SetEndTimeCommand() {\n        super();\n    }\n\n    public SetEndTimeCommand(Instant endTime) {\n        super(endTime);\n    }\n\n    @JsonCreator\n    private SetEndTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/RemoveTagEvent.java\n@JsonTypeName(\"RemoveTag\")\npublic final class RemoveTagEvent extends TagEvent {\n    @JsonCreator\n    public RemoveTagEvent(\n            @JsonProperty(\"time\") Instant time,\n            @JsonProperty(\"tag\") TagId tag,\n            @JsonProperty(\"teamNb\") int teamNb) {\n        super(time, tag, teamNb);\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot snapshot) {\n        TeamTagMap newTeamTagMap = snapshot.getTeamTagMap().removeTag(getTag());\n        return Snapshot.builder(getTime(), snapshot).withTeamTagMap(newTeamTagMap).build();\n    }\n\n    public static RemoveTagEvent fromCommand(Command command) {\n        assert(command instanceof RemoveTagCommand);\n        RemoveTagCommand cmd = (RemoveTagCommand) command;\n        return new RemoveTagEvent(cmd.getTime(), cmd.getTag(), cmd.getTeamNb());\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/control/handlers/EventCommandHandler.java\npublic final class EventCommandHandler<EventT extends Event> implements CommandHandler {\n    private final Class<? extends Command> clazz;\n    private final Function<Command, EventT> toEvent;\n    private final BiConsumer<Event, Consumer<Boolean>> processCallback;\n\n    public EventCommandHandler(Class<? extends Command> clazz,\n                               Function<Command, EventT> toEvent,\n                               BiConsumer<Event, Consumer<Boolean>> processCallback) {\n        this.clazz = clazz;\n        this.toEvent = toEvent;\n        this.processCallback = processCallback;\n    }\n\n    @Override\n    public void handle(Command command, Consumer<Boolean> callback) {\n        Event event = toEvent.apply(command);\n        processCallback.accept(event, callback);\n    }\n\n    @Override\n    public Class<? extends Command> getCommandClass() {\n        return clazz;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/CorrectionCommand.java\n@JsonTypeName(\"Correction\")\npublic class CorrectionCommand extends Command {\n    private final int teamNb;\n    private final int correction;\n\n    /**\n     * Create a CorrectionCommand\n     * @param teamNb\n     *        The team number to correct\n     * @param correction\n     *        The correction in nb. of laps. Positive adds laps,\n     *        negative removes laps.\n     */\n    public CorrectionCommand(int teamNb, int correction) {\n        super();\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public CorrectionCommand(Instant time, int teamNb, int correction) {\n        super(time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    @JsonCreator\n    private CorrectionCommand(@JsonProperty(\"commandId\") String commandId,\n                              @JsonProperty(\"time\") Instant time,\n                              @JsonProperty(\"teamNb\") int teamNb,\n                              @JsonProperty(\"correction\") int correction) {\n        super(commandId, time);\n        this.teamNb = teamNb;\n        this.correction = correction;\n    }\n\n    public int getTeamNb() {\n        return teamNb;\n    }\n\n    public int getCorrection() {\n        return correction;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/TagId.java\n@JsonSerialize(using=TagId.Serializer.class)\n@JsonDeserialize(using=TagId.Deserializer.class)\npublic final class TagId {\n    private final String id;\n    private final String lowerCaseId;\n    private final int hashCode;\n\n    static class Serializer extends JsonSerializer<TagId> {\n        @Override\n        public void serialize(TagId value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n            jgen.writeString(value.toString());\n        }\n    }\n\n    static class Deserializer extends JsonDeserializer<TagId> {\n        @Override\n        public TagId deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n            return new TagId(jp.getValueAsString());\n        }\n    }\n\n    /**\n     * = Create a new TagId from the given byte array.\n     *\n     * @param id\n     *        The tag id in byte array form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(byte[] id) {\n        this(BaseEncoding.base16().lowerCase().encode(id));\n    }\n\n    /**\n     * = Create a new TagId from the given byte list.\n     *\n     * @param id\n     *        The tag id in byte list form. It will be\n     *        converted to a lowercase hex form.\n     */\n    public TagId(List<Byte> id) {\n        this(BaseEncoding.base16().lowerCase().encode(Bytes.toArray(id)));\n    }\n\n    /**\n     * = Create a new TagId\n     *\n     * @param id\n     *        A string that uniquely identifies the tag\n     * @throws java.lang.NullPointerException\n     *         A NullPointerException will be thrown if the given id is null.\n     */\n    public TagId(String id) throws NullPointerException {\n        if (id == null) throw new NullPointerException(\"The tag id is not allowed to be null!\");\n        this.id = id;\n        this.lowerCaseId = id.toLowerCase();\n        this.hashCode = this.lowerCaseId.hashCode();\n    }\n\n    /**\n     * = Get the tag id as a string\n     *\n     * @return This tag id as a string\n     */\n    @Override\n    public String toString() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) return true;\n        if (other == null) return false;\n        if (!(other instanceof TagId)) return false;\n        return this.lowerCaseId.equals(((TagId) other).lowerCaseId);\n    }\n\n    @Override\n    public int hashCode() {\n        return this.hashCode;\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/control/commands/SetStartTimeCommand.java\n@JsonTypeName(\"SetStartTime\")\npublic final class SetStartTimeCommand extends Command {\n    public SetStartTimeCommand() {\n        super();\n    }\n\n    public SetStartTimeCommand(Instant startTime) {\n        super(startTime);\n    }\n\n    @JsonCreator\n    private SetStartTimeCommand(@JsonProperty(\"commandId\") String commandId,\n                                @JsonProperty(\"time\") Instant time) {\n        super(commandId, time);\n    }\n}\nshared/src/main/java/org/ulyssis/ipp/config/Config.java\npublic class Config {\n    private static final Logger LOG = LogManager.getLogger(Config.class);\n\n    private double trackLength;\n    private ImmutableList<ReaderConfig> readers = ImmutableList.of();\n    private ImmutableList<URI> speedwayURIs = ImmutableList.of();\n    private ImmutableList<Team> teams = ImmutableList.of();\n    private long retryInterval = 5000L;\n    private long minUpdateInterval = 5000L;\n    private long maxUpdateInterval = 30000L;\n    private String statusChannel = \"status\";\n    private String updateChannel = \"update\";\n    private String updatesList = \"updates\";\n    private String updatesSet = \"updates\";\n    private String controlChannel = \"control\";\n\n    /**\n     * Private constructor used by Jackson\n     */\n    private Config() {\n    }\n    \n    /**\n     * Create a configuration from the given configuration file.\n     * \n     * Expects the configuration file to be UTF-8 formatted.\n     */\n    public static Optional<Config> fromConfigurationFile(Path configFile) {\n        try {\n            byte[] config = Files.readAllBytes(configFile);\n            Charset charset = Charset.forName(\"utf-8\");\n            String configString = charset.decode(ByteBuffer.wrap(config)).toString();\n            return fromConfigurationString(configString);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration file: {}\", configFile, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Create a configuration from the given JSON configuration string.\n     */\n    public static Optional<Config> fromConfigurationString(String configuration) {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.findAndRegisterModules();\n        try {\n            Config result = mapper.readValue(configuration, Config.class);\n            return Optional.of(result);\n        } catch (IOException e) {\n            LOG.error(\"Error reading configuration\", e);\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Get the track length in meters.\n     */\n    public double getTrackLength() {\n        return trackLength;\n    }\n\n    public ImmutableList<ReaderConfig> getReaders() {\n        return readers;\n    }\n    public ReaderConfig getReader(int readerId) {\n        return this.readers.get(readerId);\n    }\n    public int getNbReaders() {\n        return readers.size();\n    }\n\n    public ImmutableList<URI> getSpeedwayURIs() {\n        return speedwayURIs;\n    }\n    /**\n     * Get the URI of the Impinj Speedway corresponding\n     * to the reader with the given id. This id ranges from 0 to\n     * getSpeedwayURIs.size() - 1\n     */\n    public URI getSpeedwayURI(int readerId) {\n        return speedwayURIs.get(readerId);\n    }\n    public int getNbSpeedways() {\n        return speedwayURIs.size();\n    }\n\n    /**\n     * The retry interval for connections in ms.\n     */\n    public long getRetryInterval() {\n        return retryInterval;\n    }\n    \n    /**\n     * The minimum amount of time in ms between two updates, any\n     * update within this amount of time is ignored.\n     */\n    public long getMinUpdateInterval() {\n        return minUpdateInterval;\n    }\n    \n    /**\n     * The maximum time in ms to wait for an update before issuing a warning.\n     */\n    public long getMaxUpdateInterval() {\n        return maxUpdateInterval;\n    }\n    \n    /**\n     * Gets the Redis channel name on which status updates are posted.\n     *\n     * Defaults to \"status\".\n     *\n     * Generally, the db id will be added to the prefix, because\n     * pubsub channels are not database-specific in Redis.\n     */\n    public String getStatusChannel() {\n        return statusChannel;\n    }\n    \n    /**\n     * The prefix of the channel where the reader announces new updates.\n     *\n     * This prefix defaults to \"update\". Generally, the db id will be added\n     * to the prefix, because if multiple readers would use the same Redis\n     * instance (e.g. for testing purposes), these would collide, because\n     * pubsub channels are not database-specific.\n     */\n    public String getUpdateChannel() {\n        return updateChannel;\n    }\n\n    /**\n     * The prefix of the channel where an entity in the system receives control messages.\n     *\n     * This defaults to \"control\". Generally, the db id will be added to this prefix,\n     * because pubsub channels are not database-specific in Redis.\n     */\n    public String getControlChannel() {\n        return controlChannel;\n    }\n\n    /**\n     * The name of the list where readers push their updates on.\n     *\n     * Defaults to \"updates\".\n     */\n    public String getUpdatesList() {\n        return updatesList;\n    }\n\n    /**\n     * The name of the set in which updates are stored in the processor.\n     */\n    public String getUpdatesSet() {\n        return updatesSet;\n    }\n\n    /**\n     * The teams, with team number and name.\n     */\n    public ImmutableList<Team> getTeams() {\n        return teams;\n    }\n\n    // TODO: Maybe find some other solution?\n    private static Config currentConfig;\n\n    public static void setCurrentConfig(Config config) {\n        currentConfig = config;\n    }\n\n    public static Config getCurrentConfig() {\n        return currentConfig;\n    }\n}\nProcessor/src/main/java/org/ulyssis/ipp/snapshot/StatusChangeEvent.java\n@JsonTypeName(\"StatusChange\")\npublic final class StatusChangeEvent extends Event {\n    private final Status status;\n\n    @JsonCreator\n    public StatusChangeEvent(@JsonProperty(\"time\") Instant time,\n                             @JsonProperty(\"status\")Status status) {\n        super(time);\n        this.status = status;\n    }\n\n    public Status getStatus() {\n        return status;\n    }\n\n    public static StatusChangeEvent fromCommand(Command command) {\n        assert(command instanceof SetStatusCommand);\n        SetStatusCommand cmd = (SetStatusCommand) command;\n        return new StatusChangeEvent(cmd.getTime(), cmd.getStatus());\n    }\n\n    @Override\n    protected Snapshot doApply(Snapshot before) {\n        Snapshot.Builder builder = Snapshot.builder(getTime(), before).withStatus(status);\n        if (!before.getStatus().isPublic() && status.isPublic()) {\n            builder.withPublicTeamStates(before.getTeamStates());\n        }\n        return builder.build();\n    }\n\n    @Override\n    public boolean isRemovable() {\n        return true;\n    }\n}\n", "answers": ["                new EventCommandHandler<>(SetUpdateFrequencyCommand.class, UpdateFrequencyChangeEvent::fromCommand, this::queueEvent));"], "pred": "  queueEvent::fromCommand::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::fromEvent::", "length": 6872, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "2c164c959e45cbd40c80a8618dfe2fbe7d12a613e0ce71c4"}
{"prompt": "Please complete the code given below. \nsrc/main/java/uw/task/util/LocalRateLimiter.java\npublic class LocalRateLimiter {\r\n\r\n    private ConcurrentHashMap<String, RateLimiter> map = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u83b7\u5f97\u9650\u5236\u5141\u8bb8\u72b6\u6001\u3002\r\n     *\r\n     * @param name\r\n     * @return\r\n     */\r\n    public boolean tryAcquire(String name, int requests, int seconds, long waitTime, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return true;\r\n        }\r\n        final double rate = (double) requests / (double) seconds;\r\n        RateLimiter limiter = map.computeIfAbsent(name, key -> RateLimiter.create(rate));\r\n        if (limiter != null) {\r\n            //\u68c0\u67e5\u5e76\u4fee\u6539\r\n            if (limiter.getRate() != rate) {\r\n                limiter.setRate(rate);\r\n            }\r\n            return limiter.tryAcquire(permits, waitTime, TimeUnit.SECONDS);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskFactory.java\npublic class TaskFactory {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskFactory.class);\n\n    /**\n     * rabbitTemplate\u6a21\u677f.\n     */\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * \u5168\u5c40sequence\u5e8f\u5217\uff0c\u4e3b\u8981\u7528\u4e8etaskLog\u65e5\u5fd7\u3002\n     */\n    private GlobalSequenceManager globalSequenceManager;\n\n    /**\n     * \u7528\u4e8e\u672c\u5730\u6267\u884c\u4efb\u52a1\u7684taskConsumer\u3002\n     */\n    private TaskRunnerContainer taskRunnerContainer;\n\n    /**\n     * rpc\u5f02\u6b65\u8c03\u7528\u7ebf\u7a0b\u6c60\n     */\n    private ExecutorService taskRpcService = null;\n\n    /**\n     * \u6700\u5927\u91cd\u8bd5\u6b21\u6570\u3002\n     */\n    private static final int MAX_RETRY_TIMES = 10;\n\n\n    public TaskFactory(TaskProperties taskProperties, RabbitTemplate rabbitTemplate,\n                       TaskRunnerContainer taskRunnerContainer, GlobalSequenceManager globalSequenceManager) {\n        this.rabbitTemplate = rabbitTemplate;\n        this.taskRunnerContainer = taskRunnerContainer;\n        this.globalSequenceManager = globalSequenceManager;\n        taskRpcService = new ThreadPoolExecutor(taskProperties.getTaskRpcMinThreadNum(),\n                taskProperties.getTaskRpcMaxThreadNum(), 20L, TimeUnit.SECONDS, new SynchronousQueue<>(),\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"TaskRpc-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    }\n\n    /**\n     * \u628a\u4efb\u52a1\u53d1\u9001\u5230\u961f\u5217\u4e2d\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     */\n    public void sendToQueue(final TaskData<?, ?> taskData) {\n        Message message = buildTaskQueueMessage(taskData);\n        String queue = message.getMessageProperties().getConsumerQueue();\n        //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n        for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n            try {\n                if (i > 0) {\n                    Thread.sleep(i * 500);\n                }\n                rabbitTemplate.send(queue, queue, message);\n                return;\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n        throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n    }\n\n    /**\n     * \u6784\u9020Task\u6d88\u606f\u5bf9\u8c61\uff0c\u6b64\u65b9\u6cd5\u7528\u4e8e\u63d0\u524d\u6784\u9020TaskData\u3002\n     *\n     * @param taskData\n     * @return\n     */\n    private Message buildTaskQueueMessage(final TaskData taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        taskData.setRunType(TaskData.RUN_TYPE_GLOBAL);\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setConsumerQueue(TaskMetaInfoManager.getFitQueue(taskData));\n        Message msg = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n        return msg;\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTask(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n            for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                try {\n                    if (i > 0) {\n                        Thread.sleep(i * 500);\n                    }\n                    Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                    return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n            throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n        }\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTaskLocal(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            throw new TaskRuntimeException(taskData.getClass().getName() + \" is not a local task! \");\n        }\n    }\n\n    /**\n     * \u8fdc\u7a0b\u8fd0\u884c\u4efb\u52a1\uff0c\u5e76\u8fd4\u56defuture<TaskData<?,?>>\u3002 \u5982\u679c\u9700\u8981\u83b7\u5f97\u6570\u636e\uff0c\u53ef\u4ee5\u4f7f\u7528futrue.get()\u6765\u83b7\u5f97\u3002\n     * \u6b64\u65b9\u6cd5\u8981\u8c28\u614e\u4f7f\u7528\uff0c\u56e0\u4e3atask\u5b58\u5728\u9650\u901f\uff0c\u5927\u5e76\u53d1\u4e0b\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7ebf\u7a0b\u6570\u8d85\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> Future<TaskData<TP, RD>> runTaskAsync(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            return taskRpcService.submit(() -> {\n                taskRunnerContainer.process(taskData);\n                return taskData;\n            });\n        } else {\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            return taskRpcService.submit(() -> {\n                //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n                for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                    try {\n                        if (i > 0) {\n                            Thread.sleep(i * 500);\n                        }\n                        Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                        return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                    } catch (Exception e) {\n                        log.error(e.getMessage(), e);\n                    }\n                }\n                throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n            });\n        }\n    }\n\n    /**\n     * \u83b7\u5f97\u961f\u5217\u4fe1\u606f\u3002\n     *\n     * @param queueName\n     * @return 0 \u662f\u6d88\u606f\u6570\u91cf 1 \u662f\u6d88\u8d39\u8005\u6570\u91cf\n     */\n    public int[] getQueueInfo(String queueName) {\n        AMQP.Queue.DeclareOk declareOk = this.rabbitTemplate.execute(new ChannelCallback<AMQP.Queue.DeclareOk>() {\n            public AMQP.Queue.DeclareOk doInRabbit(Channel channel) throws Exception {\n                return channel.queueDeclarePassive(queueName);\n            }\n        });\n        return new int[]{declareOk.getMessageCount(), declareOk.getConsumerCount()};\n    }\n\n    /**\n     * \u6e05\u9664\u961f\u5217\u3002\n     *\n     * @param queueName\n     * @return \u88ab\u6e05\u9664\u7684\u961f\u5217\u6570\n     */\n    public int purgeQueue(String queueName) {\n        return this.rabbitTemplate.execute(channel -> {\n            AMQP.Queue.PurgeOk queuePurged = channel.queuePurge(queueName);\n            return queuePurged.getMessageCount();\n        });\n    }\n\n}\nsrc/main/java/uw/task/listener/RunnerTaskListener.java\npublic interface RunnerTaskListener {\r\n\r\n    /**\r\n     * \u6267\u884c\u524d\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPreExecute(TaskData data);\r\n\r\n    /**\r\n     * \u6267\u884c\u540e\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPostExecute(TaskData data);\r\n\r\n}\r\nsrc/main/java/uw/task/util/GlobalRateLimiter.java\npublic class GlobalRateLimiter {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(GlobalRateLimiter.class);\r\n\r\n    private static final String REDIS_PREFIX = \"TaskRateLimit:\";\r\n\r\n    private final RedisTemplate<String, Long> redisTemplate;\r\n\r\n    /**\r\n     * LUA\u811a\u672c\u3002\r\n     * \u8fd4\u56de\u503c\u4e3a\uff1a\u53ef\u7528\u8bf7\u6c42\u6570,\u7b49\u5f85\u6beb\u79d2\u6570\u3002\r\n     */\r\n    private static final RedisScript<Long> LUA_RATE_LIMIT = RedisScript.of(\r\n            \"local key = KEYS[1];\\n\" +\r\n                    \"local requests = tonumber(ARGV[1]);\\n\" +\r\n                    \"local millis = tonumber(ARGV[2])*1000;\\n\" +\r\n                    \"local permits = tonumber(ARGV[3]);\\n\" +\r\n                    \"local remainRequests=0;\\n\" +\r\n                    \"local waitMillis=0;\\n\" +\r\n                    \"local nowRate= redis.call('INCRBY', key,permits);\\n\" +\r\n                    \"if (nowRate==permits) then \\n\" +//\u5982\u679c\u662f\u7b2c\u4e00\u6b21\u6267\u884c\uff0c\u8bbe\u7f6e\u6709\u6548\u671f\u4fdd\u62a4\u3002\r\n                    \"    redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"end\\n\" +\r\n                    \"remainRequests = requests-nowRate;\\n\" +\r\n                    \"if (remainRequests<1) then \\n\" +//\u8bf7\u6c42\u6570\u8d85\u8fc7\u9650\u5236\r\n                    \"    waitMillis = redis.call('PTTL',key);\\n\" +\r\n                    \"    if (waitMillis == -1) then \\n\" +\r\n                    \"        redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"        waitMillis = millis;\\n\" +\r\n                    \"    end\\n\" +\r\n                    \"end \\n\" +\r\n                    \"return waitMillis\", Long.class);\r\n\r\n\r\n    public GlobalRateLimiter(final RedisConnectionFactory redisConnectionFactory) {\r\n        redisTemplate = new RedisTemplate<String, Long>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericToStringSerializer<Long>(Long.class));\r\n        redisTemplate.setExposeConnection(true);\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.afterPropertiesSet();\r\n    }\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u53ef\u5426\u83b7\u5f97\u6388\u6743\u3002\r\n     *\r\n     * @param permits       \u7533\u8bf7\u8bbf\u95ee\u6b21\u6570\r\n     * @return \u5982\u679c\u672a\u8d85\u9650\u5219\u8fd4\u56de0\uff0c-1\u4e3a\u4e0d\u786e\u5b9a\u65f6\u95f4\uff0c\u5176\u4ed6\u4e3a\u9700\u8981\u7b49\u5f85\u7684\u6beb\u79d2\u6570\r\n     */\r\n    public long tryAcquire(String name, int requests, int seconds, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return 0;\r\n        }\r\n        Long waitLimit = redisTemplate.execute(LUA_RATE_LIMIT, Collections.singletonList(REDIS_PREFIX + name), requests,seconds, permits);\r\n        if (waitLimit==null)\r\n            return 0;\r\n        else\r\n            return waitLimit;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/exception/TaskPartnerException.java\npublic class TaskPartnerException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskPartnerException() {\r\n        super();\r\n    }\r\n\r\n    public TaskPartnerException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskPartnerException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskPartnerException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/TaskData.java\npublic class TaskData<TP, RD> implements Serializable {\n\n    /**\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 1333167065535557828L;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u672a\u8bbe\u7f6e\n     */\n    public static final int STATE_UNKNOWN = 0;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6210\u529f\n     */\n    public static final int STATE_SUCCESS = 1;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7a0b\u5e8f\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PROGRAM = 2;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u914d\u7f6e\u9519\u8bef\uff0c\u5982\u8d85\u8fc7\u6d41\u91cf\u9650\u5236\n     */\n    public static final int STATE_FAIL_CONFIG = 3;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7b2c\u4e09\u65b9\u63a5\u53e3\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PARTNER = 4;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6570\u636e\u9519\u8bef\n     */\n    public static final int STATE_FAIL_DATA = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u672c\u5730\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_LOCAL = 1;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_GLOBAL = 3;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\n     */\n    public static final int RUN_TYPE_GLOBAL_RPC = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u81ea\u52a8\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\uff0c\u4f7f\u7528\u6b64\u6a21\u5f0f\uff0c\u4f1a\u81ea\u52a8\u9009\u62e9\u672c\u5730\u8fd8\u8fdc\u7a0b\u8fd0\u884c\u6a21\u5f0f\u3002\n     */\n    public static final int RUN_TYPE_AUTO_RPC = 6;\n\n    /**\n     * \u81ea\u52a8\u91cd\u8bd5[\u4e3a\u4e86\u517c\u5bb9,\u9ed8\u8ba4\u5f00\u542f\u91cd\u8bd5]\n     */\n    public static final int RETRY_TYPE_AUTO = 0;\n\n    /**\n     * \u7528\u6237\u624b\u5de5\u91cd\u8bd5\n     */\n    public static final int RETRY_TYPE_MANUAL = 1;\n\n    /**\n     * id\uff0c\u6b64\u5e8f\u5217\u503c\u7531\u6846\u67b6\u81ea\u52a8\u751f\u6210\uff0c\u65e0\u9700\u624b\u5de5\u8bbe\u7f6e\u3002\n     */\n    private long id;\n\n    /**\n     * \u5173\u8054TAG\uff0c\u7531\u8c03\u7528\u65b9\u8bbe\u5b9a\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private String refTag;\n\n    /**\n     * \u5173\u8054id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refId;\n\n    /**\n     * \u5173\u8054\u5b50id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refSubId;\n\n    /**\n     * \u5173\u8054\u5bf9\u8c61\uff0c\u6b64\u5bf9\u8c61\u4e0d\u5b58\u5165\u6570\u636e\u5e93\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7Listener\u6765\u8bbf\u95ee\u3002\n     */\n    @JsonIgnore\n    private Object refObject;\n\n    /**\n     * \u6d41\u91cf\u9650\u5236TAG\u3002\n     */\n    private String rateLimitTag;\n\n    /**\n     * \u9700\u8981\u6267\u884c\u7684\u7c7b\u540d\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u7531\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private String taskClass = \"\";\n\n    /**\n     * \u4efb\u52a1\u6807\u7b7e\uff0c\u7528\u4e8e\u7ec6\u5206\u4efb\u52a1\u961f\u5217\uff0c\u652f\u6301\u591a\u5b9e\u4f8b\u8fd0\u884c\u3002\n     */\n    private String taskTag = \"\";\n\n    /**\n     * \u4efb\u52a1\u5ef6\u8fdf\u6beb\u79d2\u6570\u3002\u4e00\u822c\u8fd9\u4e2a\u65f6\u95f4\u4e0d\u5b9c\u592a\u957f\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4e0d\u8981\u8d85\u8fc760\u79d2\u3002\n     */\n    private long taskDelay;\n\n    /**\n     * \u6267\u884c\u53c2\u6570\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u6709\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private TP taskParam;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u7c7b\u578b\uff0c\u9ed8\u8ba4\u4e3a\u81ea\u52a8RPC\uff0c\u6839\u636e\u60c5\u51b5\u9009\u62e9\u672c\u5730\u8fd8\u662f\u8fdc\u7a0b\u8fd0\u884c\u3002\n     */\n    private int runType = RUN_TYPE_AUTO_RPC;\n\n    /**\n     * \u91cd\u8bd5\u7c7b\u578b\n     */\n    private int retryType;\n\n    /**\n     * \u6307\u5b9a\u8fd0\u884c\u76ee\u6807\u3002\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aIP\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostIp;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aID\uff08\u53ef\u80fd\u4e3adocker\u7684ContainerID\uff09\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostId;\n\n    /**\n     * \u8fdb\u5165\u961f\u5217\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date queueDate;\n\n    /**\n     * \u5f00\u59cb\u6d88\u8d39\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date consumeDate;\n\n    /**\n     * \u5f00\u59cb\u8fd0\u884c\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date runDate;\n\n    /**\n     * \u8fd0\u884c\u7ed3\u675f\u65e5\u671f\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date finishDate;\n\n    /**\n     * \u6267\u884c\u4fe1\u606f\uff0c\u7528\u4e8e\u5b58\u50a8\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private RD resultData;\n\n    /**\n     * \u51fa\u9519\u4fe1\u606f\n     */\n    private String errorInfo;\n\n    /**\n     * \u5df2\u7ecf\u6267\u884c\u7684\u6b21\u6570\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int ranTimes;\n\n    /**\n     * \u6267\u884c\u72b6\u6001\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u6839\u636e\u5f02\u5e38\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int state;\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * @param id the id to set\n     */\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return refId;\n    }\n\n    /**\n     * @param refId the refId to set\n     */\n    public void setRefId(long refId) {\n        this.refId = refId;\n    }\n\n    /**\n\t * @return the refSubId\n\t */\n\tpublic long getRefSubId() {\n\t\treturn refSubId;\n\t}\n\n\t/**\n\t * @param refSubId the refSubId to set\n\t */\n\tpublic void setRefSubId(long refSubId) {\n\t\tthis.refSubId = refSubId;\n\t}\n\n\t/**\n\t * @return the refTag\n\t */\n\tpublic String getRefTag() {\n\t\treturn refTag;\n\t}\n\n\t/**\n\t * @param refTag the refTag to set\n\t */\n\tpublic void setRefTag(String refTag) {\n\t\tthis.refTag = refTag;\n\t}\n\n\t/**\n\t * @return the rateLimitTag\n\t */\n\tpublic String getRateLimitTag() {\n\t\treturn rateLimitTag;\n\t}\n\n\t/**\n\t * @param rateLimitTag the rateLimitTag to set\n\t */\n\tpublic void setRateLimitTag(String rateLimitTag) {\n\t\tthis.rateLimitTag = rateLimitTag;\n\t}\n\n\t/**\n\t * @return the refObject\n\t */\n\tpublic Object getRefObject() {\n\t\treturn refObject;\n\t}\n\n    /**\n     * @param refObject the refObject to set\n     */\n    public void setRefObject(Object refObject) {\n        this.refObject = refObject;\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    /**\n     * @param taskClass the taskClass to set\n     */\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    /**\n\t * @return the taskTag\n\t */\n\tpublic String getTaskTag() {\n\t\treturn taskTag;\n\t}\n\n\tpublic long getTaskDelay() {\n\t\treturn taskDelay;\n\t}\n\n\tpublic void setTaskDelay(long taskDelay) {\n\t\tthis.taskDelay = taskDelay;\n\t}\n\n\t/**\n\t * @param taskTag the taskTag to set\n\t */\n\tpublic void setTaskTag(String taskTag) {\n\t\tthis.taskTag = taskTag;\n\t}\n\n\t/**\n     * @return the taskParam\n     */\n    public TP getTaskParam() {\n        return taskParam;\n    }\n\n    /**\n     * @param taskParam the taskParam to set\n     */\n    public void setTaskParam(TP taskParam) {\n        this.taskParam = taskParam;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return runType;\n    }\n\n    /**\n     * @param runType the runType to set\n     */\n    public void setRunType(int runType) {\n        this.runType = runType;\n    }\n\n    public int getRetryType() {\n        return retryType;\n    }\n\n    public void setRetryType(int retryType) {\n        this.retryType = retryType;\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    /**\n     * @param runTarget the runTarget to set\n     */\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * @param hostIp the hostIp to set\n     */\n    public void setHostIp(String hostIp) {\n        this.hostIp = hostIp;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return queueDate;\n    }\n\n    /**\n     * @param queueDate the queueDate to set\n     */\n    public void setQueueDate(Date queueDate) {\n        this.queueDate = queueDate;\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return consumeDate;\n    }\n\n    /**\n     * @param consumeDate the consumeDate to set\n     */\n    public void setConsumeDate(Date consumeDate) {\n        this.consumeDate = consumeDate;\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return runDate;\n    }\n\n    /**\n     * @param runDate the runDate to set\n     */\n    public void setRunDate(Date runDate) {\n        this.runDate = runDate;\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return finishDate;\n    }\n\n    /**\n     * @param finishDate the finishDate to set\n     */\n    public void setFinishDate(Date finishDate) {\n        this.finishDate = finishDate;\n    }\n\n    /**\n     * @return the resultData\n     */\n    public RD getResultData() {\n        return resultData;\n    }\n\n    /**\n     * @param resultData the resultData to set\n     */\n    public void setResultData(RD resultData) {\n        this.resultData = resultData;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return errorInfo;\n    }\n\n    /**\n     * @param errorInfo the errorInfo to set\n     */\n    public void setErrorInfo(String errorInfo) {\n        this.errorInfo = errorInfo;\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return ranTimes;\n    }\n\n    /**\n     * @param ranTimes the ranTimes to set\n     */\n    public void setRanTimes(int ranTimes) {\n        this.ranTimes = ranTimes;\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * @param status the status to set\n     */\n    public void setState(int status) {\n        this.state = status;\n    }\n\n}\nsrc/main/java/uw/task/TaskRunner.java\npublic abstract class TaskRunner<TP, RD> {\r\n\r\n    /**\r\n     * \u6267\u884c\u4efb\u52a1\u3002\r\n     * \u4e1a\u52a1\u5c42\u9762\u7684\u5f02\u5e38\u8bf7\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u624b\u52a8Throw TaskException:\r\n     * \u76ee\u524d\u652f\u6301\u7684\u5f02\u5e38:\r\n     * 1. TaskDataException \u4efb\u52a1\u6570\u636e\u5f02\u5e38\r\n     * 2. TaskPartnerException \u4efb\u52a1\u5408\u4f5c\u65b9\u5f02\u5e38\r\n     *\r\n     * @param taskData \u6570\u636e\r\n     * @throws Exception \u5f02\u5e38\r\n     * @return \u6307\u5b9a\u7684\u8fd4\u56de\u5bf9\u8c61\r\n     */\r\n    public abstract RD runTask(TaskData<TP, RD> taskData) throws Exception;\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u914d\u7f6e\u4fe1\u606f\r\n     *\r\n     * @return TaskRunnerConfig\u914d\u7f6e\r\n     */\r\n    public abstract TaskRunnerConfig initConfig();\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     *\r\n     * @return TaskContact\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     */\r\n    public abstract TaskContact initContact();\r\n}\nsrc/main/java/uw/task/conf/TaskMetaInfoManager.java\npublic class TaskMetaInfoManager {\r\n\r\n\t/**\r\n\t * \u8fd0\u884c\u4e3b\u673a\u914d\u7f6e\r\n\t */\r\n\tstatic List<String> targetConfig = null;\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tstatic Map<String, TaskRunner> runnerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic Map<String, TaskCroner> cronerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskRunnerConfig> runnerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskCronerConfig> cronerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u8fd0\u884c\u5b9e\u4f8b\u3002\r\n\t *\r\n\t * @param taskClass\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunner<?, ?> getRunner(String taskClass) {\r\n\t\treturn runnerMap.get(taskClass);\r\n\t}\r\n\r\n\t/**\r\n\t * \u68c0\u67e5\u4e00\u4e2arunner\u662f\u5426\u53ef\u4ee5\u5728\u672c\u5730\u8fd0\u884c\u3002\r\n\t * \r\n\t * @param taskData\r\n\t * @return\r\n\t */\r\n\tpublic static boolean checkRunnerRunLocal(TaskData<?, ?> taskData) {\r\n\t\treturn runnerMap.containsKey(taskData.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u6839\u636e\u670d\u52a1\u5668\u7aefQueue\u5217\u8868\uff0c\u8fd4\u56de\u5408\u9002\u7684key\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getFitQueue(TaskData<?, ?> data) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tif (runnerConfigMap.containsKey(all)) {\r\n\t\t\treturn all;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            if (runnerConfigMap.containsKey(test)) {\r\n                return test;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u6700\u540e\u90fd\u6ca1\u5339\u914d\u5230\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e\r\n\t\treturn all;\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u914d\u7f6e\r\n\t *\r\n\t * @param data\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunnerConfig getRunnerConfig(TaskData<?, ?> data) {\r\n\t\tTaskRunnerConfig config = null;\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tconfig = runnerConfigMap.get(all);\r\n\t\tif (config != null) {\r\n\t\t\treturn config;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            config = runnerConfigMap.get(test);\r\n            if (config != null) {\r\n                return config;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new RuntimeException(\"\u627e\u4e0d\u5230\u4efb\u52a1\u914d\u7f6e: taskClass = \" + data.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u66f4\u65b0\u7cfb\u7edf\u961f\u5217\u8868\u3002\r\n\t * \r\n\t * @param config\r\n\t */\r\n\tstatic void updateSysQueue(final TaskRunnerConfig config) {\r\n\t\tString key = getRunnerConfigKey(config);\r\n\t\t// \u68c0\u6d4b\u662f\u5426\u8001\u7684TaskRunnerConfig\u662f\u5426\u662f\u672c\u5730\u7684\u5b8c\u6574\u914d\u7f6e\uff0c\u5982\u679c\u662f\uff0c\u5219\u4e0d\u7ba1\u3002\r\n\t\tTaskRunnerConfig old = runnerConfigMap.get(key);\r\n\t\tif (old == null || (old != null && old.getCreateDate() == null)) {\r\n\t\t\tif (config.getState() < 1) {\r\n\t\t\t\trunnerConfigMap.remove(key);\r\n\t\t\t} else {\r\n\t\t\t\trunnerConfigMap.put(key, config);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97croner\u914d\u7f6e\u952e\u3002 \u4f7f\u7528taskClass#Id$target\u6765\u914d\u7f6e\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getCronerConfigKey(TaskCronerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskParam() != null && config.getTaskParam().length() > 0) {\r\n\t\t\tsb.append(config.getId());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97Runner\u914d\u7f6e\u7ed3\u5408Host\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getRunnerConfigKey(TaskRunnerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskTag() != null && config.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(config.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n    /**\r\n     * \u83b7\u5f97RunnerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getRunnerLogKey(TaskData<?,?> log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskTag() != null && log.getTaskTag().length() > 0) {\r\n            sb.append(log.getTaskTag());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97CronerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getCronerLogKey(TaskCronerLog log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskParam() != null && log.getTaskParam().length()>0){\r\n            sb.append(log.getTaskParam());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\nsrc/main/java/uw/task/api/TaskAPI.java\npublic class TaskAPI {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskAPI.class);\n\n    /**\n     * Task\u914d\u7f6e\u6587\u4ef6\n     */\n    private TaskProperties taskProperties;\n\n    /**\n     * Rest\u6a21\u677f\u7c7b\n     */\n    private RestTemplate restTemplate;\n\n    /**\n     * \u65e5\u5fd7\u5ba2\u6237\u7aef\u3002\n     */\n    private LogClient logClient = null;\n\n    /**\n     * \u672c\u673a\u7684\u5916\u7f51IP\n     */\n    private String hostIp = \"\";\n\n    public TaskAPI(final TaskProperties taskProperties, final RestTemplate restTemplate,\n                   final LogClient logClient) {\n        this.taskProperties = taskProperties;\n        this.restTemplate = restTemplate;\n        this.logClient = logClient;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u76ee\u6807\u914d\u7f6e\u3002\n     *\n     * @return\n     */\n    public List<String> getServerTargetConfig() {\n        List<String> targetConfig = null;\n        // \u5224\u65ad\u662f\u5426\u662f\u79c1\u6709\u6a21\u5f0f\u3002\n        boolean privacyMode = taskProperties.isPrivacyMode();\n        try {\n            String[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/target/config?targetType={targetType}\", String[].class,\n                    privacyMode ? 1 : 0);\n            targetConfig = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getHostConfig()\u670d\u52a1\u7aefTarget\u914d\u7f6e\u62c9\u53d6\u5f02\u5e38:{}\", e.getMessage());\n        }\n        if (targetConfig == null || targetConfig.size() == 0) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"\u83b7\u5f97\u4e3b\u673aTarget\u670d\u52a1\u7aef\u914d\u7f6e\u5931\u8d25\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e\u9879!\");\n            }\n            targetConfig = new ArrayList<>();\n            if (!privacyMode) {\n                targetConfig.add(\"\");\n            }\n        }\n        return targetConfig;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u72b6\u6001\uff0c\u8fd4\u56de\u4e3b\u673aIP\u5730\u5740\u3002\n     *\n     * @return \u4e3b\u673aIP\u5730\u5740\n     */\n    public String updateHostStatus() {\n        String ip = \"\";\n        TaskHostStatus taskHostStatus = new TaskHostStatus();\n        taskHostStatus.setHostId(taskProperties.getHostId());\n        taskHostStatus.setTaskProject(taskProperties.getProject());\n        try {\n            ip = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/host/status\", taskHostStatus,\n                    String.class);\n            hostIp = ip;\n        } catch (Exception e) {\n            log.error(\"TaskAPI.updateHostStatus()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return ip;\n    }\n\n    /**\n     * \u521d\u59cb\u5316CronerConfig\u3002\n     *\n     * @param config\n     */\n    public TaskCronerConfig initTaskCronerConfig(TaskCronerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/croner/config\", config,\n                    TaskCronerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskCronerConfig\u4e0a\u4f20Croner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n    }\n\n    /**\n     * \u521d\u59cb\u5316RunnerConfig\n     *\n     * @param config\n     */\n    public TaskRunnerConfig initTaskRunnerConfig(TaskRunnerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/runner/config\", config,\n                    TaskRunnerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskRunnerConfig\u4e0a\u4f20Runner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n\n    }\n\n    /**\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\u3002\n     *\n     * @param contact\n     */\n    public void initTaskContact(TaskContact contact) {\n        try {\n            restTemplate.postForLocation(taskProperties.getTaskCenterHost() + \"/taskapi/contact\", contact);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskContact\u4e0a\u4f20\u8054\u7cfb\u4eba\u4fe1\u606f\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n    }\n\n    /**\n     * \u6839\u636e\u66f4\u65b0\u65f6\u95f4\u83b7\u5f97\u53d8\u5316\u7684TaskRunner\u961f\u5217\u5217\u8868\u3002\n     *\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerQueueList(long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/runner/queue?lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerQueueList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskRunner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/runner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskCroner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskCronerConfig> getTaskCronerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskCronerConfig> list = null;\n        try {\n            TaskCronerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskCronerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskCronerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u53d1\u9001Runner\u4efb\u52a1\u65e5\u5fd7\u3002\n     *\n     * @param log\n     */\n    public void sendTaskRunnerLog(TaskRunnerLog log) {\n        logClient.log(log);\n    }\n\n    /**\n     * \u53d1\u9001CronLog\u65e5\u5fd7\n     *\n     * @param configId      \u914d\u7f6eId,\u65b9\u4fbf\u66f4\u65b0\u4e0b\u4e00\u6b21\u6267\u884c\u65f6\u95f4\n     * @param taskCronerLog \u65e5\u5fd7\u5bf9\u8c61\n     */\n    public void sendTaskCronerLog(long configId, TaskCronerLog taskCronerLog) {\n        try {\n            restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/tick?id={id}&nextDate={nextDate}\",\n                    Integer.class, configId, taskCronerLog.getNextDate().getTime());\n        } catch (Exception e) {\n            log.error(\"TaskAPI.cornerTick()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38: \" + e.getMessage(), e);\n        }\n\n        int logLevel = taskCronerLog.getLogLevel();\n        int logLimitSize = taskCronerLog.getLogLimitSize();\n        if (logLevel > TaskCronerConfig.TASK_LOG_TYPE_NONE) {\n            switch (logLevel) {\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD: {\n                    taskCronerLog.setTaskParam(null);\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM: {\n                    String taskParam = taskCronerLog.getTaskParam();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                        taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA: {\n                    String resultData = taskCronerLog.getResultData();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                        taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setTaskParam(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_ALL: {\n                    if (logLimitSize > 0) {\n                        String taskParam = taskCronerLog.getTaskParam();\n                        String resultData = taskCronerLog.getResultData();\n                        if (StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                            taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                        }\n                        if (StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                            taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                        }\n                    }\n                }\n                break;\n            }\n            logClient.log(taskCronerLog);\n        }\n    }\n}\nsrc/main/java/uw/task/exception/TaskDataException.java\npublic class TaskDataException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskDataException() {\r\n        super();\r\n    }\r\n\r\n    public TaskDataException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskDataException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskDataException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/entity/TaskRunnerConfig.java\npublic class TaskRunnerConfig implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u4e0d\u9650\u901f\n     */\n    public static final int RATE_LIMIT_NONE = 0;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730\u8fdb\u7a0b\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL = 1;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK = 2;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK_TAG = 3;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40\u4e3b\u673aHOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_HOST = 4;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG = 5;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK = 6;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG+HOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG_HOST = 7;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_HOST = 8;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG = 9;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG_HOST = 10;\n\n    /**\n     * \u4ec0\u4e48\u90fd\u4e0d\u8bb0\u5f55\n     */\n    public static final int TASK_LOG_TYPE_NONE = -1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD = 0;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8bf7\u6c42\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_TASK_PARAM = 1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8fd4\u56de\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_RESULT_DATA = 2;\n\n    /**\n     * \u8bb0\u5f55\u5168\u90e8\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD_ALL = 3;\n\n    private long id;\n\n    /**\n     * \u4efb\u52a1\u540d\u79f0\n     */\n    private String taskName;\n\n    /**\n     * \u4efb\u52a1\u63cf\u8ff0\n     */\n    private String taskDesc;\n\n    /**\n     * \u6267\u884c\u7c7b\u4fe1\u606f\n     */\n    private String taskClass;\n\n    /**\n     * \u6267\u884c\u7c7bTAG\uff0c\u53ef\u80fd\u7528\u4e8e\u533a\u5206\u5b50\u4efb\u52a1\n     */\n    private String taskTag;\n\n    /**\n     * \u6d88\u8d39\u8005\u7684\u6570\u91cf\n     */\n    private int consumerNum = 1;\n\n    /**\n     * \u9884\u53d6\u4efb\u52a1\u6570\u3002\n     */\n    private int prefetchNum = 1;\n\n    /**\n     * \u8be6\u89c1\u6d41\u91cf\u9650\u5236\u7c7b\u578b\u8bf4\u660e\u3002\n     */\n    private int rateLimitType = RATE_LIMIT_NONE;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u6570\u503c\uff0c\u9ed8\u8ba4\u4e3a10\u6b21\n     */\n    private int rateLimitValue = 10;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u65f6\u95f4(S)\uff0c\u9ed8\u8ba4\u4e3a1\u79d2\n     */\n    private int rateLimitTime = 1;\n\n    /**\n     * \u5f53\u53d1\u751f\u6d41\u91cf\u9650\u5236\u65f6\uff0c\u7b49\u5f85\u7684\u79d2\u6570\uff0c\u9ed8\u8ba4300\u79d2\n     */\n    private int rateLimitWait = 30;\n\n    /**\n     * \u8d85\u8fc7\u6d41\u91cf\u9650\u5236\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u5728\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByOverrated = 0;\n\n    /**\n     * \u5bf9\u65b9\u63a5\u53e3\u9519\u8bef\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u518d\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByPartner = 0;\n\n    /**\n     * \u8fd0\u884c\u76ee\u6807\uff0c\u9ed8\u8ba4\u4e0d\u6307\u5b9a\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u5931\u8d25\u7387\n     */\n    private int failRate;\n\n    /**\n     * \u63a5\u53e3\u5931\u8d25\u7387\n     */\n    private int failPartnerRate;\n\n    /**\n     * \u7a0b\u5e8f\u5931\u8d25\u7387\n     */\n    private int failProgramRate;\n\n    /**\n     * \u914d\u7f6e\u5931\u8d25\u7387\n     */\n    private int failConfigRate;\n\n    /**\n     * \u6570\u636e\u5931\u8d25\u7387\n     */\n    private int failDataRate;\n\n    /**\n     * \u961f\u5217\u7b49\u5f85\u8d85\u65f6\n     */\n    private int queueTimeout;\n\n    /**\n     * \u7b49\u5f85\u8d85\u65f6\n     */\n    private int waitTimeout;\n\n    /**\n     * \u8fd0\u884c\u8d85\u65f6\n     */\n    private int runTimeout;\n\n    /**\n     * \u521b\u5efa\u65e5\u671f\u3002\n     */\n    private Date createDate;\n\n    /**\n     * \u4fee\u6539\u65e5\u671f\u3002\n     */\n    private Date modifyDate;\n\n    /**\n     * \u72b6\u6001\u503c\n     */\n    private int state = 1;\n\n    /**\n     * \u8be6\u89c1\u65e5\u5fd7\u7c7b\u578b\u8bf4\u660e\n     */\n    private int logLevel = TASK_LOG_TYPE_RECORD;\n\n    /**\n     * \u65e5\u5fd7\u5b57\u7b26\u4e32\u5b57\u6bb5\u5927\u5c0f\u9650\u5236: 0 \u8868\u793a\u65e0\u9650\u5236\n     */\n    private int logLimitSize = 0;\n\n    public TaskRunnerConfig() {\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getTaskName() {\n        return taskName;\n    }\n\n    public void setTaskName(String taskName) {\n        this.taskName = taskName;\n    }\n\n    public String getTaskDesc() {\n        return taskDesc;\n    }\n\n    public void setTaskDesc(String taskDesc) {\n        this.taskDesc = taskDesc;\n    }\n\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    public String getTaskTag() {\n        return taskTag;\n    }\n\n    public void setTaskTag(String taskTag) {\n        this.taskTag = taskTag;\n    }\n\n    public int getConsumerNum() {\n        return consumerNum;\n    }\n\n    public void setConsumerNum(int consumerNum) {\n        this.consumerNum = consumerNum;\n    }\n\n    public int getPrefetchNum() {\n        return prefetchNum;\n    }\n\n    public void setPrefetchNum(int prefetchNum) {\n        this.prefetchNum = prefetchNum;\n    }\n\n    public int getRateLimitType() {\n        return rateLimitType;\n    }\n\n    public void setRateLimitType(int rateLimitType) {\n        this.rateLimitType = rateLimitType;\n    }\n\n    public int getRateLimitValue() {\n        return rateLimitValue;\n    }\n\n    public void setRateLimitValue(int rateLimitValue) {\n        this.rateLimitValue = rateLimitValue;\n    }\n\n    public int getRateLimitTime() {\n        return rateLimitTime;\n    }\n\n    public void setRateLimitTime(int rateLimitTime) {\n        this.rateLimitTime = rateLimitTime;\n    }\n\n    public int getRateLimitWait() {\n        return rateLimitWait;\n    }\n\n    public void setRateLimitWait(int rateLimitWait) {\n        this.rateLimitWait = rateLimitWait;\n    }\n\n    public int getRetryTimesByOverrated() {\n        return retryTimesByOverrated;\n    }\n\n    public void setRetryTimesByOverrated(int retryTimesByOverrated) {\n        this.retryTimesByOverrated = retryTimesByOverrated;\n    }\n\n    public int getRetryTimesByPartner() {\n        return retryTimesByPartner;\n    }\n\n    public void setRetryTimesByPartner(int retryTimesByPartner) {\n        this.retryTimesByPartner = retryTimesByPartner;\n    }\n\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    public int getFailRate() {\n        return failRate;\n    }\n\n    public void setFailRate(int failRate) {\n        this.failRate = failRate;\n    }\n\n    public int getFailPartnerRate() {\n        return failPartnerRate;\n    }\n\n    public void setFailPartnerRate(int failPartnerRate) {\n        this.failPartnerRate = failPartnerRate;\n    }\n\n    public int getFailProgramRate() {\n        return failProgramRate;\n    }\n\n    public void setFailProgramRate(int failProgramRate) {\n        this.failProgramRate = failProgramRate;\n    }\n\n    public int getFailConfigRate() {\n        return failConfigRate;\n    }\n\n    public void setFailConfigRate(int failConfigRate) {\n        this.failConfigRate = failConfigRate;\n    }\n\n    public int getFailDataRate() {\n        return failDataRate;\n    }\n\n    public void setFailDataRate(int failDataRate) {\n        this.failDataRate = failDataRate;\n    }\n\n    public int getQueueTimeout() {\n        return queueTimeout;\n    }\n\n    public void setQueueTimeout(int queueTimeout) {\n        this.queueTimeout = queueTimeout;\n    }\n\n    public int getWaitTimeout() {\n        return waitTimeout;\n    }\n\n    public void setWaitTimeout(int waitTimeout) {\n        this.waitTimeout = waitTimeout;\n    }\n\n    public int getRunTimeout() {\n        return runTimeout;\n    }\n\n    public void setRunTimeout(int runTimeout) {\n        this.runTimeout = runTimeout;\n    }\n\n    public Date getCreateDate() {\n        return createDate;\n    }\n\n    public void setCreateDate(Date createDate) {\n        this.createDate = createDate;\n    }\n\n    public Date getModifyDate() {\n        return modifyDate;\n    }\n\n    public void setModifyDate(Date modifyDate) {\n        this.modifyDate = modifyDate;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n    }\n\n    public int getLogLevel() {\n        return logLevel;\n    }\n\n    public void setLogLevel(int logLevel) {\n        this.logLevel = logLevel;\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/util/MiscUtils.java\npublic class MiscUtils {\r\n\r\n    /**\r\n     * taskData\u7684copy\u5668\u3002\r\n     */\r\n    private static BeanCopier beanCopier = BeanCopier.create(TaskData.class, TaskData.class, false);\r\n\r\n    /**\r\n     * copy taskData\u5bf9\u8c61\u3002\r\n     *\r\n     * @param srcData\r\n     * @param dstData\r\n     */\r\n    public static void copyTaskData(TaskData srcData, TaskData dstData) {\r\n        beanCopier.copy(srcData, dstData, null);\r\n    }\r\n\r\n    /**\r\n     * \u6253\u5370\u5f02\u5e38\u4fe1\u606f\uff0c\u5c4f\u853d\u6389spring\u81ea\u5df1\u7684\u5806\u6808\u8f93\u51fa\u3002\r\n     *\r\n     * @param e \u9700\u8981\u6253\u5370\u7684\u5f02\u5e38\u4fe1\u606f\r\n     * @return\r\n     */\r\n    public static String exceptionToString(Throwable e) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(e.toString()).append(\"\\n\");\r\n\r\n        StackTraceElement[] trace = e.getStackTrace();\r\n        for (StackTraceElement traceElement : trace) {\r\n            if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                continue;\r\n            }\r\n            if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                continue;\r\n            }\r\n            sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n        }\r\n        Throwable ourCause = e.getCause();\r\n        if (ourCause != null) {\r\n            sb.append(\"CAUSE BY\").append(ourCause.toString()).append(\"\\n\");\r\n            trace = ourCause.getStackTrace();\r\n            for (StackTraceElement traceElement : trace) {\r\n                if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                    continue;\r\n                }\r\n                if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                    continue;\r\n                }\r\n                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskListenerManager.java\npublic class TaskListenerManager {\r\n\r\n\t/**\r\n\t * runner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n\t */\r\n    private ArrayList<RunnerTaskListener> runnerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * croner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n     */\r\n    private ArrayList<CronerTaskListener> cronerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener\u3002\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addRunnerListener(RunnerTaskListener listener) {\r\n        runnerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener.\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addCronerListener(CronerTaskListener listener) {\r\n        cronerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearRunnerListener() {\r\n        runnerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearCronerListener() {\r\n        cronerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Runner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<RunnerTaskListener> getRunnerListenerList() {\r\n        return runnerListenerList;\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Croner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<CronerTaskListener> getCronerListenerList() {\r\n        return cronerListenerList;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/entity/TaskRunnerLog.java\n@JsonIgnoreProperties({\"taskData\"})\npublic class TaskRunnerLog extends LogBaseVo {\n\n    private static final Logger logger = LoggerFactory.getLogger(TaskRunnerLog.class);\n\n    private TaskData taskData;\n\n    /**\n     * logLimitSize\u3002\n     */\n    private int logLimitSize;\n\n    public TaskRunnerLog(TaskData taskData) {\n        this.taskData = taskData;\n    }\n\n    public TaskData getTaskData() {\n        return taskData;\n    }\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return taskData.getId();\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return taskData.getRefId();\n    }\n\n    /**\n     * @return the refSubId\n     */\n    public long getRefSubId() {\n        return taskData.getRefSubId();\n    }\n\n    /**\n     * @return the refTag\n     */\n    public String getRefTag() {\n        return taskData.getRefTag();\n    }\n\n    /**\n     * @return the rateLimitTag\n     */\n    public String getRateLimitTag() {\n        return taskData.getRateLimitTag();\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskData.getTaskClass();\n    }\n\n    /**\n     * @return the taskTag\n     */\n    public String getTaskTag() {\n        return taskData.getTaskTag();\n    }\n\n    public long getTaskDelay() {\n        return taskData.getTaskDelay();\n    }\n\n    /**\n     * @return the taskParam\n     */\n    public String getTaskParam() {\n        Object value = taskData.getTaskParam();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return taskData.getRunType();\n    }\n\n    /**\n     * @return the retryType\n     */\n    public int getRetryType() {\n        return taskData.getRetryType();\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return taskData.getRunTarget();\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return taskData.getHostIp();\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return taskData.getHostId();\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return taskData.getQueueDate();\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return taskData.getConsumeDate();\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return taskData.getRunDate();\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return taskData.getFinishDate();\n    }\n\n    /**\n     * @return the resultData\n     */\n    public String getResultData() {\n        Object value = taskData.getResultData();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return taskData.getErrorInfo();\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return taskData.getRanTimes();\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return taskData.getState();\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/conf/TaskProperties.java\n@ConfigurationProperties(prefix = \"uw.task\")\npublic class TaskProperties {\n\n    /**\n     * \u662f\u5426\u542f\u7528uw-task\u670d\u52a1\u6ce8\u518c\u548c\u4e3b\u673a\u6ce8\u518c\uff0c\u9ed8\u8ba4\u4e0d\u542f\u7528\u3002\n     *\n     */\n    private boolean enableTaskRegistry = false;\n    /**\n     * \u4efb\u52a1\u540d\uff0c\u5fc5\u987b\u8bbe\u7f6e\u4e3a\u57fa\u7840\u5305\u540d\u3002\n     */\n    private String project;\n\n    /**\n     * \u79c1\u6709\u6a21\u5f0f\u3002\u4e0d\u8fd0\u884c\u5168\u5c40target\u4efb\u52a1\u3002\n     */\n    private boolean privacyMode = false;\n\n    /**\n     * croner\u7ebf\u7a0b\u6570\uff0c\u9ed8\u8ba4\u57283\u4e2a\uff0c\u5efa\u8bae\u6309\u7167\u5b9e\u9645croner\u4efb\u52a1\u6570\u91cf*70%\u3002\n     */\n    private int cronerThreadNum = 5;\n\n    /**\n     * RPC\u6700\u5c0f\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u5982\u4e0d\u4f7f\u7528rpc\uff0c\u5efa\u8bae\u8bbe\u7f6e\u4e3a1\uff0c\u5426\u5219\u6309\u7167\u6700\u5927\u5e76\u53d1\u91cf*10%\u8bbe\u7f6e\u3002\n     */\n    private int taskRpcMinThreadNum = 1;\n\n    /**\n     * RPC\u6700\u5927\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u8d85\u8fc7\u6b64\u7ebf\u7a0b\u6570\uff0c\u5c06\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     */\n    private int taskRpcMaxThreadNum = 100;\n\n    /**\n     * \u961f\u5217\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba42\u79d2\n     */\n    private long taskQueueRetryDelay = 2000;\n\n    /**\n     *  rpc\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba4100\u6beb\u79d2\n     */\n    private long taskRpcRetryDelay = 100;\n\n    /**\n     * \u8fd0\u884c\u4e3b\u673aID\n     */\n    private String hostId = ManagementFactory.getRuntimeMXBean().getName();\n\n    /**\n     * \u4efb\u52a1\u670d\u52a1\u5668\n     */\n    private String taskCenterHost = \"127.0.0.1\";\n\n    /**\n     * Redis\u914d\u7f6e\n     */\n    private RedisProperties redis = new RedisProperties();\n\n    /**\n     * Rabbit MQ\u914d\u7f6e\n     */\n    private RabbitProperties rabbitmq = new RabbitProperties();\n\n    public static class RedisProperties extends org.springframework.boot.autoconfigure.data.redis.RedisProperties {\n\n    }\n\n    public static class RabbitProperties extends org.springframework.boot.autoconfigure.amqp.RabbitProperties {\n\n    }\n\n    public boolean isEnableTaskRegistry() {\n        return enableTaskRegistry;\n    }\n\n    public void setEnableTaskRegistry(boolean enableTaskRegistry) {\n        this.enableTaskRegistry = enableTaskRegistry;\n    }\n\n    /**\n\t * @return the privacyMode\n\t */\n\tpublic boolean isPrivacyMode() {\n\t\treturn privacyMode;\n\t}\n\n\t/**\n\t * @param privacyMode the privacyMode to set\n\t */\n\tpublic void setPrivacyMode(boolean privacyMode) {\n\t\tthis.privacyMode = privacyMode;\n\t}\n\n\tpublic int getTaskRpcMinThreadNum() {\n\t\treturn taskRpcMinThreadNum;\n\t}\n\n\tpublic void setTaskRpcMinThreadNum(int taskRpcMinThreadNum) {\n\t\tthis.taskRpcMinThreadNum = taskRpcMinThreadNum;\n\t}\n\n\tpublic int getTaskRpcMaxThreadNum() {\n\t\treturn taskRpcMaxThreadNum;\n\t}\n\n\tpublic void setTaskRpcMaxThreadNum(int taskRpcMaxThreadNum) {\n\t\tthis.taskRpcMaxThreadNum = taskRpcMaxThreadNum;\n\t}\n\n\t/**\n     * @return the project\n     */\n    public String getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(String project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n\t * @return the cronerThreadNum\n\t */\n\tpublic int getCronerThreadNum() {\n\t\treturn cronerThreadNum;\n\t}\n\n\t/**\n\t * @param cronerThreadNum the cronerThreadNum to set\n\t */\n\tpublic void setCronerThreadNum(int cronerThreadNum) {\n\t\tthis.cronerThreadNum = cronerThreadNum;\n\t}\n\n\t/**\n     * @return the taskCenterHost\n     */\n    public String getTaskCenterHost() {\n        return taskCenterHost;\n    }\n\n    /**\n     * @param taskCenterHost the taskCenterHost to set\n     */\n    public void setTaskCenterHost(String taskCenterHost) {\n        this.taskCenterHost = taskCenterHost;\n    }\n\n    public RedisProperties getRedis() {\n        return redis;\n    }\n\n    public void setRedis(RedisProperties redis) {\n        this.redis = redis;\n    }\n\n    public RabbitProperties getRabbitmq() {\n        return rabbitmq;\n    }\n\n    public void setRabbitmq(RabbitProperties rabbitmq) {\n        this.rabbitmq = rabbitmq;\n    }\n\n    public long getTaskQueueRetryDelay() {\n        return taskQueueRetryDelay;\n    }\n\n    public void setTaskQueueRetryDelay(long taskQueueRetryDelay) {\n        this.taskQueueRetryDelay = taskQueueRetryDelay;\n    }\n\n    public long getTaskRpcRetryDelay() {\n        return taskRpcRetryDelay;\n    }\n\n    public void setTaskRpcRetryDelay(long taskRpcRetryDelay) {\n        this.taskRpcRetryDelay = taskRpcRetryDelay;\n    }\n}\npackage uw.task.container;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport uw.task.TaskData;\nimport uw.task.TaskFactory;\nimport uw.task.TaskListenerManager;\nimport uw.task.TaskRunner;\nimport uw.task.api.TaskAPI;\nimport uw.task.conf.TaskMetaInfoManager;\nimport uw.task.conf.TaskProperties;\nimport uw.task.entity.TaskRunnerConfig;\nimport uw.task.entity.TaskRunnerLog;\nimport uw.task.exception.TaskDataException;\nimport uw.task.exception.TaskPartnerException;\nimport uw.task.listener.RunnerTaskListener;\nimport uw.task.util.GlobalRateLimiter;\nimport uw.task.util.LocalRateLimiter;\nimport uw.task.util.MiscUtils;\n\n\n\n\n/**\n * \u5728\u6b64\u5904\u63a5\u53d7MQ\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c\u5904\u7406\u3002\n *\n * @author axeon\n */\npublic class TaskRunnerContainer {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskRunnerContainer.class);\n\n    /**\n     * TaskFactory\n     */\n    private TaskFactory taskFactory;\n\n    /**\n     * \u670d\u52a1\u7aef\u4efb\u52a1API\n     */\n    private TaskAPI taskAPI;\n\n    /**\n     * \u5168\u5c40\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */\n    private GlobalRateLimiter globalRateLimiter;\n\n    /**\n     * \u672c\u5730\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */Next line of code:\n", "input": "package uw.task.container;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport uw.task.TaskData;\nimport uw.task.TaskFactory;\nimport uw.task.TaskListenerManager;\nimport uw.task.TaskRunner;\nimport uw.task.api.TaskAPI;\nimport uw.task.conf.TaskMetaInfoManager;\nimport uw.task.conf.TaskProperties;\nimport uw.task.entity.TaskRunnerConfig;\nimport uw.task.entity.TaskRunnerLog;\nimport uw.task.exception.TaskDataException;\nimport uw.task.exception.TaskPartnerException;\nimport uw.task.listener.RunnerTaskListener;\nimport uw.task.util.GlobalRateLimiter;\nimport uw.task.util.LocalRateLimiter;\nimport uw.task.util.MiscUtils;\n\n\n\n\n/**\n * \u5728\u6b64\u5904\u63a5\u53d7MQ\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c\u5904\u7406\u3002\n *\n * @author axeon\n */\npublic class TaskRunnerContainer {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskRunnerContainer.class);\n\n    /**\n     * TaskFactory\n     */\n    private TaskFactory taskFactory;\n\n    /**\n     * \u670d\u52a1\u7aef\u4efb\u52a1API\n     */\n    private TaskAPI taskAPI;\n\n    /**\n     * \u5168\u5c40\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */\n    private GlobalRateLimiter globalRateLimiter;\n\n    /**\n     * \u672c\u5730\u6d41\u91cf\u9650\u5236\u670d\u52a1\n     */", "context": "src/main/java/uw/task/util/LocalRateLimiter.java\npublic class LocalRateLimiter {\r\n\r\n    private ConcurrentHashMap<String, RateLimiter> map = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u83b7\u5f97\u9650\u5236\u5141\u8bb8\u72b6\u6001\u3002\r\n     *\r\n     * @param name\r\n     * @return\r\n     */\r\n    public boolean tryAcquire(String name, int requests, int seconds, long waitTime, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return true;\r\n        }\r\n        final double rate = (double) requests / (double) seconds;\r\n        RateLimiter limiter = map.computeIfAbsent(name, key -> RateLimiter.create(rate));\r\n        if (limiter != null) {\r\n            //\u68c0\u67e5\u5e76\u4fee\u6539\r\n            if (limiter.getRate() != rate) {\r\n                limiter.setRate(rate);\r\n            }\r\n            return limiter.tryAcquire(permits, waitTime, TimeUnit.SECONDS);\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskFactory.java\npublic class TaskFactory {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskFactory.class);\n\n    /**\n     * rabbitTemplate\u6a21\u677f.\n     */\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * \u5168\u5c40sequence\u5e8f\u5217\uff0c\u4e3b\u8981\u7528\u4e8etaskLog\u65e5\u5fd7\u3002\n     */\n    private GlobalSequenceManager globalSequenceManager;\n\n    /**\n     * \u7528\u4e8e\u672c\u5730\u6267\u884c\u4efb\u52a1\u7684taskConsumer\u3002\n     */\n    private TaskRunnerContainer taskRunnerContainer;\n\n    /**\n     * rpc\u5f02\u6b65\u8c03\u7528\u7ebf\u7a0b\u6c60\n     */\n    private ExecutorService taskRpcService = null;\n\n    /**\n     * \u6700\u5927\u91cd\u8bd5\u6b21\u6570\u3002\n     */\n    private static final int MAX_RETRY_TIMES = 10;\n\n\n    public TaskFactory(TaskProperties taskProperties, RabbitTemplate rabbitTemplate,\n                       TaskRunnerContainer taskRunnerContainer, GlobalSequenceManager globalSequenceManager) {\n        this.rabbitTemplate = rabbitTemplate;\n        this.taskRunnerContainer = taskRunnerContainer;\n        this.globalSequenceManager = globalSequenceManager;\n        taskRpcService = new ThreadPoolExecutor(taskProperties.getTaskRpcMinThreadNum(),\n                taskProperties.getTaskRpcMaxThreadNum(), 20L, TimeUnit.SECONDS, new SynchronousQueue<>(),\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"TaskRpc-%d\").build(), new ThreadPoolExecutor.CallerRunsPolicy());\n\n    }\n\n    /**\n     * \u628a\u4efb\u52a1\u53d1\u9001\u5230\u961f\u5217\u4e2d\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     */\n    public void sendToQueue(final TaskData<?, ?> taskData) {\n        Message message = buildTaskQueueMessage(taskData);\n        String queue = message.getMessageProperties().getConsumerQueue();\n        //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n        for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n            try {\n                if (i > 0) {\n                    Thread.sleep(i * 500);\n                }\n                rabbitTemplate.send(queue, queue, message);\n                return;\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n        throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n    }\n\n    /**\n     * \u6784\u9020Task\u6d88\u606f\u5bf9\u8c61\uff0c\u6b64\u65b9\u6cd5\u7528\u4e8e\u63d0\u524d\u6784\u9020TaskData\u3002\n     *\n     * @param taskData\n     * @return\n     */\n    private Message buildTaskQueueMessage(final TaskData taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        taskData.setRunType(TaskData.RUN_TYPE_GLOBAL);\n        MessageProperties messageProperties = new MessageProperties();\n        messageProperties.setConsumerQueue(TaskMetaInfoManager.getFitQueue(taskData));\n        Message msg = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n        return msg;\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTask(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n            for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                try {\n                    if (i > 0) {\n                        Thread.sleep(i * 500);\n                    }\n                    Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                    return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n            throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n        }\n    }\n\n    /**\n     * \u540c\u6b65\u6267\u884c\u4efb\u52a1\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> TaskData<TP, RD> runTaskLocal(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            taskRunnerContainer.process(taskData);\n            return taskData;\n        } else {\n            throw new TaskRuntimeException(taskData.getClass().getName() + \" is not a local task! \");\n        }\n    }\n\n    /**\n     * \u8fdc\u7a0b\u8fd0\u884c\u4efb\u52a1\uff0c\u5e76\u8fd4\u56defuture<TaskData<?,?>>\u3002 \u5982\u679c\u9700\u8981\u83b7\u5f97\u6570\u636e\uff0c\u53ef\u4ee5\u4f7f\u7528futrue.get()\u6765\u83b7\u5f97\u3002\n     * \u6b64\u65b9\u6cd5\u8981\u8c28\u614e\u4f7f\u7528\uff0c\u56e0\u4e3atask\u5b58\u5728\u9650\u901f\uff0c\u5927\u5e76\u53d1\u4e0b\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7ebf\u7a0b\u6570\u8d85\u3002\n     * \u5728\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\uff0ctaskData\u5bf9\u8c61\u4e0d\u53ef\u6539\u53d8\uff01\n     *\n     * @param taskData \u4efb\u52a1\u6570\u636e\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <TP, RD> Future<TaskData<TP, RD>> runTaskAsync(final TaskData<TP, RD> taskData) {\n        taskData.setId(globalSequenceManager.nextId(\"task_runner_log\"));\n        taskData.setQueueDate(new Date());\n\n        // \u5f53\u81ea\u52a8RPC\uff0c\u5e76\u4e14\u672c\u5730\u6709runner\uff0c\u800c\u4e14target\u5339\u914d\u7684\u65f6\u5019\uff0c\u8fd0\u884c\u5728\u672c\u5730\u6a21\u5f0f\u4e0b\u3002\n        if (taskData.getRunType() == TaskData.RUN_TYPE_AUTO_RPC && TaskMetaInfoManager.checkRunnerRunLocal(taskData)) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            taskData.setRunType(TaskData.RUN_TYPE_LOCAL);\n        }\n        if (taskData.getRunType() == TaskData.RUN_TYPE_LOCAL) {\n            // \u542f\u52a8\u672c\u5730\u8fd0\u884c\u6a21\u5f0f\u3002\n            return taskRpcService.submit(() -> {\n                taskRunnerContainer.process(taskData);\n                return taskData;\n            });\n        } else {\n            // \u5168\u5c40\u8fd0\u884c\u6a21\u5f0f\n            taskData.setRunType(TaskData.RUN_TYPE_GLOBAL_RPC);\n            //\u52a0\u5165\u4f18\u5148\u7ea7\u4fe1\u606f\u3002\n            MessageProperties messageProperties = new MessageProperties();\n            messageProperties.setPriority(10);\n            messageProperties.setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT);\n            messageProperties.setExpiration(\"180000\");\n            Message message = rabbitTemplate.getMessageConverter().toMessage(taskData, messageProperties);\n            String queue = TaskMetaInfoManager.getFitQueue(taskData);\n            return taskRpcService.submit(() -> {\n                //\u6b64\u5904\u53ef\u80fd\u51fa\u73b0The channelMax limit is reached.\u62a5\u9519\uff0c\u6240\u4ee5\u8fdb\u884c\u91cd\u8bd5\u3002\n                for (int i = 0; i < MAX_RETRY_TIMES; i++) {\n                    try {\n                        if (i > 0) {\n                            Thread.sleep(i * 500);\n                        }\n                        Message retMessage = rabbitTemplate.sendAndReceive(queue, queue, message);\n                        return (TaskData<TP, RD>) rabbitTemplate.getMessageConverter().fromMessage(retMessage);\n                    } catch (Exception e) {\n                        log.error(e.getMessage(), e);\n                    }\n                }\n                throw new TaskRuntimeException(\"The channelMax limit is reached!\");\n            });\n        }\n    }\n\n    /**\n     * \u83b7\u5f97\u961f\u5217\u4fe1\u606f\u3002\n     *\n     * @param queueName\n     * @return 0 \u662f\u6d88\u606f\u6570\u91cf 1 \u662f\u6d88\u8d39\u8005\u6570\u91cf\n     */\n    public int[] getQueueInfo(String queueName) {\n        AMQP.Queue.DeclareOk declareOk = this.rabbitTemplate.execute(new ChannelCallback<AMQP.Queue.DeclareOk>() {\n            public AMQP.Queue.DeclareOk doInRabbit(Channel channel) throws Exception {\n                return channel.queueDeclarePassive(queueName);\n            }\n        });\n        return new int[]{declareOk.getMessageCount(), declareOk.getConsumerCount()};\n    }\n\n    /**\n     * \u6e05\u9664\u961f\u5217\u3002\n     *\n     * @param queueName\n     * @return \u88ab\u6e05\u9664\u7684\u961f\u5217\u6570\n     */\n    public int purgeQueue(String queueName) {\n        return this.rabbitTemplate.execute(channel -> {\n            AMQP.Queue.PurgeOk queuePurged = channel.queuePurge(queueName);\n            return queuePurged.getMessageCount();\n        });\n    }\n\n}\nsrc/main/java/uw/task/listener/RunnerTaskListener.java\npublic interface RunnerTaskListener {\r\n\r\n    /**\r\n     * \u6267\u884c\u524d\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPreExecute(TaskData data);\r\n\r\n    /**\r\n     * \u6267\u884c\u540e\u7684\u76d1\u542c\u5668\u3002\r\n     *\r\n     * @param data\r\n     */\r\n    public void onPostExecute(TaskData data);\r\n\r\n}\r\nsrc/main/java/uw/task/util/GlobalRateLimiter.java\npublic class GlobalRateLimiter {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(GlobalRateLimiter.class);\r\n\r\n    private static final String REDIS_PREFIX = \"TaskRateLimit:\";\r\n\r\n    private final RedisTemplate<String, Long> redisTemplate;\r\n\r\n    /**\r\n     * LUA\u811a\u672c\u3002\r\n     * \u8fd4\u56de\u503c\u4e3a\uff1a\u53ef\u7528\u8bf7\u6c42\u6570,\u7b49\u5f85\u6beb\u79d2\u6570\u3002\r\n     */\r\n    private static final RedisScript<Long> LUA_RATE_LIMIT = RedisScript.of(\r\n            \"local key = KEYS[1];\\n\" +\r\n                    \"local requests = tonumber(ARGV[1]);\\n\" +\r\n                    \"local millis = tonumber(ARGV[2])*1000;\\n\" +\r\n                    \"local permits = tonumber(ARGV[3]);\\n\" +\r\n                    \"local remainRequests=0;\\n\" +\r\n                    \"local waitMillis=0;\\n\" +\r\n                    \"local nowRate= redis.call('INCRBY', key,permits);\\n\" +\r\n                    \"if (nowRate==permits) then \\n\" +//\u5982\u679c\u662f\u7b2c\u4e00\u6b21\u6267\u884c\uff0c\u8bbe\u7f6e\u6709\u6548\u671f\u4fdd\u62a4\u3002\r\n                    \"    redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"end\\n\" +\r\n                    \"remainRequests = requests-nowRate;\\n\" +\r\n                    \"if (remainRequests<1) then \\n\" +//\u8bf7\u6c42\u6570\u8d85\u8fc7\u9650\u5236\r\n                    \"    waitMillis = redis.call('PTTL',key);\\n\" +\r\n                    \"    if (waitMillis == -1) then \\n\" +\r\n                    \"        redis.call('PEXPIRE',key,millis);\\n\" +\r\n                    \"        waitMillis = millis;\\n\" +\r\n                    \"    end\\n\" +\r\n                    \"end \\n\" +\r\n                    \"return waitMillis\", Long.class);\r\n\r\n\r\n    public GlobalRateLimiter(final RedisConnectionFactory redisConnectionFactory) {\r\n        redisTemplate = new RedisTemplate<String, Long>();\r\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\r\n        redisTemplate.setValueSerializer(new GenericToStringSerializer<Long>(Long.class));\r\n        redisTemplate.setExposeConnection(true);\r\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\r\n        redisTemplate.afterPropertiesSet();\r\n    }\r\n\r\n    /**\r\n     * \u5c1d\u8bd5\u53ef\u5426\u83b7\u5f97\u6388\u6743\u3002\r\n     *\r\n     * @param permits       \u7533\u8bf7\u8bbf\u95ee\u6b21\u6570\r\n     * @return \u5982\u679c\u672a\u8d85\u9650\u5219\u8fd4\u56de0\uff0c-1\u4e3a\u4e0d\u786e\u5b9a\u65f6\u95f4\uff0c\u5176\u4ed6\u4e3a\u9700\u8981\u7b49\u5f85\u7684\u6beb\u79d2\u6570\r\n     */\r\n    public long tryAcquire(String name, int requests, int seconds, int permits) {\r\n        if (requests == 0 || seconds == 0) {\r\n            return 0;\r\n        }\r\n        Long waitLimit = redisTemplate.execute(LUA_RATE_LIMIT, Collections.singletonList(REDIS_PREFIX + name), requests,seconds, permits);\r\n        if (waitLimit==null)\r\n            return 0;\r\n        else\r\n            return waitLimit;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/exception/TaskPartnerException.java\npublic class TaskPartnerException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskPartnerException() {\r\n        super();\r\n    }\r\n\r\n    public TaskPartnerException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskPartnerException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskPartnerException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/TaskData.java\npublic class TaskData<TP, RD> implements Serializable {\n\n    /**\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 1333167065535557828L;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u672a\u8bbe\u7f6e\n     */\n    public static final int STATE_UNKNOWN = 0;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6210\u529f\n     */\n    public static final int STATE_SUCCESS = 1;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7a0b\u5e8f\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PROGRAM = 2;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u914d\u7f6e\u9519\u8bef\uff0c\u5982\u8d85\u8fc7\u6d41\u91cf\u9650\u5236\n     */\n    public static final int STATE_FAIL_CONFIG = 3;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u7b2c\u4e09\u65b9\u63a5\u53e3\u9519\u8bef\n     */\n    public static final int STATE_FAIL_PARTNER = 4;\n\n    /**\n     * \u4efb\u52a1\u72b6\u6001:\u6570\u636e\u9519\u8bef\n     */\n    public static final int STATE_FAIL_DATA = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u672c\u5730\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_LOCAL = 1;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884c\n     */\n    public static final int RUN_TYPE_GLOBAL = 3;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u5168\u5c40\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\n     */\n    public static final int RUN_TYPE_GLOBAL_RPC = 5;\n\n    /**\n     * \u8fd0\u884c\u6a21\u5f0f\uff1a\u81ea\u52a8\u8fd0\u884cRPC\u8fd4\u56de\u7ed3\u679c\uff0c\u4f7f\u7528\u6b64\u6a21\u5f0f\uff0c\u4f1a\u81ea\u52a8\u9009\u62e9\u672c\u5730\u8fd8\u8fdc\u7a0b\u8fd0\u884c\u6a21\u5f0f\u3002\n     */\n    public static final int RUN_TYPE_AUTO_RPC = 6;\n\n    /**\n     * \u81ea\u52a8\u91cd\u8bd5[\u4e3a\u4e86\u517c\u5bb9,\u9ed8\u8ba4\u5f00\u542f\u91cd\u8bd5]\n     */\n    public static final int RETRY_TYPE_AUTO = 0;\n\n    /**\n     * \u7528\u6237\u624b\u5de5\u91cd\u8bd5\n     */\n    public static final int RETRY_TYPE_MANUAL = 1;\n\n    /**\n     * id\uff0c\u6b64\u5e8f\u5217\u503c\u7531\u6846\u67b6\u81ea\u52a8\u751f\u6210\uff0c\u65e0\u9700\u624b\u5de5\u8bbe\u7f6e\u3002\n     */\n    private long id;\n\n    /**\n     * \u5173\u8054TAG\uff0c\u7531\u8c03\u7528\u65b9\u8bbe\u5b9a\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private String refTag;\n\n    /**\n     * \u5173\u8054id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refId;\n\n    /**\n     * \u5173\u8054\u5b50id\uff0c\u7531\u8c03\u7528\u65b9\u6839\u636e\u9700\u8981\u8bbe\u7f6e\uff0c\u7528\u4e8e\u7b2c\u4e09\u65b9\u7edf\u8ba1\u4fe1\u606f\u3002\n     */\n    private long refSubId;\n\n    /**\n     * \u5173\u8054\u5bf9\u8c61\uff0c\u6b64\u5bf9\u8c61\u4e0d\u5b58\u5165\u6570\u636e\u5e93\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7Listener\u6765\u8bbf\u95ee\u3002\n     */\n    @JsonIgnore\n    private Object refObject;\n\n    /**\n     * \u6d41\u91cf\u9650\u5236TAG\u3002\n     */\n    private String rateLimitTag;\n\n    /**\n     * \u9700\u8981\u6267\u884c\u7684\u7c7b\u540d\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u7531\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private String taskClass = \"\";\n\n    /**\n     * \u4efb\u52a1\u6807\u7b7e\uff0c\u7528\u4e8e\u7ec6\u5206\u4efb\u52a1\u961f\u5217\uff0c\u652f\u6301\u591a\u5b9e\u4f8b\u8fd0\u884c\u3002\n     */\n    private String taskTag = \"\";\n\n    /**\n     * \u4efb\u52a1\u5ef6\u8fdf\u6beb\u79d2\u6570\u3002\u4e00\u822c\u8fd9\u4e2a\u65f6\u95f4\u4e0d\u5b9c\u592a\u957f\uff0c\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4e0d\u8981\u8d85\u8fc760\u79d2\u3002\n     */\n    private long taskDelay;\n\n    /**\n     * \u6267\u884c\u53c2\u6570\uff0c\u6b64\u6570\u503c\u5fc5\u987b\u6709\u8c03\u7528\u65b9\u8bbe\u7f6e\u3002\n     */\n    private TP taskParam;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u7c7b\u578b\uff0c\u9ed8\u8ba4\u4e3a\u81ea\u52a8RPC\uff0c\u6839\u636e\u60c5\u51b5\u9009\u62e9\u672c\u5730\u8fd8\u662f\u8fdc\u7a0b\u8fd0\u884c\u3002\n     */\n    private int runType = RUN_TYPE_AUTO_RPC;\n\n    /**\n     * \u91cd\u8bd5\u7c7b\u578b\n     */\n    private int retryType;\n\n    /**\n     * \u6307\u5b9a\u8fd0\u884c\u76ee\u6807\u3002\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aIP\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostIp;\n\n    /**\n     * \u4efb\u52a1\u8fd0\u884c\u65f6\u4e3b\u673aID\uff08\u53ef\u80fd\u4e3adocker\u7684ContainerID\uff09\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private String hostId;\n\n    /**\n     * \u8fdb\u5165\u961f\u5217\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date queueDate;\n\n    /**\n     * \u5f00\u59cb\u6d88\u8d39\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date consumeDate;\n\n    /**\n     * \u5f00\u59cb\u8fd0\u884c\u65f6\u95f4\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date runDate;\n\n    /**\n     * \u8fd0\u884c\u7ed3\u675f\u65e5\u671f\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private Date finishDate;\n\n    /**\n     * \u6267\u884c\u4fe1\u606f\uff0c\u7528\u4e8e\u5b58\u50a8\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private RD resultData;\n\n    /**\n     * \u51fa\u9519\u4fe1\u606f\n     */\n    private String errorInfo;\n\n    /**\n     * \u5df2\u7ecf\u6267\u884c\u7684\u6b21\u6570\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int ranTimes;\n\n    /**\n     * \u6267\u884c\u72b6\u6001\uff0c\u6b64\u4fe1\u606f\u7531\u6846\u67b6\u6839\u636e\u5f02\u5e38\u81ea\u52a8\u8bbe\u7f6e\u3002\n     */\n    private int state;\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return id;\n    }\n\n    /**\n     * @param id the id to set\n     */\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return refId;\n    }\n\n    /**\n     * @param refId the refId to set\n     */\n    public void setRefId(long refId) {\n        this.refId = refId;\n    }\n\n    /**\n\t * @return the refSubId\n\t */\n\tpublic long getRefSubId() {\n\t\treturn refSubId;\n\t}\n\n\t/**\n\t * @param refSubId the refSubId to set\n\t */\n\tpublic void setRefSubId(long refSubId) {\n\t\tthis.refSubId = refSubId;\n\t}\n\n\t/**\n\t * @return the refTag\n\t */\n\tpublic String getRefTag() {\n\t\treturn refTag;\n\t}\n\n\t/**\n\t * @param refTag the refTag to set\n\t */\n\tpublic void setRefTag(String refTag) {\n\t\tthis.refTag = refTag;\n\t}\n\n\t/**\n\t * @return the rateLimitTag\n\t */\n\tpublic String getRateLimitTag() {\n\t\treturn rateLimitTag;\n\t}\n\n\t/**\n\t * @param rateLimitTag the rateLimitTag to set\n\t */\n\tpublic void setRateLimitTag(String rateLimitTag) {\n\t\tthis.rateLimitTag = rateLimitTag;\n\t}\n\n\t/**\n\t * @return the refObject\n\t */\n\tpublic Object getRefObject() {\n\t\treturn refObject;\n\t}\n\n    /**\n     * @param refObject the refObject to set\n     */\n    public void setRefObject(Object refObject) {\n        this.refObject = refObject;\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    /**\n     * @param taskClass the taskClass to set\n     */\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    /**\n\t * @return the taskTag\n\t */\n\tpublic String getTaskTag() {\n\t\treturn taskTag;\n\t}\n\n\tpublic long getTaskDelay() {\n\t\treturn taskDelay;\n\t}\n\n\tpublic void setTaskDelay(long taskDelay) {\n\t\tthis.taskDelay = taskDelay;\n\t}\n\n\t/**\n\t * @param taskTag the taskTag to set\n\t */\n\tpublic void setTaskTag(String taskTag) {\n\t\tthis.taskTag = taskTag;\n\t}\n\n\t/**\n     * @return the taskParam\n     */\n    public TP getTaskParam() {\n        return taskParam;\n    }\n\n    /**\n     * @param taskParam the taskParam to set\n     */\n    public void setTaskParam(TP taskParam) {\n        this.taskParam = taskParam;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return runType;\n    }\n\n    /**\n     * @param runType the runType to set\n     */\n    public void setRunType(int runType) {\n        this.runType = runType;\n    }\n\n    public int getRetryType() {\n        return retryType;\n    }\n\n    public void setRetryType(int retryType) {\n        this.retryType = retryType;\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    /**\n     * @param runTarget the runTarget to set\n     */\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * @param hostIp the hostIp to set\n     */\n    public void setHostIp(String hostIp) {\n        this.hostIp = hostIp;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return queueDate;\n    }\n\n    /**\n     * @param queueDate the queueDate to set\n     */\n    public void setQueueDate(Date queueDate) {\n        this.queueDate = queueDate;\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return consumeDate;\n    }\n\n    /**\n     * @param consumeDate the consumeDate to set\n     */\n    public void setConsumeDate(Date consumeDate) {\n        this.consumeDate = consumeDate;\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return runDate;\n    }\n\n    /**\n     * @param runDate the runDate to set\n     */\n    public void setRunDate(Date runDate) {\n        this.runDate = runDate;\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return finishDate;\n    }\n\n    /**\n     * @param finishDate the finishDate to set\n     */\n    public void setFinishDate(Date finishDate) {\n        this.finishDate = finishDate;\n    }\n\n    /**\n     * @return the resultData\n     */\n    public RD getResultData() {\n        return resultData;\n    }\n\n    /**\n     * @param resultData the resultData to set\n     */\n    public void setResultData(RD resultData) {\n        this.resultData = resultData;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return errorInfo;\n    }\n\n    /**\n     * @param errorInfo the errorInfo to set\n     */\n    public void setErrorInfo(String errorInfo) {\n        this.errorInfo = errorInfo;\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return ranTimes;\n    }\n\n    /**\n     * @param ranTimes the ranTimes to set\n     */\n    public void setRanTimes(int ranTimes) {\n        this.ranTimes = ranTimes;\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return state;\n    }\n\n    /**\n     * @param status the status to set\n     */\n    public void setState(int status) {\n        this.state = status;\n    }\n\n}\nsrc/main/java/uw/task/TaskRunner.java\npublic abstract class TaskRunner<TP, RD> {\r\n\r\n    /**\r\n     * \u6267\u884c\u4efb\u52a1\u3002\r\n     * \u4e1a\u52a1\u5c42\u9762\u7684\u5f02\u5e38\u8bf7\u6839\u636e\u5b9e\u9645\u60c5\u51b5\u624b\u52a8Throw TaskException:\r\n     * \u76ee\u524d\u652f\u6301\u7684\u5f02\u5e38:\r\n     * 1. TaskDataException \u4efb\u52a1\u6570\u636e\u5f02\u5e38\r\n     * 2. TaskPartnerException \u4efb\u52a1\u5408\u4f5c\u65b9\u5f02\u5e38\r\n     *\r\n     * @param taskData \u6570\u636e\r\n     * @throws Exception \u5f02\u5e38\r\n     * @return \u6307\u5b9a\u7684\u8fd4\u56de\u5bf9\u8c61\r\n     */\r\n    public abstract RD runTask(TaskData<TP, RD> taskData) throws Exception;\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u914d\u7f6e\u4fe1\u606f\r\n     *\r\n     * @return TaskRunnerConfig\u914d\u7f6e\r\n     */\r\n    public abstract TaskRunnerConfig initConfig();\r\n\r\n    /**\r\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     *\r\n     * @return TaskContact\u8054\u7cfb\u4eba\u4fe1\u606f\r\n     */\r\n    public abstract TaskContact initContact();\r\n}\nsrc/main/java/uw/task/conf/TaskMetaInfoManager.java\npublic class TaskMetaInfoManager {\r\n\r\n\t/**\r\n\t * \u8fd0\u884c\u4e3b\u673a\u914d\u7f6e\r\n\t */\r\n\tstatic List<String> targetConfig = null;\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tstatic Map<String, TaskRunner> runnerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u5b9e\u4f8b\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic Map<String, TaskCroner> cronerMap = new HashMap<>();\r\n\r\n\t/**\r\n\t * Runner\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskRunnerConfig> runnerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * Cron\u4efb\u52a1\u914d\u7f6e\u7f13\u5b58\u3002\r\n\t */\r\n\tstatic ConcurrentHashMap<String, TaskCronerConfig> cronerConfigMap = new ConcurrentHashMap<>();\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u8fd0\u884c\u5b9e\u4f8b\u3002\r\n\t *\r\n\t * @param taskClass\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunner<?, ?> getRunner(String taskClass) {\r\n\t\treturn runnerMap.get(taskClass);\r\n\t}\r\n\r\n\t/**\r\n\t * \u68c0\u67e5\u4e00\u4e2arunner\u662f\u5426\u53ef\u4ee5\u5728\u672c\u5730\u8fd0\u884c\u3002\r\n\t * \r\n\t * @param taskData\r\n\t * @return\r\n\t */\r\n\tpublic static boolean checkRunnerRunLocal(TaskData<?, ?> taskData) {\r\n\t\treturn runnerMap.containsKey(taskData.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u6839\u636e\u670d\u52a1\u5668\u7aefQueue\u5217\u8868\uff0c\u8fd4\u56de\u5408\u9002\u7684key\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getFitQueue(TaskData<?, ?> data) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tif (runnerConfigMap.containsKey(all)) {\r\n\t\t\treturn all;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            if (runnerConfigMap.containsKey(test)) {\r\n                return test;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tif (runnerConfigMap.containsKey(test)) {\r\n\t\t\t\treturn test;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u6700\u540e\u90fd\u6ca1\u5339\u914d\u5230\uff0c\u8fd4\u56de\u539f\u59cb\u6570\u636e\r\n\t\treturn all;\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97\u4efb\u52a1\u914d\u7f6e\r\n\t *\r\n\t * @param data\r\n\t * @return\r\n\t */\r\n\tpublic static TaskRunnerConfig getRunnerConfig(TaskData<?, ?> data) {\r\n\t\tTaskRunnerConfig config = null;\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(data.getTaskClass()).append(\"#\");\r\n\t\tif (data.getTaskTag() != null && data.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(data.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (data.getRunTarget() != null && data.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(data.getRunTarget());\r\n\t\t}\r\n\t\tString all = sb.toString();\r\n\t\tconfig = runnerConfigMap.get(all);\r\n\t\tif (config != null) {\r\n\t\t\treturn config;\r\n\t\t}\r\n        // \u68c0\u6d4b\u53bb\u9664TAG\u7684\u60c5\u51b5\r\n        if (!all.contains(\"#$\")) {\r\n            String test = all.substring(0, all.indexOf('#') + 1) + all.substring(all.lastIndexOf('$'), all.length());\r\n            config = runnerConfigMap.get(test);\r\n            if (config != null) {\r\n                return config;\r\n            }\r\n        }\r\n\t\t// \u68c0\u6d4b\u53bb\u9664\u76ee\u6807\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"$\")) {\r\n\t\t\tString test = all.substring(0, all.lastIndexOf('$') + 1);\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u4e24\u4e2a\u90fd\u53bb\u9664\u7684\u60c5\u51b5\r\n\t\tif (!all.endsWith(\"#$\")) {\r\n\t\t\tString test = data.getTaskClass() + \"#$\";\r\n\t\t\tconfig = runnerConfigMap.get(test);\r\n\t\t\tif (config != null) {\r\n\t\t\t\treturn config;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new RuntimeException(\"\u627e\u4e0d\u5230\u4efb\u52a1\u914d\u7f6e: taskClass = \" + data.getTaskClass());\r\n\t}\r\n\r\n\t/**\r\n\t * \u66f4\u65b0\u7cfb\u7edf\u961f\u5217\u8868\u3002\r\n\t * \r\n\t * @param config\r\n\t */\r\n\tstatic void updateSysQueue(final TaskRunnerConfig config) {\r\n\t\tString key = getRunnerConfigKey(config);\r\n\t\t// \u68c0\u6d4b\u662f\u5426\u8001\u7684TaskRunnerConfig\u662f\u5426\u662f\u672c\u5730\u7684\u5b8c\u6574\u914d\u7f6e\uff0c\u5982\u679c\u662f\uff0c\u5219\u4e0d\u7ba1\u3002\r\n\t\tTaskRunnerConfig old = runnerConfigMap.get(key);\r\n\t\tif (old == null || (old != null && old.getCreateDate() == null)) {\r\n\t\t\tif (config.getState() < 1) {\r\n\t\t\t\trunnerConfigMap.remove(key);\r\n\t\t\t} else {\r\n\t\t\t\trunnerConfigMap.put(key, config);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97croner\u914d\u7f6e\u952e\u3002 \u4f7f\u7528taskClass#Id$target\u6765\u914d\u7f6e\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getCronerConfigKey(TaskCronerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskParam() != null && config.getTaskParam().length() > 0) {\r\n\t\t\tsb.append(config.getId());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * \u83b7\u5f97Runner\u914d\u7f6e\u7ed3\u5408Host\u3002\r\n\t * \r\n\t * @return\r\n\t */\r\n\tpublic static String getRunnerConfigKey(TaskRunnerConfig config) {\r\n\t\tStringBuilder sb = new StringBuilder(100);\r\n\t\tsb.append(config.getTaskClass()).append(\"#\");\r\n\t\tif (config.getTaskTag() != null && config.getTaskTag().length() > 0) {\r\n\t\t\tsb.append(config.getTaskTag());\r\n\t\t}\r\n\t\tsb.append(\"$\");\r\n\t\tif (config.getRunTarget() != null && config.getRunTarget().length() > 0) {\r\n\t\t\tsb.append(config.getRunTarget());\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n    /**\r\n     * \u83b7\u5f97RunnerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getRunnerLogKey(TaskData<?,?> log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskTag() != null && log.getTaskTag().length() > 0) {\r\n            sb.append(log.getTaskTag());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97CronerLog\u914d\u7f6eKEY\r\n     *\r\n     * @return\r\n     */\r\n    public static String getCronerLogKey(TaskCronerLog log) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(log.getTaskClass()).append(\"#\");\r\n        if (log.getTaskParam() != null && log.getTaskParam().length()>0){\r\n            sb.append(log.getTaskParam());\r\n        }\r\n        sb.append(\"$\");\r\n        if (log.getRunTarget() != null && log.getRunTarget().length() > 0) {\r\n            sb.append(log.getRunTarget());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\nsrc/main/java/uw/task/api/TaskAPI.java\npublic class TaskAPI {\n\n    private static final Logger log = LoggerFactory.getLogger(TaskAPI.class);\n\n    /**\n     * Task\u914d\u7f6e\u6587\u4ef6\n     */\n    private TaskProperties taskProperties;\n\n    /**\n     * Rest\u6a21\u677f\u7c7b\n     */\n    private RestTemplate restTemplate;\n\n    /**\n     * \u65e5\u5fd7\u5ba2\u6237\u7aef\u3002\n     */\n    private LogClient logClient = null;\n\n    /**\n     * \u672c\u673a\u7684\u5916\u7f51IP\n     */\n    private String hostIp = \"\";\n\n    public TaskAPI(final TaskProperties taskProperties, final RestTemplate restTemplate,\n                   final LogClient logClient) {\n        this.taskProperties = taskProperties;\n        this.restTemplate = restTemplate;\n        this.logClient = logClient;\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return hostIp;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u76ee\u6807\u914d\u7f6e\u3002\n     *\n     * @return\n     */\n    public List<String> getServerTargetConfig() {\n        List<String> targetConfig = null;\n        // \u5224\u65ad\u662f\u5426\u662f\u79c1\u6709\u6a21\u5f0f\u3002\n        boolean privacyMode = taskProperties.isPrivacyMode();\n        try {\n            String[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/target/config?targetType={targetType}\", String[].class,\n                    privacyMode ? 1 : 0);\n            targetConfig = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getHostConfig()\u670d\u52a1\u7aefTarget\u914d\u7f6e\u62c9\u53d6\u5f02\u5e38:{}\", e.getMessage());\n        }\n        if (targetConfig == null || targetConfig.size() == 0) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"\u83b7\u5f97\u4e3b\u673aTarget\u670d\u52a1\u7aef\u914d\u7f6e\u5931\u8d25\uff0c\u542f\u7528\u9ed8\u8ba4\u914d\u7f6e\u9879!\");\n            }\n            targetConfig = new ArrayList<>();\n            if (!privacyMode) {\n                targetConfig.add(\"\");\n            }\n        }\n        return targetConfig;\n    }\n\n    /**\n     * \u66f4\u65b0\u5f53\u524d\u4e3b\u673a\u72b6\u6001\uff0c\u8fd4\u56de\u4e3b\u673aIP\u5730\u5740\u3002\n     *\n     * @return \u4e3b\u673aIP\u5730\u5740\n     */\n    public String updateHostStatus() {\n        String ip = \"\";\n        TaskHostStatus taskHostStatus = new TaskHostStatus();\n        taskHostStatus.setHostId(taskProperties.getHostId());\n        taskHostStatus.setTaskProject(taskProperties.getProject());\n        try {\n            ip = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/host/status\", taskHostStatus,\n                    String.class);\n            hostIp = ip;\n        } catch (Exception e) {\n            log.error(\"TaskAPI.updateHostStatus()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return ip;\n    }\n\n    /**\n     * \u521d\u59cb\u5316CronerConfig\u3002\n     *\n     * @param config\n     */\n    public TaskCronerConfig initTaskCronerConfig(TaskCronerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/croner/config\", config,\n                    TaskCronerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskCronerConfig\u4e0a\u4f20Croner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n    }\n\n    /**\n     * \u521d\u59cb\u5316RunnerConfig\n     *\n     * @param config\n     */\n    public TaskRunnerConfig initTaskRunnerConfig(TaskRunnerConfig config) {\n        try {\n            config = restTemplate.postForObject(taskProperties.getTaskCenterHost() + \"/taskapi/runner/config\", config,\n                    TaskRunnerConfig.class);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskRunnerConfig\u4e0a\u4f20Runner\u914d\u7f6e\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n        return config;\n\n    }\n\n    /**\n     * \u521d\u59cb\u5316\u8054\u7cfb\u4eba\u4fe1\u606f\u3002\n     *\n     * @param contact\n     */\n    public void initTaskContact(TaskContact contact) {\n        try {\n            restTemplate.postForLocation(taskProperties.getTaskCenterHost() + \"/taskapi/contact\", contact);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.initTaskContact\u4e0a\u4f20\u8054\u7cfb\u4eba\u4fe1\u606f\u5230\u670d\u52a1\u7aef\u5f02\u5e38:{}\", e.getMessage());\n        }\n    }\n\n    /**\n     * \u6839\u636e\u66f4\u65b0\u65f6\u95f4\u83b7\u5f97\u53d8\u5316\u7684TaskRunner\u961f\u5217\u5217\u8868\u3002\n     *\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerQueueList(long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost() + \"/taskapi/runner/queue?lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerQueueList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskRunner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskRunnerConfig> getTaskRunnerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskRunnerConfig> list = null;\n        try {\n            TaskRunnerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/runner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskRunnerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskRunnerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u6839\u636e\u5305\u540d\u524d\u7f00\u83b7\u5f97TaskCroner\u914d\u7f6e\u5217\u8868\u3002\n     *\n     * @param taskPackage\n     * @param lastUpdateTime \u6700\u540e\u66f4\u65b0\u65f6\u95f4\n     * @return\n     */\n    public List<TaskCronerConfig> getTaskCronerConfigList(String taskPackage, long lastUpdateTime) {\n        List<TaskCronerConfig> list = null;\n        try {\n            TaskCronerConfig[] data = restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/config?taskPackage={taskPackage}&lastUpdateTime={lastUpdateTime}\",\n                    TaskCronerConfig[].class, taskPackage, lastUpdateTime);\n            list = Arrays.asList(data);\n        } catch (Exception e) {\n            log.error(\"TaskAPI.getTaskCronerConfigList()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38:{}\", e.getMessage());\n        }\n\n        return list;\n    }\n\n    /**\n     * \u53d1\u9001Runner\u4efb\u52a1\u65e5\u5fd7\u3002\n     *\n     * @param log\n     */\n    public void sendTaskRunnerLog(TaskRunnerLog log) {\n        logClient.log(log);\n    }\n\n    /**\n     * \u53d1\u9001CronLog\u65e5\u5fd7\n     *\n     * @param configId      \u914d\u7f6eId,\u65b9\u4fbf\u66f4\u65b0\u4e0b\u4e00\u6b21\u6267\u884c\u65f6\u95f4\n     * @param taskCronerLog \u65e5\u5fd7\u5bf9\u8c61\n     */\n    public void sendTaskCronerLog(long configId, TaskCronerLog taskCronerLog) {\n        try {\n            restTemplate.getForObject(\n                    taskProperties.getTaskCenterHost()\n                            + \"/taskapi/croner/tick?id={id}&nextDate={nextDate}\",\n                    Integer.class, configId, taskCronerLog.getNextDate().getTime());\n        } catch (Exception e) {\n            log.error(\"TaskAPI.cornerTick()\u670d\u52a1\u7aef\u4e3b\u673a\u72b6\u6001\u66f4\u65b0\u5f02\u5e38: \" + e.getMessage(), e);\n        }\n\n        int logLevel = taskCronerLog.getLogLevel();\n        int logLimitSize = taskCronerLog.getLogLimitSize();\n        if (logLevel > TaskCronerConfig.TASK_LOG_TYPE_NONE) {\n            switch (logLevel) {\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD: {\n                    taskCronerLog.setTaskParam(null);\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM: {\n                    String taskParam = taskCronerLog.getTaskParam();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                        taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setResultData(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA: {\n                    String resultData = taskCronerLog.getResultData();\n                    if (logLimitSize > 0 && StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                        taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                    }\n                    taskCronerLog.setTaskParam(null);\n                }\n                break;\n                case TaskCronerConfig.TASK_LOG_TYPE_RECORD_ALL: {\n                    if (logLimitSize > 0) {\n                        String taskParam = taskCronerLog.getTaskParam();\n                        String resultData = taskCronerLog.getResultData();\n                        if (StringUtils.isNotBlank(taskParam) && taskParam.length() > logLimitSize) {\n                            taskCronerLog.setTaskParam(taskParam.substring(0, logLimitSize));\n                        }\n                        if (StringUtils.isNotBlank(resultData) && resultData.length() > logLimitSize) {\n                            taskCronerLog.setResultData(resultData.substring(0, logLimitSize));\n                        }\n                    }\n                }\n                break;\n            }\n            logClient.log(taskCronerLog);\n        }\n    }\n}\nsrc/main/java/uw/task/exception/TaskDataException.java\npublic class TaskDataException extends Exception {\r\n\r\n    /**\r\n     * <code>serialVersionUID</code> \u7684\u6ce8\u91ca\r\n     */\r\n    private static final long serialVersionUID = 8713460933603499992L;\r\n\r\n    public TaskDataException() {\r\n        super();\r\n    }\r\n\r\n    public TaskDataException(String msg) {\r\n        super(msg);\r\n    }\r\n\r\n    public TaskDataException(Throwable nestedThrowable) {\r\n        super(nestedThrowable);\r\n    }\r\n\r\n    public TaskDataException(String msg, Throwable nestedThrowable) {\r\n        super(msg, nestedThrowable);\r\n    }\r\n\r\n}\nsrc/main/java/uw/task/entity/TaskRunnerConfig.java\npublic class TaskRunnerConfig implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u4e0d\u9650\u901f\n     */\n    public static final int RATE_LIMIT_NONE = 0;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730\u8fdb\u7a0b\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL = 1;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK = 2;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u672c\u5730TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_LOCAL_TASK_TAG = 3;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40\u4e3b\u673aHOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_HOST = 4;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG = 5;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK = 6;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TAG+HOST\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TAG_HOST = 7;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_HOST = 8;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG = 9;\n\n    /**\n     * \u9650\u901f\u7c7b\u578b\uff1a\u5168\u5c40TASK+TAG+IP\u9650\u901f\n     */\n    public static final int RATE_LIMIT_GLOBAL_TASK_TAG_HOST = 10;\n\n    /**\n     * \u4ec0\u4e48\u90fd\u4e0d\u8bb0\u5f55\n     */\n    public static final int TASK_LOG_TYPE_NONE = -1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD = 0;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8bf7\u6c42\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_TASK_PARAM = 1;\n\n    /**\n     * \u8bb0\u5f55\u65e5\u5fd7,\u542b\u8fd4\u56de\u53c2\u6570\n     */\n    public static final int TASK_LOG_TYPE_RECORD_RESULT_DATA = 2;\n\n    /**\n     * \u8bb0\u5f55\u5168\u90e8\u65e5\u5fd7\n     */\n    public static final int TASK_LOG_TYPE_RECORD_ALL = 3;\n\n    private long id;\n\n    /**\n     * \u4efb\u52a1\u540d\u79f0\n     */\n    private String taskName;\n\n    /**\n     * \u4efb\u52a1\u63cf\u8ff0\n     */\n    private String taskDesc;\n\n    /**\n     * \u6267\u884c\u7c7b\u4fe1\u606f\n     */\n    private String taskClass;\n\n    /**\n     * \u6267\u884c\u7c7bTAG\uff0c\u53ef\u80fd\u7528\u4e8e\u533a\u5206\u5b50\u4efb\u52a1\n     */\n    private String taskTag;\n\n    /**\n     * \u6d88\u8d39\u8005\u7684\u6570\u91cf\n     */\n    private int consumerNum = 1;\n\n    /**\n     * \u9884\u53d6\u4efb\u52a1\u6570\u3002\n     */\n    private int prefetchNum = 1;\n\n    /**\n     * \u8be6\u89c1\u6d41\u91cf\u9650\u5236\u7c7b\u578b\u8bf4\u660e\u3002\n     */\n    private int rateLimitType = RATE_LIMIT_NONE;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u6570\u503c\uff0c\u9ed8\u8ba4\u4e3a10\u6b21\n     */\n    private int rateLimitValue = 10;\n\n    /**\n     * \u6d41\u91cf\u9650\u5b9a\u65f6\u95f4(S)\uff0c\u9ed8\u8ba4\u4e3a1\u79d2\n     */\n    private int rateLimitTime = 1;\n\n    /**\n     * \u5f53\u53d1\u751f\u6d41\u91cf\u9650\u5236\u65f6\uff0c\u7b49\u5f85\u7684\u79d2\u6570\uff0c\u9ed8\u8ba4300\u79d2\n     */\n    private int rateLimitWait = 30;\n\n    /**\n     * \u8d85\u8fc7\u6d41\u91cf\u9650\u5236\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u5728\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByOverrated = 0;\n\n    /**\n     * \u5bf9\u65b9\u63a5\u53e3\u9519\u8bef\u91cd\u8bd5\u6b21\u6570\uff0c\u9ed8\u8ba4\u4e0d\u518d\u91cd\u8bd5\uff0c\u653e\u5f03\u4efb\u52a1\u3002\n     */\n    private int retryTimesByPartner = 0;\n\n    /**\n     * \u8fd0\u884c\u76ee\u6807\uff0c\u9ed8\u8ba4\u4e0d\u6307\u5b9a\n     */\n    private String runTarget = \"\";\n\n    /**\n     * \u5931\u8d25\u7387\n     */\n    private int failRate;\n\n    /**\n     * \u63a5\u53e3\u5931\u8d25\u7387\n     */\n    private int failPartnerRate;\n\n    /**\n     * \u7a0b\u5e8f\u5931\u8d25\u7387\n     */\n    private int failProgramRate;\n\n    /**\n     * \u914d\u7f6e\u5931\u8d25\u7387\n     */\n    private int failConfigRate;\n\n    /**\n     * \u6570\u636e\u5931\u8d25\u7387\n     */\n    private int failDataRate;\n\n    /**\n     * \u961f\u5217\u7b49\u5f85\u8d85\u65f6\n     */\n    private int queueTimeout;\n\n    /**\n     * \u7b49\u5f85\u8d85\u65f6\n     */\n    private int waitTimeout;\n\n    /**\n     * \u8fd0\u884c\u8d85\u65f6\n     */\n    private int runTimeout;\n\n    /**\n     * \u521b\u5efa\u65e5\u671f\u3002\n     */\n    private Date createDate;\n\n    /**\n     * \u4fee\u6539\u65e5\u671f\u3002\n     */\n    private Date modifyDate;\n\n    /**\n     * \u72b6\u6001\u503c\n     */\n    private int state = 1;\n\n    /**\n     * \u8be6\u89c1\u65e5\u5fd7\u7c7b\u578b\u8bf4\u660e\n     */\n    private int logLevel = TASK_LOG_TYPE_RECORD;\n\n    /**\n     * \u65e5\u5fd7\u5b57\u7b26\u4e32\u5b57\u6bb5\u5927\u5c0f\u9650\u5236: 0 \u8868\u793a\u65e0\u9650\u5236\n     */\n    private int logLimitSize = 0;\n\n    public TaskRunnerConfig() {\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public String getTaskName() {\n        return taskName;\n    }\n\n    public void setTaskName(String taskName) {\n        this.taskName = taskName;\n    }\n\n    public String getTaskDesc() {\n        return taskDesc;\n    }\n\n    public void setTaskDesc(String taskDesc) {\n        this.taskDesc = taskDesc;\n    }\n\n    public String getTaskClass() {\n        return taskClass;\n    }\n\n    public void setTaskClass(String taskClass) {\n        this.taskClass = taskClass;\n    }\n\n    public String getTaskTag() {\n        return taskTag;\n    }\n\n    public void setTaskTag(String taskTag) {\n        this.taskTag = taskTag;\n    }\n\n    public int getConsumerNum() {\n        return consumerNum;\n    }\n\n    public void setConsumerNum(int consumerNum) {\n        this.consumerNum = consumerNum;\n    }\n\n    public int getPrefetchNum() {\n        return prefetchNum;\n    }\n\n    public void setPrefetchNum(int prefetchNum) {\n        this.prefetchNum = prefetchNum;\n    }\n\n    public int getRateLimitType() {\n        return rateLimitType;\n    }\n\n    public void setRateLimitType(int rateLimitType) {\n        this.rateLimitType = rateLimitType;\n    }\n\n    public int getRateLimitValue() {\n        return rateLimitValue;\n    }\n\n    public void setRateLimitValue(int rateLimitValue) {\n        this.rateLimitValue = rateLimitValue;\n    }\n\n    public int getRateLimitTime() {\n        return rateLimitTime;\n    }\n\n    public void setRateLimitTime(int rateLimitTime) {\n        this.rateLimitTime = rateLimitTime;\n    }\n\n    public int getRateLimitWait() {\n        return rateLimitWait;\n    }\n\n    public void setRateLimitWait(int rateLimitWait) {\n        this.rateLimitWait = rateLimitWait;\n    }\n\n    public int getRetryTimesByOverrated() {\n        return retryTimesByOverrated;\n    }\n\n    public void setRetryTimesByOverrated(int retryTimesByOverrated) {\n        this.retryTimesByOverrated = retryTimesByOverrated;\n    }\n\n    public int getRetryTimesByPartner() {\n        return retryTimesByPartner;\n    }\n\n    public void setRetryTimesByPartner(int retryTimesByPartner) {\n        this.retryTimesByPartner = retryTimesByPartner;\n    }\n\n    public String getRunTarget() {\n        return runTarget;\n    }\n\n    public void setRunTarget(String runTarget) {\n        this.runTarget = runTarget;\n    }\n\n    public int getFailRate() {\n        return failRate;\n    }\n\n    public void setFailRate(int failRate) {\n        this.failRate = failRate;\n    }\n\n    public int getFailPartnerRate() {\n        return failPartnerRate;\n    }\n\n    public void setFailPartnerRate(int failPartnerRate) {\n        this.failPartnerRate = failPartnerRate;\n    }\n\n    public int getFailProgramRate() {\n        return failProgramRate;\n    }\n\n    public void setFailProgramRate(int failProgramRate) {\n        this.failProgramRate = failProgramRate;\n    }\n\n    public int getFailConfigRate() {\n        return failConfigRate;\n    }\n\n    public void setFailConfigRate(int failConfigRate) {\n        this.failConfigRate = failConfigRate;\n    }\n\n    public int getFailDataRate() {\n        return failDataRate;\n    }\n\n    public void setFailDataRate(int failDataRate) {\n        this.failDataRate = failDataRate;\n    }\n\n    public int getQueueTimeout() {\n        return queueTimeout;\n    }\n\n    public void setQueueTimeout(int queueTimeout) {\n        this.queueTimeout = queueTimeout;\n    }\n\n    public int getWaitTimeout() {\n        return waitTimeout;\n    }\n\n    public void setWaitTimeout(int waitTimeout) {\n        this.waitTimeout = waitTimeout;\n    }\n\n    public int getRunTimeout() {\n        return runTimeout;\n    }\n\n    public void setRunTimeout(int runTimeout) {\n        this.runTimeout = runTimeout;\n    }\n\n    public Date getCreateDate() {\n        return createDate;\n    }\n\n    public void setCreateDate(Date createDate) {\n        this.createDate = createDate;\n    }\n\n    public Date getModifyDate() {\n        return modifyDate;\n    }\n\n    public void setModifyDate(Date modifyDate) {\n        this.modifyDate = modifyDate;\n    }\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n    }\n\n    public int getLogLevel() {\n        return logLevel;\n    }\n\n    public void setLogLevel(int logLevel) {\n        this.logLevel = logLevel;\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/util/MiscUtils.java\npublic class MiscUtils {\r\n\r\n    /**\r\n     * taskData\u7684copy\u5668\u3002\r\n     */\r\n    private static BeanCopier beanCopier = BeanCopier.create(TaskData.class, TaskData.class, false);\r\n\r\n    /**\r\n     * copy taskData\u5bf9\u8c61\u3002\r\n     *\r\n     * @param srcData\r\n     * @param dstData\r\n     */\r\n    public static void copyTaskData(TaskData srcData, TaskData dstData) {\r\n        beanCopier.copy(srcData, dstData, null);\r\n    }\r\n\r\n    /**\r\n     * \u6253\u5370\u5f02\u5e38\u4fe1\u606f\uff0c\u5c4f\u853d\u6389spring\u81ea\u5df1\u7684\u5806\u6808\u8f93\u51fa\u3002\r\n     *\r\n     * @param e \u9700\u8981\u6253\u5370\u7684\u5f02\u5e38\u4fe1\u606f\r\n     * @return\r\n     */\r\n    public static String exceptionToString(Throwable e) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(e.toString()).append(\"\\n\");\r\n\r\n        StackTraceElement[] trace = e.getStackTrace();\r\n        for (StackTraceElement traceElement : trace) {\r\n            if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                continue;\r\n            }\r\n            if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                continue;\r\n            }\r\n            sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n        }\r\n        Throwable ourCause = e.getCause();\r\n        if (ourCause != null) {\r\n            sb.append(\"CAUSE BY\").append(ourCause.toString()).append(\"\\n\");\r\n            trace = ourCause.getStackTrace();\r\n            for (StackTraceElement traceElement : trace) {\r\n                if (traceElement.getClassName().startsWith(\"org.spring\")) {\r\n                    continue;\r\n                }\r\n                if (traceElement.getClassName().startsWith(\"sun.\")) {\r\n                    continue;\r\n                }\r\n                sb.append(\"\\tat \").append(traceElement).append(\"\\n\");\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/TaskListenerManager.java\npublic class TaskListenerManager {\r\n\r\n\t/**\r\n\t * runner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n\t */\r\n    private ArrayList<RunnerTaskListener> runnerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * croner\u76d1\u542c\u5668\u5217\u8868\u3002\r\n     */\r\n    private ArrayList<CronerTaskListener> cronerListenerList = new ArrayList<>();\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener\u3002\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addRunnerListener(RunnerTaskListener listener) {\r\n        runnerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u52a0\u5165\u4e00\u4e2aRunnerListener.\r\n     *\r\n     * @param listener\r\n     */\r\n    public void addCronerListener(CronerTaskListener listener) {\r\n        cronerListenerList.add(listener);\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearRunnerListener() {\r\n        runnerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u6e05\u9664RunnerListener\u5217\u8868\r\n     */\r\n    public void clearCronerListener() {\r\n        cronerListenerList.clear();\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Runner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<RunnerTaskListener> getRunnerListenerList() {\r\n        return runnerListenerList;\r\n    }\r\n\r\n    /**\r\n     * \u83b7\u5f97Croner Listener\u5217\u8868\u3002\r\n     *\r\n     * @return\r\n     */\r\n    public ArrayList<CronerTaskListener> getCronerListenerList() {\r\n        return cronerListenerList;\r\n    }\r\n\r\n}\r\nsrc/main/java/uw/task/entity/TaskRunnerLog.java\n@JsonIgnoreProperties({\"taskData\"})\npublic class TaskRunnerLog extends LogBaseVo {\n\n    private static final Logger logger = LoggerFactory.getLogger(TaskRunnerLog.class);\n\n    private TaskData taskData;\n\n    /**\n     * logLimitSize\u3002\n     */\n    private int logLimitSize;\n\n    public TaskRunnerLog(TaskData taskData) {\n        this.taskData = taskData;\n    }\n\n    public TaskData getTaskData() {\n        return taskData;\n    }\n\n    /**\n     * @return the id\n     */\n    public long getId() {\n        return taskData.getId();\n    }\n\n    /**\n     * @return the refId\n     */\n    public long getRefId() {\n        return taskData.getRefId();\n    }\n\n    /**\n     * @return the refSubId\n     */\n    public long getRefSubId() {\n        return taskData.getRefSubId();\n    }\n\n    /**\n     * @return the refTag\n     */\n    public String getRefTag() {\n        return taskData.getRefTag();\n    }\n\n    /**\n     * @return the rateLimitTag\n     */\n    public String getRateLimitTag() {\n        return taskData.getRateLimitTag();\n    }\n\n    /**\n     * @return the taskClass\n     */\n    public String getTaskClass() {\n        return taskData.getTaskClass();\n    }\n\n    /**\n     * @return the taskTag\n     */\n    public String getTaskTag() {\n        return taskData.getTaskTag();\n    }\n\n    public long getTaskDelay() {\n        return taskData.getTaskDelay();\n    }\n\n    /**\n     * @return the taskParam\n     */\n    public String getTaskParam() {\n        Object value = taskData.getTaskParam();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_TASK_PARAM) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the runType\n     */\n    public int getRunType() {\n        return taskData.getRunType();\n    }\n\n    /**\n     * @return the retryType\n     */\n    public int getRetryType() {\n        return taskData.getRetryType();\n    }\n\n    /**\n     * @return the runTarget\n     */\n    public String getRunTarget() {\n        return taskData.getRunTarget();\n    }\n\n    /**\n     * @return the hostIp\n     */\n    public String getHostIp() {\n        return taskData.getHostIp();\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return taskData.getHostId();\n    }\n\n    /**\n     * @return the queueDate\n     */\n    public Date getQueueDate() {\n        return taskData.getQueueDate();\n    }\n\n    /**\n     * @return the consumeDate\n     */\n    public Date getConsumeDate() {\n        return taskData.getConsumeDate();\n    }\n\n    /**\n     * @return the runDate\n     */\n    public Date getRunDate() {\n        return taskData.getRunDate();\n    }\n\n    /**\n     * @return the finishDate\n     */\n    public Date getFinishDate() {\n        return taskData.getFinishDate();\n    }\n\n    /**\n     * @return the resultData\n     */\n    public String getResultData() {\n        Object value = taskData.getResultData();\n        if (value != null) {\n            // \u62a5\u9519\u4e86\n            if (taskData.getState() != TaskData.STATE_SUCCESS || logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_ALL ||\n                    logLevel == TaskRunnerConfig.TASK_LOG_TYPE_RECORD_RESULT_DATA) {\n                String data = null;\n                try {\n                    data = JsonMapper.MAPPER.writeValueAsString(value);\n                } catch (Exception e) {\n                    data = e.getMessage();\n                    logger.error(e.getMessage(), e);\n                }\n                if (data != null) {\n                    if (logLimitSize > 0 && data.length() > logLimitSize) {\n                        data = data.substring(0, logLimitSize);\n                    }\n                    return data;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @return the errorInfo\n     */\n    public String getErrorInfo() {\n        return taskData.getErrorInfo();\n    }\n\n    /**\n     * @return the ranTimes\n     */\n    public int getRanTimes() {\n        return taskData.getRanTimes();\n    }\n\n    /**\n     * @return the status\n     */\n    public int getState() {\n        return taskData.getState();\n    }\n\n    public int getLogLimitSize() {\n        return logLimitSize;\n    }\n\n    public void setLogLimitSize(int logLimitSize) {\n        this.logLimitSize = logLimitSize;\n    }\n}\nsrc/main/java/uw/task/conf/TaskProperties.java\n@ConfigurationProperties(prefix = \"uw.task\")\npublic class TaskProperties {\n\n    /**\n     * \u662f\u5426\u542f\u7528uw-task\u670d\u52a1\u6ce8\u518c\u548c\u4e3b\u673a\u6ce8\u518c\uff0c\u9ed8\u8ba4\u4e0d\u542f\u7528\u3002\n     *\n     */\n    private boolean enableTaskRegistry = false;\n    /**\n     * \u4efb\u52a1\u540d\uff0c\u5fc5\u987b\u8bbe\u7f6e\u4e3a\u57fa\u7840\u5305\u540d\u3002\n     */\n    private String project;\n\n    /**\n     * \u79c1\u6709\u6a21\u5f0f\u3002\u4e0d\u8fd0\u884c\u5168\u5c40target\u4efb\u52a1\u3002\n     */\n    private boolean privacyMode = false;\n\n    /**\n     * croner\u7ebf\u7a0b\u6570\uff0c\u9ed8\u8ba4\u57283\u4e2a\uff0c\u5efa\u8bae\u6309\u7167\u5b9e\u9645croner\u4efb\u52a1\u6570\u91cf*70%\u3002\n     */\n    private int cronerThreadNum = 5;\n\n    /**\n     * RPC\u6700\u5c0f\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u5982\u4e0d\u4f7f\u7528rpc\uff0c\u5efa\u8bae\u8bbe\u7f6e\u4e3a1\uff0c\u5426\u5219\u6309\u7167\u6700\u5927\u5e76\u53d1\u91cf*10%\u8bbe\u7f6e\u3002\n     */\n    private int taskRpcMinThreadNum = 1;\n\n    /**\n     * RPC\u6700\u5927\u7ebf\u7a0b\u6570,\u7528\u4e8e\u6267\u884cRPC\u8c03\u7528\uff0c\u8d85\u8fc7\u6b64\u7ebf\u7a0b\u6570\uff0c\u5c06\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\n     */\n    private int taskRpcMaxThreadNum = 100;\n\n    /**\n     * \u961f\u5217\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba42\u79d2\n     */\n    private long taskQueueRetryDelay = 2000;\n\n    /**\n     *  rpc\u4efb\u52a1\u91cd\u8bd5\u5ef6\u65f6\u6beb\u79d2\u6570\uff0c\u9ed8\u8ba4100\u6beb\u79d2\n     */\n    private long taskRpcRetryDelay = 100;\n\n    /**\n     * \u8fd0\u884c\u4e3b\u673aID\n     */\n    private String hostId = ManagementFactory.getRuntimeMXBean().getName();\n\n    /**\n     * \u4efb\u52a1\u670d\u52a1\u5668\n     */\n    private String taskCenterHost = \"127.0.0.1\";\n\n    /**\n     * Redis\u914d\u7f6e\n     */\n    private RedisProperties redis = new RedisProperties();\n\n    /**\n     * Rabbit MQ\u914d\u7f6e\n     */\n    private RabbitProperties rabbitmq = new RabbitProperties();\n\n    public static class RedisProperties extends org.springframework.boot.autoconfigure.data.redis.RedisProperties {\n\n    }\n\n    public static class RabbitProperties extends org.springframework.boot.autoconfigure.amqp.RabbitProperties {\n\n    }\n\n    public boolean isEnableTaskRegistry() {\n        return enableTaskRegistry;\n    }\n\n    public void setEnableTaskRegistry(boolean enableTaskRegistry) {\n        this.enableTaskRegistry = enableTaskRegistry;\n    }\n\n    /**\n\t * @return the privacyMode\n\t */\n\tpublic boolean isPrivacyMode() {\n\t\treturn privacyMode;\n\t}\n\n\t/**\n\t * @param privacyMode the privacyMode to set\n\t */\n\tpublic void setPrivacyMode(boolean privacyMode) {\n\t\tthis.privacyMode = privacyMode;\n\t}\n\n\tpublic int getTaskRpcMinThreadNum() {\n\t\treturn taskRpcMinThreadNum;\n\t}\n\n\tpublic void setTaskRpcMinThreadNum(int taskRpcMinThreadNum) {\n\t\tthis.taskRpcMinThreadNum = taskRpcMinThreadNum;\n\t}\n\n\tpublic int getTaskRpcMaxThreadNum() {\n\t\treturn taskRpcMaxThreadNum;\n\t}\n\n\tpublic void setTaskRpcMaxThreadNum(int taskRpcMaxThreadNum) {\n\t\tthis.taskRpcMaxThreadNum = taskRpcMaxThreadNum;\n\t}\n\n\t/**\n     * @return the project\n     */\n    public String getProject() {\n        return project;\n    }\n\n    /**\n     * @param project the project to set\n     */\n    public void setProject(String project) {\n        this.project = project;\n    }\n\n    /**\n     * @return the hostId\n     */\n    public String getHostId() {\n        return hostId;\n    }\n\n    /**\n     * @param hostId the hostId to set\n     */\n    public void setHostId(String hostId) {\n        this.hostId = hostId;\n    }\n\n    /**\n\t * @return the cronerThreadNum\n\t */\n\tpublic int getCronerThreadNum() {\n\t\treturn cronerThreadNum;\n\t}\n\n\t/**\n\t * @param cronerThreadNum the cronerThreadNum to set\n\t */\n\tpublic void setCronerThreadNum(int cronerThreadNum) {\n\t\tthis.cronerThreadNum = cronerThreadNum;\n\t}\n\n\t/**\n     * @return the taskCenterHost\n     */\n    public String getTaskCenterHost() {\n        return taskCenterHost;\n    }\n\n    /**\n     * @param taskCenterHost the taskCenterHost to set\n     */\n    public void setTaskCenterHost(String taskCenterHost) {\n        this.taskCenterHost = taskCenterHost;\n    }\n\n    public RedisProperties getRedis() {\n        return redis;\n    }\n\n    public void setRedis(RedisProperties redis) {\n        this.redis = redis;\n    }\n\n    public RabbitProperties getRabbitmq() {\n        return rabbitmq;\n    }\n\n    public void setRabbitmq(RabbitProperties rabbitmq) {\n        this.rabbitmq = rabbitmq;\n    }\n\n    public long getTaskQueueRetryDelay() {\n        return taskQueueRetryDelay;\n    }\n\n    public void setTaskQueueRetryDelay(long taskQueueRetryDelay) {\n        this.taskQueueRetryDelay = taskQueueRetryDelay;\n    }\n\n    public long getTaskRpcRetryDelay() {\n        return taskRpcRetryDelay;\n    }\n\n    public void setTaskRpcRetryDelay(long taskRpcRetryDelay) {\n        this.taskRpcRetryDelay = taskRpcRetryDelay;\n    }\n}\n", "answers": ["    private LocalRateLimiter localRateLimiter;"], "pred": "  ******************************************************************************************************************************", "length": 5298, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "fbea06f3c6f93b8aaf69f52783041ff4c6ce262cc8922060"}
{"prompt": "Please complete the code given below. \nsrc/main/java/org/cryptomator/sanitizer/Passphrase.java\npublic class Passphrase implements CharSequence, AutoCloseable {\n\n\tprivate final char[] chars;\n\n\tpublic Passphrase(char[] chars) {\n\t\tthis.chars = chars;\n\t}\n\n\tpublic Passphrase(CharBuffer chars) {\n\t\tthis.chars = new char[chars.remaining()];\n\t\tchars.get(this.chars);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tArrays.fill(chars, ' ');\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn chars.length;\n\t}\n\n\t@Override\n\tpublic char charAt(int index) {\n\t\treturn chars[index];\n\t}\n\n\t@Override\n\tpublic Passphrase subSequence(int start, int end) {\n\t\tint len = end - start;\n\t\tchar[] result = new char[len];\n\t\tSystem.arraycopy(chars, start, result, 0, len);\n\t\treturn new Passphrase(result);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new String(chars);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/IntegrityCheck.java\npublic class IntegrityCheck {\n\n\tprivate final CryptorHolder cryptorHolder;\n\n\tpublic IntegrityCheck(CryptorHolder cryptorHolder) {\n\t\tthis.cryptorHolder = cryptorHolder;\n\t}\n\n\tpublic Set<Problem> check(Path path, CharSequence passphrase, boolean checkFileIntegrity) throws AbortCheckException {\n\t\tProblems problems = new Problems(path);\n\t\ttry {\n\t\t\tcryptorHolder.createCryptor(problems, path, passphrase).ifPresent(cryptor -> {\n\t\t\t\ttry {\n\t\t\t\t\tvaultFormatChecks(cryptor, path, checkFileIntegrity).check(problems, path);\n\t\t\t\t} finally {\n\t\t\t\t\tcryptor.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (AbortCheckException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tproblems.reportException(e);\n\t\t}\n\t\treturn problems.asSet();\n\t}\n\n\tprivate Check vaultFormatChecks(Cryptor cryptor, Path pathToVault, boolean checkContentIntegrity) {\n\t\tCheck referencedDirectoryExists = referencedDirectoryExists(cryptor, pathToVault);\n\t\tHasCorrespondingDirectoryFileCheck hasCorrespondingDirectoryFileCheck = hasCorrespondingDirectoryFile(cryptor, pathToVault);\n\t\tCheck decryptedNameCheckForRegularFiles = decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck);\n\t\tHasCorrespondingDFileCheck hasCorrespondingDFile = hasCorrespondingDFileIn(pathToVault);\n\t\tCheck decryptedNameCheckForLongFiles = Checks.decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck, hasCorrespondingDFile);\n\t\tCheck emptyEncryptedFileIfEmpty = emptyEncryptedFileIfEmpty();\n\t\treturn dir().containing( //\n\t\t\t\tdir().that(hasName(\"d\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{30}\")) //\n\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()).validate(hasCorrespondingDirectoryFileCheck) //\n\t\t\t\t\t\t\t\t\t\t.reportAs(rootDirectoryIfMachting(cryptor)) //\n\t\t\t\t\t\t\t\t\t\t.containing( //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidDirectoryFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0?([A-Z2-7]{8})*[A-Z2-7=]{1,7}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aFileWithMissingEqualsSign()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tdir().that(hasName(\"m\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName()))\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles), //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName())) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles)\n\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator\")).validate(nameDoesNotContainUppercaseChars()), // do not validate contents because this already happened when creating the Cryptor\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator.bkup\")).validate(isMasterkeyBackupFile()));\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/SolutionContext.java\npublic interface SolutionContext {\n\n\tpublic static SolutionContext simulatePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, true);\n\t}\n\n\tpublic static SolutionContext executePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, false);\n\t}\n\n\tvoid start(String format, Object... args);\n\n\tvoid finish();\n\n\tvoid fail(String format, Object... args);\n\n\tvoid fail(Throwable reason);\n\n\tboolean dryRun();\n\n\tPath vaultLocation();\n\n\tCryptor cryptor();\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void printNoNewline(String line) {\n\tprintNoNewline(line, System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Severity.java\npublic enum Severity {\n\n\t/**\n\t * Issues which prevent the integrity check from operating correctly.\n\t */\n\tFATAL,\n\n\t/**\n\t * Issues which are guaranteed to cause problems while using the vault.\n\t */\n\tERROR,\n\n\t/**\n\t * Issues which are not guaranteed to cause problems while using the vault.\n\t */\n\tWARN,\n\n\t/**\n\t * Issues which occur during normal operation of the vault.\n\t */\n\tINFO\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Problem.java\npublic interface Problem {\n\n\tSeverity severity();\n\n\tdefault Optional<Solution> solution() {\n\t\treturn Optional.empty();\n\t}\n\n\tdefault String name() {\n\t\treturn \"notSolvable\";\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/CryptorHolder.java\npublic class CryptorHolder implements AutoCloseable {\n\n\tprivate static final int VAULT_VERSION = 6;\n\n\tprivate static final int VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION = 6;\n\n\tprivate Optional<Cryptor> cryptor = Optional.empty();\n\n\tpublic Optional<Cryptor> optionalCryptor() {\n\t\treturn cryptor;\n\t}\n\n\tpublic Optional<Cryptor> createCryptor(Problems problems, Path path, CharSequence passphrase) throws IOException, AbortCheckException {\n\t\tdestroyCryptor();\n\t\tPath masterkeyFile = path.resolve(\"masterkey.cryptomator\");\n\t\ttry {\n\t\t\tif (!isRegularFile(masterkeyFile)) {\n\t\t\t\tproblems.reportMissingMasterkeyFile(masterkeyFile);\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tKeyFile keyFile = KeyFile.parse(readAllBytes(masterkeyFile));\n\t\t\tif (keyFile.getVersion() != VAULT_VERSION) {\n\t\t\t\tthrow new AbortCheckException(format(\"Vault version mismatch. Expected: %d Actual: %d\", VAULT_VERSION, keyFile.getVersion()));\n\t\t\t}\n\t\t\tcryptor = Optional.of(bestGuessCryptorProvider(keyFile).createFromKeyFile(keyFile, normalizePassphrase(keyFile, passphrase), keyFile.getVersion()));\n\t\t\treturn cryptor;\n\t\t} catch (InvalidPassphraseException e) {\n\t\t\tthrow new AbortCheckException(\"Invalid passphrase\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (e.getCause() instanceof InvalidKeyException) {\n\t\t\t\tthrow new AbortCheckException(\"JCE files seem to be missing. Download from \\n\" //\n\t\t\t\t\t\t+ \"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html.\\n\" //\n\t\t\t\t\t\t+ \"and install according to instructions in README.txt\");\n\t\t\t} else {\n\t\t\t\tproblems.reportInvalidMasterkeyFile(masterkeyFile);\n\t\t\t}\n\t\t}\n\t\tcryptor = Optional.empty();\n\t\treturn cryptor;\n\t}\n\n\tpublic void destroyCryptor() {\n\t\tcryptor.ifPresent(Cryptor::destroy);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tdestroyCryptor();\n\t}\n\n\tpublic static CharSequence normalizePassphrase(KeyFile keyFile, CharSequence passphrase) {\n\t\tif (keyFile.getVersion() < VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION) {\n\t\t\treturn passphrase;\n\t\t}\n\t\treturn Normalizer.normalize(passphrase, Form.NFC);\n\t}\n\n\tpublic static CryptorProvider bestGuessCryptorProvider(KeyFile keyFile) {\n\t\tswitch (keyFile.getVersion()) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\treturn Cryptors.version1(strongSecureRandom());\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unsupported vault version \" + keyFile.getVersion());\n\t\t}\n\t}\n\n\tprivate static SecureRandom strongSecureRandom() {\n\t\ttry {\n\t\t\treturn SecureRandom.getInstanceStrong();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(\"Java platform is required to support a strong SecureRandom.\", e);\n\t\t}\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/AbortCheckException.java\npublic class AbortCheckException extends Exception {\n\n\tpublic AbortCheckException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void print() {\n\tprint(System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/utils/Counter.java\npublic class Counter {\n\n\tprivate long count = 0;\n\n\tpublic void increment() {\n\t\tcount++;\n\t}\n\n\tpublic long get() {\n\t\treturn count;\n\t}\n\n}\npackage org.cryptomator.sanitizer.commands;\nimport static java.lang.String.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.isDirectory;\nimport static java.nio.file.Files.isRegularFile;\nimport static java.nio.file.Files.newBufferedWriter;\nimport static java.nio.file.Files.size;\nimport static java.nio.file.Files.walk;\nimport static java.nio.file.StandardOpenOption.CREATE_NEW;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.util.Collections.sort;\nimport static java.util.stream.Collectors.toList;\nimport static org.cryptomator.sanitizer.Sanitizer.print;\nimport static org.cryptomator.sanitizer.Sanitizer.printNoNewline;\nimport static org.cryptomator.sanitizer.integrity.problems.Severity.INFO;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.cryptomator.sanitizer.CryptorHolder;\nimport org.cryptomator.sanitizer.Passphrase;\nimport org.cryptomator.sanitizer.integrity.AbortCheckException;\nimport org.cryptomator.sanitizer.integrity.IntegrityCheck;\nimport org.cryptomator.sanitizer.integrity.problems.Problem;\nimport org.cryptomator.sanitizer.integrity.problems.Severity;\nimport org.cryptomator.sanitizer.integrity.problems.SolutionContext;\nimport org.cryptomator.sanitizer.utils.Counter;\n\n\n\n\nclass CheckRunner implements Runnable {\n\n\tprivate static final long KIBI = 1024;\n\tprivate static final String[] KIBI_POWERS = {\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"};\n\n\tprivate final CheckCommand args;\n\n\tpublic CheckRunner(CheckCommand args) {\n\t\tthis.args = args;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry (CryptorHolder cryptorHolder = new CryptorHolder(); //\n\t\t\t\tPassphrase passphrase = args.passphrase()) {\n\t\t\tIntegrityCheck integrityCheck = new IntegrityCheck(cryptorHolder);Next line of code:\n", "input": "package org.cryptomator.sanitizer.commands;\nimport static java.lang.String.format;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.nio.file.Files.isDirectory;\nimport static java.nio.file.Files.isRegularFile;\nimport static java.nio.file.Files.newBufferedWriter;\nimport static java.nio.file.Files.size;\nimport static java.nio.file.Files.walk;\nimport static java.nio.file.StandardOpenOption.CREATE_NEW;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.util.Collections.sort;\nimport static java.util.stream.Collectors.toList;\nimport static org.cryptomator.sanitizer.Sanitizer.print;\nimport static org.cryptomator.sanitizer.Sanitizer.printNoNewline;\nimport static org.cryptomator.sanitizer.integrity.problems.Severity.INFO;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport org.cryptomator.sanitizer.CryptorHolder;\nimport org.cryptomator.sanitizer.Passphrase;\nimport org.cryptomator.sanitizer.integrity.AbortCheckException;\nimport org.cryptomator.sanitizer.integrity.IntegrityCheck;\nimport org.cryptomator.sanitizer.integrity.problems.Problem;\nimport org.cryptomator.sanitizer.integrity.problems.Severity;\nimport org.cryptomator.sanitizer.integrity.problems.SolutionContext;\nimport org.cryptomator.sanitizer.utils.Counter;\n\n\n\n\nclass CheckRunner implements Runnable {\n\n\tprivate static final long KIBI = 1024;\n\tprivate static final String[] KIBI_POWERS = {\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"};\n\n\tprivate final CheckCommand args;\n\n\tpublic CheckRunner(CheckCommand args) {\n\t\tthis.args = args;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry (CryptorHolder cryptorHolder = new CryptorHolder(); //\n\t\t\t\tPassphrase passphrase = args.passphrase()) {\n\t\t\tIntegrityCheck integrityCheck = new IntegrityCheck(cryptorHolder);", "context": "src/main/java/org/cryptomator/sanitizer/Passphrase.java\npublic class Passphrase implements CharSequence, AutoCloseable {\n\n\tprivate final char[] chars;\n\n\tpublic Passphrase(char[] chars) {\n\t\tthis.chars = chars;\n\t}\n\n\tpublic Passphrase(CharBuffer chars) {\n\t\tthis.chars = new char[chars.remaining()];\n\t\tchars.get(this.chars);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tArrays.fill(chars, ' ');\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn chars.length;\n\t}\n\n\t@Override\n\tpublic char charAt(int index) {\n\t\treturn chars[index];\n\t}\n\n\t@Override\n\tpublic Passphrase subSequence(int start, int end) {\n\t\tint len = end - start;\n\t\tchar[] result = new char[len];\n\t\tSystem.arraycopy(chars, start, result, 0, len);\n\t\treturn new Passphrase(result);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn new String(chars);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/IntegrityCheck.java\npublic class IntegrityCheck {\n\n\tprivate final CryptorHolder cryptorHolder;\n\n\tpublic IntegrityCheck(CryptorHolder cryptorHolder) {\n\t\tthis.cryptorHolder = cryptorHolder;\n\t}\n\n\tpublic Set<Problem> check(Path path, CharSequence passphrase, boolean checkFileIntegrity) throws AbortCheckException {\n\t\tProblems problems = new Problems(path);\n\t\ttry {\n\t\t\tcryptorHolder.createCryptor(problems, path, passphrase).ifPresent(cryptor -> {\n\t\t\t\ttry {\n\t\t\t\t\tvaultFormatChecks(cryptor, path, checkFileIntegrity).check(problems, path);\n\t\t\t\t} finally {\n\t\t\t\t\tcryptor.destroy();\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (AbortCheckException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tproblems.reportException(e);\n\t\t}\n\t\treturn problems.asSet();\n\t}\n\n\tprivate Check vaultFormatChecks(Cryptor cryptor, Path pathToVault, boolean checkContentIntegrity) {\n\t\tCheck referencedDirectoryExists = referencedDirectoryExists(cryptor, pathToVault);\n\t\tHasCorrespondingDirectoryFileCheck hasCorrespondingDirectoryFileCheck = hasCorrespondingDirectoryFile(cryptor, pathToVault);\n\t\tCheck decryptedNameCheckForRegularFiles = decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck);\n\t\tHasCorrespondingDFileCheck hasCorrespondingDFile = hasCorrespondingDFileIn(pathToVault);\n\t\tCheck decryptedNameCheckForLongFiles = Checks.decryptedNameCheck(cryptor, hasCorrespondingDirectoryFileCheck, hasCorrespondingDFile);\n\t\tCheck emptyEncryptedFileIfEmpty = emptyEncryptedFileIfEmpty();\n\t\treturn dir().containing( //\n\t\t\t\tdir().that(hasName(\"d\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{30}\")) //\n\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()).validate(hasCorrespondingDirectoryFileCheck) //\n\t\t\t\t\t\t\t\t\t\t.reportAs(rootDirectoryIfMachting(cryptor)) //\n\t\t\t\t\t\t\t\t\t\t.containing( //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\").and(hasCorrespondingMFileIn(pathToVault).that(containsValidDirectoryFileName()))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0?([A-Z2-7]{8})*[A-Z2-7=]{1,7}\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aFileWithMissingEqualsSign()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"0([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasSize(36).and(containsUuid()).and(referencedDirectoryExists)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"([A-Z2-7]{8})*[A-Z2-7=]{8}.+\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(emptyEncryptedFileIfEmpty) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasMinSize(88).and(isAuthentic(cryptor, checkContentIntegrity))) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForRegularFiles) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict()), //\n\t\t\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingMFileIn(pathToVault)) //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tdir().that(hasName(\"m\")).validate(nameDoesNotContainUppercaseChars()).containing( //\n\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\tdir().that(hasName(\"[A-Z2-7]{2}\")).validate(nameDoesNotContainLowercaseChars()).containing( //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName()))\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles), //\n\t\t\t\t\t\t\t\t\t\tfile().that(hasName(\"[A-Z2-7]{32}.+\\\\.lng\")) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(nameDoesNotContainLowercaseChars()) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(hasCorrespondingDFile.and(containsValidName())) //\n\t\t\t\t\t\t\t\t\t\t\t\t.validate(decryptedNameCheckForLongFiles)\n\t\t\t\t\t\t\t\t\t\t\t\t.reportAs(aConflict())))), //\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator\")).validate(nameDoesNotContainUppercaseChars()), // do not validate contents because this already happened when creating the Cryptor\n\t\t\t\tfile().that(hasName(\"masterkey.cryptomator.bkup\")).validate(isMasterkeyBackupFile()));\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/SolutionContext.java\npublic interface SolutionContext {\n\n\tpublic static SolutionContext simulatePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, true);\n\t}\n\n\tpublic static SolutionContext executePrintingTo(Path vaultLocation, Cryptor cryptor, PrintStream out) {\n\t\treturn new PrintStreamSolutionContext(vaultLocation, cryptor, out, false);\n\t}\n\n\tvoid start(String format, Object... args);\n\n\tvoid finish();\n\n\tvoid fail(String format, Object... args);\n\n\tvoid fail(Throwable reason);\n\n\tboolean dryRun();\n\n\tPath vaultLocation();\n\n\tCryptor cryptor();\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void printNoNewline(String line) {\n\tprintNoNewline(line, System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Severity.java\npublic enum Severity {\n\n\t/**\n\t * Issues which prevent the integrity check from operating correctly.\n\t */\n\tFATAL,\n\n\t/**\n\t * Issues which are guaranteed to cause problems while using the vault.\n\t */\n\tERROR,\n\n\t/**\n\t * Issues which are not guaranteed to cause problems while using the vault.\n\t */\n\tWARN,\n\n\t/**\n\t * Issues which occur during normal operation of the vault.\n\t */\n\tINFO\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/problems/Problem.java\npublic interface Problem {\n\n\tSeverity severity();\n\n\tdefault Optional<Solution> solution() {\n\t\treturn Optional.empty();\n\t}\n\n\tdefault String name() {\n\t\treturn \"notSolvable\";\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/CryptorHolder.java\npublic class CryptorHolder implements AutoCloseable {\n\n\tprivate static final int VAULT_VERSION = 6;\n\n\tprivate static final int VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION = 6;\n\n\tprivate Optional<Cryptor> cryptor = Optional.empty();\n\n\tpublic Optional<Cryptor> optionalCryptor() {\n\t\treturn cryptor;\n\t}\n\n\tpublic Optional<Cryptor> createCryptor(Problems problems, Path path, CharSequence passphrase) throws IOException, AbortCheckException {\n\t\tdestroyCryptor();\n\t\tPath masterkeyFile = path.resolve(\"masterkey.cryptomator\");\n\t\ttry {\n\t\t\tif (!isRegularFile(masterkeyFile)) {\n\t\t\t\tproblems.reportMissingMasterkeyFile(masterkeyFile);\n\t\t\t\treturn Optional.empty();\n\t\t\t}\n\t\t\tKeyFile keyFile = KeyFile.parse(readAllBytes(masterkeyFile));\n\t\t\tif (keyFile.getVersion() != VAULT_VERSION) {\n\t\t\t\tthrow new AbortCheckException(format(\"Vault version mismatch. Expected: %d Actual: %d\", VAULT_VERSION, keyFile.getVersion()));\n\t\t\t}\n\t\t\tcryptor = Optional.of(bestGuessCryptorProvider(keyFile).createFromKeyFile(keyFile, normalizePassphrase(keyFile, passphrase), keyFile.getVersion()));\n\t\t\treturn cryptor;\n\t\t} catch (InvalidPassphraseException e) {\n\t\t\tthrow new AbortCheckException(\"Invalid passphrase\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (e.getCause() instanceof InvalidKeyException) {\n\t\t\t\tthrow new AbortCheckException(\"JCE files seem to be missing. Download from \\n\" //\n\t\t\t\t\t\t+ \"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html.\\n\" //\n\t\t\t\t\t\t+ \"and install according to instructions in README.txt\");\n\t\t\t} else {\n\t\t\t\tproblems.reportInvalidMasterkeyFile(masterkeyFile);\n\t\t\t}\n\t\t}\n\t\tcryptor = Optional.empty();\n\t\treturn cryptor;\n\t}\n\n\tpublic void destroyCryptor() {\n\t\tcryptor.ifPresent(Cryptor::destroy);\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tdestroyCryptor();\n\t}\n\n\tpublic static CharSequence normalizePassphrase(KeyFile keyFile, CharSequence passphrase) {\n\t\tif (keyFile.getVersion() < VAULT_VERSION_INTRODUCING_PASSWORD_NORMALIZATION) {\n\t\t\treturn passphrase;\n\t\t}\n\t\treturn Normalizer.normalize(passphrase, Form.NFC);\n\t}\n\n\tpublic static CryptorProvider bestGuessCryptorProvider(KeyFile keyFile) {\n\t\tswitch (keyFile.getVersion()) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\t\treturn Cryptors.version1(strongSecureRandom());\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Unsupported vault version \" + keyFile.getVersion());\n\t\t}\n\t}\n\n\tprivate static SecureRandom strongSecureRandom() {\n\t\ttry {\n\t\t\treturn SecureRandom.getInstanceStrong();\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IllegalStateException(\"Java platform is required to support a strong SecureRandom.\", e);\n\t\t}\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/integrity/AbortCheckException.java\npublic class AbortCheckException extends Exception {\n\n\tpublic AbortCheckException(String message) {\n\t\tsuper(message);\n\t}\n\n}\nsrc/main/java/org/cryptomator/sanitizer/Sanitizer.java\npublic static void print() {\n\tprint(System.out);\n}\nsrc/main/java/org/cryptomator/sanitizer/utils/Counter.java\npublic class Counter {\n\n\tprivate long count = 0;\n\n\tpublic void increment() {\n\t\tcount++;\n\t}\n\n\tpublic long get() {\n\t\treturn count;\n\t}\n\n}\n", "answers": ["\t\t\tprint(\"Scanning vault structure may take some time. Be patient...\");"], "pred": "  (IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  IntegrityCheck code:  Integrity", "length": 924, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "47573702c5f1ad33b86b8645ddc49617af39e584b4303008"}
{"prompt": "Please complete the code given below. \nyasme/src/main/java/de/fau/cs/mad/yasme/android/encryption/KeyEncryption.java\npublic class KeyEncryption {\r\n\r\n    public static final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n    public static final String PRIVATEKEY = \"privateKey\";\r\n    public static final String PUBLICKEY = \"publicKey\";\r\n    private final byte CREATOR = 0;\r\n    private final byte RECIPIENT = 1;\r\n    private RSAEncryption rsa;\r\n    private DatabaseManager db = DatabaseManager.INSTANCE;\r\n\r\n    public KeyEncryption() {\r\n        this.rsa = new RSAEncryption();\r\n    }\r\n\r\n    /**\r\n     * generate a random RSA-KeyPair (Private and Public Key)\r\n     */\r\n    public void generateRSAKeys(){\r\n        rsa.generateKeyPair();\r\n    }\r\n\r\n    /**\r\n     * encode generated RSA-KeyPair to base64 and store it to local storage (SharedPreferences)\r\n     * there is a own SharedPreference for every user on the device\r\n     *\r\n     * @param deviceId deviceId from the user logged in currently\r\n     * @return true/false\r\n     */\r\n    public boolean saveRSAKeys(long deviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + deviceId;\r\n\r\n        try {\r\n\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            //delete existing keys\r\n            if (privKeyStorage.getString(PRIVATEKEY, \"\") != \"\"){\r\n                keyeditor.remove(PRIVATEKEY);\r\n            }\r\n            if (privKeyStorage.getString(PUBLICKEY, \"\") != \"\"){\r\n                keyeditor.remove(PUBLICKEY);\r\n            }\r\n\r\n            keyeditor.putString(PRIVATEKEY, rsa.getPrivKeyinBase64());\r\n            keyeditor.putString(PUBLICKEY, rsa.getPubKeyinBase64());\r\n\r\n            keyeditor.commit();\r\n\r\n            // For Developer-Devices only\r\n            if (DebugManager.INSTANCE.isDebugMode()) {\r\n                Log.d(getClass().getSimpleName(), \"Store keys to external storage\");\r\n                DebugManager.INSTANCE.storePrivatePublicKeyToExternalStorage(rsa.getPrivKeyinBase64(),rsa.getPubKeyinBase64());\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"RSA Keys generated and saved\");\r\n\r\n\r\n            return true;\r\n        } catch (Exception e){\r\n            Log.e(this.getClass().getSimpleName(), \"saving rsa keys failed\");\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the generated RSA Public Key in Base64\r\n     * method is needed in registration when the Public Key needs to be sent to the server\r\n     *\r\n     * @return base64 encoded string\r\n     */\r\n    public String getGeneratedPubKeyInBase64(){\r\n        return rsa.getPubKeyinBase64();\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the RSA PublicKey from the recipient\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be encrypted\r\n     * @return messageKey containing the RSA-encrypted AES-Key\r\n     */\r\n    public MessageKey encrypt(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, RECIPIENT);\r\n\r\n        if (pubKey != null){\r\n            String keyEncrypted = rsa.encrypt(messageKey.getMessageKey(), pubKey);\r\n            messageKey.setKey(keyEncrypted);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the encrypted AES-Key that should be decrypted\r\n     * @return messageKey containing the decrypted AES-Key\r\n     */\r\n    public MessageKey decrypt(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getRecipientDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String key = rsa.decrypt(messageKey.getMessageKey(), privKey);\r\n            if (key == null) {\r\n                return null;\r\n            }\r\n            messageKey.setKey(key);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sign an AES-Key using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be signed\r\n     * @return  messageKey containing the signature\r\n     */\r\n    public MessageKey sign(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getCreatorDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String keySigned = rsa.sign(messageKey.getMessageKey(), privKey);\r\n            messageKey.setSign(keySigned);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * verify the signature from given messageKey using the RSA Public Key from the creatorDevice\r\n     *\r\n     * @param messageKey messageKey containing the signature\r\n     * @return true/false\r\n     */\r\n    public boolean verify(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, CREATOR);\r\n\r\n        if (pubKey != null) {\r\n            Log.d(getClass().getSimpleName(), \"Verify key\");\r\n            return rsa.verify(messageKey.getSign(), messageKey.getMessageKey(), pubKey);\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"PubKey is null\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * load own RSA Private Key from local storage\r\n     *\r\n     * @param selfDeviceId deviceId from the user logged in currently\r\n     * @return PrivateKey\r\n     */\r\n    public PrivateKey getPrivateRSAKeyFromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String privKeyInBase64 = privKeyStorage.getString(PRIVATEKEY, \"\");\r\n\r\n        Log.d(this.getClass().getSimpleName(),\"Load private Key from storage: \" + RSAKEY_STORAGE_USER);\r\n\r\n        //if Key is available\r\n        if (privKeyInBase64 != \"\") {\r\n\r\n            PrivateKey privKey = rsa.convertBase64toPrivKey(privKeyInBase64);\r\n\r\n            if (privKey != null){\r\n                Log.d(this.getClass().getSimpleName(),\"Private Key was successfully loaded from storage\");\r\n                return privKey;\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Getting private key from storage failed\");\r\n            return null;\r\n        }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Private Key could not be found.\");\r\n            return null;\r\n\r\n    }\r\n\r\n    /**\r\n     * load the needed RSA Public Key from local storage/Device-Object\r\n     *\r\n     * @param messageKey messageKey containing the information about creatorDevice and recipientDevice\r\n     * @param type define, the RSA Public Key from the recipient or the creator is needed\r\n     * @return PublicKey\r\n     */\r\n    public PublicKey getPubKeyFromUser(MessageKey messageKey, byte type) {\r\n\r\n        String pubKeyInBase64 = null;\r\n\r\n        //try to extract Public Key from MessageKey\r\n        if (type == CREATOR){\r\n                pubKeyInBase64 = messageKey.getCreatorDevice().getPublicKey();\r\n        }\r\n        else if (type == RECIPIENT){\r\n                pubKeyInBase64 = messageKey.getRecipientDevice().getPublicKey();\r\n        }\r\n        else{\r\n            Log.d(this.getClass().getSimpleName(), \"Wrong use of function: getPubKeyFromUser()\");\r\n            return null;\r\n        }\r\n\r\n        //convert Base64toPublicKey\r\n        if (pubKeyInBase64 != null) {\r\n            PublicKey pubKey = rsa.convertBase64toPubKey(pubKeyInBase64);\r\n            if (pubKey != null) return pubKey;\r\n        }\r\n\r\n        Log.d(this.getClass().getSimpleName(), \"Getting public key from storage failed\");\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    //get own PublicKey in Base64\r\n    public String getPublicRSAKeyInBase64FromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String pubKeyInBase64 = privKeyStorage.getString(PUBLICKEY, \"\");\r\n\r\n        return pubKeyInBase64;\r\n    }\r\n    */\r\n\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/LoginFragment.java\npublic class LoginFragment extends Fragment implements NotifiableFragment<LoginFragment.LoginParam> {\n\n    //Keep track of the login task to ensure we can cancel it if requested.\n    private UserLoginTask authTask = null;\n\n    // UI references.\n    private EditText emailView;\n    private EditText passwordView;\n    private TextView loginStatusMessageView;\n    private View mProgressView;\n    private View mLoginFormView;\n    // values for devices yasme server\n    private String deviceProduct;\n    // Values for name, email and password at the time of the login attempt.\n    private String emailTmp;\n    private String passwordTmp;\n    // focusView for validate()\n    private View focusView = null;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        // In debug app, show @yasme.net\n        String defaultEmail = (BuildConfig.DEBUG) ? \"@yasme.net\" : \"\";\n\n        // Restore preferences\n        emailTmp = DatabaseManager.INSTANCE.getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, defaultEmail);\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_login, container,\n                false);\n\n        // Set up the login form.\n        emailView = (EditText) rootView.findViewById(R.id.email);\n        emailView.setText(emailTmp);\n\n        passwordView = (EditText) rootView.findViewById(R.id.password);\n        if (BuildConfig.DEBUG) {\n            passwordView.setText(R.string.default_password);\n        }\n        passwordView\n                .setOnEditorActionListener(new TextView.OnEditorActionListener() {\n                    @Override\n                    public boolean onEditorAction(TextView textView, int id,\n                                                  KeyEvent keyEvent) {\n                        if (id == R.id.login || id == EditorInfo.IME_NULL) {\n                            attemptLogin();\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        loginStatusMessageView = (TextView) rootView.findViewById(R.id.login_status_message);\n\n        rootView.findViewById(R.id.sign_in_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"SignIn-Button pushed\");\n                        attemptLogin();\n                    }\n                }\n        );\n\n        rootView.findViewById(R.id.register_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Register-Button pushed\");\n                        registerDialog();\n                    }\n                }\n        );\n\n        TextView tv = (TextView) rootView.findViewById(R.id.forgot_password);\n\n        Pattern pattern = Pattern.compile(getString(R.string.forgot_password));\n        /*\n        Linkify.addLinks(tv, pattern, \"\", null, new Linkify.TransformFilter() {\n            @Override\n            public String transformUrl(Matcher matcher, String s) {\n                return \"\";\n            }\n        });\n        */\n        tv.setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Forgot Password-Button pushed\");\n                        requestMail();\n                    }\n                }\n        );\n\n        return rootView;\n    }\n\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(this.getClass().getSimpleName(), \"Try to get LoginObservableInstance\");\n        FragmentObservable<LoginFragment, LoginParam> obs = ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"... successful\");\n\n        obs.register(this);\n        mProgressView = getActivity().findViewById(R.id.login_status);\n        mLoginFormView = getActivity().findViewById(R.id.login);\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        FragmentObservable<LoginFragment, LoginParam> obs =\n                ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"Remove from observer\");\n        obs.remove(this);\n    }\n\n    private void registerDialog() {\n        getFragmentManager().beginTransaction()\n                .add(R.id.singleFragmentContainer, new RegisterFragment()).commit();\n    }\n\n    /**\n     * Attempts to sign in or register the account specified by the login form.\n     * If there are form errors (missing fields, etc.), the errors are presented\n     * and no actual login attempt is made.\n     */\n    public void attemptLogin() {\n        if (authTask == null) {\n            authTask = new UserLoginTask(true, this.getClass());\n            Log.d(this.getClass().getSimpleName(), \"AuthTask is null\");\n        }\n\n        // Reset errors.\n        emailView.setError(null);\n        passwordView.setError(null);\n\n        // Store values at the time of the login attempt.\n        emailTmp = emailView.getText().toString();\n        passwordTmp = passwordView.getText().toString();\n\n        boolean cancel = false;\n\n        // Check for a valid password.\n        if (TextUtils.isEmpty(passwordTmp)) {\n            passwordView.setError(getString(R.string.error_field_required));\n            focusView = passwordView;\n            cancel = true;\n        } else if (passwordTmp.length() < 8) {\n            passwordView.setError(getString(R.string.error_invalid_password));\n            focusView = passwordView;\n            cancel = true;\n        }\n\n        // Check for a valid mail.\n        if (TextUtils.isEmpty(emailTmp)) {\n            emailView.setError(getString(R.string.error_field_required));\n            focusView = emailView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            // Show a progress spinner, and kick off a background task to\n            // perform the user login attempt.\n            loginStatusMessageView.setText(R.string.login_progress_signing_in);\n            showProgress(true);\n\n            // Hide the virtual keyboard\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            View focus = activity.getCurrentFocus();\n            if (null == focus) {\n                focus = focusView;\n            }\n            if (null == focus) {\n                focus = passwordView;\n            }\n            if (null == focus) {\n                focus = emailView;\n            }\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (null != imm && null != focus)\n                imm.hideSoftInputFromWindow(focus.getWindowToken(), 0);\n\n            // Start the asynctask\n            authTask.execute(emailTmp, passwordTmp);\n            authTask = null;\n        }\n    }\n\n    public void onPostLoginExecute(Boolean success, long userId) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        activity.getSelfUser().setId(userId);\n\n        if (success) {\n            //Initialize database (once in application)\n            if (!DatabaseManager.INSTANCE.isInitialized()) {\n                Log.e(getClass().getSimpleName(), \"DB-Manger hasn't been initialized\");\n            }\n            DatabaseManager.INSTANCE.setUserId(userId);\n\n            // check if there is a device in the Database\n            if (yasmeDeviceCheck()) {\n                Log.d(this.getClass().getSimpleName(), \"Device exists in Database\");\n\n                long deviceId = DatabaseManager.INSTANCE.getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n                if (deviceId < 0) {\n                    // Error ocurred\n                    Log.e(this.getClass().getSimpleName(), \"Could not load registered device's id from shared prefs\");\n                    showProgress(false);\n                    return;\n                }\n\n                DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n                showProgress(false);\n                Intent intent = new Intent(activity, ChatListActivity.class);\n                startActivity(intent);\n                getActivity().finish();\n            } else {\n                // register device\n                Log.d(this.getClass().getSimpleName(), \"Device does not exist in Database\");\n                Log.d(this.getClass().getSimpleName(), \"Starting task to register device at yasme server\");\n\n                new DeviceRegistrationTask(activity, this.getClass())\n                        .execute(Long.toString(userId), this.deviceProduct, this.getClass().getName());\n\n            }\n        } else {\n            Log.d(getClass().getSimpleName(), \"Login failed\");\n            ServerInfo serverInfo = DatabaseManager.INSTANCE.getServerInfo();\n            if (serverInfo != null && !serverInfo.getLoginAllowed() && serverInfo.hasMessage()) {\n                passwordView.setError(DatabaseManager.INSTANCE.getServerInfo().getMessage());\n            } else {\n                passwordView.setError(getString(R.string.error_incorrect_user_or_password));\n            }\n            passwordView.requestFocus();\n            showProgress(false);\n        }\n    }\n\n    public void onPostYasmeDeviceRegExecute(Boolean success, long deviceId) {\n        if (!success) {\n            Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n        } else {\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            // Initialize the session a second time because the deviceId was missing\n            /*SharedPreferences devicePrefs = activity.getSharedPreferences(\n                    AbstractYasmeActivity.DEVICE_PREFS,\n                    AbstractYasmeActivity.MODE_PRIVATE);\n            long userId = devicePrefs.getLong(AbstractYasmeActivity.USER_ID, -1);\n            if (userId < 0) {\n                // Error ocurred\n                Log.e(this.getClass().getSimpleName(), \"Did not find user id in shared prefs\");\n                Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n                showProgress(false);\n                return;\n            }*/\n\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n            Log.d(this.getClass().getSimpleName(), \"Login after device registration at yasme server\");\n            showProgress(false);\n            Intent intent = new Intent(activity, ChatListActivity.class);\n            startActivity(intent);\n            getActivity().finish();\n        }\n    }\n\n    /**\n     * This method checks if there is a device in the DB\n     */\n    public boolean yasmeDeviceCheck() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        //set the deviceProduct\n        this.deviceProduct = Build.MANUFACTURER + \" \" + Build.MODEL;\n        Log.d(this.getClass().getSimpleName(), \"MODEL is \" + Build.MODEL);\n        Log.d(this.getClass().getSimpleName(), \"DEVICE is \" + Build.DEVICE);\n        Log.d(this.getClass().getSimpleName(), \"PRODUCT is \" + Build.PRODUCT);\n        Log.d(this.getClass().getSimpleName(), \"MANUFACTURER is \" + Build.MANUFACTURER);\n        Log.d(this.getClass().getSimpleName(), \"BRAND is \" + Build.BRAND);\n        Log.d(this.getClass().getSimpleName(), \"NOW is \" + this.deviceProduct);\n        //try to load device from shared preferences\n        SharedPreferences devicePrefs = activity.getSharedPreferences(\n                AbstractYasmeActivity.DEVICE_PREFS,\n                AbstractYasmeActivity.MODE_PRIVATE);\n        long deviceId = devicePrefs.getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n\n        // load regId\n        SharedPreferences pushPrefs = activity.\n                getSharedPreferences(AbstractYasmeActivity.PUSH_PREFS,\n                        AbstractYasmeActivity.MODE_PRIVATE);\n\n        String googleRegId = pushPrefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, null);\n        // TODO proper check\n\n        if (deviceId == -1) {\n            if (DebugManager.INSTANCE.isDebugMode()) {\n                return DebugManager.INSTANCE.restoreData();\n            }\n            return false;\n        }\n        // TODO devices from server\n        // TODO use case : plain app + old user + old device\n\n        Log.d(this.getClass().getSimpleName(), \"deviceId is \" + deviceId);\n        return true;\n    }\n\n    public void requestMail() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.request_email_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final TextView requestEmailText = new TextView(activity);\n        requestEmailText.setText(R.string.request_email_body);\n\n        final EditText mail = new EditTextWithX(activity).getEditText();\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n        mail.setText(emailTmp);\n\n        list.addView(mail);\n        list.addView(requestEmailText, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        // Grab the EditText's input\n                        emailTmp = mail.getText().toString();\n                        Log.d(this.getClass().getSimpleName(), \"Mail to send token at: \" + emailTmp);\n                        User user = new User();\n                        user.setEmail(emailTmp);\n                        new ChangePasswordTask(user).execute(\"1\");\n                        forgotPasswordDialog(emailTmp);\n                    }\n                }\n        );\n\n        // Skip, email was already sent\n        alert.setNeutralButton(R.string.skip,\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        forgotPasswordDialog(null);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    public void forgotPasswordDialog(final String inputMail) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.password_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final EditText token = new EditText(activity);\n        token.setInputType(InputType.TYPE_CLASS_TEXT);\n        token.setHint(R.string.hint_mail_token);\n\n        final TextView tokenExplanation = new TextView(activity);\n        tokenExplanation.setText(R.string.explanation_mail_token);\n\n        final EditText password = new EditText(activity);\n        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        password.setHint(R.string.hint_new_password);\n\n        final EditText passwordCheck = new EditText(activity);\n        passwordCheck.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        passwordCheck.setHint(R.string.hint_repeat_new_password);\n\n        final EditText mail = new EditText(activity);\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n\n        if (inputMail == null || inputMail.isEmpty()) {\n            list.addView(mail);\n        }\n        list.addView(token, layoutParams);\n        list.addView(tokenExplanation, layoutParams);\n        list.addView(password, layoutParams);\n        list.addView(passwordCheck, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n\n                        // Grab the EditText's input\n                        String email;\n                        if (inputMail == null || inputMail.isEmpty()) {\n                            email = mail.getText().toString();\n                        } else {\n                            email = inputMail;\n                        }\n                        String mailToken = token.getText().toString();\n                        String inputPassword = password.getText().toString();\n                        String inputPasswordCheck = passwordCheck.getText()\n                                .toString();\n\n                        if (password.getText().length() < 8) {\n                            Toaster.getInstance().toast(R.string.password_too_short,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        if (!inputPassword.equals(inputPasswordCheck)) {\n                            Toaster.getInstance().toast(R.string.passwords_do_not_match,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        User user = new User(email, inputPassword);\n                        PasswordEncryption pwEnc = new PasswordEncryption(user);\n                        User secured = pwEnc.securePassword();\n                        new ChangePasswordTask(secured).execute(\"0\", mailToken);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    /**\n     * Shows the progress UI and hides the login form.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(final boolean show) {\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n                }\n            });\n\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n                }\n            });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply show\n            // and hide the relevant UI components.\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void notifyFragment(LoginParam param) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified. Yeeha!\");\n        if (param instanceof LoginProcessParam) {\n            notifyFragment((LoginProcessParam) param);\n        } else if (param instanceof DeviceRegistrationParam) {\n            notifyFragment((DeviceRegistrationParam) param);\n        }\n    }\n\n    public void notifyFragment(LoginProcessParam loginParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with loginParam\");\n\n        onPostLoginExecute(loginParam.getSuccess(), loginParam.getUserId());\n        Log.d(super.getClass().getSimpleName(), \"Login-Status: \" + loginParam.getSuccess());\n    }\n\n    public void notifyFragment(DeviceRegistrationParam deviceRegistrationParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with deviceRegistrationParam\");\n\n        onPostYasmeDeviceRegExecute(deviceRegistrationParam.getSuccess(),\n                deviceRegistrationParam.getDeviceId());\n\n    }\n\n    public static class LoginParam {\n        protected Boolean success;\n\n        public Boolean getSuccess() {\n            return success;\n        }\n    }\n\n    public static class LoginProcessParam extends LoginParam {\n        private Long userId;\n\n        public LoginProcessParam(Boolean success) {\n            this.success = success;\n            this.userId = DatabaseManager.INSTANCE.getUserId();\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n    }\n\n    public static class DeviceRegistrationParam extends LoginParam {\n        private Long deviceId;\n\n        public DeviceRegistrationParam(Boolean success) {\n            this.success = success;\n            this.deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        }\n\n        public Long getDeviceId() {\n            return deviceId;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/gcm/CloudMessaging.java\npublic class CloudMessaging {\n\n    private static CloudMessaging instance;\n\n    private Activity activity;\n    private GoogleCloudMessaging gcm;\n    private Context context;\n    private String regid;\n\n\n    public static CloudMessaging getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CloudMessaging(activity);\n        }\n        return instance;\n    }\n\n    private CloudMessaging(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.gcm = GoogleCloudMessaging.getInstance(activity);\n    }\n\n    public boolean checkPlayServices() {\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                GooglePlayServicesUtil.getErrorDialog(resultCode, activity,\n                        AbstractYasmeActivity.PLAY_SERVICES_RESOLUTION_REQUEST).show();\n            } else {\n                Log.i(AbstractYasmeActivity.TAG, \"This device is not supported.\");\n                activity.finish();\n            }\n            return false;\n        }\n        return true;\n    }\n\n    public String getRegistrationId() {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        String registrationId = prefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, \"\");\n        Log.i(AbstractYasmeActivity.TAG + \"WOOOOOLOOOLOOOO\", \"this is my id: [\" + AbstractYasmeActivity.PROPERTY_REG_ID + \"]\");\n        if (registrationId.isEmpty()) {\n            Log.i(AbstractYasmeActivity.TAG, \"Registration not found.\");\n            return \"\";\n        }\n        // Check if app was updated; if so, it must clear the registration ID\n        // since the existing regID is not guaranteed to work with the new\n        // app version.\n        int registeredVersion = prefs.getInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, Integer.MIN_VALUE);\n        int currentVersion = getAppVersion(context);\n        if (registeredVersion != currentVersion) {\n            Log.i(AbstractYasmeActivity.TAG, \"App version changed.\");\n            return \"\";\n        }\n        return registrationId;\n    }\n\n    public SharedPreferences getGCMPreferences(Context context) {\n        return context.getSharedPreferences(LoginActivity.class.getSimpleName(),\n                Context.MODE_PRIVATE);\n    }\n\n    public int getAppVersion(Context context) {\n        try {\n            PackageInfo packageInfo = context.getPackageManager()\n                    .getPackageInfo(context.getPackageName(), 0);\n            return packageInfo.versionCode;\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new RuntimeException(\"Could not get package name: \" + e);\n        }\n    }\n\n    public String registerInBackground() {\n        try {\n            if (gcm == null) {\n                gcm = GoogleCloudMessaging.getInstance(context);\n            }\n            regid = gcm.register(AbstractYasmeActivity.SENDER_ID);\n\n            Log.d(this.getClass().getSimpleName(), \"Device registered, registration ID=\" + regid);\n\n            // Persist the regID - no need to register again.\n            storeRegistrationId(context, regid);\n            return regid;\n        } catch (IOException e) {\n            // If there is an error, don't just keep trying to register.\n            // Require the user to click a button again, or perform\n            // exponential back-off.\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    private void storeRegistrationId(Context context, String regId) {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        int appVersion = getAppVersion(context);\n        Log.i(AbstractYasmeActivity.TAG, \"Saving regId on app version \" + appVersion);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(AbstractYasmeActivity.PROPERTY_REG_ID, regId);\n        editor.putInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, appVersion);\n        editor.commit();\n\n        // For Developer-Devices only\n        if (DebugManager.INSTANCE.isDebugMode()) {\n            Log.d(getClass().getSimpleName(), \"Store gcmId to external storage\");\n            DebugManager.INSTANCE.storePushId(regId);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DebugManager.java\npublic enum DebugManager {\r\n    INSTANCE;\r\n\r\n    private final String OWNDEVICE = \"owndevice\";\r\n    private final String MESSAGEKEYS = \"messagekeys\";\r\n\r\n    private boolean debugMode = false;\r\n    private OwnDevice ownDevice = new OwnDevice();\r\n\r\n    public boolean isDebugMode() {\r\n        return debugMode;\r\n    }\r\n\r\n    public boolean storeDeviceId(long deviceId) {\r\n        ownDevice.setId(deviceId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n\r\n    public boolean storePrivatePublicKeyToExternalStorage(String privateKey, String publicKey) {\r\n        ownDevice.setPrivateKey(privateKey);\r\n        ownDevice.setPublicKey(publicKey);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    public boolean storePushId(String pushId) {\r\n        ownDevice.setPushId(pushId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    private boolean storeOwnDeviceToExternalStorage() {\r\n        return storeToExternalStorage(OWNDEVICE, ownDevice, false);\r\n    }\r\n\r\n    public boolean storeMessageKeyToExternalStorage(MessageKey data) {\r\n        return storeToExternalStorage(MESSAGEKEYS, data, true);\r\n    }\r\n\r\n    private boolean storeToExternalStorage(String name, Object data, boolean append) {\r\n        try {\r\n            String state = Environment.getExternalStorageState();\r\n            Log.d(getClass().getSimpleName(), \"Check state\");\r\n            if (!Environment.MEDIA_MOUNTED.equals(state)) {\r\n                return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            Log.d(getClass().getSimpleName(), \"Mkdir\");\r\n            if (!dir.exists() && !dir.mkdirs()) {\r\n                Log.d(getClass().getSimpleName(), \"... failed\");\r\n               return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            File file = new File(dir,name + \".txt\");\r\n            Log.d(getClass().getSimpleName(), \"Write file\");\r\n\r\n            ObjectWriter objectWriter = new ObjectMapper().writer();\r\n            String json = objectWriter.writeValueAsString(data);\r\n            Log.d(getClass().getSimpleName(),\"Generated JSON: \" + json);\r\n\r\n            FileOutputStream f = new FileOutputStream(file,append);\r\n            PrintWriter pw = new PrintWriter(f);\r\n            if (append) {\r\n                pw.println(json + \",\");\r\n            } else {\r\n                pw.println(json);\r\n            }\r\n            pw.flush();\r\n            pw.close();\r\n            f.close();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean restoreData() {\r\n        Log.d(getClass().getSimpleName(),\"Restoring data\");\r\n        if (!restoreOwnDeviceFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring OwnDevice failed\");\r\n            return false;\r\n        }\r\n        if (!restoreMessageKeysFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring MessageKeys failed\");\r\n            return false;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Restoring successful\");\r\n        Toaster.getInstance().toast(\"Restoring Debug-Data successful\", Toast.LENGTH_LONG);\r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean restoreOwnDeviceFromExternalStorage() {\r\n         final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n         final String PRIVATEKEY = \"privateKey\";\r\n         final String PUBLICKEY = \"publicKey\";\r\n\r\n        try {\r\n            OwnDevice device = getOwnDeviceFromExternalStorage();\r\n            if (device == null) {\r\n                Log.d(getClass().getSimpleName(), \"Device is null\");\r\n                return false;\r\n            }\r\n\r\n            // Restore devId\r\n            Log.d(getClass().getSimpleName(), \"Restore devId\");\r\n            SharedPreferences.Editor editor1 = DatabaseManager.INSTANCE.getSharedPreferences().edit();\r\n            editor1.putLong(AbstractYasmeActivity.DEVICE_ID, ownDevice.getId());\r\n            editor1.commit();\r\n\r\n            // Restore pushId and app version\r\n            Log.d(getClass().getSimpleName(), \"Restore pushId\");\r\n            SharedPreferences prefs = DatabaseManager.INSTANCE.getContext().getSharedPreferences(LoginActivity.class.getSimpleName(), Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor2 = prefs.edit();\r\n            editor2.putString(AbstractYasmeActivity.PROPERTY_REG_ID, ownDevice.getPushId());\r\n            editor2.commit();\r\n\r\n            // Restore PrivatePublicKey\r\n            Log.d(getClass().getSimpleName(), \"Restore PrivPubKeys\");\r\n            String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + ownDevice.getId();\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            keyeditor.putString(PRIVATEKEY, device.getPrivateKey());\r\n            keyeditor.putString(PUBLICKEY,device.getPublicKey());\r\n            keyeditor.commit();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private OwnDevice getOwnDeviceFromExternalStorage() {\r\n        String text = readText(OWNDEVICE);\r\n        if (text == null || text == \"\") {\r\n            return null;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Device-Text: \" + text);\r\n        try {\r\n            OwnDevice device = new ObjectMapper().readValue(text, OwnDevice.class);\r\n            Log.d(getClass().getSimpleName(), \"PubKey: \" + device.getPublicKey());\r\n            return device;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private boolean restoreMessageKeysFromExternalStorage() {\r\n        String text = readText(MESSAGEKEYS);\r\n        if (text == null) {\r\n            return false;\r\n        }\r\n        if (text == \"\") {\r\n            // No messageKey stored yet\r\n            return true;\r\n        }\r\n        String json = \"[\" + text + \"{}]\";\r\n        Log.d(getClass().getSimpleName(), \"MessageKeys-Text: \" + text);\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"JSON: \" + json);\r\n            JSONArray jsonArray = new JSONArray(json);\r\n\r\n            for (int i = 0; i < jsonArray.length() - 1; i++) {\r\n                MessageKey messageKey = new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\r\n                        toString(), MessageKey.class);\r\n                messageKey.setAuthenticity(true);\r\n                DatabaseManager.INSTANCE.getMessageKeyDAO().addOrUpdate(messageKey);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private String readText(String name) {\r\n        String filename = \"\";\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            if (!dir.exists()) {\r\n                return null;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            filename = dir.getAbsolutePath() + \"/\" + name + \".txt\";\r\n\r\n\r\n            BufferedReader br = new BufferedReader(new FileReader(filename));\r\n            StringBuilder sb = new StringBuilder();\r\n            String line = br.readLine();\r\n\r\n            while (line != null) {\r\n                sb.append(line);\r\n                line = br.readLine();\r\n            }\r\n            br.close();\r\n            return sb.toString();\r\n        } catch (FileNotFoundException e) {\r\n            Log.e(getClass().getSimpleName(), \"File \" + filename + \" not found.\");\r\n            return \"\";\r\n        }\r\n        catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private File getDir() {\r\n        return new File(Environment.getExternalStoragePublicDirectory(\"yasme\"), String.valueOf(DatabaseManager.INSTANCE.getUserId()));\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/DeviceTask.java\npublic class DeviceTask extends ConnectionTask {\n\n    private static DeviceTask instance;\n\n    public static DeviceTask getInstance() {\n        if (instance == null) {\n            synchronized (DeviceTask.class) {\n                if (null == instance) {\n                    instance = new DeviceTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private DeviceTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/device\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n    }\n\n    public Long registerDevice(OwnDevice device) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", device);\n\n            //Log.d(this.getClass().getSimpleName(), \"Device registration was successful\");\n\n            long deviceId = (new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent())\n            )).readLine())).getLong(\"id\");\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n            return deviceId;\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n        return null;\n    }\n\n    public Device getDevice(long devId) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(devId));\n            return new ObjectMapper().readValue(new BufferedReader(new InputStreamReader(httpResponse.getEntity()\n                    .getContent())).readLine(), Device.class);\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public ArrayList<Device> getAllDevices(Long userId) throws RestServiceException {\n\n        ArrayList<Device> devices = new ArrayList<Device>();\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"all/\" + userId);\n\n            JSONArray jsonArray = new JSONArray(new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent())).readLine());\n\n            for (int i = 0; i < jsonArray.length(); i++)\n                devices.add(new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\n                        toString(), Device.class));\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n\n        //Log.d(this.getClass().getSimpleName(), \"No.Devices: \" + devices.size());\n        return devices;\n    }\n\n    public void deleteDevice(long deviceId) throws RestServiceException {\n        executeRequest(Request.DELETE, Long.toString(deviceId));\n        //Log.d(this.getClass().getSimpleName(), \"Device removed!\");\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/contacts/QR.java\npublic class QR {\n    private static final int SIZE = 1024;\n    private static Bitmap qrCode;\n    private static boolean isRunning = false;\n\n    public static void init(boolean force) {\n        if (force) {\n            qrCode = null;\n            isRunning = false;\n        }\n        if (qrCode == null && !isRunning) {\n            isRunning = true;\n            new QRTask().execute();\n        }\n    }\n\n    public static void finished() {\n        isRunning = false;\n    }\n\n    public Bitmap generateQRCode() {\n        if (qrCode != null) {\n            return qrCode;\n        }\n        QRData qrdata = new QRData();\n        DatabaseManager db = DatabaseManager.INSTANCE;\n        qrdata.setDeviceId(db.getDeviceId());\n\n        Context context = db.getContext();\n        String RSAKEY_STORAGE_USER = KeyEncryption.RSAKEY_STORAGE + \"_\" + db.getDeviceId();\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\n        String pubKeyInBase64 = privKeyStorage.getString(KeyEncryption.PUBLICKEY, \"\");\n        qrdata.setPublicKey(pubKeyInBase64);\n\n        //ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();\n        ObjectWriter objectWriter = new ObjectMapper().writer();\n        try {\n            String data = objectWriter.writeValueAsString(qrdata);\n            qrCode = generateQRCode(data);\n            return qrCode;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Bitmap generateQRCode(String data) {\n        Log.d(getClass().getName(), \"Generate QR for \" + data);\n        com.google.zxing.Writer writer = new QRCodeWriter();\n        BitMatrix bm;\n        try {\n            bm = writer.encode(data, BarcodeFormat.QR_CODE,SIZE, SIZE);\n        } catch (Exception e) {\n            return null;\n        }\n\n        Bitmap imageBitmap = Bitmap.createBitmap(SIZE, SIZE, Bitmap.Config.ARGB_8888);\n\n        for (int i = 0; i < SIZE; i++) {//width\n            for (int j = 0; j < SIZE; j++) {//height\n                imageBitmap.setPixel(i, j, bm.get(i, j) ? Color.BLACK: Color.WHITE);\n            }\n        }\n        return imageBitmap;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/OwnDevice.java\npublic class OwnDevice {\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        WINDOWSPHONE;\n    }\n\n    private long id;\n    private Platform platform; // android, ios or windowsmobile\n    private String type;    // mobilephone, tablet or desktop\n    private User user;\n    private String number;  // optional\n    private String publicKey;\n    private String privateKey;\n    private String product; // product name e.g. Google Nexux 5\n    private String pushId;\n\n    private Date created;\n\n    private Date lastModified;\n\n    public OwnDevice(User user, Platform platform, String publicKey, String type, String number, String product, String pushId) {\n        this.user = user;\n        this.platform = platform;\n        this.type = type;\n        this.number = number;\n        this.product = product;\n        this.pushId = pushId;\n        this.publicKey = publicKey;\n    }\n\n    public OwnDevice() {\n    }\n\n    public OwnDevice(long id) {\n        this.id = id;\n    }\n\n    @JsonIgnoreProperties({ \"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\" })\n    public User getUser() {\n        return this.user;\n    }\n\n    public String getPushId(){return this.pushId;}\n\n    public String getProduct(){return this.product;}\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setProduct(String product){this.product = product;}\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Platform getPlatform() {\n        return platform;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setPlatform(Platform platform) {\n        this.platform = platform;\n    }\n\n    public void setPushId(String pushId){this.pushId = pushId;}\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPublicKey() {\n        return publicKey;\n    }\n\n    public void setPublicKey(String publicKey) {\n        this.publicKey = publicKey;\n    }\n\n    public Date getCreated() {\n        return this.created;\n    }\n\n    public Date getLastModified() {\n        return this.lastModified;\n    }\n\n    public String getPrivateKey() {\n        return privateKey;\n    }\n\n    public void setPrivateKey(String privateKey) {\n        this.privateKey = privateKey;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\npackage de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.app.Activity;\nimport android.os.AsyncTask;\nimport de.fau.cs.mad.yasme.android.connection.DeviceTask;\nimport de.fau.cs.mad.yasme.android.contacts.QR;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.encryption.KeyEncryption;\nimport de.fau.cs.mad.yasme.android.entities.OwnDevice;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.gcm.CloudMessaging;\nimport de.fau.cs.mad.yasme.android.storage.DebugManager;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.fragments.LoginFragment;\n\n\n\n/**\n * Created by Cuong Bui <cuong.bui@fau.de> on 21/06/14.\n */\npublic class DeviceRegistrationTask extends AsyncTask<String, Void, Boolean> {\n\n    private long deviceId;\n    private Activity activity;\n    private String regId;\n    private Class classToNotify;\n\n    public DeviceRegistrationTask(Activity activity, Class classToNotify) {\n        this.activity = activity;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @params params[0] is userId\n     * @params params[1] is product\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        long userId = Long.parseLong(params[0]);\n\n        // the product : e.g Google Nexus\n        String product = params[1];\n\n        // Register for Google Cloud Messaging at Google Server\n        if (!registerGCM()) {\n            return false;\n        }\n\n        // Register at YASME server\n        return registerDeviceAtYASME(userId, product, regId);\n    }\n\n\n    private boolean registerGCM() {\n        CloudMessaging cloudMessaging = CloudMessaging.getInstance(this.activity);\n\n        if (cloudMessaging.checkPlayServices()) {\n            String regid = cloudMessaging.getRegistrationId();\n            Log.d(this.getClass().getSimpleName(), \"Google reg id is empty? \" + regid.isEmpty());\n            if (regid.isEmpty()) {\n                regId = cloudMessaging.registerInBackground();\n                if (null == regId || regId.isEmpty()) {\n                    Log.e(this.getClass().getSimpleName(), \"reg id for GCM is empty\");\n                    return false;\n                }\n            }\n        } else {\n            Log.i(AbstractYasmeActivity.TAG, \"No valid Google Play Services APK found.\");\n        }\n\n        return true;\n    }\n\n\n    private boolean registerDeviceAtYASME(long userId, String product, String regId) {\n        long deviceIdFromServer;\n\n        //register device through REST-Call\n        // create a new device to be registered\n\n        // user which want to register the device\n        // ignore the name user, the server will set the right values according to the userId\n        User user = new User(\"user\", userId);\n\n        // indicates if its a smartphone or a tablet\n        // currently unused\n        String type = \"device\";\n\n        // phone number, currently unused\n        String number = null;\n\n        KeyEncryption rsa = new KeyEncryption();\n        //generate private and public Key\n        rsa.generateRSAKeys();\n        String pubKeyInBase64 = rsa.getGeneratedPubKeyInBase64();\n\n        OwnDevice deviceToBeRegistered = new OwnDevice(user, OwnDevice.Platform.ANDROID, pubKeyInBase64, type, number, product, regId);\n\n        // make the REST-Call\n        try {\n            deviceIdFromServer = DeviceTask.getInstance().registerDevice(deviceToBeRegistered);\n            deviceId = deviceIdFromServer;\n            //save private and public Key to storage\n            rsa.saveRSAKeys(deviceId);Next line of code:\n", "input": "package de.fau.cs.mad.yasme.android.asyncTasks.server;\nimport android.app.Activity;\nimport android.os.AsyncTask;\nimport de.fau.cs.mad.yasme.android.connection.DeviceTask;\nimport de.fau.cs.mad.yasme.android.contacts.QR;\nimport de.fau.cs.mad.yasme.android.controller.Log;\nimport de.fau.cs.mad.yasme.android.controller.ObservableRegistry;\nimport de.fau.cs.mad.yasme.android.controller.SpinnerObservable;\nimport de.fau.cs.mad.yasme.android.encryption.KeyEncryption;\nimport de.fau.cs.mad.yasme.android.entities.OwnDevice;\nimport de.fau.cs.mad.yasme.android.entities.User;\nimport de.fau.cs.mad.yasme.android.exception.RestServiceException;\nimport de.fau.cs.mad.yasme.android.gcm.CloudMessaging;\nimport de.fau.cs.mad.yasme.android.storage.DebugManager;\nimport de.fau.cs.mad.yasme.android.ui.AbstractYasmeActivity;\nimport de.fau.cs.mad.yasme.android.ui.fragments.LoginFragment;\n\n\n\n/**\n * Created by Cuong Bui <cuong.bui@fau.de> on 21/06/14.\n */\npublic class DeviceRegistrationTask extends AsyncTask<String, Void, Boolean> {\n\n    private long deviceId;\n    private Activity activity;\n    private String regId;\n    private Class classToNotify;\n\n    public DeviceRegistrationTask(Activity activity, Class classToNotify) {\n        this.activity = activity;\n        this.classToNotify = classToNotify;\n    }\n\n    @Override\n    protected void onPreExecute() {\n        super.onPreExecute();\n        SpinnerObservable.getInstance().registerBackgroundTask(this);\n    }\n\n    /**\n     * @params params[0] is userId\n     * @params params[1] is product\n     */\n    @Override\n    protected Boolean doInBackground(String... params) {\n        long userId = Long.parseLong(params[0]);\n\n        // the product : e.g Google Nexus\n        String product = params[1];\n\n        // Register for Google Cloud Messaging at Google Server\n        if (!registerGCM()) {\n            return false;\n        }\n\n        // Register at YASME server\n        return registerDeviceAtYASME(userId, product, regId);\n    }\n\n\n    private boolean registerGCM() {\n        CloudMessaging cloudMessaging = CloudMessaging.getInstance(this.activity);\n\n        if (cloudMessaging.checkPlayServices()) {\n            String regid = cloudMessaging.getRegistrationId();\n            Log.d(this.getClass().getSimpleName(), \"Google reg id is empty? \" + regid.isEmpty());\n            if (regid.isEmpty()) {\n                regId = cloudMessaging.registerInBackground();\n                if (null == regId || regId.isEmpty()) {\n                    Log.e(this.getClass().getSimpleName(), \"reg id for GCM is empty\");\n                    return false;\n                }\n            }\n        } else {\n            Log.i(AbstractYasmeActivity.TAG, \"No valid Google Play Services APK found.\");\n        }\n\n        return true;\n    }\n\n\n    private boolean registerDeviceAtYASME(long userId, String product, String regId) {\n        long deviceIdFromServer;\n\n        //register device through REST-Call\n        // create a new device to be registered\n\n        // user which want to register the device\n        // ignore the name user, the server will set the right values according to the userId\n        User user = new User(\"user\", userId);\n\n        // indicates if its a smartphone or a tablet\n        // currently unused\n        String type = \"device\";\n\n        // phone number, currently unused\n        String number = null;\n\n        KeyEncryption rsa = new KeyEncryption();\n        //generate private and public Key\n        rsa.generateRSAKeys();\n        String pubKeyInBase64 = rsa.getGeneratedPubKeyInBase64();\n\n        OwnDevice deviceToBeRegistered = new OwnDevice(user, OwnDevice.Platform.ANDROID, pubKeyInBase64, type, number, product, regId);\n\n        // make the REST-Call\n        try {\n            deviceIdFromServer = DeviceTask.getInstance().registerDevice(deviceToBeRegistered);\n            deviceId = deviceIdFromServer;\n            //save private and public Key to storage\n            rsa.saveRSAKeys(deviceId);", "context": "yasme/src/main/java/de/fau/cs/mad/yasme/android/encryption/KeyEncryption.java\npublic class KeyEncryption {\r\n\r\n    public static final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n    public static final String PRIVATEKEY = \"privateKey\";\r\n    public static final String PUBLICKEY = \"publicKey\";\r\n    private final byte CREATOR = 0;\r\n    private final byte RECIPIENT = 1;\r\n    private RSAEncryption rsa;\r\n    private DatabaseManager db = DatabaseManager.INSTANCE;\r\n\r\n    public KeyEncryption() {\r\n        this.rsa = new RSAEncryption();\r\n    }\r\n\r\n    /**\r\n     * generate a random RSA-KeyPair (Private and Public Key)\r\n     */\r\n    public void generateRSAKeys(){\r\n        rsa.generateKeyPair();\r\n    }\r\n\r\n    /**\r\n     * encode generated RSA-KeyPair to base64 and store it to local storage (SharedPreferences)\r\n     * there is a own SharedPreference for every user on the device\r\n     *\r\n     * @param deviceId deviceId from the user logged in currently\r\n     * @return true/false\r\n     */\r\n    public boolean saveRSAKeys(long deviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + deviceId;\r\n\r\n        try {\r\n\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            //delete existing keys\r\n            if (privKeyStorage.getString(PRIVATEKEY, \"\") != \"\"){\r\n                keyeditor.remove(PRIVATEKEY);\r\n            }\r\n            if (privKeyStorage.getString(PUBLICKEY, \"\") != \"\"){\r\n                keyeditor.remove(PUBLICKEY);\r\n            }\r\n\r\n            keyeditor.putString(PRIVATEKEY, rsa.getPrivKeyinBase64());\r\n            keyeditor.putString(PUBLICKEY, rsa.getPubKeyinBase64());\r\n\r\n            keyeditor.commit();\r\n\r\n            // For Developer-Devices only\r\n            if (DebugManager.INSTANCE.isDebugMode()) {\r\n                Log.d(getClass().getSimpleName(), \"Store keys to external storage\");\r\n                DebugManager.INSTANCE.storePrivatePublicKeyToExternalStorage(rsa.getPrivKeyinBase64(),rsa.getPubKeyinBase64());\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"RSA Keys generated and saved\");\r\n\r\n\r\n            return true;\r\n        } catch (Exception e){\r\n            Log.e(this.getClass().getSimpleName(), \"saving rsa keys failed\");\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the generated RSA Public Key in Base64\r\n     * method is needed in registration when the Public Key needs to be sent to the server\r\n     *\r\n     * @return base64 encoded string\r\n     */\r\n    public String getGeneratedPubKeyInBase64(){\r\n        return rsa.getPubKeyinBase64();\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the RSA PublicKey from the recipient\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be encrypted\r\n     * @return messageKey containing the RSA-encrypted AES-Key\r\n     */\r\n    public MessageKey encrypt(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, RECIPIENT);\r\n\r\n        if (pubKey != null){\r\n            String keyEncrypted = rsa.encrypt(messageKey.getMessageKey(), pubKey);\r\n            messageKey.setKey(keyEncrypted);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * encrypt the given messageKey using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the encrypted AES-Key that should be decrypted\r\n     * @return messageKey containing the decrypted AES-Key\r\n     */\r\n    public MessageKey decrypt(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getRecipientDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String key = rsa.decrypt(messageKey.getMessageKey(), privKey);\r\n            if (key == null) {\r\n                return null;\r\n            }\r\n            messageKey.setKey(key);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sign an AES-Key using the own RSA Private Key\r\n     *\r\n     * @param messageKey messageKey containing the AES-Key that should be signed\r\n     * @return  messageKey containing the signature\r\n     */\r\n    public MessageKey sign(MessageKey messageKey){\r\n\r\n        long selfDeviceId = messageKey.getCreatorDevice().getId();\r\n        PrivateKey privKey = getPrivateRSAKeyFromStorage(selfDeviceId);\r\n\r\n        if (privKey != null) {\r\n            String keySigned = rsa.sign(messageKey.getMessageKey(), privKey);\r\n            messageKey.setSign(keySigned);\r\n            return messageKey;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * verify the signature from given messageKey using the RSA Public Key from the creatorDevice\r\n     *\r\n     * @param messageKey messageKey containing the signature\r\n     * @return true/false\r\n     */\r\n    public boolean verify(MessageKey messageKey){\r\n\r\n        PublicKey pubKey = getPubKeyFromUser(messageKey, CREATOR);\r\n\r\n        if (pubKey != null) {\r\n            Log.d(getClass().getSimpleName(), \"Verify key\");\r\n            return rsa.verify(messageKey.getSign(), messageKey.getMessageKey(), pubKey);\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"PubKey is null\");\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * load own RSA Private Key from local storage\r\n     *\r\n     * @param selfDeviceId deviceId from the user logged in currently\r\n     * @return PrivateKey\r\n     */\r\n    public PrivateKey getPrivateRSAKeyFromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String privKeyInBase64 = privKeyStorage.getString(PRIVATEKEY, \"\");\r\n\r\n        Log.d(this.getClass().getSimpleName(),\"Load private Key from storage: \" + RSAKEY_STORAGE_USER);\r\n\r\n        //if Key is available\r\n        if (privKeyInBase64 != \"\") {\r\n\r\n            PrivateKey privKey = rsa.convertBase64toPrivKey(privKeyInBase64);\r\n\r\n            if (privKey != null){\r\n                Log.d(this.getClass().getSimpleName(),\"Private Key was successfully loaded from storage\");\r\n                return privKey;\r\n            }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Getting private key from storage failed\");\r\n            return null;\r\n        }\r\n\r\n            Log.d(this.getClass().getSimpleName(), \"Private Key could not be found.\");\r\n            return null;\r\n\r\n    }\r\n\r\n    /**\r\n     * load the needed RSA Public Key from local storage/Device-Object\r\n     *\r\n     * @param messageKey messageKey containing the information about creatorDevice and recipientDevice\r\n     * @param type define, the RSA Public Key from the recipient or the creator is needed\r\n     * @return PublicKey\r\n     */\r\n    public PublicKey getPubKeyFromUser(MessageKey messageKey, byte type) {\r\n\r\n        String pubKeyInBase64 = null;\r\n\r\n        //try to extract Public Key from MessageKey\r\n        if (type == CREATOR){\r\n                pubKeyInBase64 = messageKey.getCreatorDevice().getPublicKey();\r\n        }\r\n        else if (type == RECIPIENT){\r\n                pubKeyInBase64 = messageKey.getRecipientDevice().getPublicKey();\r\n        }\r\n        else{\r\n            Log.d(this.getClass().getSimpleName(), \"Wrong use of function: getPubKeyFromUser()\");\r\n            return null;\r\n        }\r\n\r\n        //convert Base64toPublicKey\r\n        if (pubKeyInBase64 != null) {\r\n            PublicKey pubKey = rsa.convertBase64toPubKey(pubKeyInBase64);\r\n            if (pubKey != null) return pubKey;\r\n        }\r\n\r\n        Log.d(this.getClass().getSimpleName(), \"Getting public key from storage failed\");\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    //get own PublicKey in Base64\r\n    public String getPublicRSAKeyInBase64FromStorage(long selfDeviceId){\r\n\r\n        String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + selfDeviceId;\r\n\r\n        Context context = DatabaseManager.INSTANCE.getContext();\r\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n        String pubKeyInBase64 = privKeyStorage.getString(PUBLICKEY, \"\");\r\n\r\n        return pubKeyInBase64;\r\n    }\r\n    */\r\n\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/fragments/LoginFragment.java\npublic class LoginFragment extends Fragment implements NotifiableFragment<LoginFragment.LoginParam> {\n\n    //Keep track of the login task to ensure we can cancel it if requested.\n    private UserLoginTask authTask = null;\n\n    // UI references.\n    private EditText emailView;\n    private EditText passwordView;\n    private TextView loginStatusMessageView;\n    private View mProgressView;\n    private View mLoginFormView;\n    // values for devices yasme server\n    private String deviceProduct;\n    // Values for name, email and password at the time of the login attempt.\n    private String emailTmp;\n    private String passwordTmp;\n    // focusView for validate()\n    private View focusView = null;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        // In debug app, show @yasme.net\n        String defaultEmail = (BuildConfig.DEBUG) ? \"@yasme.net\" : \"\";\n\n        // Restore preferences\n        emailTmp = DatabaseManager.INSTANCE.getSharedPreferences().getString(AbstractYasmeActivity.USER_MAIL, defaultEmail);\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.fragment_login, container,\n                false);\n\n        // Set up the login form.\n        emailView = (EditText) rootView.findViewById(R.id.email);\n        emailView.setText(emailTmp);\n\n        passwordView = (EditText) rootView.findViewById(R.id.password);\n        if (BuildConfig.DEBUG) {\n            passwordView.setText(R.string.default_password);\n        }\n        passwordView\n                .setOnEditorActionListener(new TextView.OnEditorActionListener() {\n                    @Override\n                    public boolean onEditorAction(TextView textView, int id,\n                                                  KeyEvent keyEvent) {\n                        if (id == R.id.login || id == EditorInfo.IME_NULL) {\n                            attemptLogin();\n                            return true;\n                        }\n                        return false;\n                    }\n                });\n\n        loginStatusMessageView = (TextView) rootView.findViewById(R.id.login_status_message);\n\n        rootView.findViewById(R.id.sign_in_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"SignIn-Button pushed\");\n                        attemptLogin();\n                    }\n                }\n        );\n\n        rootView.findViewById(R.id.register_button).setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Register-Button pushed\");\n                        registerDialog();\n                    }\n                }\n        );\n\n        TextView tv = (TextView) rootView.findViewById(R.id.forgot_password);\n\n        Pattern pattern = Pattern.compile(getString(R.string.forgot_password));\n        /*\n        Linkify.addLinks(tv, pattern, \"\", null, new Linkify.TransformFilter() {\n            @Override\n            public String transformUrl(Matcher matcher, String s) {\n                return \"\";\n            }\n        });\n        */\n        tv.setOnClickListener(\n                new View.OnClickListener() {\n                    @Override\n                    public void onClick(View view) {\n                        Log.d(this.getClass().getSimpleName(), \"Forgot Password-Button pushed\");\n                        requestMail();\n                    }\n                }\n        );\n\n        return rootView;\n    }\n\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Log.d(this.getClass().getSimpleName(), \"Try to get LoginObservableInstance\");\n        FragmentObservable<LoginFragment, LoginParam> obs = ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"... successful\");\n\n        obs.register(this);\n        mProgressView = getActivity().findViewById(R.id.login_status);\n        mLoginFormView = getActivity().findViewById(R.id.login);\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        FragmentObservable<LoginFragment, LoginParam> obs =\n                ObservableRegistry.getObservable(LoginFragment.class);\n        Log.d(this.getClass().getSimpleName(), \"Remove from observer\");\n        obs.remove(this);\n    }\n\n    private void registerDialog() {\n        getFragmentManager().beginTransaction()\n                .add(R.id.singleFragmentContainer, new RegisterFragment()).commit();\n    }\n\n    /**\n     * Attempts to sign in or register the account specified by the login form.\n     * If there are form errors (missing fields, etc.), the errors are presented\n     * and no actual login attempt is made.\n     */\n    public void attemptLogin() {\n        if (authTask == null) {\n            authTask = new UserLoginTask(true, this.getClass());\n            Log.d(this.getClass().getSimpleName(), \"AuthTask is null\");\n        }\n\n        // Reset errors.\n        emailView.setError(null);\n        passwordView.setError(null);\n\n        // Store values at the time of the login attempt.\n        emailTmp = emailView.getText().toString();\n        passwordTmp = passwordView.getText().toString();\n\n        boolean cancel = false;\n\n        // Check for a valid password.\n        if (TextUtils.isEmpty(passwordTmp)) {\n            passwordView.setError(getString(R.string.error_field_required));\n            focusView = passwordView;\n            cancel = true;\n        } else if (passwordTmp.length() < 8) {\n            passwordView.setError(getString(R.string.error_invalid_password));\n            focusView = passwordView;\n            cancel = true;\n        }\n\n        // Check for a valid mail.\n        if (TextUtils.isEmpty(emailTmp)) {\n            emailView.setError(getString(R.string.error_field_required));\n            focusView = emailView;\n            cancel = true;\n        }\n\n        if (cancel) {\n            // There was an error; don't attempt login and focus the first\n            // form field with an error.\n            focusView.requestFocus();\n        } else {\n            // Show a progress spinner, and kick off a background task to\n            // perform the user login attempt.\n            loginStatusMessageView.setText(R.string.login_progress_signing_in);\n            showProgress(true);\n\n            // Hide the virtual keyboard\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            View focus = activity.getCurrentFocus();\n            if (null == focus) {\n                focus = focusView;\n            }\n            if (null == focus) {\n                focus = passwordView;\n            }\n            if (null == focus) {\n                focus = emailView;\n            }\n            InputMethodManager imm = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);\n            if (null != imm && null != focus)\n                imm.hideSoftInputFromWindow(focus.getWindowToken(), 0);\n\n            // Start the asynctask\n            authTask.execute(emailTmp, passwordTmp);\n            authTask = null;\n        }\n    }\n\n    public void onPostLoginExecute(Boolean success, long userId) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n\n        activity.getSelfUser().setId(userId);\n\n        if (success) {\n            //Initialize database (once in application)\n            if (!DatabaseManager.INSTANCE.isInitialized()) {\n                Log.e(getClass().getSimpleName(), \"DB-Manger hasn't been initialized\");\n            }\n            DatabaseManager.INSTANCE.setUserId(userId);\n\n            // check if there is a device in the Database\n            if (yasmeDeviceCheck()) {\n                Log.d(this.getClass().getSimpleName(), \"Device exists in Database\");\n\n                long deviceId = DatabaseManager.INSTANCE.getSharedPreferences().getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n                if (deviceId < 0) {\n                    // Error ocurred\n                    Log.e(this.getClass().getSimpleName(), \"Could not load registered device's id from shared prefs\");\n                    showProgress(false);\n                    return;\n                }\n\n                DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n                showProgress(false);\n                Intent intent = new Intent(activity, ChatListActivity.class);\n                startActivity(intent);\n                getActivity().finish();\n            } else {\n                // register device\n                Log.d(this.getClass().getSimpleName(), \"Device does not exist in Database\");\n                Log.d(this.getClass().getSimpleName(), \"Starting task to register device at yasme server\");\n\n                new DeviceRegistrationTask(activity, this.getClass())\n                        .execute(Long.toString(userId), this.deviceProduct, this.getClass().getName());\n\n            }\n        } else {\n            Log.d(getClass().getSimpleName(), \"Login failed\");\n            ServerInfo serverInfo = DatabaseManager.INSTANCE.getServerInfo();\n            if (serverInfo != null && !serverInfo.getLoginAllowed() && serverInfo.hasMessage()) {\n                passwordView.setError(DatabaseManager.INSTANCE.getServerInfo().getMessage());\n            } else {\n                passwordView.setError(getString(R.string.error_incorrect_user_or_password));\n            }\n            passwordView.requestFocus();\n            showProgress(false);\n        }\n    }\n\n    public void onPostYasmeDeviceRegExecute(Boolean success, long deviceId) {\n        if (!success) {\n            Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n        } else {\n            AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n            // Initialize the session a second time because the deviceId was missing\n            /*SharedPreferences devicePrefs = activity.getSharedPreferences(\n                    AbstractYasmeActivity.DEVICE_PREFS,\n                    AbstractYasmeActivity.MODE_PRIVATE);\n            long userId = devicePrefs.getLong(AbstractYasmeActivity.USER_ID, -1);\n            if (userId < 0) {\n                // Error ocurred\n                Log.e(this.getClass().getSimpleName(), \"Did not find user id in shared prefs\");\n                Toaster.getInstance().toast(getResources().getString(R.string.device_registration_failed), Toast.LENGTH_LONG);\n                showProgress(false);\n                return;\n            }*/\n\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n\n            Log.d(this.getClass().getSimpleName(), \"Login after device registration at yasme server\");\n            showProgress(false);\n            Intent intent = new Intent(activity, ChatListActivity.class);\n            startActivity(intent);\n            getActivity().finish();\n        }\n    }\n\n    /**\n     * This method checks if there is a device in the DB\n     */\n    public boolean yasmeDeviceCheck() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        //set the deviceProduct\n        this.deviceProduct = Build.MANUFACTURER + \" \" + Build.MODEL;\n        Log.d(this.getClass().getSimpleName(), \"MODEL is \" + Build.MODEL);\n        Log.d(this.getClass().getSimpleName(), \"DEVICE is \" + Build.DEVICE);\n        Log.d(this.getClass().getSimpleName(), \"PRODUCT is \" + Build.PRODUCT);\n        Log.d(this.getClass().getSimpleName(), \"MANUFACTURER is \" + Build.MANUFACTURER);\n        Log.d(this.getClass().getSimpleName(), \"BRAND is \" + Build.BRAND);\n        Log.d(this.getClass().getSimpleName(), \"NOW is \" + this.deviceProduct);\n        //try to load device from shared preferences\n        SharedPreferences devicePrefs = activity.getSharedPreferences(\n                AbstractYasmeActivity.DEVICE_PREFS,\n                AbstractYasmeActivity.MODE_PRIVATE);\n        long deviceId = devicePrefs.getLong(AbstractYasmeActivity.DEVICE_ID, -1);\n\n        // load regId\n        SharedPreferences pushPrefs = activity.\n                getSharedPreferences(AbstractYasmeActivity.PUSH_PREFS,\n                        AbstractYasmeActivity.MODE_PRIVATE);\n\n        String googleRegId = pushPrefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, null);\n        // TODO proper check\n\n        if (deviceId == -1) {\n            if (DebugManager.INSTANCE.isDebugMode()) {\n                return DebugManager.INSTANCE.restoreData();\n            }\n            return false;\n        }\n        // TODO devices from server\n        // TODO use case : plain app + old user + old device\n\n        Log.d(this.getClass().getSimpleName(), \"deviceId is \" + deviceId);\n        return true;\n    }\n\n    public void requestMail() {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.request_email_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final TextView requestEmailText = new TextView(activity);\n        requestEmailText.setText(R.string.request_email_body);\n\n        final EditText mail = new EditTextWithX(activity).getEditText();\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n        mail.setText(emailTmp);\n\n        list.addView(mail);\n        list.addView(requestEmailText, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        // Grab the EditText's input\n                        emailTmp = mail.getText().toString();\n                        Log.d(this.getClass().getSimpleName(), \"Mail to send token at: \" + emailTmp);\n                        User user = new User();\n                        user.setEmail(emailTmp);\n                        new ChangePasswordTask(user).execute(\"1\");\n                        forgotPasswordDialog(emailTmp);\n                    }\n                }\n        );\n\n        // Skip, email was already sent\n        alert.setNeutralButton(R.string.skip,\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        forgotPasswordDialog(null);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    public void forgotPasswordDialog(final String inputMail) {\n        AbstractYasmeActivity activity = (AbstractYasmeActivity) getActivity();\n        AlertDialog.Builder alert = new AlertDialog.Builder(activity);\n        alert.setTitle(getString(R.string.password_title));\n\n        LinearLayout list = new LinearLayout(activity);\n        list.setOrientation(LinearLayout.VERTICAL);\n        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT);\n\n        final EditText token = new EditText(activity);\n        token.setInputType(InputType.TYPE_CLASS_TEXT);\n        token.setHint(R.string.hint_mail_token);\n\n        final TextView tokenExplanation = new TextView(activity);\n        tokenExplanation.setText(R.string.explanation_mail_token);\n\n        final EditText password = new EditText(activity);\n        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        password.setHint(R.string.hint_new_password);\n\n        final EditText passwordCheck = new EditText(activity);\n        passwordCheck.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n        passwordCheck.setHint(R.string.hint_repeat_new_password);\n\n        final EditText mail = new EditText(activity);\n        mail.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\n        mail.setHint(R.string.registration_email);\n\n        if (inputMail == null || inputMail.isEmpty()) {\n            list.addView(mail);\n        }\n        list.addView(token, layoutParams);\n        list.addView(tokenExplanation, layoutParams);\n        list.addView(password, layoutParams);\n        list.addView(passwordCheck, layoutParams);\n\n        alert.setView(list);\n\n        // \"OK\" button to save the values\n        alert.setPositiveButton(R.string.OK,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n\n                        // Grab the EditText's input\n                        String email;\n                        if (inputMail == null || inputMail.isEmpty()) {\n                            email = mail.getText().toString();\n                        } else {\n                            email = inputMail;\n                        }\n                        String mailToken = token.getText().toString();\n                        String inputPassword = password.getText().toString();\n                        String inputPasswordCheck = passwordCheck.getText()\n                                .toString();\n\n                        if (password.getText().length() < 8) {\n                            Toaster.getInstance().toast(R.string.password_too_short,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        if (!inputPassword.equals(inputPasswordCheck)) {\n                            Toaster.getInstance().toast(R.string.passwords_do_not_match,\n                                    Toast.LENGTH_LONG);\n                            return;\n                        }\n                        User user = new User(email, inputPassword);\n                        PasswordEncryption pwEnc = new PasswordEncryption(user);\n                        User secured = pwEnc.securePassword();\n                        new ChangePasswordTask(secured).execute(\"0\", mailToken);\n                    }\n                }\n        );\n\n        // \"Cancel\" button\n        alert.setNegativeButton(R.string.cancel,\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int whichButton) {\n                        dialog.cancel();\n                    }\n                }\n        );\n        alert.show();\n    }\n\n    /**\n     * Shows the progress UI and hides the login form.\n     */\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\n    public void showProgress(final boolean show) {\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\n        // for very easy animations. If available, use these APIs to fade-in\n        // the progress spinner.\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\n\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n                }\n            });\n\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n                }\n            });\n        } else {\n            // The ViewPropertyAnimator APIs are not available, so simply show\n            // and hide the relevant UI components.\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\n        }\n    }\n\n    @Override\n    public void notifyFragment(LoginParam param) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified. Yeeha!\");\n        if (param instanceof LoginProcessParam) {\n            notifyFragment((LoginProcessParam) param);\n        } else if (param instanceof DeviceRegistrationParam) {\n            notifyFragment((DeviceRegistrationParam) param);\n        }\n    }\n\n    public void notifyFragment(LoginProcessParam loginParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with loginParam\");\n\n        onPostLoginExecute(loginParam.getSuccess(), loginParam.getUserId());\n        Log.d(super.getClass().getSimpleName(), \"Login-Status: \" + loginParam.getSuccess());\n    }\n\n    public void notifyFragment(DeviceRegistrationParam deviceRegistrationParam) {\n        Log.d(super.getClass().getSimpleName(), \"I have been notified with deviceRegistrationParam\");\n\n        onPostYasmeDeviceRegExecute(deviceRegistrationParam.getSuccess(),\n                deviceRegistrationParam.getDeviceId());\n\n    }\n\n    public static class LoginParam {\n        protected Boolean success;\n\n        public Boolean getSuccess() {\n            return success;\n        }\n    }\n\n    public static class LoginProcessParam extends LoginParam {\n        private Long userId;\n\n        public LoginProcessParam(Boolean success) {\n            this.success = success;\n            this.userId = DatabaseManager.INSTANCE.getUserId();\n        }\n\n        public Long getUserId() {\n            return userId;\n        }\n    }\n\n    public static class DeviceRegistrationParam extends LoginParam {\n        private Long deviceId;\n\n        public DeviceRegistrationParam(Boolean success) {\n            this.success = success;\n            this.deviceId = DatabaseManager.INSTANCE.getDeviceId();\n        }\n\n        public Long getDeviceId() {\n            return deviceId;\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/ui/AbstractYasmeActivity.java\npublic abstract class AbstractYasmeActivity extends Activity implements Toastable {\n    public final static String USER_ID = \"de.fau.cs.mad.yasme.android.USER_ID\";\n    public final static String USER_NAME = \"de.fau.cs.mad.yasme.android.USER_NAME\";\n    public final static String USER_MAIL = \"de.fau.cs.mad.yasme.android.USER_MAIL\";\n    public final static String USER_PW = \"de.fau.cs.mad.yasme.android.USER_PW\";\n    public final static String DEVICE_ID = \"de.fau.cs.mad.yasme.android.DEVICE_ID\";\n    public final static String PROFILE_PICTURE = \"de.fau.cs.mad.yasme.android.PROFILE_PICTURE\";\n\n    public final static String CHAT_ID = \"de.fau.cs.mad.yasme.android.CHAT_ID\";\n    public final static String LAST_MESSAGE_ID = \"de.fau.cs.mad.yasme.android.LAST_MESSAGE_ID\";\n\n    public final static String ACCESSTOKEN = \"de.fau.cs.mad.yasme.android.ACCESSTOKEN\";\n    public final static String SIGN_IN = \"de.fau.cs.mad.yasme.android.SIGN_IN\";\n\n    public final static String SERVERINFOUPDATETIME = \"de.fau.cs.mad.yasme.android.SERVERINFOUPDATETIME\";\n    public final static String SERVERMESSAGE = \"de.fau.cs.mad.yasme.android.SERVERMESSAGE\";\n\n    public final static String STORAGE_PREFS = \"de.fau.cs.mad.yasme.android.STORAGE_PREFS\";\n    public final static String SETTINGS_PREFS = \"de.fau.cs.mad.yasme.android.SETTINGS_PREFS\";\n    public final static String DEVICE_PREFS = \"de.fau.cs.mad.yasme.android.DEVICE_PREFS\";\n    public final static String PUSH_PREFS = \"de.fau.cs.mad.yasme.android.PUSH_PREFS\";\n\n    public final static String NOTIFICATION_VIBRATE = \"de.fau.cs.mad.yasme.android.NOTIFICATION_VIBRATE\";\n    public final static String NOTIFICATION_SOUND = \"de.fau.cs.mad.yasme.android.NOTIFICATION_SOUND\";\n\n\n    //GCM Properties\n    public static final String PROPERTY_REG_ID = \"registration_id\";\n    public static final String PROPERTY_APP_VERSION = \"appVersion\";\n    public static final String SENDER_ID = \"688782154540\"; //\"104759172131\";\n    public static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;\n    public static final String TAG = \"YasmeGCM\";\n\n    protected User selfUser;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        if (!ConnectionTask.isInitialized()) {\n            String server = getResources().getString(R.string.server_host);\n            if (BuildConfig.DEBUG) {\n                server = getResources().getString(R.string.server_host_debug);\n            }\n            Log.d(getClass().getSimpleName(), \"YASME-Server: \" + server);\n            ConnectionTask.initParams(getResources().getString(R.string.server_scheme),\n                    server,\n                    getResources().getString(R.string.server_port), getResources().getString(R.string.language), getVersion());\n        }\n\n        SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n        SharedPreferences settings = getSharedPreferences(SETTINGS_PREFS, MODE_PRIVATE);\n        Long userId = storage.getLong(USER_ID, 0);\n        String userName = storage.getString(USER_NAME, \"\");\n        String userMail = storage.getString(USER_MAIL, \"\");\n        String userPw = storage.getString(USER_PW, \"password\");\n\n        if(selfUser==null) {\n            selfUser = new User();\n        }\n        selfUser.setId(userId);\n        selfUser.setName(userName);\n        selfUser.setEmail(userMail);\n        selfUser.setPw(userPw);\n\n\n        //Initialize databaseManager (once in application)\n        if (!DatabaseManager.INSTANCE.isInitialized()) {\n            DatabaseManager.INSTANCE.init(this, storage, settings, userId);\n        }\n        //Init QR-Code\n        QR.init(false);\n\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        Toaster.getInstance().register(this);\n        stopSpinning();\n        SpinnerObservable.getInstance().registerActivity(this);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        String accessToken = DatabaseManager.INSTANCE.getAccessToken();\n        if ((accessToken == null || accessToken.length() <= 0) && !this.getClass().equals(LoginActivity.class)) {\n            Log.i(this.getClass().getSimpleName(), \"Not logged in, starting login activity\");\n            Intent intent = new Intent(this, LoginActivity.class);\n            startActivity(intent);\n            finish();\n            return;\n        }\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        Toaster.getInstance().remove(this);\n        SpinnerObservable.getInstance().removeActivity(this);\n    }\n\n    public void setActionBarTitle(String title) {\n        getActionBar().setTitle(title);\n    }\n\n    public void setActionBarTitle(String title, String subtitle) {\n        getActionBar().setTitle(title);\n        getActionBar().setSubtitle(subtitle);\n    }\n\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        Intent intent;\n        int itemId = item.getItemId();\n        switch (itemId) {\n            case android.R.id.home:\n                if (NavUtils.getParentActivityName(this) != null) {\n                    NavUtils.navigateUpFromSameTask(this);\n                }\n                return true;\n            case R.id.action_settings:\n                intent = new Intent(this, SettingsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_chats:\n                intent = new Intent(this, ChatListActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n                startActivity(intent);\n                return true;\n            case R.id.action_add_chat:\n                intent = new Intent(this, InviteToChatActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            case R.id.action_contacts:\n                intent = new Intent(this, ContactActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(intent);\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n\n    public String getSelfName() {\n\n        if(selfUser==null) {\n            SharedPreferences storage = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE);\n            Long userId = storage.getLong(USER_ID, 0);\n            String userName = storage.getString(USER_NAME, \"\");\n            String userMail = storage.getString(USER_MAIL, \"\");\n            String userPw = storage.getString(USER_PW, \"password\");\n\n            selfUser = new User();\n            selfUser.setId(userId);\n            selfUser.setName(userName);\n            selfUser.setEmail(userMail);\n            selfUser.setPw(userPw);\n        }\n        if (selfUser.getName().isEmpty()) {\n            String name = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_NAME, \"\");\n            selfUser.setName(name);\n        }\n        return selfUser.getName();\n    }\n\n    public User getSelfUser() {\n        return selfUser;\n    }\n\n    public String getUserMail() {\n        if (selfUser == null || selfUser.getEmail().isEmpty()) {\n            String mail = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(USER_MAIL, \"\");\n            selfUser.setEmail(mail);\n        }\n        return selfUser.getEmail();\n    }\n\n    public long getUserId() {\n        return selfUser.getId();\n    }\n\n    public String getOwnProfilePicture() {\n        String path = selfUser.getProfilePicture();\n        if (path == null || path.isEmpty()) {\n            path = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).getString(PROFILE_PICTURE, null);\n        }\n        return path;\n    }\n\n    public void setOwnProfilePicture(String ownProfilePicture) {\n        selfUser.setProfilePicture(ownProfilePicture);\n        SharedPreferences.Editor editor = getSharedPreferences(STORAGE_PREFS, MODE_PRIVATE).edit();\n        editor.putString(AbstractYasmeActivity.PROFILE_PICTURE, ownProfilePicture);\n        editor.commit();\n    }\n\n    public String getAccessToken() {\n        return DatabaseManager.INSTANCE.getAccessToken();\n    }\n\n    public void toast(final int messageId, final int duration) {\n        String text = getApplicationContext().getResources().getString(messageId);\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration) {\n        toast(text, duration, -1);\n    }\n\n    public void toast(final String text, final int duration, final int gravity) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                Toast toast = Toast.makeText(getApplicationContext(), text, duration);\n                if (-1 != gravity) {\n                    toast.setGravity(gravity, 0, 0);\n                }\n                // otherwise use default position\n                Log.d(getClass().getSimpleName(), \"Toast: \" + text);\n                toast.show();\n            }\n        });\n    }\n\n    public void startSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(true);\n            }\n        });\n    }\n\n    public void stopSpinning() {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                setProgressBarIndeterminateVisibility(false);\n            }\n        });\n    }\n\n    public int getVersion() {\n        try {\n            return getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n        } catch (Exception e) {\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return 0;\n        }\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/gcm/CloudMessaging.java\npublic class CloudMessaging {\n\n    private static CloudMessaging instance;\n\n    private Activity activity;\n    private GoogleCloudMessaging gcm;\n    private Context context;\n    private String regid;\n\n\n    public static CloudMessaging getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CloudMessaging(activity);\n        }\n        return instance;\n    }\n\n    private CloudMessaging(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.gcm = GoogleCloudMessaging.getInstance(activity);\n    }\n\n    public boolean checkPlayServices() {\n        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n        if (resultCode != ConnectionResult.SUCCESS) {\n            if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {\n                GooglePlayServicesUtil.getErrorDialog(resultCode, activity,\n                        AbstractYasmeActivity.PLAY_SERVICES_RESOLUTION_REQUEST).show();\n            } else {\n                Log.i(AbstractYasmeActivity.TAG, \"This device is not supported.\");\n                activity.finish();\n            }\n            return false;\n        }\n        return true;\n    }\n\n    public String getRegistrationId() {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        String registrationId = prefs.getString(AbstractYasmeActivity.PROPERTY_REG_ID, \"\");\n        Log.i(AbstractYasmeActivity.TAG + \"WOOOOOLOOOLOOOO\", \"this is my id: [\" + AbstractYasmeActivity.PROPERTY_REG_ID + \"]\");\n        if (registrationId.isEmpty()) {\n            Log.i(AbstractYasmeActivity.TAG, \"Registration not found.\");\n            return \"\";\n        }\n        // Check if app was updated; if so, it must clear the registration ID\n        // since the existing regID is not guaranteed to work with the new\n        // app version.\n        int registeredVersion = prefs.getInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, Integer.MIN_VALUE);\n        int currentVersion = getAppVersion(context);\n        if (registeredVersion != currentVersion) {\n            Log.i(AbstractYasmeActivity.TAG, \"App version changed.\");\n            return \"\";\n        }\n        return registrationId;\n    }\n\n    public SharedPreferences getGCMPreferences(Context context) {\n        return context.getSharedPreferences(LoginActivity.class.getSimpleName(),\n                Context.MODE_PRIVATE);\n    }\n\n    public int getAppVersion(Context context) {\n        try {\n            PackageInfo packageInfo = context.getPackageManager()\n                    .getPackageInfo(context.getPackageName(), 0);\n            return packageInfo.versionCode;\n        } catch (PackageManager.NameNotFoundException e) {\n            throw new RuntimeException(\"Could not get package name: \" + e);\n        }\n    }\n\n    public String registerInBackground() {\n        try {\n            if (gcm == null) {\n                gcm = GoogleCloudMessaging.getInstance(context);\n            }\n            regid = gcm.register(AbstractYasmeActivity.SENDER_ID);\n\n            Log.d(this.getClass().getSimpleName(), \"Device registered, registration ID=\" + regid);\n\n            // Persist the regID - no need to register again.\n            storeRegistrationId(context, regid);\n            return regid;\n        } catch (IOException e) {\n            // If there is an error, don't just keep trying to register.\n            // Require the user to click a button again, or perform\n            // exponential back-off.\n            Log.e(this.getClass().getSimpleName(), e.getMessage());\n            return null;\n        }\n    }\n\n    private void storeRegistrationId(Context context, String regId) {\n        final SharedPreferences prefs = getGCMPreferences(context);\n        int appVersion = getAppVersion(context);\n        Log.i(AbstractYasmeActivity.TAG, \"Saving regId on app version \" + appVersion);\n        SharedPreferences.Editor editor = prefs.edit();\n        editor.putString(AbstractYasmeActivity.PROPERTY_REG_ID, regId);\n        editor.putInt(AbstractYasmeActivity.PROPERTY_APP_VERSION, appVersion);\n        editor.commit();\n\n        // For Developer-Devices only\n        if (DebugManager.INSTANCE.isDebugMode()) {\n            Log.d(getClass().getSimpleName(), \"Store gcmId to external storage\");\n            DebugManager.INSTANCE.storePushId(regId);\n        }\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/storage/DebugManager.java\npublic enum DebugManager {\r\n    INSTANCE;\r\n\r\n    private final String OWNDEVICE = \"owndevice\";\r\n    private final String MESSAGEKEYS = \"messagekeys\";\r\n\r\n    private boolean debugMode = false;\r\n    private OwnDevice ownDevice = new OwnDevice();\r\n\r\n    public boolean isDebugMode() {\r\n        return debugMode;\r\n    }\r\n\r\n    public boolean storeDeviceId(long deviceId) {\r\n        ownDevice.setId(deviceId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n\r\n    public boolean storePrivatePublicKeyToExternalStorage(String privateKey, String publicKey) {\r\n        ownDevice.setPrivateKey(privateKey);\r\n        ownDevice.setPublicKey(publicKey);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    public boolean storePushId(String pushId) {\r\n        ownDevice.setPushId(pushId);\r\n        return storeOwnDeviceToExternalStorage();\r\n    }\r\n\r\n    private boolean storeOwnDeviceToExternalStorage() {\r\n        return storeToExternalStorage(OWNDEVICE, ownDevice, false);\r\n    }\r\n\r\n    public boolean storeMessageKeyToExternalStorage(MessageKey data) {\r\n        return storeToExternalStorage(MESSAGEKEYS, data, true);\r\n    }\r\n\r\n    private boolean storeToExternalStorage(String name, Object data, boolean append) {\r\n        try {\r\n            String state = Environment.getExternalStorageState();\r\n            Log.d(getClass().getSimpleName(), \"Check state\");\r\n            if (!Environment.MEDIA_MOUNTED.equals(state)) {\r\n                return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            Log.d(getClass().getSimpleName(), \"Mkdir\");\r\n            if (!dir.exists() && !dir.mkdirs()) {\r\n                Log.d(getClass().getSimpleName(), \"... failed\");\r\n               return false;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            File file = new File(dir,name + \".txt\");\r\n            Log.d(getClass().getSimpleName(), \"Write file\");\r\n\r\n            ObjectWriter objectWriter = new ObjectMapper().writer();\r\n            String json = objectWriter.writeValueAsString(data);\r\n            Log.d(getClass().getSimpleName(),\"Generated JSON: \" + json);\r\n\r\n            FileOutputStream f = new FileOutputStream(file,append);\r\n            PrintWriter pw = new PrintWriter(f);\r\n            if (append) {\r\n                pw.println(json + \",\");\r\n            } else {\r\n                pw.println(json);\r\n            }\r\n            pw.flush();\r\n            pw.close();\r\n            f.close();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean restoreData() {\r\n        Log.d(getClass().getSimpleName(),\"Restoring data\");\r\n        if (!restoreOwnDeviceFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring OwnDevice failed\");\r\n            return false;\r\n        }\r\n        if (!restoreMessageKeysFromExternalStorage()) {\r\n            Log.d(getClass().getSimpleName(), \"Restoring MessageKeys failed\");\r\n            return false;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Restoring successful\");\r\n        Toaster.getInstance().toast(\"Restoring Debug-Data successful\", Toast.LENGTH_LONG);\r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean restoreOwnDeviceFromExternalStorage() {\r\n         final String RSAKEY_STORAGE = \"rsaKeyStorage\"; //Storage for Private and Public Keys from user\r\n         final String PRIVATEKEY = \"privateKey\";\r\n         final String PUBLICKEY = \"publicKey\";\r\n\r\n        try {\r\n            OwnDevice device = getOwnDeviceFromExternalStorage();\r\n            if (device == null) {\r\n                Log.d(getClass().getSimpleName(), \"Device is null\");\r\n                return false;\r\n            }\r\n\r\n            // Restore devId\r\n            Log.d(getClass().getSimpleName(), \"Restore devId\");\r\n            SharedPreferences.Editor editor1 = DatabaseManager.INSTANCE.getSharedPreferences().edit();\r\n            editor1.putLong(AbstractYasmeActivity.DEVICE_ID, ownDevice.getId());\r\n            editor1.commit();\r\n\r\n            // Restore pushId and app version\r\n            Log.d(getClass().getSimpleName(), \"Restore pushId\");\r\n            SharedPreferences prefs = DatabaseManager.INSTANCE.getContext().getSharedPreferences(LoginActivity.class.getSimpleName(), Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor editor2 = prefs.edit();\r\n            editor2.putString(AbstractYasmeActivity.PROPERTY_REG_ID, ownDevice.getPushId());\r\n            editor2.commit();\r\n\r\n            // Restore PrivatePublicKey\r\n            Log.d(getClass().getSimpleName(), \"Restore PrivPubKeys\");\r\n            String RSAKEY_STORAGE_USER = RSAKEY_STORAGE + \"_\" + ownDevice.getId();\r\n            Context context = DatabaseManager.INSTANCE.getContext();\r\n            SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\r\n            SharedPreferences.Editor keyeditor = privKeyStorage.edit();\r\n\r\n            keyeditor.putString(PRIVATEKEY, device.getPrivateKey());\r\n            keyeditor.putString(PUBLICKEY,device.getPublicKey());\r\n            keyeditor.commit();\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private OwnDevice getOwnDeviceFromExternalStorage() {\r\n        String text = readText(OWNDEVICE);\r\n        if (text == null || text == \"\") {\r\n            return null;\r\n        }\r\n        Log.d(getClass().getSimpleName(), \"Device-Text: \" + text);\r\n        try {\r\n            OwnDevice device = new ObjectMapper().readValue(text, OwnDevice.class);\r\n            Log.d(getClass().getSimpleName(), \"PubKey: \" + device.getPublicKey());\r\n            return device;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private boolean restoreMessageKeysFromExternalStorage() {\r\n        String text = readText(MESSAGEKEYS);\r\n        if (text == null) {\r\n            return false;\r\n        }\r\n        if (text == \"\") {\r\n            // No messageKey stored yet\r\n            return true;\r\n        }\r\n        String json = \"[\" + text + \"{}]\";\r\n        Log.d(getClass().getSimpleName(), \"MessageKeys-Text: \" + text);\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"JSON: \" + json);\r\n            JSONArray jsonArray = new JSONArray(json);\r\n\r\n            for (int i = 0; i < jsonArray.length() - 1; i++) {\r\n                MessageKey messageKey = new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\r\n                        toString(), MessageKey.class);\r\n                messageKey.setAuthenticity(true);\r\n                DatabaseManager.INSTANCE.getMessageKeyDAO().addOrUpdate(messageKey);\r\n            }\r\n\r\n            return true;\r\n        } catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private String readText(String name) {\r\n        String filename = \"\";\r\n        try {\r\n            Log.d(getClass().getSimpleName(), \"Open dir\");\r\n            File dir = getDir();\r\n            if (!dir.exists()) {\r\n                return null;\r\n            }\r\n            Log.d(getClass().getSimpleName(), \"Open file\");\r\n            filename = dir.getAbsolutePath() + \"/\" + name + \".txt\";\r\n\r\n\r\n            BufferedReader br = new BufferedReader(new FileReader(filename));\r\n            StringBuilder sb = new StringBuilder();\r\n            String line = br.readLine();\r\n\r\n            while (line != null) {\r\n                sb.append(line);\r\n                line = br.readLine();\r\n            }\r\n            br.close();\r\n            return sb.toString();\r\n        } catch (FileNotFoundException e) {\r\n            Log.e(getClass().getSimpleName(), \"File \" + filename + \" not found.\");\r\n            return \"\";\r\n        }\r\n        catch (Exception e) {\r\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private File getDir() {\r\n        return new File(Environment.getExternalStoragePublicDirectory(\"yasme\"), String.valueOf(DatabaseManager.INSTANCE.getUserId()));\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/connection/DeviceTask.java\npublic class DeviceTask extends ConnectionTask {\n\n    private static DeviceTask instance;\n\n    public static DeviceTask getInstance() {\n        if (instance == null) {\n            synchronized (DeviceTask.class) {\n                if (null == instance) {\n                    instance = new DeviceTask();\n                }\n            }\n        }\n        return instance;\n    }\n\n    private DeviceTask() {\n        try {\n            this.uri = new URIBuilder(baseURI).setPath(ConnectionTask.APIVERSION + \"/device\").build();\n        } catch (URISyntaxException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n    }\n\n    public Long registerDevice(OwnDevice device) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.POST, \"\", device);\n\n            //Log.d(this.getClass().getSimpleName(), \"Device registration was successful\");\n\n            long deviceId = (new JSONObject((new BufferedReader(\n                    new InputStreamReader(httpResponse.getEntity()\n                            .getContent())\n            )).readLine())).getLong(\"id\");\n            DatabaseManager.INSTANCE.setDeviceId(deviceId);\n            return deviceId;\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n        return null;\n    }\n\n    public Device getDevice(long devId) throws RestServiceException {\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, String.valueOf(devId));\n            return new ObjectMapper().readValue(new BufferedReader(new InputStreamReader(httpResponse.getEntity()\n                    .getContent())).readLine(), Device.class);\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        }\n    }\n\n    public ArrayList<Device> getAllDevices(Long userId) throws RestServiceException {\n\n        ArrayList<Device> devices = new ArrayList<Device>();\n\n        try {\n            HttpResponse httpResponse = executeRequest(Request.GET, \"all/\" + userId);\n\n            JSONArray jsonArray = new JSONArray(new BufferedReader(new InputStreamReader(\n                    httpResponse.getEntity().getContent())).readLine());\n\n            for (int i = 0; i < jsonArray.length(); i++)\n                devices.add(new ObjectMapper().readValue((jsonArray.getJSONObject(i)).\n                        toString(), Device.class));\n\n        } catch (IOException e) {\n            throw new RestServiceException(Error.CONNECTION_ERROR);\n        } catch (JSONException e) {\n            Log.e(this.getClass().getSimpleName(),e.getMessage());\n        }\n\n        //Log.d(this.getClass().getSimpleName(), \"No.Devices: \" + devices.size());\n        return devices;\n    }\n\n    public void deleteDevice(long deviceId) throws RestServiceException {\n        executeRequest(Request.DELETE, Long.toString(deviceId));\n        //Log.d(this.getClass().getSimpleName(), \"Device removed!\");\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/User.java\n@JsonIgnoreProperties(ignoreUnknown = true)\n@DatabaseTable(tableName = DatabaseConstants.USER_TABLE)\npublic class User implements Serializable {\n\n    @DatabaseField(columnName = DatabaseConstants.USER_ID, id = true)\n    private long id;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_NAME)\n    private String name;\n\n    //@DatabaseField(columnName = DatabaseConstants.USER_EMAIL)\n    private String email;\n\n    private String pw;\n\n    @JsonIgnore\n    private List<Device> devices;   // Just for convenience\n\n    @DatabaseField(columnName = DatabaseConstants.USER_LAST_MODIFIED)\n    private Date lastModified;\n\n    @DatabaseField(columnName = DatabaseConstants.USER_CREATED)\n    private Date created;\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.USER_PICTURE)\n    private String profilePicture;\n\n\n    @JsonIgnore\n    @DatabaseField(columnName = DatabaseConstants.CONTACT)\n    private int contactFlag = 0;\n\n\n    public User(String pw, String name, String email) {\n        this.pw = pw;\n        this.name = name;\n        this.email = email;\n    }\n\n    public User(String email, String pw) {\n        this.email = email;\n        this.pw = pw;\n    }\n\n    public User(String name, long id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    public User(long id) {\n        this.id = id;\n    }\n\n    public User(String name, String email, long id) {\n        this.name = name;\n        this.email = email;\n        this.id = id;\n    }\n\n    public User() {\n        // ORMLite needs a no-arg constructor\n    }\n\n    /*\n     * Getters\n     */\n\n    @JsonIgnoreProperties({\"id\", \"user\", \"publicKey\", \"product\", \"lastModified\"})\n    public List<Device> getDevices() {\n        return devices;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getPw() {\n        return pw;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Date getLastModified() {\n        return lastModified;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public String getProfilePicture() {\n        return profilePicture;\n    }\n\n    /*\n     * Setters\n     */\n\n    public void setDevices(List<Device> devices) {\n        this.devices = devices;\n    }\n\n    public void setPw(String pw) {\n        this.pw = pw;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setProfilePicture(String profilePicture) {\n        this.profilePicture = profilePicture;\n    }\n\n    @JsonIgnore\n    public void addToContacts() {\n        contactFlag = 1;\n    }\n\n    @JsonIgnore\n    public void removeFromContacts() {\n        contactFlag = 0;\n    }\n\n    @JsonIgnore\n    public boolean isContact() {\n        return contactFlag == 1;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/ObservableRegistry.java\npublic class ObservableRegistry {\n\n    private static ArrayList<ObservableRegistryEntry> entries = new ArrayList<ObservableRegistryEntry>();\n\n    public static <T extends NotifiableFragment<P>, P> FragmentObservable<T, P> getObservable(Class fragmentClass) {\n        for (ObservableRegistryEntry entry : entries) {\n            if (entry.check(fragmentClass)) {\n                Log.d(\"ObserverRegistry\",\"Returned existing observable\");\n                return (FragmentObservable<T,P>) entry.getObs(); // no idea how to solve this... \n            }\n        }\n\n        FragmentObservable<T, P> res = new FragmentObservable<T, P>();\n        Log.d(\"ObserverRegistry\",\"Created new observable\");\n        entries.add(new ObservableRegistryEntry<P>(res,fragmentClass));\n        return res;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/Log.java\npublic class Log {\r\n    static final boolean LOG_I = BuildConfig.DEBUG;\r\n    static final boolean LOG_E = BuildConfig.DEBUG;\r\n    static final boolean LOG_D = BuildConfig.DEBUG;\r\n    static final boolean LOG_V = BuildConfig.DEBUG;\r\n    static final boolean LOG_W = BuildConfig.DEBUG;\r\n\r\n    public static void i(String tag, String string) {\r\n        if (LOG_I) android.util.Log.i(tag, string);\r\n    }\r\n    public static void e(String tag, String string) {\r\n        if (LOG_E) android.util.Log.e(tag, string);\r\n    }\r\n    public static void d(String tag, String string) {\r\n        if (LOG_D) android.util.Log.d(tag, string);\r\n    }\r\n    public static void v(String tag, String string) {\r\n        if (LOG_V) android.util.Log.v(tag, string);\r\n    }\r\n    public static void w(String tag, String string) {\r\n        if (LOG_W) android.util.Log.w(tag, string);\r\n    }\r\n}\r\nyasme/src/main/java/de/fau/cs/mad/yasme/android/exception/RestServiceException.java\npublic class RestServiceException extends Exception {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int code;\n\n\tpublic RestServiceException(ErrorCode error) {\n\n\t\tthis(error.getDescription(), error.getNumber());\n\n\t}\n\n\tpublic RestServiceException(String message, int code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\n\t\tSystem.err.println(\"Code: \" + this.code + \"  \" + \"Message: \"\n\t\t\t\t+ this.getMessage());\n\t}\n\n    public int getCode() {\n        return code;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/contacts/QR.java\npublic class QR {\n    private static final int SIZE = 1024;\n    private static Bitmap qrCode;\n    private static boolean isRunning = false;\n\n    public static void init(boolean force) {\n        if (force) {\n            qrCode = null;\n            isRunning = false;\n        }\n        if (qrCode == null && !isRunning) {\n            isRunning = true;\n            new QRTask().execute();\n        }\n    }\n\n    public static void finished() {\n        isRunning = false;\n    }\n\n    public Bitmap generateQRCode() {\n        if (qrCode != null) {\n            return qrCode;\n        }\n        QRData qrdata = new QRData();\n        DatabaseManager db = DatabaseManager.INSTANCE;\n        qrdata.setDeviceId(db.getDeviceId());\n\n        Context context = db.getContext();\n        String RSAKEY_STORAGE_USER = KeyEncryption.RSAKEY_STORAGE + \"_\" + db.getDeviceId();\n        SharedPreferences privKeyStorage = context.getSharedPreferences(RSAKEY_STORAGE_USER, Context.MODE_PRIVATE);\n        String pubKeyInBase64 = privKeyStorage.getString(KeyEncryption.PUBLICKEY, \"\");\n        qrdata.setPublicKey(pubKeyInBase64);\n\n        //ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();\n        ObjectWriter objectWriter = new ObjectMapper().writer();\n        try {\n            String data = objectWriter.writeValueAsString(qrdata);\n            qrCode = generateQRCode(data);\n            return qrCode;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Bitmap generateQRCode(String data) {\n        Log.d(getClass().getName(), \"Generate QR for \" + data);\n        com.google.zxing.Writer writer = new QRCodeWriter();\n        BitMatrix bm;\n        try {\n            bm = writer.encode(data, BarcodeFormat.QR_CODE,SIZE, SIZE);\n        } catch (Exception e) {\n            return null;\n        }\n\n        Bitmap imageBitmap = Bitmap.createBitmap(SIZE, SIZE, Bitmap.Config.ARGB_8888);\n\n        for (int i = 0; i < SIZE; i++) {//width\n            for (int j = 0; j < SIZE; j++) {//height\n                imageBitmap.setPixel(i, j, bm.get(i, j) ? Color.BLACK: Color.WHITE);\n            }\n        }\n        return imageBitmap;\n    }\n\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/entities/OwnDevice.java\npublic class OwnDevice {\n\n    public enum Platform {\n        ANDROID,\n        IOS,\n        WINDOWSPHONE;\n    }\n\n    private long id;\n    private Platform platform; // android, ios or windowsmobile\n    private String type;    // mobilephone, tablet or desktop\n    private User user;\n    private String number;  // optional\n    private String publicKey;\n    private String privateKey;\n    private String product; // product name e.g. Google Nexux 5\n    private String pushId;\n\n    private Date created;\n\n    private Date lastModified;\n\n    public OwnDevice(User user, Platform platform, String publicKey, String type, String number, String product, String pushId) {\n        this.user = user;\n        this.platform = platform;\n        this.type = type;\n        this.number = number;\n        this.product = product;\n        this.pushId = pushId;\n        this.publicKey = publicKey;\n    }\n\n    public OwnDevice() {\n    }\n\n    public OwnDevice(long id) {\n        this.id = id;\n    }\n\n    @JsonIgnoreProperties({ \"pw\", \"email\", \"name\", \"devices\", \"lastModified\", \"created\" })\n    public User getUser() {\n        return this.user;\n    }\n\n    public String getPushId(){return this.pushId;}\n\n    public String getProduct(){return this.product;}\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    public void setProduct(String product){this.product = product;}\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public void setLastModified(Date lastModified) {\n        this.lastModified = lastModified;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public Platform getPlatform() {\n        return platform;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setPlatform(Platform platform) {\n        this.platform = platform;\n    }\n\n    public void setPushId(String pushId){this.pushId = pushId;}\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPublicKey() {\n        return publicKey;\n    }\n\n    public void setPublicKey(String publicKey) {\n        this.publicKey = publicKey;\n    }\n\n    public Date getCreated() {\n        return this.created;\n    }\n\n    public Date getLastModified() {\n        return this.lastModified;\n    }\n\n    public String getPrivateKey() {\n        return privateKey;\n    }\n\n    public void setPrivateKey(String privateKey) {\n        this.privateKey = privateKey;\n    }\n}\nyasme/src/main/java/de/fau/cs/mad/yasme/android/controller/SpinnerObservable.java\npublic class SpinnerObservable {\r\n    private Set<AsyncTask> backgroundTasks;\r\n    private Set<AbstractYasmeActivity> activities;\r\n    private boolean spinning = false;\r\n\r\n    private static SpinnerObservable instance;\r\n\r\n    public static SpinnerObservable getInstance() {\r\n        if (instance == null) {\r\n            instance = new SpinnerObservable();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    private SpinnerObservable() {\r\n        backgroundTasks = new HashSet<>();\r\n        activities = new HashSet<>();\r\n    }\r\n\r\n    public void registerActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Register activity\");\r\n        activities.add(activity);\r\n        if (spinning) {\r\n            Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n            activity.startSpinning();\r\n        } else {\r\n            Log.d(getClass().getSimpleName(), \"No spinning\");\r\n        }\r\n    }\r\n\r\n    public void removeActivity(AbstractYasmeActivity activity) {\r\n        Log.d(getClass().getSimpleName(), \"Remove activity\");\r\n        activities.remove(activity);\r\n    }\r\n\r\n    public void registerBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Register backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.add(backgroundTask);\r\n        spinning = true;\r\n        startSpinning();\r\n    }\r\n\r\n    public void removeBackgroundTask(AsyncTask backgroundTask) {\r\n        Log.d(getClass().getSimpleName(), \"Remove backgroundTask: \" + backgroundTask.getClass().getSimpleName());\r\n        backgroundTasks.remove(backgroundTask);\r\n        if (backgroundTasks.size() == 0) {\r\n            spinning = false;\r\n            stopSpinning();\r\n        }\r\n    }\r\n\r\n    public void startSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Start spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.startSpinning();\r\n        }\r\n    }\r\n\r\n    public void stopSpinning() {\r\n        Log.d(getClass().getSimpleName(), \"Stop spinning\");\r\n        for (AbstractYasmeActivity activity : activities) {\r\n            activity.stopSpinning();\r\n        }\r\n    }\r\n}\r\n", "answers": ["        } catch (RestServiceException e) {"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 5741, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "6844939b4c4619bf2bb691b26c2beecaad85f0aeb4518366"}
{"prompt": "Please complete the code given below. \nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationRequest.java\npublic class RegistrationRequest {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegistrationRequest(String version, String challenge, String appId, String sessionId) {\n    this.version = version;\n    this.challenge = challenge;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(challenge, version, sessionId, appId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationRequest other = (RegistrationRequest) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(challenge, other.challenge)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic enum Transports {\n  BLUETOOTH_BREDR(\"bt\"),\n  BLUETOOTH_LOW_ENERGY(\"ble\"),\n  USB(\"usb\"),\n  NFC(\"nfc\");\n\n  private String mValue;\n\n  Transports(String value) {\n    mValue = value;\n  }\n\n  @Override\n  public String toString() {\n    return mValue;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationResponse.java\npublic class RegistrationResponse {\n  /** websafe-base64(raw registration response message) */\n  private final String registrationData;\n\n  /** websafe-base64(UTF8(stringified(client data))) */\n  private final String clientData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n  public RegistrationResponse(String registrationData, String clientData, String sessionId) {\n    this.registrationData = registrationData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getRegistrationData() {\n    return registrationData;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(registrationData, clientData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationResponse other = (RegistrationResponse) obj;\n    if (clientData == null) {\n      if (other.clientData != null)\n        return false;\n    } else if (!clientData.equals(other.clientData))\n      return false;\n    if (registrationData == null) {\n      if (other.registrationData != null)\n        return false;\n    } else if (!registrationData.equals(other.registrationData))\n      return false;\n    if (sessionId == null) {\n      if (other.sessionId != null)\n        return false;\n    } else if (!sessionId.equals(other.sessionId))\n      return false;\n    return true;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SignSessionData.java\npublic class SignSessionData extends EnrollSessionData {\n  private static final long serialVersionUID = -1374014642398686120L;\n\n  private final byte[] publicKey;\n\n  public SignSessionData(String accountName, String appId, byte[] challenge, byte[] publicKey) {\n    super(accountName, appId, challenge);\n    this.publicKey = publicKey;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/SignResponse.java\npublic class SignResponse {\n\n  /** websafe-base64 key handle from U2F device */\n  private final String keyHandle;\n\n  /** websafe-base64(client data) */\n  private final String clientData;\n\n  /** websafe-base64(raw response from U2F device) */\n  private final String signatureData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n\n  public SignResponse(String keyHandle, String signatureData, String clientData, String sessionId) {\n    this.keyHandle = keyHandle;\n    this.signatureData = signatureData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSignatureData() {\n    return signatureData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(keyHandle, clientData, signatureData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (getClass() != obj.getClass())\n      return false;\n    SignResponse other = (SignResponse) obj;\n    return Objects.equals(keyHandle, other.keyHandle)\n        && Objects.equals(clientData, other.clientData)\n        && Objects.equals(signatureData, other.signatureData)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic class SecurityKeyData {\n  public enum Transports {\n    BLUETOOTH_BREDR(\"bt\"),\n    BLUETOOTH_LOW_ENERGY(\"ble\"),\n    USB(\"usb\"),\n    NFC(\"nfc\");\n\n    private String mValue;\n\n    Transports(String value) {\n      mValue = value;\n    }\n\n    @Override\n    public String toString() {\n      return mValue;\n    }\n  }\n\n  private final long enrollmentTime;\n  private final List<Transports> transports;\n  private final byte[] keyHandle;\n  private final byte[] publicKey;\n  private final X509Certificate attestationCert;\n  private int counter;\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this(enrollmentTime, null /* transports */, keyHandle, publicKey, attestationCert, counter);\n  }\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      List<Transports> transports,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this.enrollmentTime = enrollmentTime;\n    this.transports = transports;\n    this.keyHandle = keyHandle;\n    this.publicKey = publicKey;\n    this.attestationCert = attestationCert;\n    this.counter = counter;\n  }\n\n  /**\n   * When these keys were created/enrolled with the relying party.\n   */\n  public long getEnrollmentTime() {\n    return enrollmentTime;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public byte[] getKeyHandle() {\n    return keyHandle;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n\n  public X509Certificate getAttestationCertificate() {\n    return attestationCert;\n  }\n\n  public int getCounter() {\n    return counter;\n  }\n\n  public void setCounter(int newCounterValue) {\n    counter = newCounterValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        enrollmentTime,\n        transports,\n        keyHandle,\n        publicKey,\n        attestationCert,\n        counter);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof SecurityKeyData)) {\n      return false;\n    }\n    SecurityKeyData that = (SecurityKeyData) obj;\n    return Arrays.equals(this.keyHandle, that.keyHandle)\n        && (this.enrollmentTime == that.enrollmentTime)\n        && containSameTransports(this.transports, that.transports)\n        && Arrays.equals(this.publicKey, that.publicKey)\n        && Objects.equals(this.attestationCert, that.attestationCert)\n        && Objects.equals(counter, counter);\n  }\n\n  /**\n   * Compares the two Lists of Transports and says if they are equal.\n   *\n   * @param transports1 first List of Transports\n   * @param transports2 second List of Transports\n   * @return true if both lists are null or if both lists contain the same transport values\n   */\n  public static boolean containSameTransports(List<Transports> transports1,\n      List<Transports> transports2) {\n    if (transports1 == null && transports2 == null) {\n      return true;\n    } else if (transports1 == null || transports2 == null) {\n      return false;\n    }\n    return transports1.containsAll(transports2) && transports2.containsAll(transports1);\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder()\n      .append(\"public_key: \")\n      .append(Base64.encodeBase64URLSafeString(publicKey))\n      .append(\"\\n\")\n      .append(\"key_handle: \")\n      .append(Base64.encodeBase64URLSafeString(keyHandle))\n      .append(\"\\n\")\n      .append(\"counter: \")\n      .append(counter)\n      .append(\"\\n\")\n      .append(\"attestation certificate:\\n\")\n      .append(attestationCert.toString())\n      .append(\"transports: \")\n      .append(transports)\n      .append(\"\\n\")\n      .toString();\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/U2fSignRequest.java\npublic class U2fSignRequest {\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n  /** List of registered keys */\n  private List<RegisteredKey> registeredKeys;\n\n  public U2fSignRequest(String challenge, List<RegisteredKey> registeredKeys) {\n    this.challenge = challenge;\n    this.registeredKeys = registeredKeys;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public List<RegisteredKey> getRegisteredKeys() {\n    return registeredKeys;\n  }\n\n  public JsonArray getRegisteredKeysAsJson(String defaultAppId) {\n    if (registeredKeys == null) {\n      return null;\n    }\n    JsonArray result = new JsonArray();\n    for (RegisteredKey registeredKey : registeredKeys) {\n      result.add(registeredKey.getJson(defaultAppId));\n    }\n    return result;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/U2FServer.java\npublic interface U2FServer {\n\n  // registration //\n  public RegistrationRequest getRegistrationRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processRegistrationResponse(RegistrationResponse registrationResponse,\n      long currentTimeInMillis) throws U2FException;\n\n  // authentication //\n  public U2fSignRequest getSignRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processSignResponse(SignResponse signResponse) throws U2FException;\n\n  // token management //\n  public List<SecurityKeyData> getAllSecurityKeys(String accountName);\n\n  public void removeSecurityKey(String accountName, byte[] publicKey) throws U2FException;\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/EnrollSessionData.java\npublic class EnrollSessionData implements Serializable {\n  private static final long serialVersionUID = 1750990095756334568L;\n\n  private final String accountName;\n  private final byte[] challenge;\n  private final String appId;\n\n  public EnrollSessionData(String accountName, String appId, byte[] challenge) {\n    this.accountName = accountName;\n    this.challenge = challenge;\n    this.appId = appId;\n  }\n\n  public String getAccountName() {\n    return accountName;\n  }\n\n  public byte[] getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n\treturn appId;\n  }\n}\nu2f-ref-code/java/tests/com/google/u2f/TestVectors.java\npublic class TestVectors {\n  // Test vectors from FIDO U2F: Raw Message Formats - Draft 4\n  protected static final int COUNTER_VALUE = 1;\n  protected static final String ACCOUNT_NAME = \"test@example.com\";\n  protected static final Set<String> TRUSTED_DOMAINS = ImmutableSet.of(\"http://example.com\");\n  protected static final String SESSION_ID = \"session_id\";\n  protected static final String APP_ID_ENROLL = \"http://example.com\";\n  protected static final byte[] APP_ID_ENROLL_SHA256 = computeSha256(APP_ID_ENROLL);\n  protected static final String APP_ID_SIGN = \"https://gstatic.com/securitykey/a/example.com\";\n  protected static final byte[] APP_ID_SIGN_SHA256 = computeSha256(APP_ID_SIGN);\n  protected static final String ORIGIN = \"http://example.com\";\n  protected static final String SERVER_CHALLENGE_ENROLL_BASE64 =\n      \"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\";\n  protected static final byte[] SERVER_CHALLENGE_ENROLL =\n      Base64.decodeBase64(SERVER_CHALLENGE_ENROLL_BASE64);\n  protected static final String SERVER_CHALLENGE_SIGN_BASE64 =\n      \"opsXqUifDriAAmWclinfbS0e-USY0CgyJHe_Otd7z8o\";\n  protected static final byte[] SERVER_CHALLENGE_SIGN =\n      Base64.decodeBase64(SERVER_CHALLENGE_SIGN_BASE64);\n  protected static final String VENDOR_CERTIFICATE_HEX =\n      \"3082013c3081e4a003020102020a47901280001155957352300a06082a8648ce\"\n      + \"3d0403023017311530130603550403130c476e756262792050696c6f74301e17\"\n      + \"0d3132303831343138323933325a170d3133303831343138323933325a303131\"\n      + \"2f302d0603550403132650696c6f74476e756262792d302e342e312d34373930\"\n      + \"313238303030313135353935373335323059301306072a8648ce3d020106082a\"\n      + \"8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c144668\"\n      + \"2c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23abaf02\"\n      + \"03b4b8911ba0569994e101300a06082a8648ce3d0403020347003044022060cd\"\n      + \"b6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30dfa0220\"\n      + \"631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b30410df\";\n  protected static final X509Certificate VENDOR_CERTIFICATE =\n      parseCertificate(VENDOR_CERTIFICATE_HEX);\n  protected static final PrivateKey VENDOR_CERTIFICATE_PRIVATE_KEY =\n      parsePrivateKey(\"f3fccc0d00d8031954f90864d43c247f4bf5f0665c6b50cc17749a27d1cf7664\");\n  protected static final String CHANNEL_ID_STRING =\n      \"{\"\n      + \"\\\"kty\\\":\\\"EC\\\",\"\n      + \"\\\"crv\\\":\\\"P-256\\\",\"\n      + \"\\\"x\\\":\\\"HzQwlfXX7Q4S5MtCCnZUNBw3RMzPO9tOyWjBqRl4tJ8\\\",\"\n      + \"\\\"y\\\":\\\"XVguGFLIZx1fXg3wNqfdbn75hi4-_7-BxhMljw42Ht4\\\"\"\n      + \"}\";\n  protected static final JsonObject CHANNEL_ID_JSON =\n      (JsonObject) new JsonParser().parse(CHANNEL_ID_STRING);\n  protected static final String BROWSER_DATA_ENROLL = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_ENROLL_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_ENROLL_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_ENROLL.getBytes());\n  protected static final byte[] BROWSER_DATA_ENROLL_SHA256 =\n      computeSha256(BROWSER_DATA_ENROLL.getBytes());\n  protected static final String BROWSER_DATA_SIGN = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.getAssertion\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_SIGN_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_SIGN_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_SIGN.getBytes());\n  protected static final byte[] BROWSER_DATA_SIGN_SHA256 =\n      parseHex(\"ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc57\");\n  protected static final byte[] REGISTRATION_REQUEST_DATA =\n      parseHex(\"4142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfacb\"\n          + \"f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1c4\");\n  protected static final byte[] REGISTRATION_RESPONSE_DATA =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2\"\n          + \"e3925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772\"\n          + \"d70c253082013c3081e4a003020102020a47901280001155957352300a06082a\"\n          + \"8648ce3d0403023017311530130603550403130c476e756262792050696c6f74\"\n          + \"301e170d3132303831343138323933325a170d3133303831343138323933325a\"\n          + \"3031312f302d0603550403132650696c6f74476e756262792d302e342e312d34\"\n          + \"373930313238303030313135353935373335323059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c\"\n          + \"1446682c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23\"\n          + \"abaf0203b4b8911ba0569994e101300a06082a8648ce3d040302034700304402\"\n          + \"2060cdb6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30d\"\n          + \"fa0220631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b3\"\n          + \"0410df304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80f\"\n          + \"cab017db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5\"\n          + \"ad7804a6d3d3961ef871\");\n  protected static final String REGISTRATION_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA);\n\n  // Has Bluetooth Radio transport\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc\"\n          + \"6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552d\"\n          + \"fdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab6\"\n          + \"1d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019a30820140\"\n          + \"a0030201020209012242000255962657300a06082a8648ce3d0403023045310b30090\"\n          + \"603550406130241553113301106035504080c0a536f6d652d53746174653121301f06\"\n          + \"0355040a0c18496e7465726e6574205769646769747320507479204c74643020170d3\"\n          + \"135303830353136353131325a180f32303633303630373136353131325a3045310b30\"\n          + \"090603550406130241553113301106035504080c0a536f6d652d53746174653121301\"\n          + \"f060355040a0c18496e7465726e6574205769646769747320507479204c7464305930\"\n          + \"1306072a8648ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b\"\n          + \"367eb0b8dcb4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932\"\n          + \"d3167e961eb664c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51\"\n          + \"c020101040403020780300a06082a8648ce3d040302034800304502202106e368bbe2\"\n          + \"fc9f86991826b90a51c694b90fb7c01945e7a9531e4b65315ac5022100aa8e75a071e\"\n          + \"645000376150c7faef1b8a57cb4bd41729c28d9b9bec744ebb4493045022070c1b332\"\n          + \"667853491a525850b15599cc88be0433fc673be89e991b550921c2110221008326311\"\n          + \"e0feaf1698110bed2c0737f3614298a8f265121f896db3cad459607fb\");\n  protected static final String REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6\"\n          + \"b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfd\"\n          + \"b7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1\"\n          + \"6591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019930820140a003\"\n          + \"0201020209012242000255962657300a06082a8648ce3d0403023045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643020170d31353038\"\n          + \"30353136343932345a180f32303633303630373136343932345a3045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643059301306072a86\"\n          + \"48ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb\"\n          + \"4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb6\"\n          + \"64c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51c020101040403\"\n          + \"0204d0300a06082a8648ce3d0403020347003044022058b52f205dc9772e1bef915973\"\n          + \"6098290ffb5850769efd1c37cfc97141279e5f02200c4d91c96c457d1a607a0d16b0b5\"\n          + \"47bbb2e5e2865490112e4b94607b3adcad18304402202548b5204488995f00c905d2b9\"\n          + \"25ca2f9b8c0aba76faf3461dc6778864eb5ee3022005f2d852969864577e01c71cbb10\"\n          + \"93412ef0fef518141d698cda2a45fe2bc767\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS);\n\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6b\"\n          + \"952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfdb7\"\n          + \"477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1659\"\n          + \"1659cbaf00b4950f7abfe6660e2e006f76868b772d70c25308201983082013ea0030201\"\n          + \"020209012242000255962657300a06082a8648ce3d0403023045310b300906035504061\"\n          + \"30241553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18\"\n          + \"496e7465726e6574205769646769747320507479204c74643020170d313530383036323\"\n          + \"3333532385a180f32303633303630383233333532385a3045310b300906035504061302\"\n          + \"41553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18496\"\n          + \"e7465726e6574205769646769747320507479204c74643059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb4a61d1fa336\"\n          + \"bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb664c3080347e5\"\n          + \"05626c1d5d15cfa31530133011060b2b0601040182e51c0201010402aa80300a06082a8\"\n          + \"648ce3d0403020348003045022100907f965f33d857982b39d9f4c22ccb4a63359fc10a\"\n          + \"af08a81997c0e04b73dc9b02204f45d556ae2ea71a5fdfa646b516584dada84954a5d8b\"\n          + \"9d27bdb041e89b216b6304402206b5085168e0c0e850677d3423c0f3972860bd3fbf6d2\"\n          + \"d98cd7af9e1d3f46269402201bde430c86260666bcaa23155296bd0627a8e48d98c2009\"\n          + \"212bec8a7a77f7974\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS);\n\n  protected static final byte[] KEY_HANDLE =\n      parseHex(\"2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a\"\n          + \"6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c25\");\n  protected static final String KEY_HANDLE_BASE64 = Base64.encodeBase64URLSafeString(KEY_HANDLE);\n  protected static final byte[] USER_PUBLIC_KEY_ENROLL_HEX =\n      parseHex(\"04b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b65\"\n          + \"7c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6\"\n          + \"d9\");\n  protected static final String USER_PRIVATE_KEY_ENROLL_HEX =\n      \"9a9684b127c5e3a706d618c86401c7cf6fd827fd0bc18d24b0eb842e36d16df1\";\n  protected static final PublicKey USER_PUBLIC_KEY_ENROLL =\n      parsePublicKey(USER_PUBLIC_KEY_ENROLL_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_ENROLL =\n      parsePrivateKey(USER_PRIVATE_KEY_ENROLL_HEX);\n  protected static final KeyPair USER_KEY_PAIR_ENROLL =\n      new KeyPair(USER_PUBLIC_KEY_ENROLL, USER_PRIVATE_KEY_ENROLL);\n  protected static final String USER_PRIVATE_KEY_SIGN_HEX =\n      \"ffa1e110dde5a2f8d93c4df71e2d4337b7bf5ddb60c75dc2b6b81433b54dd3c0\";\n  protected static final byte[] USER_PUBLIC_KEY_SIGN_HEX =\n      parseHex(\"04d368f1b665bade3c33a20f1e429c7750d5033660c019119d29aa4ba7abc04a\"\n          + \"a7c80a46bbe11ca8cb5674d74f31f8a903f6bad105fb6ab74aefef4db8b0025e\"\n          + \"1d\");\n  protected static final PublicKey USER_PUBLIC_KEY_SIGN = parsePublicKey(USER_PUBLIC_KEY_SIGN_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_SIGN =\n      parsePrivateKey(USER_PRIVATE_KEY_SIGN_HEX);\n  protected static final KeyPair USER_KEY_PAIR_SIGN =\n      new KeyPair(USER_PUBLIC_KEY_SIGN, USER_PRIVATE_KEY_SIGN);\n  protected static final byte[] SIGN_REQUEST_DATA =\n      parseHex(\"03ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc\"\n          + \"574b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992\"\n          + \"ca402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3\"\n          + \"925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d7\"\n          + \"0c25\");\n  protected static final byte[] SIGN_RESPONSE_DATA =\n      parseHex(\"0100000001304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030c\"\n          + \"e43d406de870b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f\"\n          + \"53c7b22272ec10047a923f\");\n  protected static final String SIGN_RESPONSE_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(SIGN_RESPONSE_DATA);\n  protected static final byte[] EXPECTED_REGISTER_SIGNED_BYTES =\n      parseHex(\"00f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1\"\n          + \"c44142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfa\"\n          + \"cb2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e392\"\n          + \"5a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c\"\n          + \"2504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9\");\n  protected static final byte[] EXPECTED_AUTHENTICATE_SIGNED_BYTES =\n      parseHex(\"4b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992ca\"\n          + \"0100000001ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c482\"\n          + \"1b3b9dbc57\");\n  protected static final byte[] SIGNATURE_ENROLL =\n      parseHex(\"304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80fcab017\"\n          + \"db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5ad7804\"\n          + \"a6d3d3961ef871\");\n  protected static final byte[] SIGNATURE_AUTHENTICATE =\n      parseHex(\"304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030ce43d406de8\"\n          + \"70b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f53c7b22272\"\n          + \"ec10047a923f\");\n\n  // Test vectors provided by Discretix\n  protected static final String APP_ID_2 = APP_ID_ENROLL;\n  protected static final String CHALLENGE_2_BASE64 = SERVER_CHALLENGE_ENROLL_BASE64;\n  protected static final String BROWSER_DATA_2_BASE64 = BROWSER_DATA_ENROLL_BASE64;\n\n  protected static final String TRUSTED_CERTIFICATE_2_HEX =\n      \"308201443081eaa0030201020209019189ffffffff5183300a06082a8648ce3d\"\n      + \"040302301b3119301706035504031310476e756262792048534d204341203030\"\n      + \"3022180f32303132303630313030303030305a180f3230363230353331323335\"\n      + \"3935395a30303119301706035504031310476f6f676c6520476e756262792076\"\n      + \"3031133011060355042d030a00019189ffffffff51833059301306072a8648ce\"\n      + \"3d020106082a8648ce3d030107034200041f1302f12173a9cbea83d06d755411\"\n      + \"e582a87fbb5850eddcf3607ec759a4a12c3cb392235e8d5b17caee1b34e5b5eb\"\n      + \"548649696257f0ea8efb90846f88ad5f72300a06082a8648ce3d040302034900\"\n      + \"3046022100b4caea5dc60fbf9f004ed84fc4f18522981c1c303155c08274e889\"\n      + \"f3f10c5b23022100faafb4f10b92f4754e3b08b5af353f78485bc903ece7ea91\"\n      + \"1264fc1673b6598f\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_2 =\n      parseCertificate(TRUSTED_CERTIFICATE_2_HEX);\n\n  // Has Bluetooth Radio transport\n  private static final String TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64 =\n      \"MIIBmjCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY1MTEyWhgPMjA2MzA2MDcxNjUxMTJaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIHgDAKBggqhkjO\"\n      + \"PQQDAgNIADBFAiAhBuNou+L8n4aZGCa5ClHGlLkPt8AZReepUx5LZTFaxQIhAKqO\"\n      + \"daBx5kUAA3YVDH+u8bilfLS9QXKcKNm5vsdE67RJ\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_ONE_TRANSPORT =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  private static final String TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64 =\n      \"MIIBmTCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY0OTI0WhgPMjA2MzA2MDcxNjQ5MjRaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIE0DAKBggqhkjO\"\n      + \"PQQDAgNHADBEAiBYtS8gXcl3LhvvkVlzYJgpD/tYUHae/Rw3z8lxQSeeXwIgDE2R\"\n      + \"yWxFfRpgeg0WsLVHu7Ll4oZUkBEuS5RgezrcrRg=\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64);\n\n  private static final String TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64 =\n      \"MIIBmDCCAT6gAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA2MjMzNTI4WhgPMjA2MzA2MDgyMzM1MjhaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxUwEzARBgsrBgEEAYLlHAIBAQQCqoAwCgYIKoZIzj0E\"\n      + \"AwIDSAAwRQIhAJB/ll8z2FeYKznZ9MIsy0pjNZ/BCq8IqBmXwOBLc9ybAiBPRdVW\"\n      + \"ri6nGl/fpka1FlhNrahJVKXYudJ72wQeibIWtg==\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64);\n\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64 =\n      \"MIIBlzCCAQCgAwIBAgICJxAwDQYJKoZIhvcNAQELBQAwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXlt\"\n      + \"YXN0ZXIwHhcNNzAwMTAxMDAwMDAwWhcNNzAwMTAxMDI0NjQwWjAaMRgwFgYDVQQDDA9BIEtleW1h\"\n      + \"c3RlciBLZXkwOjANBgkqhkiG9w0BAQEFAAMpADAmAiEAvKVptjTyP1p0L8rF/XANRuIc/TOmDiBc\"\n      + \"yb0lMri0YpkCAQOjUDBOMEwGCisGAQQB1nkCAREEPjA8MDihBgIBAgIBA4IBAYMCAQClAwIBAKYD\"\n      + \"AgEBn4FIAQOfg3gBAZ+DeQIBLJ+FPQYBUqVEtxCfhT4BADAAMA0GCSqGSIb3DQEBCwUAA4GBAHwH\"\n      + \"DZvsYbkgWAPv7QRa+cxLrFxrmv7M3HxYL7UdbpXP5/5sOp3hkhBdtAwlUW9tgGLdjheFFcz0lUSP\"\n      + \"uK5et199s1ifeNzV4fePlBAGvzKFci6adJgGDMXDodM49jhIEF1KC4xlbwBWR/brl4vZa4h1EZ9H\"\n      + \"ghyoJ3PFFZC8xYOB\";\n  protected static final X509Certificate ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION =\n      parseCertificateBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64);\n\n  /**\n   * Contains a chain where:\n   *   cert[0] = attestation certificate describing some new key\n   *   cert[1] = batch certificate\n   *\n   * Note that cert[1] is signed by another cert that should be known to RPs.\n   */\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64 =\n      \"MIIBjTCCATKgAwIBAgICJxAwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXltYXN0\"\n      + \"ZXIwIBcNNzAwMTAxMDAwMDAwWhgPMjEwNjAyMDcwNjI4MTVaMBoxGDAWBgNVBAMMD0EgS2V5bWFz\"\n      + \"dGVyIEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJiTI/rSw9N1NYV3FGxgeJSj1NWyyb61\"\n      + \"/gbdEefKuM3dYOeUZhciSigDY/u9Y3gBKm0wmXsd7DxXibDk/VvGIVWjZDBiMGAGCisGAQQB1nkC\"\n      + \"AREEUjBQAgECBAljaGFsbGVuZ2UwPqEIMQYCAQICAQOiAwIBA6MEAgIBAKUFMQMCAQS/g3gDAgEB\"\n      + \"v4N5BAICASy/hT0IAgYBUqi8MmC/hT4DAgEAMAAwCgYIKoZIzj0EAwIDSQAwRgIhANnmsSeWsnVH\"\n      + \"aF5zII50tkiA7fRhIMNeZZBcPvSV2BN5AiEAwUZm63OxMZEHTIFL50ASKVN/sCLs8+gMY6uEVZRy\"\n      + \"61QwggK2MIICH6ADAgECAgIQADANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQGEwJVUzETMBEGA1UE\"\n      + \"CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UECgwMR29vZ2xlLCBJ\"\n      + \"bmMuMRAwDgYDVQQLDAdBbmRyb2lkMB4XDTE2MDEwNDEyNDA1M1oXDTM1MTIzMDEyNDA1M1owdjEL\"\n      + \"MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFTATBgNVBAoMDEdvb2dsZSwgSW5jLjEQ\"\n      + \"MA4GA1UECwwHQW5kcm9pZDEpMCcGA1UEAwwgQW5kcm9pZCBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBL\"\n      + \"ZXkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMCDI9xWiBu4MCBp9bCFYcbuvn8F4vWoQgSK\"\n      + \"votHvnb+rvJc8psq+jIAFBYBQpmJoV/PxoFes2NYPC/S8gvkmDKD3YFLFtfhhUF65Uq8KWo6bbXA\"\n      + \"BAg7aMVWwfAjOZFkGYZNULdNQK7KSEx3NWyJWgwnWr+sSZ1dfSNi8pxeAuhxAgMBAAGjZjBkMB0G\"\n      + \"A1UdDgQWBBTUDBAb+M1jufc5UrUOE1ym15mThjAfBgNVHSMEGDAWgBQp+vGszE3STJZAJ3W2sOky\"\n      + \"5Qf+LjASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIChDANBgkqhkiG9w0BAQsFAAOB\"\n      + \"gQCeLUhfjGcz3BqFrZnXUCPqFOxDsOGd6sIjRh5ytRncYCLkpWgxbAtVxOacoi2fOk+TazGLFngW\"\n      + \"DYjL2YvMgJ2E8MIn42s48f3R5xdyMVk1fZbzxX+rnY+WYSZPsr6Buw1JBCKKzp/39UIuJUT6IQcS\"\n      + \"WoO1Va0YgvhAFJucIGMEfw==\";\n  protected static final X509Certificate[] ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN =\n      parseCertificateChainBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64);\n\n  protected static final byte[] REGISTRATION_DATA_2 =\n      parseHex(\"0504478E16BBDBBB741A660A000314A8B6BD63095196ED704C52EEBC0FA02A61\"\n          + \"8F19FF59DF18451A11CEE43DEFD9A29B5710F63DFC671F752B1B0C6CA76C8427\"\n          + \"AF2D403C2415E1760D1108105720C6069A9039C99D09F76909C36D9EFC350937\"\n          + \"31F85F55AC6D73EA69DE7D9005AE9507B95E149E19676272FC202D949A3AB151\"\n          + \"B96870308201443081EAA0030201020209019189FFFFFFFF5183300A06082A86\"\n          + \"48CE3D040302301B3119301706035504031310476E756262792048534D204341\"\n          + \"2030303022180F32303132303630313030303030305A180F3230363230353331\"\n          + \"3233353935395A30303119301706035504031310476F6F676C6520476E756262\"\n          + \"7920763031133011060355042D030A00019189FFFFFFFF51833059301306072A\"\n          + \"8648CE3D020106082A8648CE3D030107034200041F1302F12173A9CBEA83D06D\"\n          + \"755411E582A87FBB5850EDDCF3607EC759A4A12C3CB392235E8D5B17CAEE1B34\"\n          + \"E5B5EB548649696257F0EA8EFB90846F88AD5F72300A06082A8648CE3D040302\"\n          + \"0349003046022100B4CAEA5DC60FBF9F004ED84FC4F18522981C1C303155C082\"\n          + \"74E889F3F10C5B23022100FAAFB4F10B92F4754E3B08B5AF353F78485BC903EC\"\n          + \"E7EA911264FC1673B6598F3046022100F3BE1BF12CBF0BE7EAB5EA32F3664EDB\"\n          + \"18A24D4999AAC5AA40FF39CF6F34C9ED022100CE72631767367467DFE2AECF6A\"\n          + \"5A4EBA9779FAC65F5CA8A2C325B174EE4769AC\");\n  protected static final String REGISTRATION_DATA_2_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_DATA_2);\n  protected static final byte[] KEY_HANDLE_2 =\n      parseHex(\"3c2415e1760d1108105720c6069a9039c99d09f76909c36d9efc35093731f85f\"\n          + \"55ac6d73ea69de7d9005ae9507b95e149e19676272fc202d949a3ab151b96870\");\n  protected static final String KEY_HANDLE_2_BASE64 =\n      Base64.encodeBase64URLSafeString(KEY_HANDLE_2);\n  protected static final byte[] USER_PUBLIC_KEY_2 =\n      parseHex(\"04478e16bbdbbb741a660a000314a8b6bd63095196ed704c52eebc0fa02a618f\"\n          + \"19ff59df18451a11cee43defd9a29b5710f63dfc671f752b1b0c6ca76c8427af\"\n          + \"2d\");\n  protected static final byte[] SIGN_DATA_2 =\n      parseHex(\"01000000223045022100FB16D12F8EC73D93EAB43BFDF141BF94E31AD3B1C98E\"\n          + \"E4459E9E80CBBBD892F70220796DBCB8BBF57EC95A20A76D9ED3365CB688BF88\"\n          + \"2ECCEABCC8D4A674024F6ABA\");\n  protected static final String SIGN_DATA_2_BASE64 = Base64.encodeBase64URLSafeString(SIGN_DATA_2);\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegisteredKey.java\npublic class RegisteredKey {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /**\n   * websafe-base64 encoding of the key handle obtained from the U2F token\n   * during registration.\n   */\n  private final String keyHandle;\n\n  /**\n   * The transports registered for this key handle.\n   */\n  private final List<Transports> transports;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegisteredKey(String version, String keyHandle, List<Transports> transports,\n      String appId, String sessionId) {\n    super();\n    this.version = version;\n    this.keyHandle = keyHandle;\n    this.transports = transports;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(version, keyHandle, transports, appId, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegisteredKey other = (RegisteredKey) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(keyHandle, other.keyHandle)\n        && SecurityKeyData.containSameTransports(transports, other.transports)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n\n  public JsonObject getJson(String defaultAppId) {\n    JsonObject result = new JsonObject();\n    if (appId != null && !appId.equals(defaultAppId)) {\n      result.addProperty(\"appId\", appId);\n    }\n    result.addProperty(\"version\", version);\n    result.addProperty(\"keyHandle\", keyHandle);\n    result.addProperty(\"sessionId\", sessionId);\n    String transportsString = getTransportsAsString();\n    if (transportsString != null) {\n      result.addProperty(\"transports\", transportsString);\n    }\n    return result;\n  }\n\n  private String getTransportsAsString() {\n    if (this.transports == null) {\n      return null;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < transports.size(); i++) {\n      stringBuilder.append(transports.get(i));\n      if (i < transports.size() - 1) {\n        stringBuilder.append(\",\");\n      }\n    }\n    return stringBuilder.toString();\n  }\n}\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport java.security.cert.X509Certificate;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Matchers;\nimport org.mockito.Mock;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.u2f.TestVectors;\nimport com.google.u2f.U2FException;\nimport com.google.u2f.server.ChallengeGenerator;\nimport com.google.u2f.server.Crypto;\nimport com.google.u2f.server.DataStore;\nimport com.google.u2f.server.SessionIdGenerator;\nimport com.google.u2f.server.U2FServer;\nimport com.google.u2f.server.data.EnrollSessionData;\nimport com.google.u2f.server.data.SecurityKeyData;\nimport com.google.u2f.server.data.SecurityKeyData.Transports;\nimport com.google.u2f.server.data.SignSessionData;\nimport com.google.u2f.server.messages.RegisteredKey;\nimport com.google.u2f.server.messages.RegistrationRequest;\nimport com.google.u2f.server.messages.RegistrationResponse;\nimport com.google.u2f.server.messages.SignResponse;\nimport com.google.u2f.server.messages.U2fSignRequest;\n\n  @Test\n  public void testGetRegistrationRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationRequest registrationRequest = u2fServer.getRegistrationRequest(ACCOUNT_NAME, APP_ID_ENROLL);\n\n    assertEquals(new RegistrationRequest(\"U2F_V2\", SERVER_CHALLENGE_ENROLL_BASE64, APP_ID_ENROLL,\n        SESSION_ID), registrationRequest);\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_noTransports() throws U2FException {\n\t  when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX, VENDOR_CERTIFICATE, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_oneTransport() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_ONE_TRANSPORT);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_ONE_TRANSPORT, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_multipleTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    transports.add(Transports.BLUETOOTH_LOW_ENERGY);\n    transports.add(Transports.NFC);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_malformedTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse2() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(VENDOR_CERTIFICATE);\n    trustedCertificates.add(TRUSTED_CERTIFICATE_2);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_2_BASE64,\n        BROWSER_DATA_2_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE_2, USER_PUBLIC_KEY_2,\n            TRUSTED_CERTIFICATE_2, 0)));\n  }\n\n  @Test\n  public void testGetSignRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n    when(mockChallengeGenerator.generateChallenge(ACCOUNT_NAME)).thenReturn(SERVER_CHALLENGE_SIGN);\nNext line of code:\n", "input": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.MockitoAnnotations.initMocks;\nimport java.security.cert.X509Certificate;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Matchers;\nimport org.mockito.Mock;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.u2f.TestVectors;\nimport com.google.u2f.U2FException;\nimport com.google.u2f.server.ChallengeGenerator;\nimport com.google.u2f.server.Crypto;\nimport com.google.u2f.server.DataStore;\nimport com.google.u2f.server.SessionIdGenerator;\nimport com.google.u2f.server.U2FServer;\nimport com.google.u2f.server.data.EnrollSessionData;\nimport com.google.u2f.server.data.SecurityKeyData;\nimport com.google.u2f.server.data.SecurityKeyData.Transports;\nimport com.google.u2f.server.data.SignSessionData;\nimport com.google.u2f.server.messages.RegisteredKey;\nimport com.google.u2f.server.messages.RegistrationRequest;\nimport com.google.u2f.server.messages.RegistrationResponse;\nimport com.google.u2f.server.messages.SignResponse;\nimport com.google.u2f.server.messages.U2fSignRequest;\n\n  @Test\n  public void testGetRegistrationRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationRequest registrationRequest = u2fServer.getRegistrationRequest(ACCOUNT_NAME, APP_ID_ENROLL);\n\n    assertEquals(new RegistrationRequest(\"U2F_V2\", SERVER_CHALLENGE_ENROLL_BASE64, APP_ID_ENROLL,\n        SESSION_ID), registrationRequest);\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_noTransports() throws U2FException {\n\t  when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX, VENDOR_CERTIFICATE, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_oneTransport() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_ONE_TRANSPORT);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_ONE_TRANSPORT, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_multipleTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    List<Transports> transports = new LinkedList<Transports>();\n    transports.add(Transports.BLUETOOTH_BREDR);\n    transports.add(Transports.BLUETOOTH_LOW_ENERGY);\n    transports.add(Transports.NFC);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, transports, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse_malformedTransports() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(\n        REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64,\n        BROWSER_DATA_ENROLL_BASE64, SESSION_ID);\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE, USER_PUBLIC_KEY_ENROLL_HEX,\n            TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION, 0)));\n  }\n\n  @Test\n  public void testProcessRegistrationResponse2() throws U2FException {\n    when(mockDataStore.getEnrollSessionData(SESSION_ID)).thenReturn(\n        new EnrollSessionData(ACCOUNT_NAME, APP_ID_ENROLL, SERVER_CHALLENGE_ENROLL));\n    HashSet<X509Certificate> trustedCertificates = new HashSet<X509Certificate>();\n    trustedCertificates.add(VENDOR_CERTIFICATE);\n    trustedCertificates.add(TRUSTED_CERTIFICATE_2);\n    when(mockDataStore.getTrustedCertificates()).thenReturn(trustedCertificates);\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n\n    RegistrationResponse registrationResponse = new RegistrationResponse(REGISTRATION_DATA_2_BASE64,\n        BROWSER_DATA_2_BASE64, SESSION_ID);\n\n    u2fServer.processRegistrationResponse(registrationResponse, 0L);\n    verify(mockDataStore).addSecurityKeyData(eq(ACCOUNT_NAME),\n        eq(new SecurityKeyData(0L, null /* transports */, KEY_HANDLE_2, USER_PUBLIC_KEY_2,\n            TRUSTED_CERTIFICATE_2, 0)));\n  }\n\n  @Test\n  public void testGetSignRequest() throws U2FException {\n    u2fServer = new U2FServerReferenceImpl(mockChallengeGenerator,\n        mockDataStore, cryto, TRUSTED_DOMAINS);\n    when(mockChallengeGenerator.generateChallenge(ACCOUNT_NAME)).thenReturn(SERVER_CHALLENGE_SIGN);\n", "context": "u2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationRequest.java\npublic class RegistrationRequest {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegistrationRequest(String version, String challenge, String appId, String sessionId) {\n    this.version = version;\n    this.challenge = challenge;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(challenge, version, sessionId, appId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationRequest other = (RegistrationRequest) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(challenge, other.challenge)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic enum Transports {\n  BLUETOOTH_BREDR(\"bt\"),\n  BLUETOOTH_LOW_ENERGY(\"ble\"),\n  USB(\"usb\"),\n  NFC(\"nfc\");\n\n  private String mValue;\n\n  Transports(String value) {\n    mValue = value;\n  }\n\n  @Override\n  public String toString() {\n    return mValue;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegistrationResponse.java\npublic class RegistrationResponse {\n  /** websafe-base64(raw registration response message) */\n  private final String registrationData;\n\n  /** websafe-base64(UTF8(stringified(client data))) */\n  private final String clientData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n  public RegistrationResponse(String registrationData, String clientData, String sessionId) {\n    this.registrationData = registrationData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getRegistrationData() {\n    return registrationData;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(registrationData, clientData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegistrationResponse other = (RegistrationResponse) obj;\n    if (clientData == null) {\n      if (other.clientData != null)\n        return false;\n    } else if (!clientData.equals(other.clientData))\n      return false;\n    if (registrationData == null) {\n      if (other.registrationData != null)\n        return false;\n    } else if (!registrationData.equals(other.registrationData))\n      return false;\n    if (sessionId == null) {\n      if (other.sessionId != null)\n        return false;\n    } else if (!sessionId.equals(other.sessionId))\n      return false;\n    return true;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SignSessionData.java\npublic class SignSessionData extends EnrollSessionData {\n  private static final long serialVersionUID = -1374014642398686120L;\n\n  private final byte[] publicKey;\n\n  public SignSessionData(String accountName, String appId, byte[] challenge, byte[] publicKey) {\n    super(accountName, appId, challenge);\n    this.publicKey = publicKey;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/SignResponse.java\npublic class SignResponse {\n\n  /** websafe-base64 key handle from U2F device */\n  private final String keyHandle;\n\n  /** websafe-base64(client data) */\n  private final String clientData;\n\n  /** websafe-base64(raw response from U2F device) */\n  private final String signatureData;\n\n  /** session id originally passed */\n  private final String sessionId;\n\n\n  public SignResponse(String keyHandle, String signatureData, String clientData, String sessionId) {\n    this.keyHandle = keyHandle;\n    this.signatureData = signatureData;\n    this.clientData = clientData;\n    this.sessionId = sessionId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getClientData() {\n    return clientData;\n  }\n\n  public String getSignatureData() {\n    return signatureData;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(keyHandle, clientData, signatureData, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (getClass() != obj.getClass())\n      return false;\n    SignResponse other = (SignResponse) obj;\n    return Objects.equals(keyHandle, other.keyHandle)\n        && Objects.equals(clientData, other.clientData)\n        && Objects.equals(signatureData, other.signatureData)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/SecurityKeyData.java\npublic class SecurityKeyData {\n  public enum Transports {\n    BLUETOOTH_BREDR(\"bt\"),\n    BLUETOOTH_LOW_ENERGY(\"ble\"),\n    USB(\"usb\"),\n    NFC(\"nfc\");\n\n    private String mValue;\n\n    Transports(String value) {\n      mValue = value;\n    }\n\n    @Override\n    public String toString() {\n      return mValue;\n    }\n  }\n\n  private final long enrollmentTime;\n  private final List<Transports> transports;\n  private final byte[] keyHandle;\n  private final byte[] publicKey;\n  private final X509Certificate attestationCert;\n  private int counter;\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this(enrollmentTime, null /* transports */, keyHandle, publicKey, attestationCert, counter);\n  }\n\n  public SecurityKeyData(\n      long enrollmentTime,\n      List<Transports> transports,\n      byte[] keyHandle,\n      byte[] publicKey,\n      X509Certificate attestationCert,\n      int counter) {\n    this.enrollmentTime = enrollmentTime;\n    this.transports = transports;\n    this.keyHandle = keyHandle;\n    this.publicKey = publicKey;\n    this.attestationCert = attestationCert;\n    this.counter = counter;\n  }\n\n  /**\n   * When these keys were created/enrolled with the relying party.\n   */\n  public long getEnrollmentTime() {\n    return enrollmentTime;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public byte[] getKeyHandle() {\n    return keyHandle;\n  }\n\n  public byte[] getPublicKey() {\n    return publicKey;\n  }\n\n  public X509Certificate getAttestationCertificate() {\n    return attestationCert;\n  }\n\n  public int getCounter() {\n    return counter;\n  }\n\n  public void setCounter(int newCounterValue) {\n    counter = newCounterValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        enrollmentTime,\n        transports,\n        keyHandle,\n        publicKey,\n        attestationCert,\n        counter);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof SecurityKeyData)) {\n      return false;\n    }\n    SecurityKeyData that = (SecurityKeyData) obj;\n    return Arrays.equals(this.keyHandle, that.keyHandle)\n        && (this.enrollmentTime == that.enrollmentTime)\n        && containSameTransports(this.transports, that.transports)\n        && Arrays.equals(this.publicKey, that.publicKey)\n        && Objects.equals(this.attestationCert, that.attestationCert)\n        && Objects.equals(counter, counter);\n  }\n\n  /**\n   * Compares the two Lists of Transports and says if they are equal.\n   *\n   * @param transports1 first List of Transports\n   * @param transports2 second List of Transports\n   * @return true if both lists are null or if both lists contain the same transport values\n   */\n  public static boolean containSameTransports(List<Transports> transports1,\n      List<Transports> transports2) {\n    if (transports1 == null && transports2 == null) {\n      return true;\n    } else if (transports1 == null || transports2 == null) {\n      return false;\n    }\n    return transports1.containsAll(transports2) && transports2.containsAll(transports1);\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder()\n      .append(\"public_key: \")\n      .append(Base64.encodeBase64URLSafeString(publicKey))\n      .append(\"\\n\")\n      .append(\"key_handle: \")\n      .append(Base64.encodeBase64URLSafeString(keyHandle))\n      .append(\"\\n\")\n      .append(\"counter: \")\n      .append(counter)\n      .append(\"\\n\")\n      .append(\"attestation certificate:\\n\")\n      .append(attestationCert.toString())\n      .append(\"transports: \")\n      .append(transports)\n      .append(\"\\n\")\n      .toString();\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/U2fSignRequest.java\npublic class U2fSignRequest {\n  /** The websafe-base64-encoded challenge. */\n  private final String challenge;\n  /** List of registered keys */\n  private List<RegisteredKey> registeredKeys;\n\n  public U2fSignRequest(String challenge, List<RegisteredKey> registeredKeys) {\n    this.challenge = challenge;\n    this.registeredKeys = registeredKeys;\n  }\n\n  public String getChallenge() {\n    return challenge;\n  }\n\n  public List<RegisteredKey> getRegisteredKeys() {\n    return registeredKeys;\n  }\n\n  public JsonArray getRegisteredKeysAsJson(String defaultAppId) {\n    if (registeredKeys == null) {\n      return null;\n    }\n    JsonArray result = new JsonArray();\n    for (RegisteredKey registeredKey : registeredKeys) {\n      result.add(registeredKey.getJson(defaultAppId));\n    }\n    return result;\n  }\n}\nu2f-ref-code/java/src/com/google/u2f/server/U2FServer.java\npublic interface U2FServer {\n\n  // registration //\n  public RegistrationRequest getRegistrationRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processRegistrationResponse(RegistrationResponse registrationResponse,\n      long currentTimeInMillis) throws U2FException;\n\n  // authentication //\n  public U2fSignRequest getSignRequest(String accountName, String appId) throws U2FException;\n\n  public SecurityKeyData processSignResponse(SignResponse signResponse) throws U2FException;\n\n  // token management //\n  public List<SecurityKeyData> getAllSecurityKeys(String accountName);\n\n  public void removeSecurityKey(String accountName, byte[] publicKey) throws U2FException;\n}\nu2f-ref-code/java/src/com/google/u2f/server/data/EnrollSessionData.java\npublic class EnrollSessionData implements Serializable {\n  private static final long serialVersionUID = 1750990095756334568L;\n\n  private final String accountName;\n  private final byte[] challenge;\n  private final String appId;\n\n  public EnrollSessionData(String accountName, String appId, byte[] challenge) {\n    this.accountName = accountName;\n    this.challenge = challenge;\n    this.appId = appId;\n  }\n\n  public String getAccountName() {\n    return accountName;\n  }\n\n  public byte[] getChallenge() {\n    return challenge;\n  }\n\n  public String getAppId() {\n\treturn appId;\n  }\n}\nu2f-ref-code/java/tests/com/google/u2f/TestVectors.java\npublic class TestVectors {\n  // Test vectors from FIDO U2F: Raw Message Formats - Draft 4\n  protected static final int COUNTER_VALUE = 1;\n  protected static final String ACCOUNT_NAME = \"test@example.com\";\n  protected static final Set<String> TRUSTED_DOMAINS = ImmutableSet.of(\"http://example.com\");\n  protected static final String SESSION_ID = \"session_id\";\n  protected static final String APP_ID_ENROLL = \"http://example.com\";\n  protected static final byte[] APP_ID_ENROLL_SHA256 = computeSha256(APP_ID_ENROLL);\n  protected static final String APP_ID_SIGN = \"https://gstatic.com/securitykey/a/example.com\";\n  protected static final byte[] APP_ID_SIGN_SHA256 = computeSha256(APP_ID_SIGN);\n  protected static final String ORIGIN = \"http://example.com\";\n  protected static final String SERVER_CHALLENGE_ENROLL_BASE64 =\n      \"vqrS6WXDe1JUs5_c3i4-LkKIHRr-3XVb3azuA5TifHo\";\n  protected static final byte[] SERVER_CHALLENGE_ENROLL =\n      Base64.decodeBase64(SERVER_CHALLENGE_ENROLL_BASE64);\n  protected static final String SERVER_CHALLENGE_SIGN_BASE64 =\n      \"opsXqUifDriAAmWclinfbS0e-USY0CgyJHe_Otd7z8o\";\n  protected static final byte[] SERVER_CHALLENGE_SIGN =\n      Base64.decodeBase64(SERVER_CHALLENGE_SIGN_BASE64);\n  protected static final String VENDOR_CERTIFICATE_HEX =\n      \"3082013c3081e4a003020102020a47901280001155957352300a06082a8648ce\"\n      + \"3d0403023017311530130603550403130c476e756262792050696c6f74301e17\"\n      + \"0d3132303831343138323933325a170d3133303831343138323933325a303131\"\n      + \"2f302d0603550403132650696c6f74476e756262792d302e342e312d34373930\"\n      + \"313238303030313135353935373335323059301306072a8648ce3d020106082a\"\n      + \"8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c144668\"\n      + \"2c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23abaf02\"\n      + \"03b4b8911ba0569994e101300a06082a8648ce3d0403020347003044022060cd\"\n      + \"b6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30dfa0220\"\n      + \"631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b30410df\";\n  protected static final X509Certificate VENDOR_CERTIFICATE =\n      parseCertificate(VENDOR_CERTIFICATE_HEX);\n  protected static final PrivateKey VENDOR_CERTIFICATE_PRIVATE_KEY =\n      parsePrivateKey(\"f3fccc0d00d8031954f90864d43c247f4bf5f0665c6b50cc17749a27d1cf7664\");\n  protected static final String CHANNEL_ID_STRING =\n      \"{\"\n      + \"\\\"kty\\\":\\\"EC\\\",\"\n      + \"\\\"crv\\\":\\\"P-256\\\",\"\n      + \"\\\"x\\\":\\\"HzQwlfXX7Q4S5MtCCnZUNBw3RMzPO9tOyWjBqRl4tJ8\\\",\"\n      + \"\\\"y\\\":\\\"XVguGFLIZx1fXg3wNqfdbn75hi4-_7-BxhMljw42Ht4\\\"\"\n      + \"}\";\n  protected static final JsonObject CHANNEL_ID_JSON =\n      (JsonObject) new JsonParser().parse(CHANNEL_ID_STRING);\n  protected static final String BROWSER_DATA_ENROLL = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.finishEnrollment\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_ENROLL_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_ENROLL_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_ENROLL.getBytes());\n  protected static final byte[] BROWSER_DATA_ENROLL_SHA256 =\n      computeSha256(BROWSER_DATA_ENROLL.getBytes());\n  protected static final String BROWSER_DATA_SIGN = String.format(\n      \"{\"\n      + \"\\\"typ\\\":\\\"navigator.id.getAssertion\\\",\"\n      + \"\\\"challenge\\\":\\\"%s\\\",\"\n      + \"\\\"cid_pubkey\\\":%s,\"\n      + \"\\\"origin\\\":\\\"%s\\\"}\",\n      SERVER_CHALLENGE_SIGN_BASE64, CHANNEL_ID_STRING, ORIGIN);\n  protected static final String BROWSER_DATA_SIGN_BASE64 =\n      Base64.encodeBase64URLSafeString(BROWSER_DATA_SIGN.getBytes());\n  protected static final byte[] BROWSER_DATA_SIGN_SHA256 =\n      parseHex(\"ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc57\");\n  protected static final byte[] REGISTRATION_REQUEST_DATA =\n      parseHex(\"4142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfacb\"\n          + \"f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1c4\");\n  protected static final byte[] REGISTRATION_RESPONSE_DATA =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2\"\n          + \"e3925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772\"\n          + \"d70c253082013c3081e4a003020102020a47901280001155957352300a06082a\"\n          + \"8648ce3d0403023017311530130603550403130c476e756262792050696c6f74\"\n          + \"301e170d3132303831343138323933325a170d3133303831343138323933325a\"\n          + \"3031312f302d0603550403132650696c6f74476e756262792d302e342e312d34\"\n          + \"373930313238303030313135353935373335323059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200048d617e65c9508e64bcc5673ac82a6799da3c\"\n          + \"1446682c258c463fffdf58dfd2fa3e6c378b53d795c4a4dffb4199edd7862f23\"\n          + \"abaf0203b4b8911ba0569994e101300a06082a8648ce3d040302034700304402\"\n          + \"2060cdb6061e9c22262d1aac1d96d8c70829b2366531dda268832cb836bcd30d\"\n          + \"fa0220631b1459f09e6330055722c8d89b7f48883b9089b88d60d1d9795902b3\"\n          + \"0410df304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80f\"\n          + \"cab017db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5\"\n          + \"ad7804a6d3d3961ef871\");\n  protected static final String REGISTRATION_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA);\n\n  // Has Bluetooth Radio transport\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc\"\n          + \"6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552d\"\n          + \"fdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab6\"\n          + \"1d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019a30820140\"\n          + \"a0030201020209012242000255962657300a06082a8648ce3d0403023045310b30090\"\n          + \"603550406130241553113301106035504080c0a536f6d652d53746174653121301f06\"\n          + \"0355040a0c18496e7465726e6574205769646769747320507479204c74643020170d3\"\n          + \"135303830353136353131325a180f32303633303630373136353131325a3045310b30\"\n          + \"090603550406130241553113301106035504080c0a536f6d652d53746174653121301\"\n          + \"f060355040a0c18496e7465726e6574205769646769747320507479204c7464305930\"\n          + \"1306072a8648ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b\"\n          + \"367eb0b8dcb4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932\"\n          + \"d3167e961eb664c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51\"\n          + \"c020101040403020780300a06082a8648ce3d040302034800304502202106e368bbe2\"\n          + \"fc9f86991826b90a51c694b90fb7c01945e7a9531e4b65315ac5022100aa8e75a071e\"\n          + \"645000376150c7faef1b8a57cb4bd41729c28d9b9bec744ebb4493045022070c1b332\"\n          + \"667853491a525850b15599cc88be0433fc673be89e991b550921c2110221008326311\"\n          + \"e0feaf1698110bed2c0737f3614298a8f265121f896db3cad459607fb\");\n  protected static final String REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_ONE_TRANSPORT);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6\"\n          + \"b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfd\"\n          + \"b7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1\"\n          + \"6591659cbaf00b4950f7abfe6660e2e006f76868b772d70c253082019930820140a003\"\n          + \"0201020209012242000255962657300a06082a8648ce3d0403023045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643020170d31353038\"\n          + \"30353136343932345a180f32303633303630373136343932345a3045310b3009060355\"\n          + \"0406130241553113301106035504080c0a536f6d652d53746174653121301f06035504\"\n          + \"0a0c18496e7465726e6574205769646769747320507479204c74643059301306072a86\"\n          + \"48ce3d020106082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb\"\n          + \"4a61d1fa336bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb6\"\n          + \"64c3080347e505626c1d5d15cfa31730153013060b2b0601040182e51c020101040403\"\n          + \"0204d0300a06082a8648ce3d0403020347003044022058b52f205dc9772e1bef915973\"\n          + \"6098290ffb5850769efd1c37cfc97141279e5f02200c4d91c96c457d1a607a0d16b0b5\"\n          + \"47bbb2e5e2865490112e4b94607b3adcad18304402202548b5204488995f00c905d2b9\"\n          + \"25ca2f9b8c0aba76faf3461dc6778864eb5ee3022005f2d852969864577e01c71cbb10\"\n          + \"93412ef0fef518141d698cda2a45fe2bc767\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MULTIPLE_TRANSPORTS);\n\n  protected static final byte[] REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS =\n      parseHex(\"0504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b657c1cc6b\"\n          + \"952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6d9402a552dfdb7\"\n          + \"477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a6019551bab61d1659\"\n          + \"1659cbaf00b4950f7abfe6660e2e006f76868b772d70c25308201983082013ea0030201\"\n          + \"020209012242000255962657300a06082a8648ce3d0403023045310b300906035504061\"\n          + \"30241553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18\"\n          + \"496e7465726e6574205769646769747320507479204c74643020170d313530383036323\"\n          + \"3333532385a180f32303633303630383233333532385a3045310b300906035504061302\"\n          + \"41553113301106035504080c0a536f6d652d53746174653121301f060355040a0c18496\"\n          + \"e7465726e6574205769646769747320507479204c74643059301306072a8648ce3d0201\"\n          + \"06082a8648ce3d030107034200042e09745f6e0f412a7a84b367eb0b8dcb4a61d1fa336\"\n          + \"bbecfe30bd0a2c8faf74734a82fc03412589f4cc107f932d3167e961eb664c3080347e5\"\n          + \"05626c1d5d15cfa31530133011060b2b0601040182e51c0201010402aa80300a06082a8\"\n          + \"648ce3d0403020348003045022100907f965f33d857982b39d9f4c22ccb4a63359fc10a\"\n          + \"af08a81997c0e04b73dc9b02204f45d556ae2ea71a5fdfa646b516584dada84954a5d8b\"\n          + \"9d27bdb041e89b216b6304402206b5085168e0c0e850677d3423c0f3972860bd3fbf6d2\"\n          + \"d98cd7af9e1d3f46269402201bde430c86260666bcaa23155296bd0627a8e48d98c2009\"\n          + \"212bec8a7a77f7974\");\n  protected static final String REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_RESPONSE_DATA_MALFORMED_TRANSPORTS);\n\n  protected static final byte[] KEY_HANDLE =\n      parseHex(\"2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3925a\"\n          + \"6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c25\");\n  protected static final String KEY_HANDLE_BASE64 = Base64.encodeBase64URLSafeString(KEY_HANDLE);\n  protected static final byte[] USER_PUBLIC_KEY_ENROLL_HEX =\n      parseHex(\"04b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b65\"\n          + \"7c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2f6\"\n          + \"d9\");\n  protected static final String USER_PRIVATE_KEY_ENROLL_HEX =\n      \"9a9684b127c5e3a706d618c86401c7cf6fd827fd0bc18d24b0eb842e36d16df1\";\n  protected static final PublicKey USER_PUBLIC_KEY_ENROLL =\n      parsePublicKey(USER_PUBLIC_KEY_ENROLL_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_ENROLL =\n      parsePrivateKey(USER_PRIVATE_KEY_ENROLL_HEX);\n  protected static final KeyPair USER_KEY_PAIR_ENROLL =\n      new KeyPair(USER_PUBLIC_KEY_ENROLL, USER_PRIVATE_KEY_ENROLL);\n  protected static final String USER_PRIVATE_KEY_SIGN_HEX =\n      \"ffa1e110dde5a2f8d93c4df71e2d4337b7bf5ddb60c75dc2b6b81433b54dd3c0\";\n  protected static final byte[] USER_PUBLIC_KEY_SIGN_HEX =\n      parseHex(\"04d368f1b665bade3c33a20f1e429c7750d5033660c019119d29aa4ba7abc04a\"\n          + \"a7c80a46bbe11ca8cb5674d74f31f8a903f6bad105fb6ab74aefef4db8b0025e\"\n          + \"1d\");\n  protected static final PublicKey USER_PUBLIC_KEY_SIGN = parsePublicKey(USER_PUBLIC_KEY_SIGN_HEX);\n  protected static final PrivateKey USER_PRIVATE_KEY_SIGN =\n      parsePrivateKey(USER_PRIVATE_KEY_SIGN_HEX);\n  protected static final KeyPair USER_KEY_PAIR_SIGN =\n      new KeyPair(USER_PUBLIC_KEY_SIGN, USER_PRIVATE_KEY_SIGN);\n  protected static final byte[] SIGN_REQUEST_DATA =\n      parseHex(\"03ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c4821b3b9dbc\"\n          + \"574b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992\"\n          + \"ca402a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e3\"\n          + \"925a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d7\"\n          + \"0c25\");\n  protected static final byte[] SIGN_RESPONSE_DATA =\n      parseHex(\"0100000001304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030c\"\n          + \"e43d406de870b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f\"\n          + \"53c7b22272ec10047a923f\");\n  protected static final String SIGN_RESPONSE_DATA_BASE64 =\n      Base64.encodeBase64URLSafeString(SIGN_RESPONSE_DATA);\n  protected static final byte[] EXPECTED_REGISTER_SIGNED_BYTES =\n      parseHex(\"00f0e6a6a97042a4f1f1c87f5f7d44315b2d852c2df5c7991cc66241bf7072d1\"\n          + \"c44142d21c00d94ffb9d504ada8f99b721f4b191ae4e37ca0140f696b6983cfa\"\n          + \"cb2a552dfdb7477ed65fd84133f86196010b2215b57da75d315b7b9e8fe2e392\"\n          + \"5a6019551bab61d16591659cbaf00b4950f7abfe6660e2e006f76868b772d70c\"\n          + \"2504b174bc49c7ca254b70d2e5c207cee9cf174820ebd77ea3c65508c26da51b\"\n          + \"657c1cc6b952f8621697936482da0a6d3d3826a59095daf6cd7c03e2e60385d2\"\n          + \"f6d9\");\n  protected static final byte[] EXPECTED_AUTHENTICATE_SIGNED_BYTES =\n      parseHex(\"4b0be934baebb5d12d26011b69227fa5e86df94e7d94aa2949a89f2d493992ca\"\n          + \"0100000001ccd6ee2e47baef244d49a222db496bad0ef5b6f93aa7cc4d30c482\"\n          + \"1b3b9dbc57\");\n  protected static final byte[] SIGNATURE_ENROLL =\n      parseHex(\"304502201471899bcc3987e62e8202c9b39c33c19033f7340352dba80fcab017\"\n          + \"db9230e402210082677d673d891933ade6f617e5dbde2e247e70423fd5ad7804\"\n          + \"a6d3d3961ef871\");\n  protected static final byte[] SIGNATURE_AUTHENTICATE =\n      parseHex(\"304402204b5f0cd17534cedd8c34ee09570ef542a353df4436030ce43d406de8\"\n          + \"70b847780220267bb998fac9b7266eb60e7cb0b5eabdfd5ba9614f53c7b22272\"\n          + \"ec10047a923f\");\n\n  // Test vectors provided by Discretix\n  protected static final String APP_ID_2 = APP_ID_ENROLL;\n  protected static final String CHALLENGE_2_BASE64 = SERVER_CHALLENGE_ENROLL_BASE64;\n  protected static final String BROWSER_DATA_2_BASE64 = BROWSER_DATA_ENROLL_BASE64;\n\n  protected static final String TRUSTED_CERTIFICATE_2_HEX =\n      \"308201443081eaa0030201020209019189ffffffff5183300a06082a8648ce3d\"\n      + \"040302301b3119301706035504031310476e756262792048534d204341203030\"\n      + \"3022180f32303132303630313030303030305a180f3230363230353331323335\"\n      + \"3935395a30303119301706035504031310476f6f676c6520476e756262792076\"\n      + \"3031133011060355042d030a00019189ffffffff51833059301306072a8648ce\"\n      + \"3d020106082a8648ce3d030107034200041f1302f12173a9cbea83d06d755411\"\n      + \"e582a87fbb5850eddcf3607ec759a4a12c3cb392235e8d5b17caee1b34e5b5eb\"\n      + \"548649696257f0ea8efb90846f88ad5f72300a06082a8648ce3d040302034900\"\n      + \"3046022100b4caea5dc60fbf9f004ed84fc4f18522981c1c303155c08274e889\"\n      + \"f3f10c5b23022100faafb4f10b92f4754e3b08b5af353f78485bc903ece7ea91\"\n      + \"1264fc1673b6598f\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_2 =\n      parseCertificate(TRUSTED_CERTIFICATE_2_HEX);\n\n  // Has Bluetooth Radio transport\n  private static final String TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64 =\n      \"MIIBmjCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY1MTEyWhgPMjA2MzA2MDcxNjUxMTJaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIHgDAKBggqhkjO\"\n      + \"PQQDAgNIADBFAiAhBuNou+L8n4aZGCa5ClHGlLkPt8AZReepUx5LZTFaxQIhAKqO\"\n      + \"daBx5kUAA3YVDH+u8bilfLS9QXKcKNm5vsdE67RJ\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_ONE_TRANSPORT =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_ONE_TRANSPORT_BASE64);\n\n  // Has Bluetooth Radio, Bluetooth Low Energy, and NFC transports\n  private static final String TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64 =\n      \"MIIBmTCCAUCgAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA1MTY0OTI0WhgPMjA2MzA2MDcxNjQ5MjRaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxcwFTATBgsrBgEEAYLlHAIBAQQEAwIE0DAKBggqhkjO\"\n      + \"PQQDAgNHADBEAiBYtS8gXcl3LhvvkVlzYJgpD/tYUHae/Rw3z8lxQSeeXwIgDE2R\"\n      + \"yWxFfRpgeg0WsLVHu7Ll4oZUkBEuS5RgezrcrRg=\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MULTIPLE_TRANSPORTS_BASE64);\n\n  private static final String TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64 =\n      \"MIIBmDCCAT6gAwIBAgIJASJCAAJVliZXMAoGCCqGSM49BAMCMEUxCzAJBgNVBAYT\"\n      + \"AkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRn\"\n      + \"aXRzIFB0eSBMdGQwIBcNMTUwODA2MjMzNTI4WhgPMjA2MzA2MDgyMzM1MjhaMEUx\"\n      + \"CzAJBgNVBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRl\"\n      + \"cm5ldCBXaWRnaXRzIFB0eSBMdGQwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQu\"\n      + \"CXRfbg9BKnqEs2frC43LSmHR+jNrvs/jC9CiyPr3RzSoL8A0ElifTMEH+TLTFn6W\"\n      + \"HrZkwwgDR+UFYmwdXRXPoxUwEzARBgsrBgEEAYLlHAIBAQQCqoAwCgYIKoZIzj0E\"\n      + \"AwIDSAAwRQIhAJB/ll8z2FeYKznZ9MIsy0pjNZ/BCq8IqBmXwOBLc9ybAiBPRdVW\"\n      + \"ri6nGl/fpka1FlhNrahJVKXYudJ72wQeibIWtg==\";\n  protected static final X509Certificate TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION =\n      parseCertificateBase64(TRUSTED_CERTIFICATE_MALFORMED_TRANSPORTS_EXTENSION_BASE64);\n\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64 =\n      \"MIIBlzCCAQCgAwIBAgICJxAwDQYJKoZIhvcNAQELBQAwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXlt\"\n      + \"YXN0ZXIwHhcNNzAwMTAxMDAwMDAwWhcNNzAwMTAxMDI0NjQwWjAaMRgwFgYDVQQDDA9BIEtleW1h\"\n      + \"c3RlciBLZXkwOjANBgkqhkiG9w0BAQEFAAMpADAmAiEAvKVptjTyP1p0L8rF/XANRuIc/TOmDiBc\"\n      + \"yb0lMri0YpkCAQOjUDBOMEwGCisGAQQB1nkCAREEPjA8MDihBgIBAgIBA4IBAYMCAQClAwIBAKYD\"\n      + \"AgEBn4FIAQOfg3gBAZ+DeQIBLJ+FPQYBUqVEtxCfhT4BADAAMA0GCSqGSIb3DQEBCwUAA4GBAHwH\"\n      + \"DZvsYbkgWAPv7QRa+cxLrFxrmv7M3HxYL7UdbpXP5/5sOp3hkhBdtAwlUW9tgGLdjheFFcz0lUSP\"\n      + \"uK5et199s1ifeNzV4fePlBAGvzKFci6adJgGDMXDodM49jhIEF1KC4xlbwBWR/brl4vZa4h1EZ9H\"\n      + \"ghyoJ3PFFZC8xYOB\";\n  protected static final X509Certificate ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION =\n      parseCertificateBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_NO_VERSION_BASE64);\n\n  /**\n   * Contains a chain where:\n   *   cert[0] = attestation certificate describing some new key\n   *   cert[1] = batch certificate\n   *\n   * Note that cert[1] is signed by another cert that should be known to RPs.\n   */\n  private static final String ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64 =\n      \"MIIBjTCCATKgAwIBAgICJxAwCgYIKoZIzj0EAwIwHDEaMBgGA1UEAwwRQW5kcm9pZCBLZXltYXN0\"\n      + \"ZXIwIBcNNzAwMTAxMDAwMDAwWhgPMjEwNjAyMDcwNjI4MTVaMBoxGDAWBgNVBAMMD0EgS2V5bWFz\"\n      + \"dGVyIEtleTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJiTI/rSw9N1NYV3FGxgeJSj1NWyyb61\"\n      + \"/gbdEefKuM3dYOeUZhciSigDY/u9Y3gBKm0wmXsd7DxXibDk/VvGIVWjZDBiMGAGCisGAQQB1nkC\"\n      + \"AREEUjBQAgECBAljaGFsbGVuZ2UwPqEIMQYCAQICAQOiAwIBA6MEAgIBAKUFMQMCAQS/g3gDAgEB\"\n      + \"v4N5BAICASy/hT0IAgYBUqi8MmC/hT4DAgEAMAAwCgYIKoZIzj0EAwIDSQAwRgIhANnmsSeWsnVH\"\n      + \"aF5zII50tkiA7fRhIMNeZZBcPvSV2BN5AiEAwUZm63OxMZEHTIFL50ASKVN/sCLs8+gMY6uEVZRy\"\n      + \"61QwggK2MIICH6ADAgECAgIQADANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQGEwJVUzETMBEGA1UE\"\n      + \"CAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UECgwMR29vZ2xlLCBJ\"\n      + \"bmMuMRAwDgYDVQQLDAdBbmRyb2lkMB4XDTE2MDEwNDEyNDA1M1oXDTM1MTIzMDEyNDA1M1owdjEL\"\n      + \"MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFTATBgNVBAoMDEdvb2dsZSwgSW5jLjEQ\"\n      + \"MA4GA1UECwwHQW5kcm9pZDEpMCcGA1UEAwwgQW5kcm9pZCBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBL\"\n      + \"ZXkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMCDI9xWiBu4MCBp9bCFYcbuvn8F4vWoQgSK\"\n      + \"votHvnb+rvJc8psq+jIAFBYBQpmJoV/PxoFes2NYPC/S8gvkmDKD3YFLFtfhhUF65Uq8KWo6bbXA\"\n      + \"BAg7aMVWwfAjOZFkGYZNULdNQK7KSEx3NWyJWgwnWr+sSZ1dfSNi8pxeAuhxAgMBAAGjZjBkMB0G\"\n      + \"A1UdDgQWBBTUDBAb+M1jufc5UrUOE1ym15mThjAfBgNVHSMEGDAWgBQp+vGszE3STJZAJ3W2sOky\"\n      + \"5Qf+LjASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIChDANBgkqhkiG9w0BAQsFAAOB\"\n      + \"gQCeLUhfjGcz3BqFrZnXUCPqFOxDsOGd6sIjRh5ytRncYCLkpWgxbAtVxOacoi2fOk+TazGLFngW\"\n      + \"DYjL2YvMgJ2E8MIn42s48f3R5xdyMVk1fZbzxX+rnY+WYSZPsr6Buw1JBCKKzp/39UIuJUT6IQcS\"\n      + \"WoO1Va0YgvhAFJucIGMEfw==\";\n  protected static final X509Certificate[] ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN =\n      parseCertificateChainBase64(ANDROID_KEYSTORE_ATTESTATION_CERT_CHAIN_BASE64);\n\n  protected static final byte[] REGISTRATION_DATA_2 =\n      parseHex(\"0504478E16BBDBBB741A660A000314A8B6BD63095196ED704C52EEBC0FA02A61\"\n          + \"8F19FF59DF18451A11CEE43DEFD9A29B5710F63DFC671F752B1B0C6CA76C8427\"\n          + \"AF2D403C2415E1760D1108105720C6069A9039C99D09F76909C36D9EFC350937\"\n          + \"31F85F55AC6D73EA69DE7D9005AE9507B95E149E19676272FC202D949A3AB151\"\n          + \"B96870308201443081EAA0030201020209019189FFFFFFFF5183300A06082A86\"\n          + \"48CE3D040302301B3119301706035504031310476E756262792048534D204341\"\n          + \"2030303022180F32303132303630313030303030305A180F3230363230353331\"\n          + \"3233353935395A30303119301706035504031310476F6F676C6520476E756262\"\n          + \"7920763031133011060355042D030A00019189FFFFFFFF51833059301306072A\"\n          + \"8648CE3D020106082A8648CE3D030107034200041F1302F12173A9CBEA83D06D\"\n          + \"755411E582A87FBB5850EDDCF3607EC759A4A12C3CB392235E8D5B17CAEE1B34\"\n          + \"E5B5EB548649696257F0EA8EFB90846F88AD5F72300A06082A8648CE3D040302\"\n          + \"0349003046022100B4CAEA5DC60FBF9F004ED84FC4F18522981C1C303155C082\"\n          + \"74E889F3F10C5B23022100FAAFB4F10B92F4754E3B08B5AF353F78485BC903EC\"\n          + \"E7EA911264FC1673B6598F3046022100F3BE1BF12CBF0BE7EAB5EA32F3664EDB\"\n          + \"18A24D4999AAC5AA40FF39CF6F34C9ED022100CE72631767367467DFE2AECF6A\"\n          + \"5A4EBA9779FAC65F5CA8A2C325B174EE4769AC\");\n  protected static final String REGISTRATION_DATA_2_BASE64 =\n      Base64.encodeBase64URLSafeString(REGISTRATION_DATA_2);\n  protected static final byte[] KEY_HANDLE_2 =\n      parseHex(\"3c2415e1760d1108105720c6069a9039c99d09f76909c36d9efc35093731f85f\"\n          + \"55ac6d73ea69de7d9005ae9507b95e149e19676272fc202d949a3ab151b96870\");\n  protected static final String KEY_HANDLE_2_BASE64 =\n      Base64.encodeBase64URLSafeString(KEY_HANDLE_2);\n  protected static final byte[] USER_PUBLIC_KEY_2 =\n      parseHex(\"04478e16bbdbbb741a660a000314a8b6bd63095196ed704c52eebc0fa02a618f\"\n          + \"19ff59df18451a11cee43defd9a29b5710f63dfc671f752b1b0c6ca76c8427af\"\n          + \"2d\");\n  protected static final byte[] SIGN_DATA_2 =\n      parseHex(\"01000000223045022100FB16D12F8EC73D93EAB43BFDF141BF94E31AD3B1C98E\"\n          + \"E4459E9E80CBBBD892F70220796DBCB8BBF57EC95A20A76D9ED3365CB688BF88\"\n          + \"2ECCEABCC8D4A674024F6ABA\");\n  protected static final String SIGN_DATA_2_BASE64 = Base64.encodeBase64URLSafeString(SIGN_DATA_2);\n}\nu2f-ref-code/java/src/com/google/u2f/server/messages/RegisteredKey.java\npublic class RegisteredKey {\n  /**\n   * Version of the protocol that the to-be-registered U2F token must speak. For\n   * the version of the protocol described herein, must be \"U2F_V2\"\n   */\n  private final String version;\n\n  /**\n   * websafe-base64 encoding of the key handle obtained from the U2F token\n   * during registration.\n   */\n  private final String keyHandle;\n\n  /**\n   * The transports registered for this key handle.\n   */\n  private final List<Transports> transports;\n\n  /**\n   * The application id that the RP would like to assert. The U2F token will\n   * enforce that the key handle provided above is associated with this\n   * application id. The browser enforces that the calling origin belongs to the\n   * application identified by the application id.\n   */\n  private final String appId;\n\n  /**\n   * A session id created by the RP. The RP can opaquely store things like\n   * expiration times for the sign-in session, protocol version used, public key\n   * expected to sign the identity assertion, etc. The response from the API\n   * will include the sessionId. This allows the RP to fire off multiple signing\n   * requests, and associate the responses with the correct request\n   */\n  private final String sessionId;\n\n  public RegisteredKey(String version, String keyHandle, List<Transports> transports,\n      String appId, String sessionId) {\n    super();\n    this.version = version;\n    this.keyHandle = keyHandle;\n    this.transports = transports;\n    this.appId = appId;\n    this.sessionId = sessionId;\n  }\n\n  public String getVersion() {\n    return version;\n  }\n\n  public List<Transports> getTransports() {\n    return transports;\n  }\n\n  public String getAppId() {\n    return appId;\n  }\n\n  public String getKeyHandle() {\n    return keyHandle;\n  }\n\n  public String getSessionId() {\n    return sessionId;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(version, keyHandle, transports, appId, sessionId);\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    RegisteredKey other = (RegisteredKey) obj;\n    return Objects.equals(version, other.version)\n        && Objects.equals(keyHandle, other.keyHandle)\n        && SecurityKeyData.containSameTransports(transports, other.transports)\n        && Objects.equals(appId, other.appId)\n        && Objects.equals(sessionId, other.sessionId);\n  }\n\n  public JsonObject getJson(String defaultAppId) {\n    JsonObject result = new JsonObject();\n    if (appId != null && !appId.equals(defaultAppId)) {\n      result.addProperty(\"appId\", appId);\n    }\n    result.addProperty(\"version\", version);\n    result.addProperty(\"keyHandle\", keyHandle);\n    result.addProperty(\"sessionId\", sessionId);\n    String transportsString = getTransportsAsString();\n    if (transportsString != null) {\n      result.addProperty(\"transports\", transportsString);\n    }\n    return result;\n  }\n\n  private String getTransportsAsString() {\n    if (this.transports == null) {\n      return null;\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = 0; i < transports.size(); i++) {\n      stringBuilder.append(transports.get(i));\n      if (i < transports.size() - 1) {\n        stringBuilder.append(\",\");\n      }\n    }\n    return stringBuilder.toString();\n  }\n}\n", "answers": ["    U2fSignRequest signRequest = u2fServer.getSignRequest(ACCOUNT_NAME, APP_ID_SIGN);"], "pred": "  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of", "length": 2959, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "d60990d706853cd274c7ff6b8b766fcccca25dc8de5ae49c"}
{"prompt": "Please complete the code given below. \nsippy/Rtp_proxy_session.py\nclass Rtp_proxy_session(object):\n    rtp_proxy_client = None\n    call_id = None\n    from_tag = None\n    to_tag = None\n    caller_session_exists = False\n    caller_codecs = None\n    caller_raddress = None\n    callee_session_exists = False\n    callee_codecs = None\n    callee_raddress = None\n    max_index = -1\n    origin = None\n    notify_socket = None\n    notify_tag = None\n    global_config = None\n\n    def __init__(self, global_config, call_id = None, from_tag = None, to_tag = None,\n      notify_socket = None, notify_tag = None):\n        self.global_config = global_config\n        if global_config.has_key('_rtp_proxy_clients'):\n            rtp_proxy_clients = [x for x in global_config['_rtp_proxy_clients'] if x.online]\n            n = len(rtp_proxy_clients)\n            if n == 0:\n                raise Exception('No online RTP proxy client has been found')\n            self.rtp_proxy_client = rtp_proxy_clients[int(random() * n)]\n        else:\n            self.rtp_proxy_client = global_config['rtp_proxy_client']\n            if not self.rtp_proxy_client.online:\n                raise Exception('No online RTP proxy client has been found')\n        if call_id != None:\n            self.call_id = call_id\n        else:\n            self.call_id = md5(str(random()) + str(time())).hexdigest()\n        if from_tag != None:\n            self.from_tag = from_tag\n        else:\n            self.from_tag = md5(str(random()) + str(time())).hexdigest()\n        if to_tag != None:\n            self.to_tag = to_tag\n        else:\n            self.to_tag = md5(str(random()) + str(time())).hexdigest()\n        self.origin = SdpOrigin()\n        self.notify_socket = notify_socket\n        self.notify_tag = notify_tag\n\n    def version(self, result_callback):\n        self.rtp_proxy_client.send_command('V', self.version_result, result_callback)\n\n    def version_result(self, result, result_callback):\n        result_callback(result)\n\n    def play_caller(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._play_caller, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_caller(None, prompt_name, times, result_callback, index)\n\n    def _play_caller(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.caller_codecs, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def play_callee(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            return\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._play_callee, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_callee(None, prompt_name, times, result_callback, index)\n\n    def _play_callee(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.callee_codecs, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_caller(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_callee(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_caller(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._copy_caller, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_caller(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_caller(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_callee(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._copy_callee, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_callee(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_callee(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def start_recording(self, rname = None, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._start_recording, '', index, rname, result_callback, index)\n            return\n        self._start_recording(None, rname, result_callback, index)\n\n    def _start_recording(self, result, rname, result_callback, index):\n        if rname == None:\n            command = 'R %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n            return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n        command = 'C %s %s.a %s %s' % ('%s-%d' % (self.call_id, index), rname, self.from_tag, self.to_tag)\n        return self.rtp_proxy_client.send_command(command, self._start_recording1, \\\n          (rname, result_callback, index))\n\n    def _start_recording1(self, result, args):\n        rname, result_callback, index = args\n        command = 'C %s %s.o %s %s' % ('%s-%d' % (self.call_id, index), rname, self.to_tag, self.from_tag)\n        return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def command_result(self, result, result_callback):\n        if result_callback != None:\n            result_callback(result)\n\n    def update_caller(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.caller_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.caller_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.caller_raddress[0]\n        command += options\n        command += ' %s %s %d %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag)\n        if self.caller_session_exists:\n            command += ' %s' % self.to_tag\n        if self.notify_socket != None and index == 0 and \\\n          self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'caller', callback_parameters))\n\n    def update_callee(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.callee_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.callee_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.callee_raddress[0]\n        command += options\n        command += ' %s %s %d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        if self.notify_socket != None and index == 0 \\\n          and self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'callee', callback_parameters))\n\n    def update_result(self, result, args):\n        result_callback, face, callback_parameters = args\n        if face == 'caller':\n            self.caller_session_exists = True\n        else:\n            self.callee_session_exists = True\n        if result == None:\n            result_callback(None, *callback_parameters)\n            return\n        t1 = result.split()\n        rtpproxy_port = int(t1[0])\n        if rtpproxy_port == 0:\n            result_callback(None, *callback_parameters)\n        family = 'IP4'\n        if len(t1) > 1:\n            rtpproxy_address = t1[1]\n            if len(t1) > 2 and t1[2] == '6':\n                family = 'IP6'\n        else:\n            rtpproxy_address = self.rtp_proxy_client.proxy_address\n        result_callback((rtpproxy_address, rtpproxy_port, family), *callback_parameters)\n\n    def delete(self):\n        while self.max_index >= 0:\n            command = 'D %s %s %s' % ('%s-%d' % (self.call_id, self.max_index), self.from_tag, self.to_tag)\n            self.rtp_proxy_client.send_command(command)\n            self.max_index -= 1\n\n    def on_caller_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_caller, sdp_body, result_callback)\n\n    def on_callee_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_callee, sdp_body, result_callback)\n\n    def on_xxx_sdp_change(self, update_xxx, sdp_body, result_callback):\n        sects = []\n        try:\n            sdp_body.parse()\n        except Exception, exception:\n            print datetime.now(), 'can\\'t parse SDP body: %s:' % str(exception)\n            print '-' * 70\n            print_exc(file = sys.stdout)\n            print '-' * 70\n            print sdp_body.content\n            print '-' * 70\n            sys.stdout.flush()\n            return\n        for i in range(0, len(sdp_body.content.sections)):\n            sect = sdp_body.content.sections[i]\n            if sect.m_header.transport.lower() not in ('udp', 'udptl', 'rtp/avp'):\n                continue\n            sects.append(sect)\n        if len(sects) == 0:\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n            return\n        formats = sects[0].m_header.formats\n        if update_xxx == self.update_caller:\n            if len(formats) > 1:\n                self.caller_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.caller_codecs = str(formats[0])\n        else:\n            if len(formats) > 1:\n                self.callee_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.callee_codecs = str(formats[0])\n        for sect in sects:\n            options = ''\n            if sect.c_header.atype == 'IP6':\n                options = '6'\n            update_xxx(sect.c_header.addr, sect.m_header.port, self.xxx_sdp_change_finish, options, \\\n              sects.index(sect), sdp_body, sect, sects, result_callback)\n        return\n\n    def xxx_sdp_change_finish(self, address_port, sdp_body, sect, sects, result_callback):\n        sect.needs_update = False\n        if address_port != None:\n            sect.c_header.atype = address_port[2]\n            sect.c_header.addr = address_port[0]\n            if sect.m_header.port != 0:\n                sect.m_header.port = address_port[1]\n        if len([x for x in sects if x.needs_update]) == 0:\n            sdp_body.content.o_header = self.origin\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n\n    def __del__(self):\n        self.delete()\n        self.rtp_proxy_client = None\nsippy/Signal.py\nclass Signal(object):\n    callback = None\n    parameters = None\n    previous_handler = None\n\n    def __init__(self, signum, callback, *parameters):\n        self.callback = callback\n        self.parameters = parameters\n        self.previous_handler = signal(signum, self.signal_handler)\n\n    def signal_handler(self, signum, *frame):\n        try:\n            reactor.callFromThread(self.callback, *self.parameters)\n        except:\n            print datetime.now(), 'Signal: unhandled exception in signal callback'\n            print '-' * 70\n            print_exc(file = stdout)\n            print '-' * 70\n            stdout.flush()\n        if self.previous_handler not in (SIG_IGN, SIG_DFL):\n            try:\n                self.previous_handler(signum, *frame)\n            except:\n                print datetime.now(), 'Signal: unhandled exception in signal chain'\n                print '-' * 70\n                print_exc(file = stdout)\n                print '-' * 70\n                stdout.flush()\nsippy/SipCiscoGUID.py\nclass SipCiscoGUID(SipGenericHF):\n    hf_names = ('cisco-guid', 'h323-conf-id')\n    ciscoGUID = None\n\n    def __init__(self, body = None, ciscoGUID = None):\n        SipGenericHF.__init__(self, body)\n        if body != None:\n            return\n        self.parsed = True\n        if ciscoGUID != None:\n            self.ciscoGUID = ciscoGUID\n        else:\n            s = md5(str((random() * 1000000000L) + time())).hexdigest()\n            self.ciscoGUID = (long(s[0:8], 16), long(s[8:16], 16), long(s[16:24], 16), long(s[24:32], 16))\n\n    def parse(self):\n        self.parsed = True\n        self.ciscoGUID = tuple([int(x) for x in  self.body.split('-', 3)])\n\n    def __str__(self):\n        if not self.parsed:\n            return self.body\n        return '%d-%d-%d-%d' % self.ciscoGUID\n\n    def getCiscoGUID(self):\n        return self.ciscoGUID\n\n    def hexForm(self):\n        return '%.8X %.8X %.8X %.8X' % self.ciscoGUID\n\n    def getCanName(self, name, compact = False):\n        if name.lower() == 'h323-conf-id':\n            return 'h323-conf-id'\n        else:\n            return 'cisco-GUID'\n\n    def getCopy(self):\n        if not self.parsed:\n            return SipCiscoGUID(self.body)\n        return SipCiscoGUID(ciscoGUID = self.ciscoGUID)\nsippy/SipHeader.py\nclass SipHeader(object):\n    name = None\n    body = None\n\n    def __init__(self, s = None, name = None, body = None, bodys = None, fixname = False):\n        if s != None:\n            name, bodys = [x.strip() for x in s.split(':', 1)]\n        if name != None:\n            self.name = name.lower()\n        if body == None:\n            try:\n                try:\n                    body = hf_types[self.name](bodys)\n                except KeyError:\n                    body = SipGenericHF(bodys, name)\n            except ESipHeaderCSV, einst:\n                einst.name = self.name\n                raise einst\n        self.body = body\n        # If no name is provided use canonic name from the body-specific\n        # class.\n        if self.name == None or fixname:\n            self.name = body.hf_names[0]\n\n    def __str__(self):\n        return str(self.body.getCanName(self.name)) + ': ' + str(self.body)\n\n    def localStr(self, local_addr = None, local_port = None, compact = False):\n        return str(self.body.getCanName(self.name, compact)) + ': ' + \\\n          self.body.localStr(local_addr, local_port)\n\n    def getBody(self):\n        if not self.body.parsed:\n            self.body.parse()\n        return self.body\nsippy/SipFrom.py\nclass SipFrom(SipAddressHF):\n    hf_names = ('from', 'f')\n\n    def __init__(self, body = None, address = None):\n        SipAddressHF.__init__(self, body, address)\n        if body == None and address == None:\n            self.address = SipAddress(name = 'Anonymous', url = SipURL(host = SipConf.my_address, port = SipConf.my_port))\n\n    def getTag(self):\n        return self.address.getParam('tag')\n\n    def genTag(self):\n        self.address.setParam('tag', md5(str((random() * 1000000000L) + time())).hexdigest())\n\n    def setTag(self, value):\n        self.address.setParam('tag', value)\n\n    def delTag(self):\n        self.address.delParam('tag')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 'f'\n        return 'From'\nsippy/CCEvents.py\nclass CCEventDisconnect(CCEventGeneric):\n    name = 'CCEventDisconnect'\n    pass\nsippy/UA.py\nclass UA(object):\n    global_config = None\n    state = None\n    event_cb = None\n    uasReq = None\n    uacResp = None\n    username = None\n    password = None\n    equeue = None\n    dId = None\n    credit_time = None\n    credit_times = None\n    credit_timer = None\n    conn_cbs = None\n    disc_cbs = None\n    fail_cbs = None\n    ring_cbs = None\n    dead_cbs = None\n    rCSeq = None\n    lTag = None\n    lUri = None\n    rUri = None\n    cId = None\n    lCSeq = None\n    lContact = None\n    cGUID = None\n    rAddr = None\n    rAddr0 = None\n    routes = None\n    rTarget = None\n    uasResp = None\n    lSDP = None\n    rSDP = None\n    kaInterval = 0\n    branch = None\n    reqs = None\n    extra_headers = None\n    useRefer = True\n    expire_time = None\n    expire_timer = None\n    no_progress_time = None\n    no_progress_timer = None\n    no_reply_time = None\n    no_reply_timer = None\n    on_local_sdp_change = None\n    on_remote_sdp_change = None\n    last_scode = 100\n    setup_ts = None\n    p100_ts = None\n    p1xx_ts = None\n    connect_ts = None\n    disconnect_ts = None\n    user_agent = None\n    elast_seq = None\n    origin = None\n    source_address = None\n\n    def __init__(self, global_config, event_cb = None, username = None, password = None, nh_address = None, credit_time = None, \\\n      conn_cbs = None, disc_cbs = None, fail_cbs = None, ring_cbs = None, dead_cbs = None, ltag = None, extra_headers = None, \\\n      expire_time = None, no_progress_time = None):\n        self.global_config = global_config\n        self.event_cb = event_cb\n        self.equeue = []\n        self.username = username\n        self.password = password\n        self.rAddr = nh_address\n        self.rAddr0 = self.rAddr\n        self.credit_time = credit_time\n        self.credit_times = {}\n        if conn_cbs != None:\n            self.conn_cbs = conn_cbs\n        else:\n            self.conn_cbs = ()\n        if disc_cbs != None:\n            self.disc_cbs = disc_cbs\n        else:\n            self.disc_cbs = ()\n        if fail_cbs != None:\n            self.fail_cbs = fail_cbs\n        else:\n            self.fail_cbs = ()\n        if ring_cbs != None:\n            self.ring_cbs = ring_cbs\n        else:\n            self.ring_cbs = ()\n        if dead_cbs != None:\n            self.dead_cbs = dead_cbs\n        else:\n            self.dead_cbs = ()\n        if ltag != None:\n            self.lTag = ltag\n        else:\n            self.lTag = md5(str((random() * 1000000000L) + time())).hexdigest()\n        self.reqs = {}\n        self.extra_headers = extra_headers\n        self.expire_time = expire_time\n        self.no_progress_time = no_progress_time\n        #print self.username, self.password\n\n    def recvRequest(self, req):\n        #print 'Received request %s in state %s instance %s' % (req.getMethod(), self.state, self)\n        #print self.rCSeq, req.getHFBody('cseq').getCSeqNum()\n        if self.user_agent == None:\n            self.update_ua(req)\n        if self.rCSeq != None and self.rCSeq >= req.getHFBody('cseq').getCSeqNum():\n            return (req.genResponse(500, 'Server Internal Error'), None, None)\n        self.rCSeq = req.getHFBody('cseq').getCSeqNum()\n        if self.state == None:\n            if req.getMethod() == 'INVITE':\n                self.changeState((UasStateIdle,))\n            else:\n                return None\n        newstate = self.state.recvRequest(req)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n        if newstate != None and req.getMethod() == 'INVITE':\n            return (None, self.state.cancel, self.disconnect)\n        else:\n            return None\n\n    def recvResponse(self, resp):\n        if self.state == None:\n            return\n        self.update_ua(resp)\n        code, reason = resp.getSCode()\n        cseq, method = resp.getHFBody('cseq').getCSeq()\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 401 and resp.countHFs('www-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('authorization') == 0:\n            challenge = resp.getHFBody('www-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm())\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 407 and resp.countHFs('proxy-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('proxy-authorization') == 0:\n            challenge = resp.getHFBody('proxy-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm(), SipProxyAuthorization)\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if code >= 200 and self.reqs.has_key(cseq):\n            del self.reqs[cseq]\n        newstate = self.state.recvResponse(resp)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def recvEvent(self, event):\n        #print self, event\n        if self.state == None:\n            if isinstance(event, CCEventTry) or isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect):\n                self.changeState((UacStateIdle,))\n            else:\n                return\n        newstate = self.state.recvEvent(event)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def disconnect(self, rtime = None):\n        if rtime == None:\n            rtime = time()\n        self.equeue.append(CCEventDisconnect(rtime = rtime))\n        self.recvEvent(CCEventDisconnect(rtime = rtime))\n\n    def expires(self):\n        self.expire_timer = None\n        self.disconnect()\n\n    def no_progress_expires(self):\n        self.no_progress_timer = None\n        self.disconnect()\n\n    def no_reply_expires(self):\n        self.no_reply_timer = None\n        self.disconnect()\n\n    def credit_expires(self, rtime):\n        self.credit_timer = None\n        self.disconnect(rtime)\n\n    def changeState(self, newstate):\n        if self.state != None:\n            self.state.onStateChange(newstate[0])\n        self.state = newstate[0](self)\n        if len(newstate) > 1:\n            for callback in newstate[1]:\n                callback(self, *newstate[2:])\n\n    def emitEvent(self, event):\n        if self.event_cb != None:\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                return\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def emitPendingEvents(self):\n        while len(self.equeue) != 0 and self.event_cb != None:\n            event = self.equeue.pop(0)\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                continue\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def genRequest(self, method, body = None, nonce = None, realm = None, SipXXXAuthorization = SipAuthorization, \\\n      reason = None):\n        req = SipRequest(method = method, ruri = self.rTarget, to = self.rUri, fr0m = self.lUri,\n                         cseq = self.lCSeq, callid = self.cId, contact = self.lContact,\n                         routes = self.routes, target = self.rAddr, cguid = self.cGUID)\n        if nonce != None and realm != None and self.username != None and self.password != None:\n            auth = SipXXXAuthorization(realm = realm, nonce = nonce, method = method, uri = str(self.rTarget),\n              username = self.username, password = self.password)\n            req.appendHeader(SipHeader(body = auth))\n        if body != None:\n            req.setBody(body)\n        if self.extra_headers != None:\n            req.appendHeaders(self.extra_headers)\n        if reason != None:\n            req.appendHeader(SipHeader(body = reason))\n        self.reqs[self.lCSeq] = req\n        return req\n\n    def sendUasResponse(self, scode, reason, body = None, contact = None, \\\n      reason_rfc3326 = None, extra_header = None):\n        self.uasResp.setSCode(scode, reason)\n        self.uasResp.setBody(body)\n        self.uasResp.delHFs('www-authenticate')\n        self.uasResp.delHFs('contact')\n        self.uasResp.delHFs('reason')\n        if contact != None:\n            self.uasResp.appendHeader(SipHeader(name = 'contact', body = contact))\n        if reason_rfc3326 != None:\n            self.uasResp.appendHeader(SipHeader(body = reason_rfc3326))\n        if extra_header != None:\n            self.uasResp.appendHeader(extra_header)\n        self.global_config['_sip_tm'].sendResponse(self.uasResp)\n\n    def isYours(self, req = None, call_id = None, from_tag = None, to_tag = None):\n        #print self.branch, req.getHFBody('via').getBranch()\n        if req != None:\n            if req.getMethod() != 'BYE' and self.branch != None and \\\n              self.branch != req.getHFBody('via').getBranch():\n                return None\n            call_id = str(req.getHFBody('call-id'))\n            from_tag = req.getHFBody('from').getTag()\n            to_tag = req.getHFBody('to').getTag()\n        #print str(self.cId), call_id\n        if call_id != str(self.cId):\n            return None\n        #print self.rUri.getTag(), from_tag\n        if self.rUri != None and self.rUri.getTag() != from_tag:\n            return None\n        #print self.lUri.getTag(), to_tag\n        if self.lUri != None and self.lUri.getTag() != to_tag:\n            return None\n        return self\n\n    def isDead(self):\n        if self.state != None:\n            return self.state.dead\n        return False\n\n    def isConnected(self):\n        if self.state != None:\n            return self.state.connected\n        return False\n\n    def getCLD(self):\n        if self.rUri == None:\n            return None\n        return self.rUri.getUrl().username\n\n    def getCLI(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUrl().username\n\n    def getCallingName(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUri().name\n\n    def getRAddr0(self):\n        return self.rAddr0\n\n    def getCID(self):\n        # Return tuple containing call-id, local tag and remote tag\n        rval = [str(self.cId), None, None]\n        if self.lUri != None:\n            rval[1] = self.lUri.getTag()\n        if self.rUri != None:\n            rval[2] = self.rUri.getTag()\n        return tuple(rval)\n\n    def delayed_remote_sdp_update(self, event, remote_sdp_body):\n        self.rSDP = remote_sdp_body.getCopy()\n        self.equeue.append(event)\n        self.emitPendingEvents()\n\n    def getAcct(self):\n        if self.disconnect_ts != None:\n            disconnect_ts = self.disconnect_ts\n            disconnected = True\n        else:\n            disconnect_ts = time()\n            disconnected = False\n        if self.connect_ts != None:\n            return (disconnect_ts - self.connect_ts, self.connect_ts - self.setup_ts, True, disconnected)\n        return (0, disconnect_ts - self.setup_ts, False, disconnected)\n\n    def update_ua(self, msg):\n        if msg.countHFs('user-agent') > 0:\n            self.user_agent = msg.getHFBody('user-agent').name\n        elif msg.countHFs('server') > 0:\n            self.user_agent = msg.getHFBody('server').name\n        return\n\n    def cancelCreditTimer(self):\n        if self.credit_timer != None:\n            self.credit_timer.cancel()\n            self.credit_timer = None\n\n    def startCreditTimer(self, rtime):\n        if self.credit_time != None:\n            self.credit_times[0] = rtime + self.credit_time\n            self.credit_time = None\n        try:\n            credit_time = min([x for x in self.credit_times.values() if x != None])\n        except ValueError:\n            return\n        self.credit_timer = TimeoutAbs(self.credit_expires, credit_time, credit_time)\n\n    def resetCreditTime(self, rtime, new_credit_times):\n        self.credit_times.update(new_credit_times)\n        if self.state.connected:\n            self.cancelCreditTimer()\n            self.startCreditTimer(rtime)\n\n    def cleanup(self):\n        pass\nsippy/CCEvents.py\nclass CCEventTry(CCEventGeneric):\n    name = 'CCEventTry'\n    pass\nsippy/RadiusAuthorisation.py\nclass RadiusAuthorisation(Radius_client):\n    def do_auth(self, username, caller, callee, h323_cid, sip_cid, remote_ip, res_cb, \\\n      realm = None, nonce = None, uri = None, response = None, extra_attributes = None):\n        sip_cid = str(sip_cid)\n        attributes = None\n        if None not in (realm, nonce, uri, response):\n            attributes = [('User-Name', username), ('Digest-Realm', realm), \\\n              ('Digest-Nonce', nonce), ('Digest-Method', 'INVITE'), ('Digest-URI', uri), \\\n              ('Digest-Algorithm', 'MD5'), ('Digest-User-Name', username), ('Digest-Response', response)]\n        else:\n            attributes = [('User-Name', remote_ip), ('Password', 'cisco')]\n        if caller == None:\n            caller = ''\n        attributes.extend((('Calling-Station-Id', caller), ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), \\\n          ('call-id', sip_cid), ('h323-remote-address', remote_ip), ('h323-session-protocol', 'sipv2')))\n        if extra_attributes != None:\n            for a, v in extra_attributes:\n                attributes.append((a, v))\n        message = 'sending AAA request:\\n' \n        message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes])\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        Radius_client.do_auth(self, attributes, self._process_result, res_cb, sip_cid, time())\n\n    def _process_result(self, results, res_cb, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'AAA request accepted (delay is %.3f), processing response:\\n' % delay\n            else:\n                message = 'AAA request rejected (delay is %.3f), processing response:\\n' % delay\n            if len(results[0]) > 0:\n                message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % x for x in results[0]])\n        else:\n            message = 'Error sending AAA request (delay is %.3f)\\n' % delay\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        res_cb(results)\nsippy/CCEvents.py\nclass CCEventConnect(CCEventGeneric):\n    name = 'CCEventConnect'\n    pass\nsippy/UasStateTrying.py\nclass UasStateTrying(UaStateGeneric):\n    sname = 'Trying(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body)\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n                if self.ua.expire_time != None:\n                    self.ua.expire_timer = TimeoutAbs(self.ua.expires, self.ua.expire_time)\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            return (UasStateRinging, self.ua.ring_cbs, event.rtime, event.origin, code)\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Trying state' % event\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/SipTo.py\nclass SipTo(SipFrom):\n    hf_names = ('to', 't')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 't'\n        return 'To'\nsippy/CCEvents.py\nclass CCEventUpdate(CCEventGeneric):\n    name = 'CCEventUpdate'\n    pass\nsippy/SipLogger.py\nclass SipLogger(object):\n    app = None\n    call_id = None\n    log = None\n    level = None\n    flock = lambda x, y, z: None\n\n    def __init__(self, app, call_id = 'GLOBAL', logfile = '/var/log/sip.log'):\n        self.app = app\n        self.call_id = call_id\n        bend = os.environ.get('SIPLOG_BEND', 'stderr').lower()\n        if bend == 'stderr':\n            self.log = sys.__stderr__\n        elif bend == 'none':\n            self.write = self.donoting\n        else:\n            logfile = os.environ.get('SIPLOG_LOGFILE_FILE', logfile)\n            self.log = file(logfile, 'a')\n            self.flock = flock\n            Signal(SIGUSR1, self.reopen, logfile)\n        self.level = eval('SIPLOG_' + os.environ.get('SIPLOG_LVL', 'INFO'))\n\n    def donoting(self, *args, **kwargs):\n        pass\n\n    def write(self, *args, **kwargs):\n        if kwargs.get('level', SIPLOG_INFO) < self.level:\n            return\n        ltime = kwargs.get('ltime', None)\n        if ltime == None:\n            ltime = time()\n        call_id = kwargs.get('call_id', self.call_id)\n        obuf = '%s.%.3d/%s/%s: %s\\n' % (strftime('%d %b %H:%M:%S', localtime(ltime)), \\\n          (ltime % 1) * 1000, call_id, self.app, \\\n          reduce(lambda x, y: x + y, [str(x) for x in args]))\n        try:\n            self.flock(self.log, LOCK_EX)\n        except IOError, e:\n            # Catch ENOTSUP\n            if e.args[0] != 45:\n                raise e\n            self.flock = lambda x, y: None\n        try:\n            self.log.write(obuf)\n        except IOError, e:\n            if e.args[0] != EINTR:\n                raise e\n        self.log.flush()\n        self.flock(self.log, LOCK_UN)\n\n    def reopen(self, logfile):\n        self.log = file(logfile, 'a')\nsippy/CCEvents.py\nclass CCEventFail(CCEventGeneric):\n    name = 'CCEventFail'\n    pass\nsippy/UasStateRinging.py\nclass UasStateRinging(UaStateGeneric):\n    sname = 'Ringing(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            self.ua.sendUasResponse(code, reason, body)\n            for ring_cb in self.ua.ring_cbs:\n                ring_cb(self.ua, event.rtime, event.origin, code)\n            return None\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Ringing state' % event\n        return None\n\n    def recvRequest(self, req):\n        if req.getMethod() == 'BYE':\n            self.ua.sendUasResponse(487, 'Request Terminated')\n            self.ua.global_config['_sip_tm'].sendResponse(req.genResponse(200, 'OK'))\n            #print 'BYE received in the Ringing state, going to the Disconnected state'\n            if req.countHFs('also') > 0:\n                also = req.getHFBody('also').getUrl().getCopy()\n            else:\n                also = None\n            event = CCEventDisconnect(also, rtime = req.rtime, origin = self.ua.origin)\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n            self.ua.equeue.append(event)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = req.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, req.rtime, self.ua.origin)\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/RadiusAccounting.py\nclass RadiusAccounting(object):\n    global_config = None\n    drec = None\n    crec = None\n    iTime = None\n    cTime = None\n    sip_cid = None\n    origin = None\n    lperiod = None\n    el = None\n    send_start = None\n    complete = False\n    ms_precision = False\n    user_agent = None\n    p1xx_ts = None\n    p100_ts = None\n\n    def __init__(self, global_config, origin, lperiod = None, send_start = False):\n        self.global_config = global_config\n        self._attributes = [('h323-call-origin', origin), ('h323-call-type', 'VoIP'), \\\n          ('h323-session-protocol', 'sipv2')]\n        self.drec = False\n        self.crec = False\n        self.origin = origin\n        self.lperiod = lperiod\n        self.send_start = send_start\n\n    def setParams(self, username, caller, callee, h323_cid, sip_cid, remote_ip, \\\n      h323_in_cid = None):\n        if caller == None:\n            caller = ''\n        self._attributes.extend((('User-Name', username), ('Calling-Station-Id', caller), \\\n          ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), ('call-id', sip_cid), \\\n          ('Acct-Session-Id', sip_cid), ('h323-remote-address', remote_ip)))\n        if h323_in_cid != None and h323_in_cid != h323_cid:\n            self._attributes.append(('h323-incoming-conf-id', h323_in_cid))\n        self.sip_cid = str(sip_cid)\n        self.complete = True\n\n    def conn(self, ua, rtime, origin):\n        if self.crec:\n            return\n        self.crec = True\n        self.iTime = ua.setup_ts\n        self.cTime = ua.connect_ts\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        if self.send_start:\n            self.asend('Start', rtime, origin, ua)\n        self._attributes.extend((('h323-voice-quality', 0), ('Acct-Terminate-Cause', 'User-Request')))\n        if self.lperiod != None and self.lperiod > 0:\n            self.el = Timeout(self.asend, self.lperiod, -1, 'Alive')\n\n    def disc(self, ua, rtime, origin, result = 0):\n        if self.drec:\n            return\n        self.drec = True\n        if self.el != None:\n            self.el.cancel()\n            self.el = None\n        if self.iTime == None:\n            self.iTime = ua.setup_ts\n        if self.cTime == None:\n            self.cTime = rtime\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        self.asend('Stop', rtime, origin, result, ua)\n\n    def asend(self, type, rtime = None, origin = None, result = 0, ua = None):\n        if not self.complete:\n            return\n        if rtime == None:\n            rtime = time()\n        if ua != None:\n            duration, delay, connected = ua.getAcct()[:3]\n        else:\n            # Alive accounting\n            duration = rtime - self.cTime\n            delay = self.cTime - self.iTime\n            connected = True\n        if not(self.ms_precision):\n            duration = round(duration)\n            delay = round(delay)\n        attributes = self._attributes[:]\n        if type != 'Start':\n            if result >= 400:\n                try:\n                    dc = sipErrToH323Err[result][0]\n                except:\n                    dc = '7f'\n            elif result < 200:\n                dc = '10'\n            else:\n                dc = '0'\n            attributes.extend((('h323-disconnect-time', self.ftime(self.iTime + delay + duration)), \\\n              ('Acct-Session-Time', '%d' % round(duration)), ('h323-disconnect-cause', dc)))\n        if type == 'Stop':\n            if origin == 'caller':\n                release_source = '2'\n            elif origin == 'callee':\n                release_source = '4'\n            else:\n                release_source = '8'\n            attributes.append(('release-source', release_source))\n        attributes.extend((('h323-connect-time', self.ftime(self.iTime + delay)), ('h323-setup-time', self.ftime(self.iTime)), \\\n          ('Acct-Status-Type', type)))\n        if self.user_agent != None:\n            attributes.append(('h323-ivr-out', 'sip_ua:' + self.user_agent))\n        if self.p1xx_ts != None:\n            attributes.append(('Acct-Delay-Time', round(self.p1xx_ts)))\n        if self.p100_ts != None:\n            attributes.append(('provisional-timepoint', self.ftime(self.p100_ts)))\n        pattributes = ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes]\n        pattributes.insert(0, 'sending Acct %s (%s):\\n' % (type, self.origin.capitalize()))\n        self.global_config['_sip_logger'].write(call_id = self.sip_cid, *pattributes)\n        self.global_config['_radius_client'].do_acct(attributes, self._process_result, self.sip_cid, time())\n\n    def ftime(self, t):\n        gt = gmtime(t)\n        day = strftime('%d', gt)\n        if day[0] == '0':\n            day = day[1]\n        if self.ms_precision:\n            msec = (t % 1) * 1000\n        else:\n            msec = 0\n        return strftime('%%H:%%M:%%S.%.3d GMT %%a %%b %s %%Y' % (msec, day), gt)\n\n    def _process_result(self, results, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'Acct/%s request accepted (delay is %.3f)\\n' % (self.origin, delay)\n            else:\n                message = 'Acct/%s request rejected (delay is %.3f)\\n' % (self.origin, delay)\n        else:\n            message = 'Error sending Acct/%s request (delay is %.3f)\\n' % (self.origin, delay)\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\nsippy/MyConfigParser.py\nclass MyConfigParser(RawConfigParser):\n    default_section = None\n    _private_keys = None\n\n    def __init__(self, default_section = 'general'):\n        self.default_section = default_section\n        self._private_keys = {}\n        RawConfigParser.__init__(self)\n        self.add_section(self.default_section)\n\n    def __getitem__(self, key):\n        if key.startswith('_'):\n            return self._private_keys[key]\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type  == 'B':\n            return self.getboolean(self.default_section, key)\n        elif value_type == 'I':\n            return self.getint(self.default_section, key)\n        return self.get(self.default_section, key)\n\n    def __setitem__(self, key, value):\n        if key.startswith('_'):\n            self._private_keys[key] = value\n        else:\n            self.set(self.default_section, key, str(value))\n        return\n\n    def has_key(self, key):\n        return self.__contains__(key)\n\n    def __contains__(self, key):\n        if key.startswith('_'):\n            return self._private_keys.has_key(key)\n        return self.has_option(self.default_section, key)\n\n    def get(self, *args):\n        if len(args) == 1:\n            return self.__getitem__(args[0])\n        return RawConfigParser.get(self, *args)\n\n    def getdefault(self, key, default_value):\n        if self.__contains__(key):\n            return self.__getitem__(key)\n        return default_value\n\n    def get_longopts(self):\n        return tuple([x + '=' for x in SUPPORTED_OPTIONS.keys()])\n\n    def read(self, fname):\n        RawConfigParser.readfp(self, open(fname))\n        for key in tuple(self.options(self.default_section)):\n            self.check_and_set(key, RawConfigParser.get(self, \\\n              self.default_section, key), False)\n\n    def check_and_set(self, key, value, compat = True):\n        value = value.strip()\n        if compat:\n            if key == 'rtp_proxy_client':\n                # XXX compatibility option\n                if self.has_key('_rtp_proxy_clients'):\n                    self['_rtp_proxy_clients'].append(value)\n                else:\n                    self['_rtp_proxy_clients'] = [value,]\n                if self.has_key('rtp_proxy_clients'):\n                    self['rtp_proxy_clients'] += ',' + value\n                else:\n                    self['rtp_proxy_clients'] = value\n                return\n            elif key == 'pass_header':\n                # XXX compatibility option\n                if self.has_key('_pass_headers'):\n                    self['_pass_headers'].append(value)\n                else:\n                    self['_pass_headers'] = [value,]\n                if self.has_key('pass_headers'):\n                    self['pass_headers'] += ',' + value\n                else:\n                    self['pass_headers'] = value\n                return\n\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type == 'B':\n            if value.lower() not in self._boolean_states:\n                raise ValueError, 'Not a boolean: %s' % value\n        elif value_type == 'I':\n            _value = int(value)\n        if key in ('keepalive_ans', 'keepalive_orig'):\n            if _value < 0:\n                raise ValueError, 'keepalive_ans should be non-negative'\n        elif key == 'max_credit_time':\n            if _value <= 0:\n                raise ValueError, 'max_credit_time should be more than zero'\n        elif key == 'allowed_pts':\n            self['_allowed_pts'] = [int(x) for x in value.split(',')]\n        elif key in ('accept_ips', 'pass_headers', 'rtp_proxy_clients'):\n            self['_' + key] = [x.strip() for x in value.split(',')]\n        elif key == 'sip_address':\n            if 'my' in dir(value):\n                self['_sip_address'] = value\n                value = '*'\n            elif value in ('*', '0.0.0.0', '::'):\n                self['_sip_address'] = SipConf.my_address\n            else:\n                self['_sip_address'] = value\n        elif key == 'sip_port':\n            if _value <= 0 or _value > 65535:\n                raise ValueError, 'sip_port should be in the range 1-65535'\n            self['_sip_port'] = _value\n        self[key] = value\n\n    def options_help(self):\n        supported_options = SUPPORTED_OPTIONS.items()\n        supported_options.sort()\n        for option, (value_type, helptext) in supported_options:\n            if value_type == 'B':\n                value = 'on/off'\n            elif value_type == 'I':\n                value = 'number'\n            else:\n                value = '\"string\"'\n            print '--%s=%s\\n\\t%s\\n' % (option, value, helptext)\nsippy/UaStateDead.py\nclass UaStateDead(UaStateGeneric):\n    sname = 'Dead'\n    dead = True\n\n    def __init__(self, ua):\n        UaStateGeneric.__init__(self, None)\n        if ua.cId != None:\n            ua.global_config['_sip_tm'].unregConsumer(ua, str(ua.cId))\n        ua.tr = None\n        ua.event_cb = None\n        ua.conn_cbs = ()\n        ua.disc_cbs = ()\n        ua.fail_cbs = ()\n        ua.on_local_sdp_change = None\n        ua.on_remote_sdp_change = None\n        ua.expire_timer = None\n        ua.no_progress_timer = None\n        ua.credit_timer = None\n        # Keep this at the very end of processing\n        for callback in ua.dead_cbs:\n            callback(ua)\n        ua.dead_cbs = ()\n        ua.cleanup()\n        # Break cross-ref chain\n        self.ua = None\nsippy/SipTransactionManager.py\nclass SipTransactionManager(object):\n    global_config = None\n    l4r = None\n    tclient = None\n    tserver = None\n    req_cb = None\n    l1rcache = None\n    l2rcache = None\n    nat_traversal = False\n    req_consumers = None\n    provisional_retr = 0\n\n    def __init__(self, global_config, req_cb = None):\n        self.global_config = global_config\n        self.l4r = local4remote(global_config, self.handleIncoming)\n        self.tclient = {}\n        self.tserver = {}\n        self.req_cb = req_cb\n        self.l1rcache = {}\n        self.l2rcache = {}\n        self.req_consumers = {}\n        Timeout(self.rCachePurge, 32, -1)\n\n    def handleIncoming(self, data, address, server):\n        if len(data) < 32:\n            return\n        rtime = time()\n        self.global_config['_sip_logger'].write('RECEIVED message from %s:%d:\\n' % address, data, ltime = rtime)\n        checksum = md5(data).digest()\n        retrans = self.l1rcache.get(checksum, None)\n        if retrans == None:\n            retrans = self.l2rcache.get(checksum, None)\n        if retrans != None:\n            userv, data, address = retrans\n            if data == None:\n                return\n            self.transmitData(userv, data, address)\n            return\n        if data.startswith('SIP/2.0 '):\n            try:\n                resp = SipResponse(data)\n                tid = resp.getTId(True, True)\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP response from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            if resp.getSCode()[0] < 100 or resp.getSCode()[0] > 999:\n                print datetime.now(), 'invalid status code in SIP response from %s:%d:' % address\n                print data\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            resp.rtime = rtime\n            if not self.tclient.has_key(tid):\n                #print 'no transaction with tid of %s in progress' % str(tid)\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            t = self.tclient[tid]\n            if self.nat_traversal and resp.countHFs('contact') > 0 and not check1918(t.address[0]):\n                curl = resp.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n            resp.setSource(address)\n            self.incomingResponse(resp, t, checksum)\n        else:\n            if self.req_cb == None:\n                return\n            try:\n                req = SipRequest(data)\n                tids = req.getTIds()\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP request from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            req.rtime = rtime\n            via0 = req.getHFBody('via')\n            ahost, aport = via0.getAddr()\n            rhost, rport = address\n            if self.nat_traversal and rport != aport and check1918(ahost):\n                req.nated = True\n            if ahost != rhost:\n                via0.params['received'] = rhost\n            if via0.params.has_key('rport') or req.nated:\n                via0.params['rport'] = str(rport)\n            if self.nat_traversal and req.countHFs('contact') > 0 and req.countHFs('via') == 1:\n                curl = req.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n                    req.nated = True\n            req.setSource(address)\n            self.incomingRequest(req, checksum, tids, server)\n\n    # 1. Client transaction methods\n    def newTransaction(self, msg, resp_cb = None, laddress = None, userv = None):\n        t = SipTransaction()\n        t.tid = msg.getTId(True, True)\n        if self.tclient.has_key(t.tid):\n            raise ValueError('BUG: Attempt to initiate transaction with the same TID as existing one!!!')\n        t.tout = 0.5\n        t.fcode = None\n        t.address = msg.getTarget()\n        if userv == None:\n            if laddress == None:\n                t.userv = self.l4r.getServer(t.address)\n            else:\n                t.userv = self.l4r.getServer(laddress, is_local = True)\n        else:\n            t.userv = userv\n        t.data = msg.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        try:\n            t.expires = msg.getHFBody('expires').getNum()\n            if t.expires <= 0:\n                t.expires = 300\n        except IndexError:\n            t.expires = 300\n        if msg.getMethod() == 'INVITE':\n            t.needack = True\n            t.ack = msg.genACK()\n            t.cancel = msg.genCANCEL()\n        else:\n            t.needack = False\n            t.ack = None\n            t.cancel = None\n        t.cancelPending = False\n        t.resp_cb = resp_cb\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n        if resp_cb != None:\n            t.r408 = msg.genResponse(408, 'Request Timeout')\n        t.teB = Timeout(self.timerB, 32.0, 1, t)\n        t.teC = None\n        t.state = TRYING\n        self.tclient[t.tid] = t\n        self.transmitData(t.userv, t.data, t.address)\n        return t\n\n    def cancelTransaction(self, t, reason = None):\n        # If we got at least one provisional reply then (state == RINGING)\n        # then start CANCEL transaction, otherwise deffer it\n        if t.state != RINGING:\n            t.cancelPending = True\n        else:\n            if reason != None:\n                t.cancel.appendHeader(SipHeader(body = reason))\n            self.newTransaction(t.cancel, userv = t.userv)\n\n    def incomingResponse(self, msg, t, checksum):\n        # In those two states upper level already notified, only do ACK retransmit\n        # if needed\n        if t.state == TERMINATED:\n            return\n\n        if t.state == TRYING:\n            # Stop timers\n            if t.teA != None:\n                t.teA.cancel()\n                t.teA = None\n\n        if t.state in (TRYING, RINGING):\n            if t.teB != None:\n                t.teB.cancel()\n                t.teB = None\n\n            if msg.getSCode()[0] < 200:\n                # Privisional response - leave everything as is, except that\n                # change state and reload timeout timer\n                if t.state == TRYING:\n                    t.state = RINGING\n                    if t.cancelPending:\n                        self.newTransaction(t.cancel, userv = t.userv)\n                        t.cancelPending = False\n                t.teB = Timeout(self.timerB, t.expires, 1, t)\n                self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n            else:\n                # Final response - notify upper layer and remove transaction\n                if t.needack:\n                    # Prepare and send ACK if necessary\n                    fcode = msg.getSCode()[0]\n                    tag = msg.getHFBody('to').getTag()\n                    if tag != None:\n                        t.ack.getHFBody('to').setTag(tag)\n                    rAddr = None\n                    if msg.getSCode()[0] >= 200 and msg.getSCode()[0] < 300:\n                        # Some hairy code ahead\n                        if msg.countHFs('contact') > 0:\n                            rTarget = msg.getHFBody('contact').getUrl().getCopy()\n                        else:\n                            rTarget = None\n                        routes = [x.getCopy() for x in msg.getHFBodys('record-route')]\n                        routes.reverse()\n                        if len(routes) > 0:\n                            if not routes[0].getUrl().lr:\n                                if rTarget != None:\n                                    routes.append(SipRoute(address = SipAddress(url = rTarget)))\n                                rTarget = routes.pop(0).getUrl()\n                                rAddr = rTarget.getAddr()\n                            else:\n                                rAddr = routes[0].getAddr()\n                        elif rTarget != None:\n                            rAddr = rTarget.getAddr()\n                        if rTarget != None:\n                            t.ack.setRURI(rTarget)\n                        if rAddr != None:\n                            t.ack.setTarget(rAddr)\n                        t.ack.delHFs('route')\n                        t.ack.appendHeaders([SipHeader(name = 'route', body = x) for x in routes])\n                    if fcode >= 200 and fcode < 300:\n                        t.ack.getHFBody('via').genBranch()\n                    if rAddr == None:\n                        rAddr = t.address\n                    self.transmitMsg(t.userv, t.ack, rAddr, checksum)\n                else:\n                    self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n                del self.tclient[t.tid]\n                t.cleanup()\n\n    def timerA(self, t):\n        #print 'timerA', t\n        self.transmitData(t.userv, t.data, t.address)\n        t.tout *= 2\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n\n    def timerB(self, t):\n        #print 'timerB', t\n        t.teB = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        t.state = TERMINATED\n        #print '2: Timeout(self.timerC, 32.0, 1, t)', t\n        t.teC = Timeout(self.timerC, 32.0, 1, t)\n        if t.resp_cb == None:\n            return\n        t.r408.rtime = time()\n        t.resp_cb(t.r408)\n        #try:\n        #    t.resp_cb(SipRequest(t.data).genResponse(408, 'Request Timeout'))\n        #except:\n        #    print 'SipTransactionManager: unhandled exception when processing response!'\n\n    def timerC(self, t):\n        #print 'timerC', t\n        #print self.tclient\n        t.teC = None\n        del self.tclient[t.tid]\n        t.cleanup()\n\n    # 2. Server transaction methods\n    def incomingRequest(self, msg, checksum, tids, server):\n        for tid in tids:\n            if self.tclient.has_key(tid):\n                resp = msg.genResponse(482, 'Loop Detected')\n                self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                return\n        tid = msg.getTId()\n        # Fasten seatbelts - bumpy transaction matching code ahead!\n        if msg.getMethod() in ('INVITE', 'CANCEL', 'ACK'):\n            btid = msg.getTId(wBRN = True)\n            t = self.tserver.get(btid, None)\n            if t == None:\n                t = self.tserver.get(tid, None)\n                if t != None and t.branch != btid[3]:\n                    if msg.getMethod() == 'INVITE':\n                        # Different branch on transaction to which no final reply\n                        # has been sent yet - merge requests\n                        resp = msg.genResponse(482, 'Loop Detected')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n                    elif msg.getMethod() == 'CANCEL':\n                        # CANCEL, but with branch that doesn't match any existing\n                        # transactions\n                        resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n        else:\n            t = self.tserver.get(tid, None)\n        if t != None:\n            #print 'existing transaction'\n            if msg.getMethod() == t.method:\n                # Duplicate received, check that we have sent any response on this\n                # request already\n                if t.data != None:\n                    self.transmitData(t.userv, t.data, t.address, checksum)\n                return\n            elif msg.getMethod() == 'CANCEL':\n                # RFC3261 says that we have to reply 200 OK in all cases if\n                # there is such transaction\n                resp = msg.genResponse(200, 'OK')\n                self.transmitMsg(t.userv, resp, resp.getHFBody('via').getTAddr(), checksum)\n                if t.state in (TRYING, RINGING):\n                    self.doCancel(t, msg.rtime, msg)\n            elif msg.getMethod() == 'ACK' and t.state == COMPLETED:\n                t.state = CONFIRMED\n                if t.teA != None:\n                    t.teA.cancel()\n                    t.teA = None\n                t.teD.cancel()\n                # We have done with the transaction, no need to wait for timeout\n                del self.tserver[t.tid]\n                t.cleanup()\n                self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'ACK':\n            # Some ACK that doesn't match any existing transaction.\n            # Drop and forget it - upper layer is unlikely to be interested\n            # to seeing this anyway.\n            print datetime.now(), 'unmatched ACK transaction - ignoring'\n            sys.stdout.flush()\n            self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'CANCEL':\n            resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n            self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n        else:\n            #print 'new transaction', msg.getMethod()\n            t = SipTransaction()\n            t.tid = tid\n            t.state = TRYING\n            t.teA = None\n            t.teD = None\n            t.teE = None\n            t.teF = None\n            t.method = msg.getMethod()\n            t.data = None\n            t.address = None\n            t.noack_cb = None\n            t.cancel_cb = None\n            t.checksum = checksum\n            if server.laddress[0] not in ('0.0.0.0', '[::]'):\n                t.userv = server\n            else:\n                # For messages received on the wildcard interface find\n                # or create more specific server.\n                t.userv = self.l4r.getServer(msg.getSource())\n            if msg.getMethod() == 'INVITE':\n                t.r487 = msg.genResponse(487, 'Request Terminated')\n                t.needack = True\n                t.branch = msg.getHFBody('via').getBranch()\n                try:\n                    e = msg.getHFBody('expires').getNum()\n                    if e <= 0:\n                        e = 300\n                except IndexError:\n                    e = 300\n                t.teE = Timeout(self.timerE, e, 1, t)\n            else:\n                t.r487 = None\n                t.needack = False\n                t.branch = None\n            self.tserver[t.tid] = t\n            for consumer in self.req_consumers.get(t.tid[0], ()):\n                consumer = consumer.isYours(msg)\n                if consumer != None:\n                    rval = consumer.recvRequest(msg)\n                    break\n            else:\n                rval = self.req_cb(msg)\n            if rval == None:\n                if t.teA != None or t.teD != None or t.teE != None or t.teF != None:\n                    return\n                if self.tserver.has_key(t.tid):\n                    del self.tserver[t.tid]\n                t.cleanup()\n                return\n            resp, cancel_cb, noack_cb = rval\n            t.cancel_cb = cancel_cb\n            t.noack_cb = noack_cb\n            if resp != None:\n                self.sendResponse(resp, t)\n\n    def regConsumer(self, consumer, call_id):\n        self.req_consumers.setdefault(call_id, []).append(consumer)\n\n    def unregConsumer(self, consumer, call_id):\n        # Usually there will be only one consumer per call_id, so that\n        # optimize management for this case\n        consumers = self.req_consumers.pop(call_id)\n        if len(consumers) > 1:\n            consumers.remove(consumer)\n            self.req_consumers[call_id] = consumers\n\n    def sendResponse(self, resp, t = None, retrans = False):\n        #print self.tserver\n        if t == None:\n            tid = resp.getTId()\n            t = self.tserver[tid]\n        if t.state not in (TRYING, RINGING) and not retrans:\n            raise ValueError('BUG: attempt to send reply on already finished transaction!!!')\n        scode = resp.getSCode()[0]\n        toHF = resp.getHFBody('to')\n        if scode > 100 and toHF.getTag() == None:\n            toHF.genTag()\n        t.data = resp.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        t.address = resp.getHFBody('via').getTAddr()\n        self.transmitData(t.userv, t.data, t.address, t.checksum)\n        if scode < 200:\n            t.state = RINGING\n            if self.provisional_retr > 0 and scode > 100:\n                if t.teF != None:\n                    t.teF.cancel()\n                t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n        else:\n            t.state = COMPLETED\n            if t.teE != None:\n                t.teE.cancel()\n                t.teE = None\n            if t.teF != None:\n                t.teF.cancel()\n                t.teF = None\n            if t.needack:\n                # Schedule removal of the transaction\n                t.teD = Timeout(self.timerD, 32.0, 1, t)\n                if scode >= 300:\n                    # Black magick to allow proxy send us another INVITE with diffetent branch\n                    del self.tserver[t.tid]\n                    t.tid = list(t.tid)\n                    t.tid.append(t.branch)\n                    t.tid = tuple(t.tid)\n                    self.tserver[t.tid] = t\n                # Install retransmit timer if necessary\n                t.tout = 0.5\n                t.teA = Timeout(self.timerA, t.tout, 1, t)\n            else:\n                # We have done with the transaction\n                del self.tserver[t.tid]\n                t.cleanup()\n\n    def doCancel(self, t, rtime = None, req = None):\n        if rtime == None:\n            rtime = time()\n        if t.r487 != None:\n            self.sendResponse(t.r487, t, True)\n        if t.cancel_cb != None:\n            t.cancel_cb(rtime, req)\n\n    def timerD(self, t):\n        #print 'timerD'\n        t.teD = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        if t.noack_cb != None and t.state != CONFIRMED:\n            t.noack_cb()\n        del self.tserver[t.tid]\n        t.cleanup()\n\n    def timerE(self, t):\n        #print 'timerE'\n        t.teE = None\n        if t.teF != None:\n            t.teF.cancel()\n            t.teF = None\n        if t.state in (TRYING, RINGING):\n            if t.r487 != None:\n                t.r487.reason = 'Request Expired'\n            self.doCancel(t)\n\n    # Timer to retransmit the last provisional reply every\n    # 2 seconds\n    def timerF(self, t):\n        #print 'timerF', t.state\n        t.teF = None\n        if t.state == RINGING and self.provisional_retr > 0:\n            self.transmitData(t.userv, t.data, t.address)\n            t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n\n    def rCachePurge(self):\n        self.l2rcache = self.l1rcache\n        self.l1rcache = {}\n        self.l4r.rotateCache()\n\n    def transmitMsg(self, userv, msg, address, cachesum, compact = False):\n        data = msg.localStr(userv.laddress[0], userv.laddress[1], compact)\n        self.transmitData(userv, data, address, cachesum)\n\n    def transmitData(self, userv, data, address, cachesum = None):\n        userv.send_to(data, address)\n        self.global_config['_sip_logger'].write('SENDING message to %s:%d:\\n' % address, data)\n        if cachesum != None:\n            self.l1rcache[cachesum] = (userv, data, address)\nsippy/CCEvents.py\nclass CCEventRing(CCEventGeneric):\n    name = 'CCEventRing'\n    pass\nfrom sippy.Timeout import Timeout\nfrom sippy.Signal import Signal\nfrom sippy.SipFrom import SipFrom\nfrom sippy.SipTo import SipTo\nfrom sippy.SipCiscoGUID import SipCiscoGUID\nfrom sippy.UA import UA\nfrom sippy.CCEvents import CCEventRing, CCEventConnect, CCEventDisconnect, CCEventTry, CCEventUpdate, CCEventFail\nfrom sippy.UasStateTrying import UasStateTrying\nfrom sippy.UasStateRinging import UasStateRinging\nfrom sippy.UaStateDead import UaStateDead\nfrom sippy.SipConf import SipConf\nfrom sippy.SipHeader import SipHeader\nfrom sippy.RadiusAuthorisation import RadiusAuthorisation\nfrom sippy.RadiusAccounting import RadiusAccounting\nfrom sippy.FakeAccounting import FakeAccounting\nfrom sippy.SipLogger import SipLogger\nfrom sippy.Rtp_proxy_session import Rtp_proxy_session\nfrom sippy.Rtp_proxy_client import Rtp_proxy_client\nfrom signal import SIGHUP, SIGPROF, SIGUSR1, SIGUSR2\nfrom twisted.internet import reactor\nfrom urllib import unquote\nfrom sippy.Cli_server_local import Cli_server_local\nfrom sippy.SipTransactionManager import SipTransactionManager\nfrom sippy.SipCallId import SipCallId\nfrom re import sub\nfrom time import time\nfrom urllib import quote\nfrom hashlib import md5\nfrom sippy.MyConfigParser import MyConfigParser\nimport gc, getopt, os, sys\n    id = 1\n    uaA = None\n    uaO = None\n    state = None\n    cId = None\n    cld = None\n    eTry = None\n    routes = None\n    remote_ip = None\n    source = None\n    acctA = None\n    acctO = None\n    global_config = None\n    rtp_proxy_session = None\n    huntstop_scodes = None\n    pass_headers = None\n    auth_proc = None\n    proxied = False\n    challenge = None\n\n    def __init__(self, remote_ip, source, global_config, pass_headers):\n        self.id = CallController.id\n        CallController.id += 1\n        self.global_config = global_config\n        self.uaA = UA(self.global_config, event_cb = self.recvEvent, conn_cbs = (self.aConn,), disc_cbs = (self.aDisc,), \\\n          fail_cbs = (self.aDisc,), dead_cbs = (self.aDead,))\n        self.uaA.kaInterval = self.global_config['keepalive_ans']\n        self.state = CCStateIdle\n        self.uaO = None\n        self.routes = []\n        self.remote_ip = remote_ip\n        self.source = source\n        self.pass_headers = pass_headers\n\n    def recvEvent(self, event, ua):\n        if ua == self.uaA:\n            if self.state == CCStateIdle:\n                if not isinstance(event, CCEventTry):\n                    # Some weird event received\n                    self.uaA.recvEvent(CCEventDisconnect(rtime = event.rtime))\n                    return\n                self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name = event.getData()\n                self.cGUID = cGUID.hexForm()\n                if self.cld == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Internal Server Error (1)'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if body == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Body-less INVITE is not supported'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if self.global_config.has_key('_allowed_pts'):\n                    try:\n                        body.parse()\n                    except:\n                        self.uaA.recvEvent(CCEventFail((400, 'Malformed SDP Body'), rtime = event.rtime))\n                        self.state = CCStateDead\n                        return\n                    allowed_pts = self.global_config['_allowed_pts']\n                    mbody = body.content.sections[0].m_header\n                    if mbody.transport.lower() == 'rtp/avp':\n                        mbody.formats = [x for x in mbody.formats if x in allowed_pts]\n                        if len(mbody.formats) == 0:\n                            self.uaA.recvEvent(CCEventFail((488, 'Not Acceptable Here')))\n                            self.state = CCStateDead\n                            return\n                if self.cld.startswith('nat-'):\n                    self.cld = self.cld[4:]\n                    body.content += 'a=nated:yes\\r\\n'\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('static_tr_in'):\n                    self.cld = re_replace(self.global_config['static_tr_in'], self.cld)\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('_rtp_proxy_clients'):\n                    self.rtp_proxy_session = Rtp_proxy_session(self.global_config, call_id = self.cId, \\\n                      notify_socket = global_config['b2bua_socket'], \\\n                      notify_tag = quote('r %s' % str(self.id)))\n                    self.rtp_proxy_session.callee_raddress = (self.remote_ip, 5060)\n                self.eTry = event\n                self.state = CCStateWaitRoute\n                if not self.global_config['auth_enable']:\n                    self.username = self.remote_ip\n                    self.rDone(((), 0))\n                elif auth == None or auth.username == None or len(auth.username) == 0:\n                    self.username = self.remote_ip\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(self.remote_ip, self.cli, self.cld, self.cGUID, \\\n                      self.cId, self.remote_ip, self.rDone)\n                else:\n                    self.username = auth.username\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(auth.username, self.cli, self.cld, self.cGUID, \n                      self.cId, self.remote_ip, self.rDone, auth.realm, auth.nonce, auth.uri, auth.response)\n                return\n            if self.state not in (CCStateARComplete, CCStateConnected, CCStateDisconnecting) or self.uaO == None:\n                return\n            self.uaO.recvEvent(event)\n        else:\n            if (isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect)) and self.state == CCStateARComplete and \\\n              (isinstance(self.uaA.state, UasStateTrying) or isinstance(self.uaA.state, UasStateRinging)) and len(self.routes) > 0:\n                if isinstance(event, CCEventFail):\n                    code = event.getData()[0]\n                else:\n                    code = None\n                if code == None or code not in self.huntstop_scodes:\n                    self.placeOriginate(self.routes.pop(0))\n                    return\n            self.uaA.recvEvent(event)\n\n    def rDone(self, results):\n        # Check that we got necessary result from Radius\n        if len(results) != 2 or results[1] != 0:\n            if isinstance(self.uaA.state, UasStateTrying):\n                if self.challenge != None:\n                    event = CCEventFail((401, 'Unauthorized'))\n                    event.extra_header = self.challenge\n                else:\n                    event = CCEventFail((403, 'Auth Failed'))\n                self.uaA.recvEvent(event)\n                self.state = CCStateDead\n            return\n        if self.global_config['acct_enable']:\nNext line of code:\n", "input": "from sippy.Timeout import Timeout\nfrom sippy.Signal import Signal\nfrom sippy.SipFrom import SipFrom\nfrom sippy.SipTo import SipTo\nfrom sippy.SipCiscoGUID import SipCiscoGUID\nfrom sippy.UA import UA\nfrom sippy.CCEvents import CCEventRing, CCEventConnect, CCEventDisconnect, CCEventTry, CCEventUpdate, CCEventFail\nfrom sippy.UasStateTrying import UasStateTrying\nfrom sippy.UasStateRinging import UasStateRinging\nfrom sippy.UaStateDead import UaStateDead\nfrom sippy.SipConf import SipConf\nfrom sippy.SipHeader import SipHeader\nfrom sippy.RadiusAuthorisation import RadiusAuthorisation\nfrom sippy.RadiusAccounting import RadiusAccounting\nfrom sippy.FakeAccounting import FakeAccounting\nfrom sippy.SipLogger import SipLogger\nfrom sippy.Rtp_proxy_session import Rtp_proxy_session\nfrom sippy.Rtp_proxy_client import Rtp_proxy_client\nfrom signal import SIGHUP, SIGPROF, SIGUSR1, SIGUSR2\nfrom twisted.internet import reactor\nfrom urllib import unquote\nfrom sippy.Cli_server_local import Cli_server_local\nfrom sippy.SipTransactionManager import SipTransactionManager\nfrom sippy.SipCallId import SipCallId\nfrom re import sub\nfrom time import time\nfrom urllib import quote\nfrom hashlib import md5\nfrom sippy.MyConfigParser import MyConfigParser\nimport gc, getopt, os, sys\n    id = 1\n    uaA = None\n    uaO = None\n    state = None\n    cId = None\n    cld = None\n    eTry = None\n    routes = None\n    remote_ip = None\n    source = None\n    acctA = None\n    acctO = None\n    global_config = None\n    rtp_proxy_session = None\n    huntstop_scodes = None\n    pass_headers = None\n    auth_proc = None\n    proxied = False\n    challenge = None\n\n    def __init__(self, remote_ip, source, global_config, pass_headers):\n        self.id = CallController.id\n        CallController.id += 1\n        self.global_config = global_config\n        self.uaA = UA(self.global_config, event_cb = self.recvEvent, conn_cbs = (self.aConn,), disc_cbs = (self.aDisc,), \\\n          fail_cbs = (self.aDisc,), dead_cbs = (self.aDead,))\n        self.uaA.kaInterval = self.global_config['keepalive_ans']\n        self.state = CCStateIdle\n        self.uaO = None\n        self.routes = []\n        self.remote_ip = remote_ip\n        self.source = source\n        self.pass_headers = pass_headers\n\n    def recvEvent(self, event, ua):\n        if ua == self.uaA:\n            if self.state == CCStateIdle:\n                if not isinstance(event, CCEventTry):\n                    # Some weird event received\n                    self.uaA.recvEvent(CCEventDisconnect(rtime = event.rtime))\n                    return\n                self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name = event.getData()\n                self.cGUID = cGUID.hexForm()\n                if self.cld == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Internal Server Error (1)'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if body == None:\n                    self.uaA.recvEvent(CCEventFail((500, 'Body-less INVITE is not supported'), rtime = event.rtime))\n                    self.state = CCStateDead\n                    return\n                if self.global_config.has_key('_allowed_pts'):\n                    try:\n                        body.parse()\n                    except:\n                        self.uaA.recvEvent(CCEventFail((400, 'Malformed SDP Body'), rtime = event.rtime))\n                        self.state = CCStateDead\n                        return\n                    allowed_pts = self.global_config['_allowed_pts']\n                    mbody = body.content.sections[0].m_header\n                    if mbody.transport.lower() == 'rtp/avp':\n                        mbody.formats = [x for x in mbody.formats if x in allowed_pts]\n                        if len(mbody.formats) == 0:\n                            self.uaA.recvEvent(CCEventFail((488, 'Not Acceptable Here')))\n                            self.state = CCStateDead\n                            return\n                if self.cld.startswith('nat-'):\n                    self.cld = self.cld[4:]\n                    body.content += 'a=nated:yes\\r\\n'\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('static_tr_in'):\n                    self.cld = re_replace(self.global_config['static_tr_in'], self.cld)\n                    event.data = (self.cId, cGUID, self.cli, self.cld, body, auth, self.caller_name)\n                if self.global_config.has_key('_rtp_proxy_clients'):\n                    self.rtp_proxy_session = Rtp_proxy_session(self.global_config, call_id = self.cId, \\\n                      notify_socket = global_config['b2bua_socket'], \\\n                      notify_tag = quote('r %s' % str(self.id)))\n                    self.rtp_proxy_session.callee_raddress = (self.remote_ip, 5060)\n                self.eTry = event\n                self.state = CCStateWaitRoute\n                if not self.global_config['auth_enable']:\n                    self.username = self.remote_ip\n                    self.rDone(((), 0))\n                elif auth == None or auth.username == None or len(auth.username) == 0:\n                    self.username = self.remote_ip\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(self.remote_ip, self.cli, self.cld, self.cGUID, \\\n                      self.cId, self.remote_ip, self.rDone)\n                else:\n                    self.username = auth.username\n                    self.auth_proc = self.global_config['_radius_client'].do_auth(auth.username, self.cli, self.cld, self.cGUID, \n                      self.cId, self.remote_ip, self.rDone, auth.realm, auth.nonce, auth.uri, auth.response)\n                return\n            if self.state not in (CCStateARComplete, CCStateConnected, CCStateDisconnecting) or self.uaO == None:\n                return\n            self.uaO.recvEvent(event)\n        else:\n            if (isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect)) and self.state == CCStateARComplete and \\\n              (isinstance(self.uaA.state, UasStateTrying) or isinstance(self.uaA.state, UasStateRinging)) and len(self.routes) > 0:\n                if isinstance(event, CCEventFail):\n                    code = event.getData()[0]\n                else:\n                    code = None\n                if code == None or code not in self.huntstop_scodes:\n                    self.placeOriginate(self.routes.pop(0))\n                    return\n            self.uaA.recvEvent(event)\n\n    def rDone(self, results):\n        # Check that we got necessary result from Radius\n        if len(results) != 2 or results[1] != 0:\n            if isinstance(self.uaA.state, UasStateTrying):\n                if self.challenge != None:\n                    event = CCEventFail((401, 'Unauthorized'))\n                    event.extra_header = self.challenge\n                else:\n                    event = CCEventFail((403, 'Auth Failed'))\n                self.uaA.recvEvent(event)\n                self.state = CCStateDead\n            return\n        if self.global_config['acct_enable']:\n", "context": "sippy/Rtp_proxy_session.py\nclass Rtp_proxy_session(object):\n    rtp_proxy_client = None\n    call_id = None\n    from_tag = None\n    to_tag = None\n    caller_session_exists = False\n    caller_codecs = None\n    caller_raddress = None\n    callee_session_exists = False\n    callee_codecs = None\n    callee_raddress = None\n    max_index = -1\n    origin = None\n    notify_socket = None\n    notify_tag = None\n    global_config = None\n\n    def __init__(self, global_config, call_id = None, from_tag = None, to_tag = None,\n      notify_socket = None, notify_tag = None):\n        self.global_config = global_config\n        if global_config.has_key('_rtp_proxy_clients'):\n            rtp_proxy_clients = [x for x in global_config['_rtp_proxy_clients'] if x.online]\n            n = len(rtp_proxy_clients)\n            if n == 0:\n                raise Exception('No online RTP proxy client has been found')\n            self.rtp_proxy_client = rtp_proxy_clients[int(random() * n)]\n        else:\n            self.rtp_proxy_client = global_config['rtp_proxy_client']\n            if not self.rtp_proxy_client.online:\n                raise Exception('No online RTP proxy client has been found')\n        if call_id != None:\n            self.call_id = call_id\n        else:\n            self.call_id = md5(str(random()) + str(time())).hexdigest()\n        if from_tag != None:\n            self.from_tag = from_tag\n        else:\n            self.from_tag = md5(str(random()) + str(time())).hexdigest()\n        if to_tag != None:\n            self.to_tag = to_tag\n        else:\n            self.to_tag = md5(str(random()) + str(time())).hexdigest()\n        self.origin = SdpOrigin()\n        self.notify_socket = notify_socket\n        self.notify_tag = notify_tag\n\n    def version(self, result_callback):\n        self.rtp_proxy_client.send_command('V', self.version_result, result_callback)\n\n    def version_result(self, result, result_callback):\n        result_callback(result)\n\n    def play_caller(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._play_caller, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_caller(None, prompt_name, times, result_callback, index)\n\n    def _play_caller(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.caller_codecs, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def play_callee(self, prompt_name, times = 1, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            return\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._play_callee, '', index, prompt_name, times, result_callback, index)\n            return\n        self._play_callee(None, prompt_name, times, result_callback, index)\n\n    def _play_callee(self, result, prompt_name, times, result_callback, index):\n        command = 'P%d %s %s %s %s %s' % (times, '%s-%d' % (self.call_id, index), prompt_name, self.callee_codecs, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_caller(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def stop_play_callee(self, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            return\n        command = 'S %s %s %s' % ('%s-%d' % (self.call_id, index), self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_caller(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._copy_caller, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_caller(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_caller(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag, self.to_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def copy_callee(self, remote_ip, remote_port, result_callback = None, index = 0):\n        if not self.callee_session_exists:\n            self.update_callee('0.0.0.0', 0, self._copy_callee, '', index, remote_ip, remote_port, result_callback, index)\n            return\n        self._copy_callee(None, remote_ip, remote_port, result_callback, index)\n\n    def _copy_callee(self, result, remote_ip, remote_port, result_callback = None, index = 0):\n        command = 'C %s udp:%s:%d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def start_recording(self, rname = None, result_callback = None, index = 0):\n        if not self.caller_session_exists:\n            self.update_caller('0.0.0.0', 0, self._start_recording, '', index, rname, result_callback, index)\n            return\n        self._start_recording(None, rname, result_callback, index)\n\n    def _start_recording(self, result, rname, result_callback, index):\n        if rname == None:\n            command = 'R %s %s %s' % ('%s-%d' % (self.call_id, index), self.from_tag, self.to_tag)\n            return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n        command = 'C %s %s.a %s %s' % ('%s-%d' % (self.call_id, index), rname, self.from_tag, self.to_tag)\n        return self.rtp_proxy_client.send_command(command, self._start_recording1, \\\n          (rname, result_callback, index))\n\n    def _start_recording1(self, result, args):\n        rname, result_callback, index = args\n        command = 'C %s %s.o %s %s' % ('%s-%d' % (self.call_id, index), rname, self.to_tag, self.from_tag)\n        return self.rtp_proxy_client.send_command(command, self.command_result, result_callback)\n\n    def command_result(self, result, result_callback):\n        if result_callback != None:\n            result_callback(result)\n\n    def update_caller(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.caller_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.caller_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.caller_raddress[0]\n        command += options\n        command += ' %s %s %d %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.from_tag)\n        if self.caller_session_exists:\n            command += ' %s' % self.to_tag\n        if self.notify_socket != None and index == 0 and \\\n          self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'caller', callback_parameters))\n\n    def update_callee(self, remote_ip, remote_port, result_callback, options = '', index = 0, *callback_parameters):\n        command = 'U'\n        self.max_index = max(self.max_index, index)\n        if self.rtp_proxy_client.sbind_supported and self.callee_raddress != None:\n            if self.rtp_proxy_client.is_local:\n                options += 'L%s' % self.global_config['_sip_tm'].l4r.getServer( \\\n                  self.callee_raddress).laddress[0]\n            else:\n                options += 'R%s' % self.callee_raddress[0]\n        command += options\n        command += ' %s %s %d %s %s' % ('%s-%d' % (self.call_id, index), remote_ip, remote_port, self.to_tag, self.from_tag)\n        if self.notify_socket != None and index == 0 \\\n          and self.rtp_proxy_client.tnot_supported:\n            command += ' %s %s' % (self.notify_socket, self.notify_tag)\n        self.rtp_proxy_client.send_command(command, self.update_result, (result_callback, 'callee', callback_parameters))\n\n    def update_result(self, result, args):\n        result_callback, face, callback_parameters = args\n        if face == 'caller':\n            self.caller_session_exists = True\n        else:\n            self.callee_session_exists = True\n        if result == None:\n            result_callback(None, *callback_parameters)\n            return\n        t1 = result.split()\n        rtpproxy_port = int(t1[0])\n        if rtpproxy_port == 0:\n            result_callback(None, *callback_parameters)\n        family = 'IP4'\n        if len(t1) > 1:\n            rtpproxy_address = t1[1]\n            if len(t1) > 2 and t1[2] == '6':\n                family = 'IP6'\n        else:\n            rtpproxy_address = self.rtp_proxy_client.proxy_address\n        result_callback((rtpproxy_address, rtpproxy_port, family), *callback_parameters)\n\n    def delete(self):\n        while self.max_index >= 0:\n            command = 'D %s %s %s' % ('%s-%d' % (self.call_id, self.max_index), self.from_tag, self.to_tag)\n            self.rtp_proxy_client.send_command(command)\n            self.max_index -= 1\n\n    def on_caller_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_caller, sdp_body, result_callback)\n\n    def on_callee_sdp_change(self, sdp_body, result_callback):\n        self.on_xxx_sdp_change(self.update_callee, sdp_body, result_callback)\n\n    def on_xxx_sdp_change(self, update_xxx, sdp_body, result_callback):\n        sects = []\n        try:\n            sdp_body.parse()\n        except Exception, exception:\n            print datetime.now(), 'can\\'t parse SDP body: %s:' % str(exception)\n            print '-' * 70\n            print_exc(file = sys.stdout)\n            print '-' * 70\n            print sdp_body.content\n            print '-' * 70\n            sys.stdout.flush()\n            return\n        for i in range(0, len(sdp_body.content.sections)):\n            sect = sdp_body.content.sections[i]\n            if sect.m_header.transport.lower() not in ('udp', 'udptl', 'rtp/avp'):\n                continue\n            sects.append(sect)\n        if len(sects) == 0:\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n            return\n        formats = sects[0].m_header.formats\n        if update_xxx == self.update_caller:\n            if len(formats) > 1:\n                self.caller_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.caller_codecs = str(formats[0])\n        else:\n            if len(formats) > 1:\n                self.callee_codecs = reduce(lambda x, y: str(x) + ',' + str(y), formats)\n            else:\n                self.callee_codecs = str(formats[0])\n        for sect in sects:\n            options = ''\n            if sect.c_header.atype == 'IP6':\n                options = '6'\n            update_xxx(sect.c_header.addr, sect.m_header.port, self.xxx_sdp_change_finish, options, \\\n              sects.index(sect), sdp_body, sect, sects, result_callback)\n        return\n\n    def xxx_sdp_change_finish(self, address_port, sdp_body, sect, sects, result_callback):\n        sect.needs_update = False\n        if address_port != None:\n            sect.c_header.atype = address_port[2]\n            sect.c_header.addr = address_port[0]\n            if sect.m_header.port != 0:\n                sect.m_header.port = address_port[1]\n        if len([x for x in sects if x.needs_update]) == 0:\n            sdp_body.content.o_header = self.origin\n            sdp_body.needs_update = False\n            result_callback(sdp_body)\n\n    def __del__(self):\n        self.delete()\n        self.rtp_proxy_client = None\nsippy/Signal.py\nclass Signal(object):\n    callback = None\n    parameters = None\n    previous_handler = None\n\n    def __init__(self, signum, callback, *parameters):\n        self.callback = callback\n        self.parameters = parameters\n        self.previous_handler = signal(signum, self.signal_handler)\n\n    def signal_handler(self, signum, *frame):\n        try:\n            reactor.callFromThread(self.callback, *self.parameters)\n        except:\n            print datetime.now(), 'Signal: unhandled exception in signal callback'\n            print '-' * 70\n            print_exc(file = stdout)\n            print '-' * 70\n            stdout.flush()\n        if self.previous_handler not in (SIG_IGN, SIG_DFL):\n            try:\n                self.previous_handler(signum, *frame)\n            except:\n                print datetime.now(), 'Signal: unhandled exception in signal chain'\n                print '-' * 70\n                print_exc(file = stdout)\n                print '-' * 70\n                stdout.flush()\nsippy/SipCiscoGUID.py\nclass SipCiscoGUID(SipGenericHF):\n    hf_names = ('cisco-guid', 'h323-conf-id')\n    ciscoGUID = None\n\n    def __init__(self, body = None, ciscoGUID = None):\n        SipGenericHF.__init__(self, body)\n        if body != None:\n            return\n        self.parsed = True\n        if ciscoGUID != None:\n            self.ciscoGUID = ciscoGUID\n        else:\n            s = md5(str((random() * 1000000000L) + time())).hexdigest()\n            self.ciscoGUID = (long(s[0:8], 16), long(s[8:16], 16), long(s[16:24], 16), long(s[24:32], 16))\n\n    def parse(self):\n        self.parsed = True\n        self.ciscoGUID = tuple([int(x) for x in  self.body.split('-', 3)])\n\n    def __str__(self):\n        if not self.parsed:\n            return self.body\n        return '%d-%d-%d-%d' % self.ciscoGUID\n\n    def getCiscoGUID(self):\n        return self.ciscoGUID\n\n    def hexForm(self):\n        return '%.8X %.8X %.8X %.8X' % self.ciscoGUID\n\n    def getCanName(self, name, compact = False):\n        if name.lower() == 'h323-conf-id':\n            return 'h323-conf-id'\n        else:\n            return 'cisco-GUID'\n\n    def getCopy(self):\n        if not self.parsed:\n            return SipCiscoGUID(self.body)\n        return SipCiscoGUID(ciscoGUID = self.ciscoGUID)\nsippy/SipHeader.py\nclass SipHeader(object):\n    name = None\n    body = None\n\n    def __init__(self, s = None, name = None, body = None, bodys = None, fixname = False):\n        if s != None:\n            name, bodys = [x.strip() for x in s.split(':', 1)]\n        if name != None:\n            self.name = name.lower()\n        if body == None:\n            try:\n                try:\n                    body = hf_types[self.name](bodys)\n                except KeyError:\n                    body = SipGenericHF(bodys, name)\n            except ESipHeaderCSV, einst:\n                einst.name = self.name\n                raise einst\n        self.body = body\n        # If no name is provided use canonic name from the body-specific\n        # class.\n        if self.name == None or fixname:\n            self.name = body.hf_names[0]\n\n    def __str__(self):\n        return str(self.body.getCanName(self.name)) + ': ' + str(self.body)\n\n    def localStr(self, local_addr = None, local_port = None, compact = False):\n        return str(self.body.getCanName(self.name, compact)) + ': ' + \\\n          self.body.localStr(local_addr, local_port)\n\n    def getBody(self):\n        if not self.body.parsed:\n            self.body.parse()\n        return self.body\nsippy/SipFrom.py\nclass SipFrom(SipAddressHF):\n    hf_names = ('from', 'f')\n\n    def __init__(self, body = None, address = None):\n        SipAddressHF.__init__(self, body, address)\n        if body == None and address == None:\n            self.address = SipAddress(name = 'Anonymous', url = SipURL(host = SipConf.my_address, port = SipConf.my_port))\n\n    def getTag(self):\n        return self.address.getParam('tag')\n\n    def genTag(self):\n        self.address.setParam('tag', md5(str((random() * 1000000000L) + time())).hexdigest())\n\n    def setTag(self, value):\n        self.address.setParam('tag', value)\n\n    def delTag(self):\n        self.address.delParam('tag')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 'f'\n        return 'From'\nsippy/CCEvents.py\nclass CCEventDisconnect(CCEventGeneric):\n    name = 'CCEventDisconnect'\n    pass\nsippy/UA.py\nclass UA(object):\n    global_config = None\n    state = None\n    event_cb = None\n    uasReq = None\n    uacResp = None\n    username = None\n    password = None\n    equeue = None\n    dId = None\n    credit_time = None\n    credit_times = None\n    credit_timer = None\n    conn_cbs = None\n    disc_cbs = None\n    fail_cbs = None\n    ring_cbs = None\n    dead_cbs = None\n    rCSeq = None\n    lTag = None\n    lUri = None\n    rUri = None\n    cId = None\n    lCSeq = None\n    lContact = None\n    cGUID = None\n    rAddr = None\n    rAddr0 = None\n    routes = None\n    rTarget = None\n    uasResp = None\n    lSDP = None\n    rSDP = None\n    kaInterval = 0\n    branch = None\n    reqs = None\n    extra_headers = None\n    useRefer = True\n    expire_time = None\n    expire_timer = None\n    no_progress_time = None\n    no_progress_timer = None\n    no_reply_time = None\n    no_reply_timer = None\n    on_local_sdp_change = None\n    on_remote_sdp_change = None\n    last_scode = 100\n    setup_ts = None\n    p100_ts = None\n    p1xx_ts = None\n    connect_ts = None\n    disconnect_ts = None\n    user_agent = None\n    elast_seq = None\n    origin = None\n    source_address = None\n\n    def __init__(self, global_config, event_cb = None, username = None, password = None, nh_address = None, credit_time = None, \\\n      conn_cbs = None, disc_cbs = None, fail_cbs = None, ring_cbs = None, dead_cbs = None, ltag = None, extra_headers = None, \\\n      expire_time = None, no_progress_time = None):\n        self.global_config = global_config\n        self.event_cb = event_cb\n        self.equeue = []\n        self.username = username\n        self.password = password\n        self.rAddr = nh_address\n        self.rAddr0 = self.rAddr\n        self.credit_time = credit_time\n        self.credit_times = {}\n        if conn_cbs != None:\n            self.conn_cbs = conn_cbs\n        else:\n            self.conn_cbs = ()\n        if disc_cbs != None:\n            self.disc_cbs = disc_cbs\n        else:\n            self.disc_cbs = ()\n        if fail_cbs != None:\n            self.fail_cbs = fail_cbs\n        else:\n            self.fail_cbs = ()\n        if ring_cbs != None:\n            self.ring_cbs = ring_cbs\n        else:\n            self.ring_cbs = ()\n        if dead_cbs != None:\n            self.dead_cbs = dead_cbs\n        else:\n            self.dead_cbs = ()\n        if ltag != None:\n            self.lTag = ltag\n        else:\n            self.lTag = md5(str((random() * 1000000000L) + time())).hexdigest()\n        self.reqs = {}\n        self.extra_headers = extra_headers\n        self.expire_time = expire_time\n        self.no_progress_time = no_progress_time\n        #print self.username, self.password\n\n    def recvRequest(self, req):\n        #print 'Received request %s in state %s instance %s' % (req.getMethod(), self.state, self)\n        #print self.rCSeq, req.getHFBody('cseq').getCSeqNum()\n        if self.user_agent == None:\n            self.update_ua(req)\n        if self.rCSeq != None and self.rCSeq >= req.getHFBody('cseq').getCSeqNum():\n            return (req.genResponse(500, 'Server Internal Error'), None, None)\n        self.rCSeq = req.getHFBody('cseq').getCSeqNum()\n        if self.state == None:\n            if req.getMethod() == 'INVITE':\n                self.changeState((UasStateIdle,))\n            else:\n                return None\n        newstate = self.state.recvRequest(req)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n        if newstate != None and req.getMethod() == 'INVITE':\n            return (None, self.state.cancel, self.disconnect)\n        else:\n            return None\n\n    def recvResponse(self, resp):\n        if self.state == None:\n            return\n        self.update_ua(resp)\n        code, reason = resp.getSCode()\n        cseq, method = resp.getHFBody('cseq').getCSeq()\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 401 and resp.countHFs('www-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('authorization') == 0:\n            challenge = resp.getHFBody('www-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm())\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if method == 'INVITE' and self.reqs.has_key(cseq) and code == 407 and resp.countHFs('proxy-authenticate') != 0 and \\\n          self.username != None and self.password != None and self.reqs[cseq].countHFs('proxy-authorization') == 0:\n            challenge = resp.getHFBody('proxy-authenticate')\n            req = self.genRequest('INVITE', self.lSDP, challenge.getNonce(), challenge.getRealm(), SipProxyAuthorization)\n            self.lCSeq += 1\n            self.tr = self.global_config['_sip_tm'].newTransaction(req, self.recvResponse, \\\n              laddress = self.source_address)\n            del self.reqs[cseq]\n            return None\n        if code >= 200 and self.reqs.has_key(cseq):\n            del self.reqs[cseq]\n        newstate = self.state.recvResponse(resp)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def recvEvent(self, event):\n        #print self, event\n        if self.state == None:\n            if isinstance(event, CCEventTry) or isinstance(event, CCEventFail) or isinstance(event, CCEventDisconnect):\n                self.changeState((UacStateIdle,))\n            else:\n                return\n        newstate = self.state.recvEvent(event)\n        if newstate != None:\n            self.changeState(newstate)\n        self.emitPendingEvents()\n\n    def disconnect(self, rtime = None):\n        if rtime == None:\n            rtime = time()\n        self.equeue.append(CCEventDisconnect(rtime = rtime))\n        self.recvEvent(CCEventDisconnect(rtime = rtime))\n\n    def expires(self):\n        self.expire_timer = None\n        self.disconnect()\n\n    def no_progress_expires(self):\n        self.no_progress_timer = None\n        self.disconnect()\n\n    def no_reply_expires(self):\n        self.no_reply_timer = None\n        self.disconnect()\n\n    def credit_expires(self, rtime):\n        self.credit_timer = None\n        self.disconnect(rtime)\n\n    def changeState(self, newstate):\n        if self.state != None:\n            self.state.onStateChange(newstate[0])\n        self.state = newstate[0](self)\n        if len(newstate) > 1:\n            for callback in newstate[1]:\n                callback(self, *newstate[2:])\n\n    def emitEvent(self, event):\n        if self.event_cb != None:\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                return\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def emitPendingEvents(self):\n        while len(self.equeue) != 0 and self.event_cb != None:\n            event = self.equeue.pop(0)\n            if self.elast_seq != None and self.elast_seq >= event.seq:\n                #print 'ignoring out-of-order event', event, event.seq, self.elast_seq, self.cId\n                continue\n            self.elast_seq = event.seq\n            self.event_cb(event, self)\n\n    def genRequest(self, method, body = None, nonce = None, realm = None, SipXXXAuthorization = SipAuthorization, \\\n      reason = None):\n        req = SipRequest(method = method, ruri = self.rTarget, to = self.rUri, fr0m = self.lUri,\n                         cseq = self.lCSeq, callid = self.cId, contact = self.lContact,\n                         routes = self.routes, target = self.rAddr, cguid = self.cGUID)\n        if nonce != None and realm != None and self.username != None and self.password != None:\n            auth = SipXXXAuthorization(realm = realm, nonce = nonce, method = method, uri = str(self.rTarget),\n              username = self.username, password = self.password)\n            req.appendHeader(SipHeader(body = auth))\n        if body != None:\n            req.setBody(body)\n        if self.extra_headers != None:\n            req.appendHeaders(self.extra_headers)\n        if reason != None:\n            req.appendHeader(SipHeader(body = reason))\n        self.reqs[self.lCSeq] = req\n        return req\n\n    def sendUasResponse(self, scode, reason, body = None, contact = None, \\\n      reason_rfc3326 = None, extra_header = None):\n        self.uasResp.setSCode(scode, reason)\n        self.uasResp.setBody(body)\n        self.uasResp.delHFs('www-authenticate')\n        self.uasResp.delHFs('contact')\n        self.uasResp.delHFs('reason')\n        if contact != None:\n            self.uasResp.appendHeader(SipHeader(name = 'contact', body = contact))\n        if reason_rfc3326 != None:\n            self.uasResp.appendHeader(SipHeader(body = reason_rfc3326))\n        if extra_header != None:\n            self.uasResp.appendHeader(extra_header)\n        self.global_config['_sip_tm'].sendResponse(self.uasResp)\n\n    def isYours(self, req = None, call_id = None, from_tag = None, to_tag = None):\n        #print self.branch, req.getHFBody('via').getBranch()\n        if req != None:\n            if req.getMethod() != 'BYE' and self.branch != None and \\\n              self.branch != req.getHFBody('via').getBranch():\n                return None\n            call_id = str(req.getHFBody('call-id'))\n            from_tag = req.getHFBody('from').getTag()\n            to_tag = req.getHFBody('to').getTag()\n        #print str(self.cId), call_id\n        if call_id != str(self.cId):\n            return None\n        #print self.rUri.getTag(), from_tag\n        if self.rUri != None and self.rUri.getTag() != from_tag:\n            return None\n        #print self.lUri.getTag(), to_tag\n        if self.lUri != None and self.lUri.getTag() != to_tag:\n            return None\n        return self\n\n    def isDead(self):\n        if self.state != None:\n            return self.state.dead\n        return False\n\n    def isConnected(self):\n        if self.state != None:\n            return self.state.connected\n        return False\n\n    def getCLD(self):\n        if self.rUri == None:\n            return None\n        return self.rUri.getUrl().username\n\n    def getCLI(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUrl().username\n\n    def getCallingName(self):\n        if self.lUri == None:\n            return None\n        return self.lUri.getUri().name\n\n    def getRAddr0(self):\n        return self.rAddr0\n\n    def getCID(self):\n        # Return tuple containing call-id, local tag and remote tag\n        rval = [str(self.cId), None, None]\n        if self.lUri != None:\n            rval[1] = self.lUri.getTag()\n        if self.rUri != None:\n            rval[2] = self.rUri.getTag()\n        return tuple(rval)\n\n    def delayed_remote_sdp_update(self, event, remote_sdp_body):\n        self.rSDP = remote_sdp_body.getCopy()\n        self.equeue.append(event)\n        self.emitPendingEvents()\n\n    def getAcct(self):\n        if self.disconnect_ts != None:\n            disconnect_ts = self.disconnect_ts\n            disconnected = True\n        else:\n            disconnect_ts = time()\n            disconnected = False\n        if self.connect_ts != None:\n            return (disconnect_ts - self.connect_ts, self.connect_ts - self.setup_ts, True, disconnected)\n        return (0, disconnect_ts - self.setup_ts, False, disconnected)\n\n    def update_ua(self, msg):\n        if msg.countHFs('user-agent') > 0:\n            self.user_agent = msg.getHFBody('user-agent').name\n        elif msg.countHFs('server') > 0:\n            self.user_agent = msg.getHFBody('server').name\n        return\n\n    def cancelCreditTimer(self):\n        if self.credit_timer != None:\n            self.credit_timer.cancel()\n            self.credit_timer = None\n\n    def startCreditTimer(self, rtime):\n        if self.credit_time != None:\n            self.credit_times[0] = rtime + self.credit_time\n            self.credit_time = None\n        try:\n            credit_time = min([x for x in self.credit_times.values() if x != None])\n        except ValueError:\n            return\n        self.credit_timer = TimeoutAbs(self.credit_expires, credit_time, credit_time)\n\n    def resetCreditTime(self, rtime, new_credit_times):\n        self.credit_times.update(new_credit_times)\n        if self.state.connected:\n            self.cancelCreditTimer()\n            self.startCreditTimer(rtime)\n\n    def cleanup(self):\n        pass\nsippy/CCEvents.py\nclass CCEventTry(CCEventGeneric):\n    name = 'CCEventTry'\n    pass\nsippy/RadiusAuthorisation.py\nclass RadiusAuthorisation(Radius_client):\n    def do_auth(self, username, caller, callee, h323_cid, sip_cid, remote_ip, res_cb, \\\n      realm = None, nonce = None, uri = None, response = None, extra_attributes = None):\n        sip_cid = str(sip_cid)\n        attributes = None\n        if None not in (realm, nonce, uri, response):\n            attributes = [('User-Name', username), ('Digest-Realm', realm), \\\n              ('Digest-Nonce', nonce), ('Digest-Method', 'INVITE'), ('Digest-URI', uri), \\\n              ('Digest-Algorithm', 'MD5'), ('Digest-User-Name', username), ('Digest-Response', response)]\n        else:\n            attributes = [('User-Name', remote_ip), ('Password', 'cisco')]\n        if caller == None:\n            caller = ''\n        attributes.extend((('Calling-Station-Id', caller), ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), \\\n          ('call-id', sip_cid), ('h323-remote-address', remote_ip), ('h323-session-protocol', 'sipv2')))\n        if extra_attributes != None:\n            for a, v in extra_attributes:\n                attributes.append((a, v))\n        message = 'sending AAA request:\\n' \n        message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes])\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        Radius_client.do_auth(self, attributes, self._process_result, res_cb, sip_cid, time())\n\n    def _process_result(self, results, res_cb, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'AAA request accepted (delay is %.3f), processing response:\\n' % delay\n            else:\n                message = 'AAA request rejected (delay is %.3f), processing response:\\n' % delay\n            if len(results[0]) > 0:\n                message += reduce(lambda x, y: x + y, ['%-32s = \\'%s\\'\\n' % x for x in results[0]])\n        else:\n            message = 'Error sending AAA request (delay is %.3f)\\n' % delay\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\n        res_cb(results)\nsippy/CCEvents.py\nclass CCEventConnect(CCEventGeneric):\n    name = 'CCEventConnect'\n    pass\nsippy/UasStateTrying.py\nclass UasStateTrying(UaStateGeneric):\n    sname = 'Trying(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body)\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n                if self.ua.expire_time != None:\n                    self.ua.expire_timer = TimeoutAbs(self.ua.expires, self.ua.expire_time)\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            return (UasStateRinging, self.ua.ring_cbs, event.rtime, event.origin, code)\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            if self.ua.no_progress_timer != None:\n                self.ua.no_progress_timer.cancel()\n                self.ua.no_progress_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Trying state' % event\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/SipTo.py\nclass SipTo(SipFrom):\n    hf_names = ('to', 't')\n\n    def getCanName(self, name, compact = False):\n        if compact:\n            return 't'\n        return 'To'\nsippy/CCEvents.py\nclass CCEventUpdate(CCEventGeneric):\n    name = 'CCEventUpdate'\n    pass\nsippy/SipLogger.py\nclass SipLogger(object):\n    app = None\n    call_id = None\n    log = None\n    level = None\n    flock = lambda x, y, z: None\n\n    def __init__(self, app, call_id = 'GLOBAL', logfile = '/var/log/sip.log'):\n        self.app = app\n        self.call_id = call_id\n        bend = os.environ.get('SIPLOG_BEND', 'stderr').lower()\n        if bend == 'stderr':\n            self.log = sys.__stderr__\n        elif bend == 'none':\n            self.write = self.donoting\n        else:\n            logfile = os.environ.get('SIPLOG_LOGFILE_FILE', logfile)\n            self.log = file(logfile, 'a')\n            self.flock = flock\n            Signal(SIGUSR1, self.reopen, logfile)\n        self.level = eval('SIPLOG_' + os.environ.get('SIPLOG_LVL', 'INFO'))\n\n    def donoting(self, *args, **kwargs):\n        pass\n\n    def write(self, *args, **kwargs):\n        if kwargs.get('level', SIPLOG_INFO) < self.level:\n            return\n        ltime = kwargs.get('ltime', None)\n        if ltime == None:\n            ltime = time()\n        call_id = kwargs.get('call_id', self.call_id)\n        obuf = '%s.%.3d/%s/%s: %s\\n' % (strftime('%d %b %H:%M:%S', localtime(ltime)), \\\n          (ltime % 1) * 1000, call_id, self.app, \\\n          reduce(lambda x, y: x + y, [str(x) for x in args]))\n        try:\n            self.flock(self.log, LOCK_EX)\n        except IOError, e:\n            # Catch ENOTSUP\n            if e.args[0] != 45:\n                raise e\n            self.flock = lambda x, y: None\n        try:\n            self.log.write(obuf)\n        except IOError, e:\n            if e.args[0] != EINTR:\n                raise e\n        self.log.flush()\n        self.flock(self.log, LOCK_UN)\n\n    def reopen(self, logfile):\n        self.log = file(logfile, 'a')\nsippy/CCEvents.py\nclass CCEventFail(CCEventGeneric):\n    name = 'CCEventFail'\n    pass\nsippy/UasStateRinging.py\nclass UasStateRinging(UaStateGeneric):\n    sname = 'Ringing(UAS)'\n\n    def recvEvent(self, event):\n        if isinstance(event, CCEventRing):\n            scode = event.getData()\n            if scode == None:\n                code, reason, body = (180, 'Ringing', None)\n            else:\n                code, reason, body = scode\n                if code == 100:\n                    return None\n                if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                    self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                    return None\n            self.ua.lSDP = body\n            if self.ua.p1xx_ts == None:\n                self.ua.p1xx_ts = event.rtime\n            self.ua.sendUasResponse(code, reason, body)\n            for ring_cb in self.ua.ring_cbs:\n                ring_cb(self.ua, event.rtime, event.origin, code)\n            return None\n        elif isinstance(event, CCEventConnect):\n            code, reason, body = event.getData()\n            if body != None and self.ua.on_local_sdp_change != None and body.needs_update:\n                self.ua.on_local_sdp_change(body, lambda x: self.ua.recvEvent(event))\n                return None\n            self.ua.lSDP = body\n            self.ua.sendUasResponse(code, reason, body, self.ua.lContact)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.startCreditTimer(event.rtime)\n            self.ua.connect_ts = event.rtime\n            return (UaStateConnected, self.ua.conn_cbs, event.rtime, event.origin)\n        elif isinstance(event, CCEventRedirect):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed', None, None)\n            self.ua.sendUasResponse(scode[0], scode[1], scode[2], SipContact(address = SipAddress(url = scode[3])))\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventFail):\n            scode = event.getData()\n            if scode == None:\n                scode = (500, 'Failed')\n            self.ua.sendUasResponse(scode[0], scode[1], reason_rfc3326 = event.reason, \\\n              extra_header = event.extra_header)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateFailed, self.ua.fail_cbs, event.rtime, event.origin, scode[0])\n        elif isinstance(event, CCEventDisconnect):\n            #import sys, traceback\n            #traceback.print_stack(file = sys.stdout)\n            self.ua.sendUasResponse(500, 'Disconnected', reason_rfc3326 = event.reason)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = event.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, event.rtime, event.origin, self.ua.last_scode)\n        #print 'wrong event %s in the Ringing state' % event\n        return None\n\n    def recvRequest(self, req):\n        if req.getMethod() == 'BYE':\n            self.ua.sendUasResponse(487, 'Request Terminated')\n            self.ua.global_config['_sip_tm'].sendResponse(req.genResponse(200, 'OK'))\n            #print 'BYE received in the Ringing state, going to the Disconnected state'\n            if req.countHFs('also') > 0:\n                also = req.getHFBody('also').getUrl().getCopy()\n            else:\n                also = None\n            event = CCEventDisconnect(also, rtime = req.rtime, origin = self.ua.origin)\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n            self.ua.equeue.append(event)\n            if self.ua.expire_timer != None:\n                self.ua.expire_timer.cancel()\n                self.ua.expire_timer = None\n            self.ua.disconnect_ts = req.rtime\n            return (UaStateDisconnected, self.ua.disc_cbs, req.rtime, self.ua.origin)\n        return None\n\n    def cancel(self, rtime, req):\n        self.ua.disconnect_ts = rtime\n        self.ua.changeState((UaStateDisconnected, self.ua.disc_cbs, rtime, self.ua.origin))\n        event = CCEventDisconnect(rtime = rtime, origin = self.ua.origin)\n        if req != None:\n            try:\n                event.reason = req.getHFBody('reason')\n            except:\n                pass\n        self.ua.emitEvent(event)\nsippy/RadiusAccounting.py\nclass RadiusAccounting(object):\n    global_config = None\n    drec = None\n    crec = None\n    iTime = None\n    cTime = None\n    sip_cid = None\n    origin = None\n    lperiod = None\n    el = None\n    send_start = None\n    complete = False\n    ms_precision = False\n    user_agent = None\n    p1xx_ts = None\n    p100_ts = None\n\n    def __init__(self, global_config, origin, lperiod = None, send_start = False):\n        self.global_config = global_config\n        self._attributes = [('h323-call-origin', origin), ('h323-call-type', 'VoIP'), \\\n          ('h323-session-protocol', 'sipv2')]\n        self.drec = False\n        self.crec = False\n        self.origin = origin\n        self.lperiod = lperiod\n        self.send_start = send_start\n\n    def setParams(self, username, caller, callee, h323_cid, sip_cid, remote_ip, \\\n      h323_in_cid = None):\n        if caller == None:\n            caller = ''\n        self._attributes.extend((('User-Name', username), ('Calling-Station-Id', caller), \\\n          ('Called-Station-Id', callee), ('h323-conf-id', h323_cid), ('call-id', sip_cid), \\\n          ('Acct-Session-Id', sip_cid), ('h323-remote-address', remote_ip)))\n        if h323_in_cid != None and h323_in_cid != h323_cid:\n            self._attributes.append(('h323-incoming-conf-id', h323_in_cid))\n        self.sip_cid = str(sip_cid)\n        self.complete = True\n\n    def conn(self, ua, rtime, origin):\n        if self.crec:\n            return\n        self.crec = True\n        self.iTime = ua.setup_ts\n        self.cTime = ua.connect_ts\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        if self.send_start:\n            self.asend('Start', rtime, origin, ua)\n        self._attributes.extend((('h323-voice-quality', 0), ('Acct-Terminate-Cause', 'User-Request')))\n        if self.lperiod != None and self.lperiod > 0:\n            self.el = Timeout(self.asend, self.lperiod, -1, 'Alive')\n\n    def disc(self, ua, rtime, origin, result = 0):\n        if self.drec:\n            return\n        self.drec = True\n        if self.el != None:\n            self.el.cancel()\n            self.el = None\n        if self.iTime == None:\n            self.iTime = ua.setup_ts\n        if self.cTime == None:\n            self.cTime = rtime\n        if ua.user_agent != None and self.user_agent == None:\n            self.user_agent = ua.user_agent\n        if ua.p1xx_ts != None:\n            self.p1xx_ts = ua.p1xx_ts\n        if ua.p100_ts != None:\n            self.p100_ts = ua.p100_ts\n        self.asend('Stop', rtime, origin, result, ua)\n\n    def asend(self, type, rtime = None, origin = None, result = 0, ua = None):\n        if not self.complete:\n            return\n        if rtime == None:\n            rtime = time()\n        if ua != None:\n            duration, delay, connected = ua.getAcct()[:3]\n        else:\n            # Alive accounting\n            duration = rtime - self.cTime\n            delay = self.cTime - self.iTime\n            connected = True\n        if not(self.ms_precision):\n            duration = round(duration)\n            delay = round(delay)\n        attributes = self._attributes[:]\n        if type != 'Start':\n            if result >= 400:\n                try:\n                    dc = sipErrToH323Err[result][0]\n                except:\n                    dc = '7f'\n            elif result < 200:\n                dc = '10'\n            else:\n                dc = '0'\n            attributes.extend((('h323-disconnect-time', self.ftime(self.iTime + delay + duration)), \\\n              ('Acct-Session-Time', '%d' % round(duration)), ('h323-disconnect-cause', dc)))\n        if type == 'Stop':\n            if origin == 'caller':\n                release_source = '2'\n            elif origin == 'callee':\n                release_source = '4'\n            else:\n                release_source = '8'\n            attributes.append(('release-source', release_source))\n        attributes.extend((('h323-connect-time', self.ftime(self.iTime + delay)), ('h323-setup-time', self.ftime(self.iTime)), \\\n          ('Acct-Status-Type', type)))\n        if self.user_agent != None:\n            attributes.append(('h323-ivr-out', 'sip_ua:' + self.user_agent))\n        if self.p1xx_ts != None:\n            attributes.append(('Acct-Delay-Time', round(self.p1xx_ts)))\n        if self.p100_ts != None:\n            attributes.append(('provisional-timepoint', self.ftime(self.p100_ts)))\n        pattributes = ['%-32s = \\'%s\\'\\n' % (x[0], str(x[1])) for x in attributes]\n        pattributes.insert(0, 'sending Acct %s (%s):\\n' % (type, self.origin.capitalize()))\n        self.global_config['_sip_logger'].write(call_id = self.sip_cid, *pattributes)\n        self.global_config['_radius_client'].do_acct(attributes, self._process_result, self.sip_cid, time())\n\n    def ftime(self, t):\n        gt = gmtime(t)\n        day = strftime('%d', gt)\n        if day[0] == '0':\n            day = day[1]\n        if self.ms_precision:\n            msec = (t % 1) * 1000\n        else:\n            msec = 0\n        return strftime('%%H:%%M:%%S.%.3d GMT %%a %%b %s %%Y' % (msec, day), gt)\n\n    def _process_result(self, results, sip_cid, btime):\n        delay = time() - btime\n        rcode = results[1]\n        if rcode in (0, 1):\n            if rcode == 0:\n                message = 'Acct/%s request accepted (delay is %.3f)\\n' % (self.origin, delay)\n            else:\n                message = 'Acct/%s request rejected (delay is %.3f)\\n' % (self.origin, delay)\n        else:\n            message = 'Error sending Acct/%s request (delay is %.3f)\\n' % (self.origin, delay)\n        self.global_config['_sip_logger'].write(message, call_id = sip_cid)\nsippy/MyConfigParser.py\nclass MyConfigParser(RawConfigParser):\n    default_section = None\n    _private_keys = None\n\n    def __init__(self, default_section = 'general'):\n        self.default_section = default_section\n        self._private_keys = {}\n        RawConfigParser.__init__(self)\n        self.add_section(self.default_section)\n\n    def __getitem__(self, key):\n        if key.startswith('_'):\n            return self._private_keys[key]\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type  == 'B':\n            return self.getboolean(self.default_section, key)\n        elif value_type == 'I':\n            return self.getint(self.default_section, key)\n        return self.get(self.default_section, key)\n\n    def __setitem__(self, key, value):\n        if key.startswith('_'):\n            self._private_keys[key] = value\n        else:\n            self.set(self.default_section, key, str(value))\n        return\n\n    def has_key(self, key):\n        return self.__contains__(key)\n\n    def __contains__(self, key):\n        if key.startswith('_'):\n            return self._private_keys.has_key(key)\n        return self.has_option(self.default_section, key)\n\n    def get(self, *args):\n        if len(args) == 1:\n            return self.__getitem__(args[0])\n        return RawConfigParser.get(self, *args)\n\n    def getdefault(self, key, default_value):\n        if self.__contains__(key):\n            return self.__getitem__(key)\n        return default_value\n\n    def get_longopts(self):\n        return tuple([x + '=' for x in SUPPORTED_OPTIONS.keys()])\n\n    def read(self, fname):\n        RawConfigParser.readfp(self, open(fname))\n        for key in tuple(self.options(self.default_section)):\n            self.check_and_set(key, RawConfigParser.get(self, \\\n              self.default_section, key), False)\n\n    def check_and_set(self, key, value, compat = True):\n        value = value.strip()\n        if compat:\n            if key == 'rtp_proxy_client':\n                # XXX compatibility option\n                if self.has_key('_rtp_proxy_clients'):\n                    self['_rtp_proxy_clients'].append(value)\n                else:\n                    self['_rtp_proxy_clients'] = [value,]\n                if self.has_key('rtp_proxy_clients'):\n                    self['rtp_proxy_clients'] += ',' + value\n                else:\n                    self['rtp_proxy_clients'] = value\n                return\n            elif key == 'pass_header':\n                # XXX compatibility option\n                if self.has_key('_pass_headers'):\n                    self['_pass_headers'].append(value)\n                else:\n                    self['_pass_headers'] = [value,]\n                if self.has_key('pass_headers'):\n                    self['pass_headers'] += ',' + value\n                else:\n                    self['pass_headers'] = value\n                return\n\n        value_type  = SUPPORTED_OPTIONS[key][0]\n        if value_type == 'B':\n            if value.lower() not in self._boolean_states:\n                raise ValueError, 'Not a boolean: %s' % value\n        elif value_type == 'I':\n            _value = int(value)\n        if key in ('keepalive_ans', 'keepalive_orig'):\n            if _value < 0:\n                raise ValueError, 'keepalive_ans should be non-negative'\n        elif key == 'max_credit_time':\n            if _value <= 0:\n                raise ValueError, 'max_credit_time should be more than zero'\n        elif key == 'allowed_pts':\n            self['_allowed_pts'] = [int(x) for x in value.split(',')]\n        elif key in ('accept_ips', 'pass_headers', 'rtp_proxy_clients'):\n            self['_' + key] = [x.strip() for x in value.split(',')]\n        elif key == 'sip_address':\n            if 'my' in dir(value):\n                self['_sip_address'] = value\n                value = '*'\n            elif value in ('*', '0.0.0.0', '::'):\n                self['_sip_address'] = SipConf.my_address\n            else:\n                self['_sip_address'] = value\n        elif key == 'sip_port':\n            if _value <= 0 or _value > 65535:\n                raise ValueError, 'sip_port should be in the range 1-65535'\n            self['_sip_port'] = _value\n        self[key] = value\n\n    def options_help(self):\n        supported_options = SUPPORTED_OPTIONS.items()\n        supported_options.sort()\n        for option, (value_type, helptext) in supported_options:\n            if value_type == 'B':\n                value = 'on/off'\n            elif value_type == 'I':\n                value = 'number'\n            else:\n                value = '\"string\"'\n            print '--%s=%s\\n\\t%s\\n' % (option, value, helptext)\nsippy/UaStateDead.py\nclass UaStateDead(UaStateGeneric):\n    sname = 'Dead'\n    dead = True\n\n    def __init__(self, ua):\n        UaStateGeneric.__init__(self, None)\n        if ua.cId != None:\n            ua.global_config['_sip_tm'].unregConsumer(ua, str(ua.cId))\n        ua.tr = None\n        ua.event_cb = None\n        ua.conn_cbs = ()\n        ua.disc_cbs = ()\n        ua.fail_cbs = ()\n        ua.on_local_sdp_change = None\n        ua.on_remote_sdp_change = None\n        ua.expire_timer = None\n        ua.no_progress_timer = None\n        ua.credit_timer = None\n        # Keep this at the very end of processing\n        for callback in ua.dead_cbs:\n            callback(ua)\n        ua.dead_cbs = ()\n        ua.cleanup()\n        # Break cross-ref chain\n        self.ua = None\nsippy/SipTransactionManager.py\nclass SipTransactionManager(object):\n    global_config = None\n    l4r = None\n    tclient = None\n    tserver = None\n    req_cb = None\n    l1rcache = None\n    l2rcache = None\n    nat_traversal = False\n    req_consumers = None\n    provisional_retr = 0\n\n    def __init__(self, global_config, req_cb = None):\n        self.global_config = global_config\n        self.l4r = local4remote(global_config, self.handleIncoming)\n        self.tclient = {}\n        self.tserver = {}\n        self.req_cb = req_cb\n        self.l1rcache = {}\n        self.l2rcache = {}\n        self.req_consumers = {}\n        Timeout(self.rCachePurge, 32, -1)\n\n    def handleIncoming(self, data, address, server):\n        if len(data) < 32:\n            return\n        rtime = time()\n        self.global_config['_sip_logger'].write('RECEIVED message from %s:%d:\\n' % address, data, ltime = rtime)\n        checksum = md5(data).digest()\n        retrans = self.l1rcache.get(checksum, None)\n        if retrans == None:\n            retrans = self.l2rcache.get(checksum, None)\n        if retrans != None:\n            userv, data, address = retrans\n            if data == None:\n                return\n            self.transmitData(userv, data, address)\n            return\n        if data.startswith('SIP/2.0 '):\n            try:\n                resp = SipResponse(data)\n                tid = resp.getTId(True, True)\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP response from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            if resp.getSCode()[0] < 100 or resp.getSCode()[0] > 999:\n                print datetime.now(), 'invalid status code in SIP response from %s:%d:' % address\n                print data\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            resp.rtime = rtime\n            if not self.tclient.has_key(tid):\n                #print 'no transaction with tid of %s in progress' % str(tid)\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            t = self.tclient[tid]\n            if self.nat_traversal and resp.countHFs('contact') > 0 and not check1918(t.address[0]):\n                curl = resp.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n            resp.setSource(address)\n            self.incomingResponse(resp, t, checksum)\n        else:\n            if self.req_cb == None:\n                return\n            try:\n                req = SipRequest(data)\n                tids = req.getTIds()\n            except Exception, exception:\n                print datetime.now(), 'can\\'t parse SIP request from %s:%d: %s:' % (address[0], address[1], str(exception))\n                print '-' * 70\n                print_exc(file = sys.stdout)\n                print '-' * 70\n                print data\n                print '-' * 70\n                sys.stdout.flush()\n                self.l1rcache[checksum] = (None, None, None)\n                return\n            req.rtime = rtime\n            via0 = req.getHFBody('via')\n            ahost, aport = via0.getAddr()\n            rhost, rport = address\n            if self.nat_traversal and rport != aport and check1918(ahost):\n                req.nated = True\n            if ahost != rhost:\n                via0.params['received'] = rhost\n            if via0.params.has_key('rport') or req.nated:\n                via0.params['rport'] = str(rport)\n            if self.nat_traversal and req.countHFs('contact') > 0 and req.countHFs('via') == 1:\n                curl = req.getHFBody('contact').getUrl()\n                if check1918(curl.host):\n                    curl.host, curl.port = address\n                    req.nated = True\n            req.setSource(address)\n            self.incomingRequest(req, checksum, tids, server)\n\n    # 1. Client transaction methods\n    def newTransaction(self, msg, resp_cb = None, laddress = None, userv = None):\n        t = SipTransaction()\n        t.tid = msg.getTId(True, True)\n        if self.tclient.has_key(t.tid):\n            raise ValueError('BUG: Attempt to initiate transaction with the same TID as existing one!!!')\n        t.tout = 0.5\n        t.fcode = None\n        t.address = msg.getTarget()\n        if userv == None:\n            if laddress == None:\n                t.userv = self.l4r.getServer(t.address)\n            else:\n                t.userv = self.l4r.getServer(laddress, is_local = True)\n        else:\n            t.userv = userv\n        t.data = msg.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        try:\n            t.expires = msg.getHFBody('expires').getNum()\n            if t.expires <= 0:\n                t.expires = 300\n        except IndexError:\n            t.expires = 300\n        if msg.getMethod() == 'INVITE':\n            t.needack = True\n            t.ack = msg.genACK()\n            t.cancel = msg.genCANCEL()\n        else:\n            t.needack = False\n            t.ack = None\n            t.cancel = None\n        t.cancelPending = False\n        t.resp_cb = resp_cb\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n        if resp_cb != None:\n            t.r408 = msg.genResponse(408, 'Request Timeout')\n        t.teB = Timeout(self.timerB, 32.0, 1, t)\n        t.teC = None\n        t.state = TRYING\n        self.tclient[t.tid] = t\n        self.transmitData(t.userv, t.data, t.address)\n        return t\n\n    def cancelTransaction(self, t, reason = None):\n        # If we got at least one provisional reply then (state == RINGING)\n        # then start CANCEL transaction, otherwise deffer it\n        if t.state != RINGING:\n            t.cancelPending = True\n        else:\n            if reason != None:\n                t.cancel.appendHeader(SipHeader(body = reason))\n            self.newTransaction(t.cancel, userv = t.userv)\n\n    def incomingResponse(self, msg, t, checksum):\n        # In those two states upper level already notified, only do ACK retransmit\n        # if needed\n        if t.state == TERMINATED:\n            return\n\n        if t.state == TRYING:\n            # Stop timers\n            if t.teA != None:\n                t.teA.cancel()\n                t.teA = None\n\n        if t.state in (TRYING, RINGING):\n            if t.teB != None:\n                t.teB.cancel()\n                t.teB = None\n\n            if msg.getSCode()[0] < 200:\n                # Privisional response - leave everything as is, except that\n                # change state and reload timeout timer\n                if t.state == TRYING:\n                    t.state = RINGING\n                    if t.cancelPending:\n                        self.newTransaction(t.cancel, userv = t.userv)\n                        t.cancelPending = False\n                t.teB = Timeout(self.timerB, t.expires, 1, t)\n                self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n            else:\n                # Final response - notify upper layer and remove transaction\n                if t.needack:\n                    # Prepare and send ACK if necessary\n                    fcode = msg.getSCode()[0]\n                    tag = msg.getHFBody('to').getTag()\n                    if tag != None:\n                        t.ack.getHFBody('to').setTag(tag)\n                    rAddr = None\n                    if msg.getSCode()[0] >= 200 and msg.getSCode()[0] < 300:\n                        # Some hairy code ahead\n                        if msg.countHFs('contact') > 0:\n                            rTarget = msg.getHFBody('contact').getUrl().getCopy()\n                        else:\n                            rTarget = None\n                        routes = [x.getCopy() for x in msg.getHFBodys('record-route')]\n                        routes.reverse()\n                        if len(routes) > 0:\n                            if not routes[0].getUrl().lr:\n                                if rTarget != None:\n                                    routes.append(SipRoute(address = SipAddress(url = rTarget)))\n                                rTarget = routes.pop(0).getUrl()\n                                rAddr = rTarget.getAddr()\n                            else:\n                                rAddr = routes[0].getAddr()\n                        elif rTarget != None:\n                            rAddr = rTarget.getAddr()\n                        if rTarget != None:\n                            t.ack.setRURI(rTarget)\n                        if rAddr != None:\n                            t.ack.setTarget(rAddr)\n                        t.ack.delHFs('route')\n                        t.ack.appendHeaders([SipHeader(name = 'route', body = x) for x in routes])\n                    if fcode >= 200 and fcode < 300:\n                        t.ack.getHFBody('via').genBranch()\n                    if rAddr == None:\n                        rAddr = t.address\n                    self.transmitMsg(t.userv, t.ack, rAddr, checksum)\n                else:\n                    self.l1rcache[checksum] = (None, None, None)\n                if t.resp_cb != None:\n                    t.resp_cb(msg)\n                del self.tclient[t.tid]\n                t.cleanup()\n\n    def timerA(self, t):\n        #print 'timerA', t\n        self.transmitData(t.userv, t.data, t.address)\n        t.tout *= 2\n        t.teA = Timeout(self.timerA, t.tout, 1, t)\n\n    def timerB(self, t):\n        #print 'timerB', t\n        t.teB = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        t.state = TERMINATED\n        #print '2: Timeout(self.timerC, 32.0, 1, t)', t\n        t.teC = Timeout(self.timerC, 32.0, 1, t)\n        if t.resp_cb == None:\n            return\n        t.r408.rtime = time()\n        t.resp_cb(t.r408)\n        #try:\n        #    t.resp_cb(SipRequest(t.data).genResponse(408, 'Request Timeout'))\n        #except:\n        #    print 'SipTransactionManager: unhandled exception when processing response!'\n\n    def timerC(self, t):\n        #print 'timerC', t\n        #print self.tclient\n        t.teC = None\n        del self.tclient[t.tid]\n        t.cleanup()\n\n    # 2. Server transaction methods\n    def incomingRequest(self, msg, checksum, tids, server):\n        for tid in tids:\n            if self.tclient.has_key(tid):\n                resp = msg.genResponse(482, 'Loop Detected')\n                self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                return\n        tid = msg.getTId()\n        # Fasten seatbelts - bumpy transaction matching code ahead!\n        if msg.getMethod() in ('INVITE', 'CANCEL', 'ACK'):\n            btid = msg.getTId(wBRN = True)\n            t = self.tserver.get(btid, None)\n            if t == None:\n                t = self.tserver.get(tid, None)\n                if t != None and t.branch != btid[3]:\n                    if msg.getMethod() == 'INVITE':\n                        # Different branch on transaction to which no final reply\n                        # has been sent yet - merge requests\n                        resp = msg.genResponse(482, 'Loop Detected')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n                    elif msg.getMethod() == 'CANCEL':\n                        # CANCEL, but with branch that doesn't match any existing\n                        # transactions\n                        resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n                        self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n                        return\n        else:\n            t = self.tserver.get(tid, None)\n        if t != None:\n            #print 'existing transaction'\n            if msg.getMethod() == t.method:\n                # Duplicate received, check that we have sent any response on this\n                # request already\n                if t.data != None:\n                    self.transmitData(t.userv, t.data, t.address, checksum)\n                return\n            elif msg.getMethod() == 'CANCEL':\n                # RFC3261 says that we have to reply 200 OK in all cases if\n                # there is such transaction\n                resp = msg.genResponse(200, 'OK')\n                self.transmitMsg(t.userv, resp, resp.getHFBody('via').getTAddr(), checksum)\n                if t.state in (TRYING, RINGING):\n                    self.doCancel(t, msg.rtime, msg)\n            elif msg.getMethod() == 'ACK' and t.state == COMPLETED:\n                t.state = CONFIRMED\n                if t.teA != None:\n                    t.teA.cancel()\n                    t.teA = None\n                t.teD.cancel()\n                # We have done with the transaction, no need to wait for timeout\n                del self.tserver[t.tid]\n                t.cleanup()\n                self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'ACK':\n            # Some ACK that doesn't match any existing transaction.\n            # Drop and forget it - upper layer is unlikely to be interested\n            # to seeing this anyway.\n            print datetime.now(), 'unmatched ACK transaction - ignoring'\n            sys.stdout.flush()\n            self.l1rcache[checksum] = (None, None, None)\n        elif msg.getMethod() == 'CANCEL':\n            resp = msg.genResponse(481, 'Call Leg/Transaction Does Not Exist')\n            self.transmitMsg(server, resp, resp.getHFBody('via').getTAddr(), checksum)\n        else:\n            #print 'new transaction', msg.getMethod()\n            t = SipTransaction()\n            t.tid = tid\n            t.state = TRYING\n            t.teA = None\n            t.teD = None\n            t.teE = None\n            t.teF = None\n            t.method = msg.getMethod()\n            t.data = None\n            t.address = None\n            t.noack_cb = None\n            t.cancel_cb = None\n            t.checksum = checksum\n            if server.laddress[0] not in ('0.0.0.0', '[::]'):\n                t.userv = server\n            else:\n                # For messages received on the wildcard interface find\n                # or create more specific server.\n                t.userv = self.l4r.getServer(msg.getSource())\n            if msg.getMethod() == 'INVITE':\n                t.r487 = msg.genResponse(487, 'Request Terminated')\n                t.needack = True\n                t.branch = msg.getHFBody('via').getBranch()\n                try:\n                    e = msg.getHFBody('expires').getNum()\n                    if e <= 0:\n                        e = 300\n                except IndexError:\n                    e = 300\n                t.teE = Timeout(self.timerE, e, 1, t)\n            else:\n                t.r487 = None\n                t.needack = False\n                t.branch = None\n            self.tserver[t.tid] = t\n            for consumer in self.req_consumers.get(t.tid[0], ()):\n                consumer = consumer.isYours(msg)\n                if consumer != None:\n                    rval = consumer.recvRequest(msg)\n                    break\n            else:\n                rval = self.req_cb(msg)\n            if rval == None:\n                if t.teA != None or t.teD != None or t.teE != None or t.teF != None:\n                    return\n                if self.tserver.has_key(t.tid):\n                    del self.tserver[t.tid]\n                t.cleanup()\n                return\n            resp, cancel_cb, noack_cb = rval\n            t.cancel_cb = cancel_cb\n            t.noack_cb = noack_cb\n            if resp != None:\n                self.sendResponse(resp, t)\n\n    def regConsumer(self, consumer, call_id):\n        self.req_consumers.setdefault(call_id, []).append(consumer)\n\n    def unregConsumer(self, consumer, call_id):\n        # Usually there will be only one consumer per call_id, so that\n        # optimize management for this case\n        consumers = self.req_consumers.pop(call_id)\n        if len(consumers) > 1:\n            consumers.remove(consumer)\n            self.req_consumers[call_id] = consumers\n\n    def sendResponse(self, resp, t = None, retrans = False):\n        #print self.tserver\n        if t == None:\n            tid = resp.getTId()\n            t = self.tserver[tid]\n        if t.state not in (TRYING, RINGING) and not retrans:\n            raise ValueError('BUG: attempt to send reply on already finished transaction!!!')\n        scode = resp.getSCode()[0]\n        toHF = resp.getHFBody('to')\n        if scode > 100 and toHF.getTag() == None:\n            toHF.genTag()\n        t.data = resp.localStr(t.userv.laddress[0], t.userv.laddress[1])\n        t.address = resp.getHFBody('via').getTAddr()\n        self.transmitData(t.userv, t.data, t.address, t.checksum)\n        if scode < 200:\n            t.state = RINGING\n            if self.provisional_retr > 0 and scode > 100:\n                if t.teF != None:\n                    t.teF.cancel()\n                t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n        else:\n            t.state = COMPLETED\n            if t.teE != None:\n                t.teE.cancel()\n                t.teE = None\n            if t.teF != None:\n                t.teF.cancel()\n                t.teF = None\n            if t.needack:\n                # Schedule removal of the transaction\n                t.teD = Timeout(self.timerD, 32.0, 1, t)\n                if scode >= 300:\n                    # Black magick to allow proxy send us another INVITE with diffetent branch\n                    del self.tserver[t.tid]\n                    t.tid = list(t.tid)\n                    t.tid.append(t.branch)\n                    t.tid = tuple(t.tid)\n                    self.tserver[t.tid] = t\n                # Install retransmit timer if necessary\n                t.tout = 0.5\n                t.teA = Timeout(self.timerA, t.tout, 1, t)\n            else:\n                # We have done with the transaction\n                del self.tserver[t.tid]\n                t.cleanup()\n\n    def doCancel(self, t, rtime = None, req = None):\n        if rtime == None:\n            rtime = time()\n        if t.r487 != None:\n            self.sendResponse(t.r487, t, True)\n        if t.cancel_cb != None:\n            t.cancel_cb(rtime, req)\n\n    def timerD(self, t):\n        #print 'timerD'\n        t.teD = None\n        if t.teA != None:\n            t.teA.cancel()\n            t.teA = None\n        if t.noack_cb != None and t.state != CONFIRMED:\n            t.noack_cb()\n        del self.tserver[t.tid]\n        t.cleanup()\n\n    def timerE(self, t):\n        #print 'timerE'\n        t.teE = None\n        if t.teF != None:\n            t.teF.cancel()\n            t.teF = None\n        if t.state in (TRYING, RINGING):\n            if t.r487 != None:\n                t.r487.reason = 'Request Expired'\n            self.doCancel(t)\n\n    # Timer to retransmit the last provisional reply every\n    # 2 seconds\n    def timerF(self, t):\n        #print 'timerF', t.state\n        t.teF = None\n        if t.state == RINGING and self.provisional_retr > 0:\n            self.transmitData(t.userv, t.data, t.address)\n            t.teF = Timeout(self.timerF, self.provisional_retr, 1, t)\n\n    def rCachePurge(self):\n        self.l2rcache = self.l1rcache\n        self.l1rcache = {}\n        self.l4r.rotateCache()\n\n    def transmitMsg(self, userv, msg, address, cachesum, compact = False):\n        data = msg.localStr(userv.laddress[0], userv.laddress[1], compact)\n        self.transmitData(userv, data, address, cachesum)\n\n    def transmitData(self, userv, data, address, cachesum = None):\n        userv.send_to(data, address)\n        self.global_config['_sip_logger'].write('SENDING message to %s:%d:\\n' % address, data)\n        if cachesum != None:\n            self.l1rcache[cachesum] = (userv, data, address)\nsippy/CCEvents.py\nclass CCEventRing(CCEventGeneric):\n    name = 'CCEventRing'\n    pass\n", "answers": ["            self.acctA = RadiusAccounting(self.global_config, 'answer', \\"], "pred": "  Code: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ", "length": 7126, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "3cd8fefa66ffe61edf15dd8ce125f6e4933fb96d398da6b5"}
{"prompt": "Please complete the code given below. \nsrc/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass Signature(SubPacket):\n    __typeid__ = -1\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass Features(FlagEnum):\n    ModificationDetection = 0x01\n\n    @classproperty\n    def pgpy_features(cls):\n        return Features.ModificationDetection\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyFlags(FlagEnum):\n    #: Signifies that a key may be used to certify keys and user ids. Primary keys always have this, even if it is not specified.\n    Certify = 0x01\n    #: Signifies that a key may be used to sign messages and documents.\n    Sign = 0x02\n    #: Signifies that a key may be used to encrypt messages.\n    EncryptCommunications = 0x04\n    #: Signifies that a key may be used to encrypt storage. Currently equivalent to :py:obj:`~pgpy.constants.EncryptCommunications`.\n    EncryptStorage = 0x08\n    #: Signifies that the private component of a given key may have been split by a secret-sharing mechanism. Split\n    #: keys are not currently supported by PGPy.\n    Split = 0x10\n    #: Signifies that a key may be used for authentication.\n    Authentication = 0x20\n    #: Signifies that the private component of a key may be in the possession of more than one person.\n    MultiPerson = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyServerPreferences(IntEnum):\n    Unknown = 0x00\n    NoModify = 0x80\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass EmbeddedSignatureHeader(VersionedHeader):\n    def __bytearray__(self):\n        return bytearray([self.version])\n\n    def parse(self, packet):\n        self.tag = 2\n        super(EmbeddedSignatureHeader, self).parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass NotationDataFlags(FlagEnum):\n    HumanReadable = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationReason(IntEnum):\n    #: No reason was specified. This is the default reason.\n    NotSpecified = 0x00\n    #: The key was superseded by a new key. Only meaningful when revoking a key.\n    Superseded = 0x01\n    #: Key material has been compromised. Only meaningful when revoking a key.\n    Compromised = 0x02\n    #: Key is retired and no longer used. Only meaningful when revoking a key.\n    Retired = 0x03\n    #: User ID information is no longer valid. Only meaningful when revoking a certification of a user id.\n    UserID = 0x20\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationKeyClass(FlagEnum):\n    Sensitive = 0x40\n    Normal = 0x80\nimport binascii\nimport calendar\nimport six\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom .types import EmbeddedSignatureHeader\nfrom .types import Signature\nfrom ...constants import CompressionAlgorithm\nfrom ...constants import Features as _Features\nfrom ...constants import HashAlgorithm\nfrom ...constants import KeyFlags as _KeyFlags\nfrom ...constants import KeyServerPreferences as _KeyServerPreferences\nfrom ...constants import NotationDataFlags\nfrom ...constants import PubKeyAlgorithm\nfrom ...constants import RevocationKeyClass\nfrom ...constants import RevocationReason\nfrom ...constants import SymmetricKeyAlgorithm\nfrom ...decorators import sdproperty\nfrom ...types import Fingerprint\n        from ..packets import SignatureV4\n\"\"\" signature.py\n\nSignature SubPackets\n\"\"\"\n\n\n\n\n\n\n\n\n__all__ = ['URI',\n           'FlagList',\n           'ByteFlag',\n           'Boolean',\n           'CreationTime',\n           'SignatureExpirationTime',\n           'ExportableCertification',\n           'TrustSignature',\n           'RegularExpression',\n           'Revocable',\n           'KeyExpirationTime',\n           'PreferredSymmetricAlgorithms',\n           'RevocationKey',\n           'Issuer',\n           'NotationData',\n           'PreferredHashAlgorithms',\n           'PreferredCompressionAlgorithms',\n           'KeyServerPreferences',\n           'PreferredKeyServer',\n           'PrimaryUserID',\n           'Policy',\n           'KeyFlags',\n           'SignersUserID',\n           'ReasonForRevocation',\n           'Features',\n           'EmbeddedSignature']\n\n\nclass URI(Signature):\nNext line of code:\n", "input": "import binascii\nimport calendar\nimport six\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom .types import EmbeddedSignatureHeader\nfrom .types import Signature\nfrom ...constants import CompressionAlgorithm\nfrom ...constants import Features as _Features\nfrom ...constants import HashAlgorithm\nfrom ...constants import KeyFlags as _KeyFlags\nfrom ...constants import KeyServerPreferences as _KeyServerPreferences\nfrom ...constants import NotationDataFlags\nfrom ...constants import PubKeyAlgorithm\nfrom ...constants import RevocationKeyClass\nfrom ...constants import RevocationReason\nfrom ...constants import SymmetricKeyAlgorithm\nfrom ...decorators import sdproperty\nfrom ...types import Fingerprint\n        from ..packets import SignatureV4\n\"\"\" signature.py\n\nSignature SubPackets\n\"\"\"\n\n\n\n\n\n\n\n\n__all__ = ['URI',\n           'FlagList',\n           'ByteFlag',\n           'Boolean',\n           'CreationTime',\n           'SignatureExpirationTime',\n           'ExportableCertification',\n           'TrustSignature',\n           'RegularExpression',\n           'Revocable',\n           'KeyExpirationTime',\n           'PreferredSymmetricAlgorithms',\n           'RevocationKey',\n           'Issuer',\n           'NotationData',\n           'PreferredHashAlgorithms',\n           'PreferredCompressionAlgorithms',\n           'KeyServerPreferences',\n           'PreferredKeyServer',\n           'PrimaryUserID',\n           'Policy',\n           'KeyFlags',\n           'SignersUserID',\n           'ReasonForRevocation',\n           'Features',\n           'EmbeddedSignature']\n\n\nclass URI(Signature):\n", "context": "src/leap/mx/vendor/pgpy/constants.py\nclass PubKeyAlgorithm(IntEnum):\n    Invalid = 0x00\n    #: Signifies that a key is an RSA key.\n    RSAEncryptOrSign = 0x01\n    RSAEncrypt = 0x02  # deprecated\n    RSASign = 0x03     # deprecated\n    #: Signifies that a key is an ElGamal key.\n    ElGamal = 0x10\n    #: Signifies that a key is a DSA key.\n    DSA = 0x11\n    #: Signifies that a key is an ECDH key.\n    ECDH = 0x12\n    #: Signifies that a key is an ECDSA key.\n    ECDSA = 0x13\n    FormerlyElGamalEncryptOrSign = 0x14  # deprecated - do not generate\n    # DiffieHellman = 0x15  # X9.42\n\n    @property\n    def can_gen(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign,\n                        PubKeyAlgorithm.DSA,\n                        PubKeyAlgorithm.ECDSA,\n                        PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_encrypt(self):  # pragma: no cover\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.ElGamal, PubKeyAlgorithm.ECDH}\n\n    @property\n    def can_sign(self):\n        return self in {PubKeyAlgorithm.RSAEncryptOrSign, PubKeyAlgorithm.DSA, PubKeyAlgorithm.ECDSA}\n\n    @property\n    def deprecated(self):\n        return self in {PubKeyAlgorithm.RSAEncrypt,\n                        PubKeyAlgorithm.RSASign,\n                        PubKeyAlgorithm.FormerlyElGamalEncryptOrSign}\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass Signature(SubPacket):\n    __typeid__ = -1\nsrc/leap/mx/vendor/pgpy/constants.py\nclass SymmetricKeyAlgorithm(IntEnum):\n    \"\"\"Supported symmetric key algorithms.\"\"\"\n    Plaintext = 0x00\n    #: .. warning::\n    #:     IDEA is insecure. PGPy only allows it to be used for decryption, not encryption!\n    IDEA = 0x01\n    #: Triple-DES with 168-bit key derived from 192\n    TripleDES = 0x02\n    #: CAST5 (or CAST-128) with 128-bit key\n    CAST5 = 0x03\n    #: Blowfish with 128-bit key and 16 rounds\n    Blowfish = 0x04\n    #: AES with 128-bit key\n    AES128 = 0x07\n    #: AES with 192-bit key\n    AES192 = 0x08\n    #: AES with 256-bit key\n    AES256 = 0x09\n    # Twofish with 256-bit key - not currently supported\n    Twofish256 = 0x0A\n    #: Camellia with 128-bit key\n    Camellia128 = 0x0B\n    #: Camellia with 192-bit key\n    Camellia192 = 0x0C\n    #: Camellia with 256-bit key\n    Camellia256 = 0x0D\n\n    @property\n    def cipher(self):\n        bs = {SymmetricKeyAlgorithm.IDEA: algorithms.IDEA,\n              SymmetricKeyAlgorithm.TripleDES: algorithms.TripleDES,\n              SymmetricKeyAlgorithm.CAST5: algorithms.CAST5,\n              SymmetricKeyAlgorithm.Blowfish: algorithms.Blowfish,\n              SymmetricKeyAlgorithm.AES128: algorithms.AES,\n              SymmetricKeyAlgorithm.AES192: algorithms.AES,\n              SymmetricKeyAlgorithm.AES256: algorithms.AES,\n              SymmetricKeyAlgorithm.Twofish256: namedtuple('Twofish256', ['block_size'])(block_size=128),\n              SymmetricKeyAlgorithm.Camellia128: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia192: algorithms.Camellia,\n              SymmetricKeyAlgorithm.Camellia256: algorithms.Camellia}\n\n        if self in bs:\n            return bs[self]\n\n        raise NotImplementedError(repr(self))\n\n    @property\n    def is_insecure(self):\n        insecure_ciphers = {SymmetricKeyAlgorithm.IDEA}\n        return self in insecure_ciphers\n\n    @property\n    def block_size(self):\n        return self.cipher.block_size\n\n    @property\n    def key_size(self):\n        ks = {SymmetricKeyAlgorithm.IDEA: 128,\n              SymmetricKeyAlgorithm.TripleDES: 192,\n              SymmetricKeyAlgorithm.CAST5: 128,\n              SymmetricKeyAlgorithm.Blowfish: 128,\n              SymmetricKeyAlgorithm.AES128: 128,\n              SymmetricKeyAlgorithm.AES192: 192,\n              SymmetricKeyAlgorithm.AES256: 256,\n              SymmetricKeyAlgorithm.Twofish256: 256,\n              SymmetricKeyAlgorithm.Camellia128: 128,\n              SymmetricKeyAlgorithm.Camellia192: 192,\n              SymmetricKeyAlgorithm.Camellia256: 256}\n\n        if self in ks:\n            return ks[self]\n\n        raise NotImplementedError(repr(self))\n\n    def gen_iv(self):\n        return os.urandom(self.block_size // 8)\n\n    def gen_key(self):\n        return os.urandom(self.key_size // 8)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass HashAlgorithm(IntEnum):\n    Invalid = 0x00\n    MD5 = 0x01\n    SHA1 = 0x02\n    RIPEMD160 = 0x03\n    _reserved_1 = 0x04\n    _reserved_2 = 0x05\n    _reserved_3 = 0x06\n    _reserved_4 = 0x07\n    SHA256 = 0x08\n    SHA384 = 0x09\n    SHA512 = 0x0A\n    SHA224 = 0x0B\n\n    def __init__(self, *args):\n        super(self.__class__, self).__init__()\n        self._tuned_count = 0\n\n    @property\n    def hasher(self):\n        return hashlib.new(self.name)\n\n    @property\n    def digest_size(self):\n        return self.hasher.digest_size\n\n    @property\n    def tuned_count(self):\n        if self._tuned_count == 0:\n            self.tune_count()\n\n        return self._tuned_count\n\n    def tune_count(self):\n        start = end = 0\n        htd = _hashtunedata[:]\n\n        while start == end:\n            # potentially do this multiple times in case the resolution of time.time is low enough that\n            # hashing 100 KiB isn't enough time to produce a measurable difference\n            # (e.g. if the timer for time.time doesn't have enough precision)\n            htd = htd + htd\n            h = self.hasher\n\n            start = time.time()\n            h.update(htd)\n            end = time.time()\n\n        # now calculate how many bytes need to be hashed to reach our expected time period\n        # GnuPG tunes for about 100ms, so we'll do that as well\n        _TIME = 0.100\n        ct = int(len(htd) * (_TIME / (end - start)))\n        c1 = ((ct >> (ct.bit_length() - 5)) - 16)\n        c2 = (ct.bit_length() - 11)\n        c = ((c2 << 4) + c1)\n\n        # constrain self._tuned_count to be between 0 and 255\n        self._tuned_count = max(min(c, 255), 0)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass CompressionAlgorithm(IntEnum):\n    #: No compression\n    Uncompressed = 0x00\n    #: ZIP DEFLATE\n    ZIP = 0x01\n    #: ZIP DEFLATE with zlib headers\n    ZLIB = 0x02\n    #: Bzip2\n    BZ2 = 0x03\n\n    def compress(self, data):\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.compress(data)[2:-4]\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.compress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.compress(data)\n\n        raise NotImplementedError(self)\n\n    def decompress(self, data):\n        if six.PY2:\n            data = bytes(data)\n\n        if self is CompressionAlgorithm.Uncompressed:\n            return data\n\n        if self is CompressionAlgorithm.ZIP:\n            return zlib.decompress(data, -15)\n\n        if self is CompressionAlgorithm.ZLIB:\n            return zlib.decompress(data)\n\n        if self is CompressionAlgorithm.BZ2:\n            return bz2.decompress(data)\n\n        raise NotImplementedError(self)\nsrc/leap/mx/vendor/pgpy/types.py\nclass Fingerprint(str):\n    \"\"\"\n    A subclass of ``str``. Can be compared using == and != to ``str``, ``unicode``, and other :py:obj:`Fingerprint` instances.\n\n    Primarily used as a key for internal dictionaries, so it ignores spaces when comparing and hashing\n    \"\"\"\n    @property\n    def keyid(self):\n        return str(self).replace(' ', '')[-16:]\n\n    @property\n    def shortid(self):\n        return str(self).replace(' ', '')[-8:]\n\n    def __new__(cls, content):\n        if isinstance(content, Fingerprint):\n            return content\n\n        # validate input before continuing: this should be a string of 40 hex digits\n        content = content.upper().replace(' ', '')\n        if not bool(re.match(r'^[A-F0-9]{40}$', content)):\n            raise ValueError(\"Expected: String of 40 hex digits\")\n\n        # store in the format: \"AAAA BBBB CCCC DDDD EEEE  FFFF 0000 1111 2222 3333\"\n        #                                               ^^ note 2 spaces here\n        spaces = [ ' ' if i != 4 else '  ' for i in range(10) ]\n        chunks = [ ''.join(g) for g in six.moves.zip_longest(*[iter(content)] * 4) ]\n        content = ''.join(j for i in six.moves.zip_longest(chunks, spaces, fillvalue='') for j in i).strip()\n\n        return str.__new__(cls, content)\n\n    def __eq__(self, other):\n        if isinstance(other, Fingerprint):\n            return str(self) == str(other)\n\n        if isinstance(other, (six.text_type, bytes, bytearray)):\n            if isinstance(other, (bytes, bytearray)):  # pragma: no cover\n                other = other.decode('latin-1')\n\n            other = str(other).replace(' ', '')\n            return any([self.replace(' ', '') == other,\n                        self.keyid == other,\n                        self.shortid == other])\n\n        return False  # pragma: no cover\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self):\n        return hash(str(self.replace(' ', '')))\n\n    def __bytes__(self):\n        return binascii.unhexlify(six.b(self.replace(' ', '')))\nsrc/leap/mx/vendor/pgpy/constants.py\nclass Features(FlagEnum):\n    ModificationDetection = 0x01\n\n    @classproperty\n    def pgpy_features(cls):\n        return Features.ModificationDetection\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyFlags(FlagEnum):\n    #: Signifies that a key may be used to certify keys and user ids. Primary keys always have this, even if it is not specified.\n    Certify = 0x01\n    #: Signifies that a key may be used to sign messages and documents.\n    Sign = 0x02\n    #: Signifies that a key may be used to encrypt messages.\n    EncryptCommunications = 0x04\n    #: Signifies that a key may be used to encrypt storage. Currently equivalent to :py:obj:`~pgpy.constants.EncryptCommunications`.\n    EncryptStorage = 0x08\n    #: Signifies that the private component of a given key may have been split by a secret-sharing mechanism. Split\n    #: keys are not currently supported by PGPy.\n    Split = 0x10\n    #: Signifies that a key may be used for authentication.\n    Authentication = 0x20\n    #: Signifies that the private component of a key may be in the possession of more than one person.\n    MultiPerson = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass KeyServerPreferences(IntEnum):\n    Unknown = 0x00\n    NoModify = 0x80\nsrc/leap/mx/vendor/pgpy/decorators.py\ndef sdproperty(fget):\n    def defset(obj, val):  # pragma: no cover\n        raise TypeError(str(val.__class__))\n\n    class SDProperty(property):\n        def register(self, cls=None, fset=None):\n            return self.fset.register(cls, fset)\n\n        def setter(self, fset):\n            self.register(object, fset)\n            return type(self)(self.fget, self.fset, self.fdel, self.__doc__)\n\n    return SDProperty(fget, sdmethod(defset))\nsrc/leap/mx/vendor/pgpy/packet/subpackets/types.py\nclass EmbeddedSignatureHeader(VersionedHeader):\n    def __bytearray__(self):\n        return bytearray([self.version])\n\n    def parse(self, packet):\n        self.tag = 2\n        super(EmbeddedSignatureHeader, self).parse(packet)\nsrc/leap/mx/vendor/pgpy/constants.py\nclass NotationDataFlags(FlagEnum):\n    HumanReadable = 0x80\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationReason(IntEnum):\n    #: No reason was specified. This is the default reason.\n    NotSpecified = 0x00\n    #: The key was superseded by a new key. Only meaningful when revoking a key.\n    Superseded = 0x01\n    #: Key material has been compromised. Only meaningful when revoking a key.\n    Compromised = 0x02\n    #: Key is retired and no longer used. Only meaningful when revoking a key.\n    Retired = 0x03\n    #: User ID information is no longer valid. Only meaningful when revoking a certification of a user id.\n    UserID = 0x20\nsrc/leap/mx/vendor/pgpy/constants.py\nclass RevocationKeyClass(FlagEnum):\n    Sensitive = 0x40\n    Normal = 0x80\n", "answers": ["    @sdproperty"], "pred": "0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x0x", "length": 1318, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ea34735f9ac205293023394877d630555a04b487a2cf6036"}
{"prompt": "Please complete the code given below. \nequip/analysis/constraint/expr.py\nclass Expr(Expression):\n  \"\"\"\n    The ``Expr`` object with helpers for sub-classes. It also derives\n    from ``ast.expr.Expression``.\n  \"\"\"\n  UNKNOWN = 1\n  CONSTANT = 2\n  REFERENCE = 3\n  OPERATOR = 4\n  COMPARATOR = 5\n  UNDEFINED = 6\n\n  CAST_TYPE_BOOLEAN = 1\n  CAST_TYPE_INTEGER = 2\n  CAST_TYPE_NUMBER = 3\n  CAST_TYPE_STRING = 4\n  CAST_TYPE_UNKNOWN = 5\n\n  def __init__(self, kind=UNKNOWN, data=None, terminal=False, binary=False):\n    Expression.__init__(self)\n    self._kind = kind\n    self._data = data\n    self._ast = None\n    self._terminal = terminal\n    self._binary = binary\n    self._cast_type = Expr.CAST_TYPE_UNKNOWN\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @ast.setter\n  def ast(self, value):\n    self._ast = value\n\n  @property\n  def cast_type(self):\n    return self._cast_type\n\n  @cast_type.setter\n  def cast_type(self, value):\n    self._cast_type = value\n\n  @property\n  def terminal(self):\n    return self._terminal\n\n  @terminal.setter\n  def terminal(self, value):\n    self._terminal = value\n\n  @property\n  def binary(self):\n    return self._binary\n\n  @binary.setter\n  def binary(self, value):\n    self._binary = value\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Expr(kind=%s, data=%s)' % (self.kind, repr(self.data))\nequip/analysis/constraint/expr.py\nCMP_IMPLICIT_NOT_EMPTY = 12\nequip/utils/log.py\nLOGGING_FMT = '%(asctime)s - %(levelname)3s] %(filename)s::%(funcName)s(%(lineno)d) - %(message)s'\ndef removeOtherHandlers(to_keep=None):\ndef enableLogger(to_file=None):\nequip/analysis/constraint/expr.py\nCMP_TYPE_CHECK = 13\nequip/analysis/graph/graphs.py\nclass TreeNode(object):\n  GLOBAL_COUNTER = 0\n\n  def __init__(self, kind=None, data=None):\n    TreeNode.GLOBAL_COUNTER += 1\n    self._id = TreeNode.GLOBAL_COUNTER\n    self._kind = kind\n    self._data = data\n    self._children = list()\n\n  @property\n  def gid(self):\n    return self._id\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def children(self):\n    return self._children\n\n  def has_children(self):\n    return len(self._children) > 0\n\n  def num_children(self):\n    return len(self._children)\n\n  @property\n  def first_child(self):\n    return self._children[0]\n\n  @property\n  def last_child(self):\n    return self._children[len(self._children) - 1]\n\n  def child(self, n):\n    return self._children[n]\n\n  def reserve_children(self, number_children):\n    self._children = [None] * number_children\n\n  def insert_child(self, n, child):\n    self._children[n] = child\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, TreeNode) and obj.gid == self.gid\n\n  def __hash__(self):\n    return hash('treenode-' + str(self.gid))\n\n  def __repr__(self):\n    return 'TreeNode%d(kind=%s, data=%s, num_children=%d)'  \\\n           % (self.gid, repr(self.kind), repr(self.data), self.num_children())\nequip/analysis/constraint/expr.py\nclass Ref(Expr):\n  \"\"\"\n    Reference to a variable, function call, etc.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.REFERENCE, data, terminal=True, binary=False)\n    self._is_var = False\n    self._is_function_call = False\n\n  @property\n  def is_var(self):\n    return self._is_var\n\n  @is_var.setter\n  def is_var(self, value):\n    self._is_var = value\n\n  @property\n  def is_function_call(self):\n    return self._is_function_call\n\n  @is_function_call.setter\n  def is_function_call(self, value):\n    self._is_function_call = value\n\n  @staticmethod\n  def fromName(arg):\n    return Ref(data=arg)\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Ref) and self.data == obj.data\n\n  def __repr__(self):\n    return 'Ref(%s)' % self.data\nequip/analysis/constraint/expr.py\nclass Comparator(Expr):\n  \"\"\"\n    A comparator operator for expressions.\n  \"\"\"\n  def __init__(self, data=None, cmp_id=None, commutative=False, binary=True):\n    Expr.__init__(self, Expr.COMPARATOR, data, terminal=False, binary=binary)\n    self._cmp_id = cmp_id\n    self._commutative = commutative\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def cmp_id(self):\n    return self._cmp_id\n\n  @cmp_id.setter\n  def cmp_id(self, value):\n    self._cmp_id = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Comparator(**CMP_MAP[arg])\n\n  @staticmethod\n  def fromKind(kind):\n    return Comparator(**CMP_MAP[CMP_REPR[kind]])\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Comparator):\n      return False\n    if self.cmp_id != obj.cmp_id:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    if not self.binary:\n      return '(%s %s)' % (CMP_REPR[self.cmp_id], repr(self.rhs))\n    return '(%s %s %s)' % (repr(self.lhs), CMP_REPR[self.cmp_id], repr(self.rhs))\nequip/analysis/constraint/expr.py\nCMP_MAP = {\n  '<': { 'cmp_id': CMP_LESS_THAN, 'commutative': False },\n  '<=' : { 'cmp_id': CMP_LESS_THAN_EQUAL, 'commutative': False },\n  '==': { 'cmp_id': CMP_EQUAL, 'commutative': True },\n  '!=' : { 'cmp_id': CMP_NOT_EQUAL, 'commutative': True },\n  '>': { 'cmp_id': CMP_GREATER_THAN, 'commutative': False },\n  '>=' : { 'cmp_id': CMP_GREATER_THAN_EQUAL, 'commutative': False },\n  'in': { 'cmp_id': CMP_IN, 'commutative': False },\n  'not in' : { 'cmp_id': CMP_NOT_IN, 'commutative': False },\n  'is': { 'cmp_id': CMP_IS, 'commutative': True },\n  'is not' : { 'cmp_id': CMP_IS_NOT, 'commutative': True },\n  'exception match': { 'cmp_id': CMP_EX_MATCH, 'commutative': False },\n  'not empty': { 'cmp_id': CMP_IMPLICIT_NOT_EMPTY, 'commutative': False, 'binary': False },\n  'typeof': { 'cmp_id': CMP_TYPE_CHECK, 'commutative': False },\n}\nequip/analysis/constraint/expr.py\nclass Undef(Expr):\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.UNDEFINED, data, terminal=True, binary=False)\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Undef'\nequip/analysis/constraint/expr.py\nOP_MAP = {\n  opcode.opmap['UNARY_POSITIVE']: {'binary': False, 'commutative': False, 'char': '+' },\n  opcode.opmap['UNARY_NEGATIVE']: {'binary': False, 'commutative': False, 'char': '-' },\n  opcode.opmap['UNARY_NOT']: {'binary': False, 'commutative': False, 'char': 'not' },\n  opcode.opmap['UNARY_CONVERT']: {'binary': False, 'commutative': False, 'char': '`__rhs__`' },\n  opcode.opmap['UNARY_INVERT']: {'binary': False, 'commutative': False, 'char': '~' },\n  opcode.opmap['BINARY_POWER']: {'binary': True, 'commutative': False, 'char': '**' },\n  opcode.opmap['BINARY_MULTIPLY']: {'binary': True, 'commutative': True, 'char': '*' },\n  opcode.opmap['BINARY_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_MODULO']: {'binary': True, 'commutative': False, 'char': '%' },\n  opcode.opmap['BINARY_ADD']: {'binary': True, 'commutative': True, 'char': '+' },\n  opcode.opmap['BINARY_SUBTRACT']: {'binary': True, 'commutative': False, 'char': '-' },\n  opcode.opmap['BINARY_SUBSCR']: {'binary': True, 'commutative': False, 'char': '__lhs__[__rhs__]' },\n  opcode.opmap['BINARY_FLOOR_DIVIDE']: {'binary': True, 'commutative': False, 'char': '//' },\n  opcode.opmap['BINARY_TRUE_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_LSHIFT']: {'binary': True, 'commutative': False, 'char': '<<' },\n  opcode.opmap['BINARY_RSHIFT']: {'binary': True, 'commutative': False, 'char': '>>' },\n  opcode.opmap['BINARY_AND']: {'binary': True, 'commutative': True, 'char': '&' },\n  opcode.opmap['BINARY_XOR']: {'binary': True, 'commutative': True, 'char': '^' },\n  opcode.opmap['BINARY_OR']: {'binary': True, 'commutative': True, 'char': '|' },\n  BINARY_TYPE_CAST_BOOL: {'binary': False, 'commutative': False, 'char': 'bool(__rhs__)' },\n  BINARY_TYPE_CAST_INT: {'binary': False, 'commutative': False, 'char': 'int(__rhs__)' },\n  BINARY_TYPE_CAST_FLOAT: {'binary': False, 'commutative': False, 'char': 'float(__rhs__)' },\n  BINARY_TYPE_CAST_CHAR: {'binary': False, 'commutative': False, 'char': 'chr(__rhs__)' },\n  BINARY_TYPE_CAST_STRING : {'binary': False, 'commutative': False, 'char': 'str(__rhs__)' },\n  BINARY_TYPE_CAST_TUPLE : {'binary': False, 'commutative': False, 'char': 'tuple(__rhs__)' },\n}\nequip/analysis/graph/graphs.py\nclass Tree(object):\n  def __init__(self):\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n\n  def to_dot(self):\n    from .io import DotConverter\n    return DotConverter.process(self)\nequip/analysis/constraint/expr.py\nclass Const(Expr):\n  \"\"\"\n    Constant expression with best-effort strong typing.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.CONSTANT, data, terminal=True, binary=False)\n    self._is_none = False\n    self._is_boolean = False\n    self._is_integer = False\n    self._is_string = False\n    self._is_container = False\n    self._is_symbol = False\n\n  @property\n  def is_none(self):\n    return self._is_none\n\n  @is_none.setter\n  def is_none(self, value):\n    self._is_none = value\n\n  @property\n  def is_boolean(self):\n    return self._is_boolean\n\n  @is_boolean.setter\n  def is_boolean(self, value):\n    self._is_boolean = value\n\n  @property\n  def boolean_value(self):\n    if self.is_boolean:\n      return self.data == 'True'\n    return None\n\n  @property\n  def is_integer(self):\n    return self._is_integer\n\n  @is_integer.setter\n  def is_integer(self, value):\n    self._is_integer = value\n\n  @property\n  def integer_value(self):\n    if self.is_integer:\n      return int(self.data)\n    return None\n\n  @property\n  def is_string(self):\n    return self._is_string\n\n  @is_string.setter\n  def is_string(self, value):\n    self._is_string = value\n\n  @property\n  def string_value(self):\n    if self.is_string:\n      return self.data\n    return None\n\n  @property\n  def is_container(self):\n    return self._is_container\n\n  @is_container.setter\n  def is_container(self, value):\n    self._is_container = value\n\n  def container_value(self):\n    if self.is_container:\n      return self.data\n    return None\n\n  @property\n  def is_symbol(self):\n    return self._is_symbol\n\n  @is_symbol.setter\n  def is_symbol(self, value):\n    self._is_symbol = value\n\n  @staticmethod\n  def fromValue(arg, is_symbol=False):\n    c = Const(data=arg)\n    if arg is None:\n      c.is_none = True\n    elif isinstance(arg, basestring):\n      c.is_string = True\n    elif isinstance(arg, bool):\n      c.is_boolean = True\n    elif isinstance(arg, int) or isinstance(arg, long):\n      c.is_integer = True\n    elif isinstance(arg, tuple):\n      c.is_container = True\n\n    if is_symbol:\n      c.is_symbol = True\n    return c\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Const) and self.data == obj.data\n\n  def __repr__(self):\n    if self.is_symbol:\n      return 'Symbol(%s)' % repr(self.data)\n    return 'Const(%s)' % repr(self.data)\nequip/analysis/constraint/expr.py\nclass Operator(Expr):\n  \"\"\"\n    An operator for the current expression (e.g., PLUS, SUBSTRACT, etc.). The\n    comparison operator is commutativity-sensitive, but not w.r.t. distributivity.\n  \"\"\"\n  def __init__(self, data=None, binary=None, commutative=None, char=None, \\\n               lhs=None, rhs=None):\n    Expr.__init__(self, Expr.OPERATOR, data, terminal=False, binary=binary)\n    self._commutative = commutative\n    self._char = char\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Operator(**OP_MAP[op])\n\n  @staticmethod\n  def fromTypeMethod(method_name):\n    if method_name == 'int':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_INT])\n    elif method_name == 'float':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_FLOAT])\n    elif method_name == 'bool':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_BOOL])\n    elif method_name == 'str':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_STRING])\n    elif method_name == 'chr':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_CHAR])\n    elif method_name == 'tuple':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_TUPLE])\n    return None\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Operator):\n      return False\n    if self._char != obj._char:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    rr = ''\n    if not self.binary:\n      if '__rhs__' in self._char:\n        rr = self._char.replace('__rhs__', repr(self.rhs))\n      else:\n        rr = self._char + repr(self.rhs)\n    else:\n      rr = self._char\n      if '__lhs__' in rr and '__rhs__' in rr:\n        for l in ('__rhs__', '__lhs__'):\n          hs = self.rhs if l == '__rhs__' else self.lhs\n          rr = rr.replace(l, repr(hs))\n      else:\n        rr = repr(self.lhs) + ' ' + self._char + ' ' + repr(self.rhs)\n    return \"(%s)\" % rr\nimport opcode\nfrom ...utils.log import logger\nfrom ..graph import Tree, TreeNode\nfrom .expr import Expr, Const, Ref, Comparator, Operator, Undef, \\\n                  CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK, OP_MAP, CMP_MAP\nfrom ..python.opcodes import *\n\"\"\"\n  equip.analysis.constraint.container\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n  Constraint container.\n\n  :copyright: (c) 2014 by Romain Gaucher (@rgaucher)\n  :license: Apache 2, see LICENSE for more details.\n\"\"\"\n\n\n\n\nclass Constraint(object):\n  \"\"\"\n    Represents a constraint in the bytecode. This is used to represent\n    conditional expressions. We store both the bytecode AST constraint\n    and a final internal representation (can be used to compare constraints\n    or generate SMT clauses).\n  \"\"\"\n  def __init__(self):\n    self._ast = Tree()\n    self._cstr = None\n    self._live = None\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n    self._ast.root = self._root\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @property\n  def live(self):\n    if self._live is None:\n      self._live = set()\n      worklist = [self.tree]\n      while worklist:\n        cur = worklist.pop(0)\n        if isinstance(cur, Ref):\n          self._live.add(cur.data)\n        else:\n          if not cur.terminal:\n            worklist.append(cur.rhs)\n            if cur.binary:\n              worklist.append(cur.lhs)\n\n    return self._live\n\n  @property\n  def tree(self):\n    if self._cstr is None:\n      self.__finalize()\n    return self._cstr\n\n  def has_comparator(self, cmp_kind):\n    worklist = [self.tree]\n    while worklist:\n      cur = worklist.pop(0)\n      logger.debug(\"Cur := %s\", cur)\n      if isinstance(cur, Comparator):\n        if cur.cmp_id == cmp_kind:\n          return True\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n      elif isinstance(cur, Operator):\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n    return False\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Constraint) and self.tree == obj.tree\n\n\n  def __finalize(self):\n    root = self.root\n    self._cstr = None\n    if root.data[0] != COMPARE_OP:\n      self._cstr = Comparator.fromKind(CMP_IMPLICIT_NOT_EMPTY)\n    else:\n      self._cstr = Comparator.fromOpcode(*root.data)\n    self._cstr.data = root.data\n\n    def process_children(cstr_node, ast_node):\n      if ast_node.has_children() and cstr_node.terminal:\n        return\n\n      if not cstr_node.terminal:\n        if cstr_node.kind == Expr.COMPARATOR and cstr_node.cmp_id in (CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK):\n          if cstr_node.cmp_id == CMP_IMPLICIT_NOT_EMPTY:\n            cstr_node.rhs = convert_ast_constraint(ast_node)\n            process_children(cstr_node.rhs, ast_node)\n          else:\n            lhs_child = ast_node.first_child\n            cstr_node.lhs = convert_ast_constraint(lhs_child)\n            process_children(cstr_node.lhs, lhs_child)\n\n            if ast_node.num_children() > 1:\n              rhs_child = ast_node.child(1)\n              cstr_node.rhs = convert_ast_constraint(rhs_child)\n              process_children(cstr_node.rhs, rhs_child)\n        else:\n          expected_children_num = 2 if cstr_node.binary else 1\n          children = ast_node.children\n          num_children = len([c for c in children if c is not None])\n          if num_children != expected_children_num:\n            logger.debug(\"Consistency error. expected %d, got %d children for %s\",\n                         expected_children_num, num_children, ast_node)\nNext line of code:\n", "input": "import opcode\nfrom ...utils.log import logger\nfrom ..graph import Tree, TreeNode\nfrom .expr import Expr, Const, Ref, Comparator, Operator, Undef, \\\n                  CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK, OP_MAP, CMP_MAP\nfrom ..python.opcodes import *\n\"\"\"\n  equip.analysis.constraint.container\n  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n  Constraint container.\n\n  :copyright: (c) 2014 by Romain Gaucher (@rgaucher)\n  :license: Apache 2, see LICENSE for more details.\n\"\"\"\n\n\n\n\nclass Constraint(object):\n  \"\"\"\n    Represents a constraint in the bytecode. This is used to represent\n    conditional expressions. We store both the bytecode AST constraint\n    and a final internal representation (can be used to compare constraints\n    or generate SMT clauses).\n  \"\"\"\n  def __init__(self):\n    self._ast = Tree()\n    self._cstr = None\n    self._live = None\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n    self._ast.root = self._root\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @property\n  def live(self):\n    if self._live is None:\n      self._live = set()\n      worklist = [self.tree]\n      while worklist:\n        cur = worklist.pop(0)\n        if isinstance(cur, Ref):\n          self._live.add(cur.data)\n        else:\n          if not cur.terminal:\n            worklist.append(cur.rhs)\n            if cur.binary:\n              worklist.append(cur.lhs)\n\n    return self._live\n\n  @property\n  def tree(self):\n    if self._cstr is None:\n      self.__finalize()\n    return self._cstr\n\n  def has_comparator(self, cmp_kind):\n    worklist = [self.tree]\n    while worklist:\n      cur = worklist.pop(0)\n      logger.debug(\"Cur := %s\", cur)\n      if isinstance(cur, Comparator):\n        if cur.cmp_id == cmp_kind:\n          return True\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n      elif isinstance(cur, Operator):\n        worklist.append(cur.lhs)\n        if cur.rhs is not None:\n          worklist.append(cur.rhs)\n    return False\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Constraint) and self.tree == obj.tree\n\n\n  def __finalize(self):\n    root = self.root\n    self._cstr = None\n    if root.data[0] != COMPARE_OP:\n      self._cstr = Comparator.fromKind(CMP_IMPLICIT_NOT_EMPTY)\n    else:\n      self._cstr = Comparator.fromOpcode(*root.data)\n    self._cstr.data = root.data\n\n    def process_children(cstr_node, ast_node):\n      if ast_node.has_children() and cstr_node.terminal:\n        return\n\n      if not cstr_node.terminal:\n        if cstr_node.kind == Expr.COMPARATOR and cstr_node.cmp_id in (CMP_IMPLICIT_NOT_EMPTY, CMP_TYPE_CHECK):\n          if cstr_node.cmp_id == CMP_IMPLICIT_NOT_EMPTY:\n            cstr_node.rhs = convert_ast_constraint(ast_node)\n            process_children(cstr_node.rhs, ast_node)\n          else:\n            lhs_child = ast_node.first_child\n            cstr_node.lhs = convert_ast_constraint(lhs_child)\n            process_children(cstr_node.lhs, lhs_child)\n\n            if ast_node.num_children() > 1:\n              rhs_child = ast_node.child(1)\n              cstr_node.rhs = convert_ast_constraint(rhs_child)\n              process_children(cstr_node.rhs, rhs_child)\n        else:\n          expected_children_num = 2 if cstr_node.binary else 1\n          children = ast_node.children\n          num_children = len([c for c in children if c is not None])\n          if num_children != expected_children_num:\n            logger.debug(\"Consistency error. expected %d, got %d children for %s\",\n                         expected_children_num, num_children, ast_node)\n", "context": "equip/analysis/constraint/expr.py\nclass Expr(Expression):\n  \"\"\"\n    The ``Expr`` object with helpers for sub-classes. It also derives\n    from ``ast.expr.Expression``.\n  \"\"\"\n  UNKNOWN = 1\n  CONSTANT = 2\n  REFERENCE = 3\n  OPERATOR = 4\n  COMPARATOR = 5\n  UNDEFINED = 6\n\n  CAST_TYPE_BOOLEAN = 1\n  CAST_TYPE_INTEGER = 2\n  CAST_TYPE_NUMBER = 3\n  CAST_TYPE_STRING = 4\n  CAST_TYPE_UNKNOWN = 5\n\n  def __init__(self, kind=UNKNOWN, data=None, terminal=False, binary=False):\n    Expression.__init__(self)\n    self._kind = kind\n    self._data = data\n    self._ast = None\n    self._terminal = terminal\n    self._binary = binary\n    self._cast_type = Expr.CAST_TYPE_UNKNOWN\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def ast(self):\n    return self._ast\n\n  @ast.setter\n  def ast(self, value):\n    self._ast = value\n\n  @property\n  def cast_type(self):\n    return self._cast_type\n\n  @cast_type.setter\n  def cast_type(self, value):\n    self._cast_type = value\n\n  @property\n  def terminal(self):\n    return self._terminal\n\n  @terminal.setter\n  def terminal(self, value):\n    self._terminal = value\n\n  @property\n  def binary(self):\n    return self._binary\n\n  @binary.setter\n  def binary(self, value):\n    self._binary = value\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Expr(kind=%s, data=%s)' % (self.kind, repr(self.data))\nequip/analysis/constraint/expr.py\nCMP_IMPLICIT_NOT_EMPTY = 12\nequip/utils/log.py\nLOGGING_FMT = '%(asctime)s - %(levelname)3s] %(filename)s::%(funcName)s(%(lineno)d) - %(message)s'\ndef removeOtherHandlers(to_keep=None):\ndef enableLogger(to_file=None):\nequip/analysis/constraint/expr.py\nCMP_TYPE_CHECK = 13\nequip/analysis/graph/graphs.py\nclass TreeNode(object):\n  GLOBAL_COUNTER = 0\n\n  def __init__(self, kind=None, data=None):\n    TreeNode.GLOBAL_COUNTER += 1\n    self._id = TreeNode.GLOBAL_COUNTER\n    self._kind = kind\n    self._data = data\n    self._children = list()\n\n  @property\n  def gid(self):\n    return self._id\n\n  @property\n  def kind(self):\n    return self._kind\n\n  @kind.setter\n  def kind(self, value):\n    self._kind = value\n\n  @property\n  def data(self):\n    return self._data\n\n  @data.setter\n  def data(self, value):\n    self._data = value\n\n  @property\n  def children(self):\n    return self._children\n\n  def has_children(self):\n    return len(self._children) > 0\n\n  def num_children(self):\n    return len(self._children)\n\n  @property\n  def first_child(self):\n    return self._children[0]\n\n  @property\n  def last_child(self):\n    return self._children[len(self._children) - 1]\n\n  def child(self, n):\n    return self._children[n]\n\n  def reserve_children(self, number_children):\n    self._children = [None] * number_children\n\n  def insert_child(self, n, child):\n    self._children[n] = child\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, TreeNode) and obj.gid == self.gid\n\n  def __hash__(self):\n    return hash('treenode-' + str(self.gid))\n\n  def __repr__(self):\n    return 'TreeNode%d(kind=%s, data=%s, num_children=%d)'  \\\n           % (self.gid, repr(self.kind), repr(self.data), self.num_children())\nequip/analysis/constraint/expr.py\nclass Ref(Expr):\n  \"\"\"\n    Reference to a variable, function call, etc.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.REFERENCE, data, terminal=True, binary=False)\n    self._is_var = False\n    self._is_function_call = False\n\n  @property\n  def is_var(self):\n    return self._is_var\n\n  @is_var.setter\n  def is_var(self, value):\n    self._is_var = value\n\n  @property\n  def is_function_call(self):\n    return self._is_function_call\n\n  @is_function_call.setter\n  def is_function_call(self, value):\n    self._is_function_call = value\n\n  @staticmethod\n  def fromName(arg):\n    return Ref(data=arg)\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Ref) and self.data == obj.data\n\n  def __repr__(self):\n    return 'Ref(%s)' % self.data\nequip/analysis/constraint/expr.py\nclass Comparator(Expr):\n  \"\"\"\n    A comparator operator for expressions.\n  \"\"\"\n  def __init__(self, data=None, cmp_id=None, commutative=False, binary=True):\n    Expr.__init__(self, Expr.COMPARATOR, data, terminal=False, binary=binary)\n    self._cmp_id = cmp_id\n    self._commutative = commutative\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def cmp_id(self):\n    return self._cmp_id\n\n  @cmp_id.setter\n  def cmp_id(self, value):\n    self._cmp_id = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Comparator(**CMP_MAP[arg])\n\n  @staticmethod\n  def fromKind(kind):\n    return Comparator(**CMP_MAP[CMP_REPR[kind]])\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Comparator):\n      return False\n    if self.cmp_id != obj.cmp_id:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    if not self.binary:\n      return '(%s %s)' % (CMP_REPR[self.cmp_id], repr(self.rhs))\n    return '(%s %s %s)' % (repr(self.lhs), CMP_REPR[self.cmp_id], repr(self.rhs))\nequip/analysis/constraint/expr.py\nCMP_MAP = {\n  '<': { 'cmp_id': CMP_LESS_THAN, 'commutative': False },\n  '<=' : { 'cmp_id': CMP_LESS_THAN_EQUAL, 'commutative': False },\n  '==': { 'cmp_id': CMP_EQUAL, 'commutative': True },\n  '!=' : { 'cmp_id': CMP_NOT_EQUAL, 'commutative': True },\n  '>': { 'cmp_id': CMP_GREATER_THAN, 'commutative': False },\n  '>=' : { 'cmp_id': CMP_GREATER_THAN_EQUAL, 'commutative': False },\n  'in': { 'cmp_id': CMP_IN, 'commutative': False },\n  'not in' : { 'cmp_id': CMP_NOT_IN, 'commutative': False },\n  'is': { 'cmp_id': CMP_IS, 'commutative': True },\n  'is not' : { 'cmp_id': CMP_IS_NOT, 'commutative': True },\n  'exception match': { 'cmp_id': CMP_EX_MATCH, 'commutative': False },\n  'not empty': { 'cmp_id': CMP_IMPLICIT_NOT_EMPTY, 'commutative': False, 'binary': False },\n  'typeof': { 'cmp_id': CMP_TYPE_CHECK, 'commutative': False },\n}\nequip/analysis/constraint/expr.py\nclass Undef(Expr):\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.UNDEFINED, data, terminal=True, binary=False)\n\n  def __ne__(self, obj):\n    return True\n\n  def __eq__(self, obj):\n    return False\n\n  def __repr__(self):\n    return 'Undef'\nequip/analysis/constraint/expr.py\nOP_MAP = {\n  opcode.opmap['UNARY_POSITIVE']: {'binary': False, 'commutative': False, 'char': '+' },\n  opcode.opmap['UNARY_NEGATIVE']: {'binary': False, 'commutative': False, 'char': '-' },\n  opcode.opmap['UNARY_NOT']: {'binary': False, 'commutative': False, 'char': 'not' },\n  opcode.opmap['UNARY_CONVERT']: {'binary': False, 'commutative': False, 'char': '`__rhs__`' },\n  opcode.opmap['UNARY_INVERT']: {'binary': False, 'commutative': False, 'char': '~' },\n  opcode.opmap['BINARY_POWER']: {'binary': True, 'commutative': False, 'char': '**' },\n  opcode.opmap['BINARY_MULTIPLY']: {'binary': True, 'commutative': True, 'char': '*' },\n  opcode.opmap['BINARY_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_MODULO']: {'binary': True, 'commutative': False, 'char': '%' },\n  opcode.opmap['BINARY_ADD']: {'binary': True, 'commutative': True, 'char': '+' },\n  opcode.opmap['BINARY_SUBTRACT']: {'binary': True, 'commutative': False, 'char': '-' },\n  opcode.opmap['BINARY_SUBSCR']: {'binary': True, 'commutative': False, 'char': '__lhs__[__rhs__]' },\n  opcode.opmap['BINARY_FLOOR_DIVIDE']: {'binary': True, 'commutative': False, 'char': '//' },\n  opcode.opmap['BINARY_TRUE_DIVIDE']: {'binary': True, 'commutative': False, 'char': '/' },\n  opcode.opmap['BINARY_LSHIFT']: {'binary': True, 'commutative': False, 'char': '<<' },\n  opcode.opmap['BINARY_RSHIFT']: {'binary': True, 'commutative': False, 'char': '>>' },\n  opcode.opmap['BINARY_AND']: {'binary': True, 'commutative': True, 'char': '&' },\n  opcode.opmap['BINARY_XOR']: {'binary': True, 'commutative': True, 'char': '^' },\n  opcode.opmap['BINARY_OR']: {'binary': True, 'commutative': True, 'char': '|' },\n  BINARY_TYPE_CAST_BOOL: {'binary': False, 'commutative': False, 'char': 'bool(__rhs__)' },\n  BINARY_TYPE_CAST_INT: {'binary': False, 'commutative': False, 'char': 'int(__rhs__)' },\n  BINARY_TYPE_CAST_FLOAT: {'binary': False, 'commutative': False, 'char': 'float(__rhs__)' },\n  BINARY_TYPE_CAST_CHAR: {'binary': False, 'commutative': False, 'char': 'chr(__rhs__)' },\n  BINARY_TYPE_CAST_STRING : {'binary': False, 'commutative': False, 'char': 'str(__rhs__)' },\n  BINARY_TYPE_CAST_TUPLE : {'binary': False, 'commutative': False, 'char': 'tuple(__rhs__)' },\n}\nequip/analysis/graph/graphs.py\nclass Tree(object):\n  def __init__(self):\n    self._root = None\n\n  @property\n  def root(self):\n    return self._root\n\n  @root.setter\n  def root(self, value):\n    self._root = value\n\n  def to_dot(self):\n    from .io import DotConverter\n    return DotConverter.process(self)\nequip/analysis/constraint/expr.py\nclass Const(Expr):\n  \"\"\"\n    Constant expression with best-effort strong typing.\n  \"\"\"\n  def __init__(self, data=None):\n    Expr.__init__(self, Expr.CONSTANT, data, terminal=True, binary=False)\n    self._is_none = False\n    self._is_boolean = False\n    self._is_integer = False\n    self._is_string = False\n    self._is_container = False\n    self._is_symbol = False\n\n  @property\n  def is_none(self):\n    return self._is_none\n\n  @is_none.setter\n  def is_none(self, value):\n    self._is_none = value\n\n  @property\n  def is_boolean(self):\n    return self._is_boolean\n\n  @is_boolean.setter\n  def is_boolean(self, value):\n    self._is_boolean = value\n\n  @property\n  def boolean_value(self):\n    if self.is_boolean:\n      return self.data == 'True'\n    return None\n\n  @property\n  def is_integer(self):\n    return self._is_integer\n\n  @is_integer.setter\n  def is_integer(self, value):\n    self._is_integer = value\n\n  @property\n  def integer_value(self):\n    if self.is_integer:\n      return int(self.data)\n    return None\n\n  @property\n  def is_string(self):\n    return self._is_string\n\n  @is_string.setter\n  def is_string(self, value):\n    self._is_string = value\n\n  @property\n  def string_value(self):\n    if self.is_string:\n      return self.data\n    return None\n\n  @property\n  def is_container(self):\n    return self._is_container\n\n  @is_container.setter\n  def is_container(self, value):\n    self._is_container = value\n\n  def container_value(self):\n    if self.is_container:\n      return self.data\n    return None\n\n  @property\n  def is_symbol(self):\n    return self._is_symbol\n\n  @is_symbol.setter\n  def is_symbol(self, value):\n    self._is_symbol = value\n\n  @staticmethod\n  def fromValue(arg, is_symbol=False):\n    c = Const(data=arg)\n    if arg is None:\n      c.is_none = True\n    elif isinstance(arg, basestring):\n      c.is_string = True\n    elif isinstance(arg, bool):\n      c.is_boolean = True\n    elif isinstance(arg, int) or isinstance(arg, long):\n      c.is_integer = True\n    elif isinstance(arg, tuple):\n      c.is_container = True\n\n    if is_symbol:\n      c.is_symbol = True\n    return c\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    return isinstance(obj, Const) and self.data == obj.data\n\n  def __repr__(self):\n    if self.is_symbol:\n      return 'Symbol(%s)' % repr(self.data)\n    return 'Const(%s)' % repr(self.data)\nequip/analysis/constraint/expr.py\nclass Operator(Expr):\n  \"\"\"\n    An operator for the current expression (e.g., PLUS, SUBSTRACT, etc.). The\n    comparison operator is commutativity-sensitive, but not w.r.t. distributivity.\n  \"\"\"\n  def __init__(self, data=None, binary=None, commutative=None, char=None, \\\n               lhs=None, rhs=None):\n    Expr.__init__(self, Expr.OPERATOR, data, terminal=False, binary=binary)\n    self._commutative = commutative\n    self._char = char\n    self._lhs = None\n    self._rhs = None\n\n  @property\n  def rhs(self):\n    return self._rhs\n\n  @rhs.setter\n  def rhs(self, value):\n    self._rhs = value\n\n  @property\n  def lhs(self):\n    return self._lhs\n\n  @lhs.setter\n  def lhs(self, value):\n    self._lhs = value\n\n  @property\n  def commutative(self):\n    return self._commutative\n\n  @commutative.setter\n  def commutative(self, value):\n    self._commutative = value\n\n  @staticmethod\n  def fromOpcode(op, arg):\n    return Operator(**OP_MAP[op])\n\n  @staticmethod\n  def fromTypeMethod(method_name):\n    if method_name == 'int':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_INT])\n    elif method_name == 'float':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_FLOAT])\n    elif method_name == 'bool':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_BOOL])\n    elif method_name == 'str':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_STRING])\n    elif method_name == 'chr':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_CHAR])\n    elif method_name == 'tuple':\n      return Operator(**OP_MAP[BINARY_TYPE_CAST_TUPLE])\n    return None\n\n  def __ne__(self, obj):\n    return not self == obj\n\n  def __eq__(self, obj):\n    if not isinstance(obj, Operator):\n      return False\n    if self._char != obj._char:\n      return False\n    if not self.commutative:\n      return self.lhs == obj.lhs and self.rhs == obj.rhs\n    else:\n      return (self.lhs == obj.lhs and self.rhs == obj.rhs) \\\n             or (self.lhs == obj.rhs and self.rhs == obj.lhs)\n\n  def __repr__(self):\n    rr = ''\n    if not self.binary:\n      if '__rhs__' in self._char:\n        rr = self._char.replace('__rhs__', repr(self.rhs))\n      else:\n        rr = self._char + repr(self.rhs)\n    else:\n      rr = self._char\n      if '__lhs__' in rr and '__rhs__' in rr:\n        for l in ('__rhs__', '__lhs__'):\n          hs = self.rhs if l == '__rhs__' else self.lhs\n          rr = rr.replace(l, repr(hs))\n      else:\n        rr = repr(self.lhs) + ' ' + self._char + ' ' + repr(self.rhs)\n    return \"(%s)\" % rr\n", "answers": ["            cstr_node.rhs = Undef(data=None)"], "pred": "  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n  Code:\n ", "length": 1751, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "0697cb04cdcd9172485f3f0398a5d0f1a9a8061972ff6197"}
{"prompt": "Please complete the code given below. \nsrc/main/java/ch/citux/td/data/model/TwitchChunks.java\npublic class TwitchChunks extends TwitchBase {\n\n    private List<TwitchChunk> live;\n\n    public List<TwitchChunk> getLive() {\n        return live;\n    }\n\n    public void setLive(List<TwitchChunk> live) {\n        this.live = live;\n    }\n}\nsrc/main/java/ch/citux/td/data/worker/TDBasicCallback.java\npublic abstract class TDBasicCallback<Result> implements TDCallback<Result> {\n\n    private Object caller;\n\n    protected TDBasicCallback(Object caller) {\n        this.caller = caller;\n    }\n\n    @Override\n    public void startLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).startLoading();\n        }\n    }\n\n    @Override\n    public void stopLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).stopLoading();\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).onError(title, message);\n        }\n    }\n}\nsrc/main/java/net/chilicat/m3u8/ParseException.java\npublic class ParseException extends Exception {\n    private final String line;\n    private final int lineNumber;\n\n    public ParseException(String line, int lineNumber, Throwable cause) {\n        super(cause);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public ParseException(String line, int lineNumber, String message) {\n        super(message);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public String getLine() {\n        return line;\n    }\n\n    public int getLineNumber() {\n        return lineNumber;\n    }\n\n    @Override\n    public String getMessage() {\n        return \"Error at line \" + getLineNumber() + \": \" + getLine() + \"\\n\" + super.getMessage();    //To change body of overridden methods use File | Settings | File Templates.\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchBroadcast.java\npublic class TwitchBroadcast extends TwitchBase {\n\n    private String api_id;\n    private String increment_view_count_url;\n    private String path;\n    private String broadcaster_software;\n    private String channel;\n    private String preview_small;\n    private String preview;\n    private TwitchChunks chunks;\n    private long duration;\n    private long start_offset;\n    private long end_offset;\n    private long play_offset;\n    private long vod_ad_frequency;\n    private long vod_ad_length;\n\n    public String getApi_id() {\n        return api_id;\n    }\n\n    public void setApi_id(String api_id) {\n        this.api_id = api_id;\n    }\n\n    public String getIncrement_view_count_url() {\n        return increment_view_count_url;\n    }\n\n    public void setIncrement_view_count_url(String increment_view_count_url) {\n        this.increment_view_count_url = increment_view_count_url;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public String getBroadcaster_software() {\n        return broadcaster_software;\n    }\n\n    public void setBroadcaster_software(String broadcaster_software) {\n        this.broadcaster_software = broadcaster_software;\n    }\n\n    public String getChannel() {\n        return channel;\n    }\n\n    public void setChannel(String channel) {\n        this.channel = channel;\n    }\n\n    public String getPreview_small() {\n        return preview_small;\n    }\n\n    public void setPreview_small(String preview_small) {\n        this.preview_small = preview_small;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public TwitchChunks getChunks() {\n        return chunks;\n    }\n\n    public void setChunks(TwitchChunks chunks) {\n        this.chunks = chunks;\n    }\n\n    public long getDuration() {\n        return duration;\n    }\n\n    public void setDuration(long duration) {\n        this.duration = duration;\n    }\n\n    public long getStart_offset() {\n        return start_offset;\n    }\n\n    public void setStart_offset(long start_offset) {\n        this.start_offset = start_offset;\n    }\n\n    public long getEnd_offset() {\n        return end_offset;\n    }\n\n    public void setEnd_offset(long end_offset) {\n        this.end_offset = end_offset;\n    }\n\n    public long getPlay_offset() {\n        return play_offset;\n    }\n\n    public void setPlay_offset(long play_offset) {\n        this.play_offset = play_offset;\n    }\n\n    public long getVod_ad_frequency() {\n        return vod_ad_frequency;\n    }\n\n    public void setVod_ad_frequency(long vod_ad_frequency) {\n        this.vod_ad_frequency = vod_ad_frequency;\n    }\n\n    public long getVod_ad_length() {\n        return vod_ad_length;\n    }\n\n    public void setVod_ad_length(long vod_ad_length) {\n        this.vod_ad_length = vod_ad_length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchVideo.java\npublic class TwitchVideo extends TwitchBase {\n\n    private String _id;\n    private String title;\n    private String description;\n    private long broadcast_id;\n    private Date recorded_at;\n    private String game;\n    private long length;\n    private String preview;\n    private String url;\n    private long views;\n    private TwitchChannel channel;\n\n    public String get_id() {\n        return _id;\n    }\n\n    public void set_id(String _id) {\n        this._id = _id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public long getBroadcast_id() {\n        return broadcast_id;\n    }\n\n    public void setBroadcast_id(long broadcast_id) {\n        this.broadcast_id = broadcast_id;\n    }\n\n    public Date getRecorded_at() {\n        return recorded_at;\n    }\n\n    public void setRecorded_at(Date recorded_at) {\n        this.recorded_at = recorded_at;\n    }\n\n    public String getGame() {\n        return game;\n    }\n\n    public void setGame(String game) {\n        this.game = game;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public long getViews() {\n        return views;\n    }\n\n    public void setViews(long views) {\n        this.views = views;\n    }\n\n    public TwitchChannel getChannel() {\n        return channel;\n    }\n\n    public void setChannel(TwitchChannel channel) {\n        this.channel = channel;\n    }\n}\nsrc/main/java/ch/citux/td/ui/dialogs/ErrorDialogFragment.java\npublic class ErrorDialogFragment extends DialogFragment {\n\n    private static final String FRAGMENT_TAG = \"ErrorDialogFragment\";\n    private static final String BUNDLE_TITLE = \"title\";\n    private static final String BUNDLE_MESSAGE = \"message\";\n    private DialogInterface.OnClickListener mOnClickListener;\n    private OnCancelListener mOnCancelListener;\n\n    private static ErrorDialogFragment newInstance(String title, String message,\n                                                   DialogInterface.OnClickListener onClickListener, OnCancelListener onCancelListener) {\n        ErrorDialogFragment dialogFragment = new ErrorDialogFragment();\n        dialogFragment.mOnClickListener = onClickListener;\n\n        Bundle args = new Bundle();\n        args.putString(BUNDLE_TITLE, title);\n        args.putString(BUNDLE_MESSAGE, message);\n        dialogFragment.setArguments(args);\n\n        return dialogFragment;\n    }\n\n    public static void dismiss(FragmentActivity activity) {\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\n        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n        Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n        if (prev != null) {\n            fragmentTransaction.remove(prev);\n        }\n        fragmentTransaction.commit();\n    }\n\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        Bundle args = getArguments();\n        AlertDialog.Builder b = new AlertDialog.Builder(getActivity());\n        b.setTitle(args.getString(BUNDLE_TITLE));\n        b.setMessage(args.getString(BUNDLE_MESSAGE));\n        setCancelable(true);\n        b.setNeutralButton(getActivity().getString(android.R.string.ok), mOnClickListener);\n        return b.create();\n    }\n\n    @Override\n    public void onCancel(DialogInterface dialog) {\n        if (mOnCancelListener != null) {\n            mOnCancelListener.onCancel();\n        }\n    }\n\n    public interface OnCancelListener {\n        public void onCancel();\n    }\n\n    public static class ErrorDialogFragmentBuilder {\n        private FragmentActivity mActivity;\n        private String mTitle;\n        private String mMessage;\n        private DialogInterface.OnClickListener mOnClickListener;\n        private OnCancelListener mOnCancelListener;\n\n        public ErrorDialogFragmentBuilder(FragmentActivity activity) {\n            if (activity != null) {\n                mActivity = activity;\n                mTitle = activity.getString(R.string.dialog_error_title);\n            }\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(int resId) {\n            mTitle = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(String text) {\n            mTitle = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(int resId) {\n            mMessage = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(String text) {\n            mMessage = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnClickListener(DialogInterface.OnClickListener onClickListener) {\n            mOnClickListener = onClickListener;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnCancelListener(OnCancelListener onCancelListener) {\n            mOnCancelListener = onCancelListener;\n            return this;\n        }\n\n        public void show() {\n            FragmentManager fragmentManager = mActivity.getSupportFragmentManager();\n            FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n            Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n            if (prev != null) {\n                fragmentTransaction.remove(prev);\n            }\n            fragmentTransaction.addToBackStack(null);\n\n            ErrorDialogFragment.newInstance(mTitle, mMessage, mOnClickListener, mOnCancelListener)\n                    .show(fragmentManager, FRAGMENT_TAG);\n        }\n    }\n}\nsrc/main/java/ch/citux/td/ui/TDActivity.java\npublic class TDActivity extends ActionBarActivity implements TDCallback<TwitchChannel>, View.OnFocusChangeListener, AdapterView.OnItemClickListener {\n\n    private FavoritesFragment favoritesFragment;\n    private GameOverviewFragment gameOverviewFragment;\n    private GameStreamsFragment gameStreamsFragment;\n    private ChannelFragment channelFragment;\n    private SearchFragment searchFragment;\n    private VideoFragment videoFragment;\n    private SettingsFragment settingsFragment;\n\n    private ActionBarDrawerToggle toggle;\n    private MenuItem refreshItem;\n    private MenuItem searchItem;\n    private View refreshView;\n    private String username;\n    private Toast toast;\n    private boolean isLoading;\n    private boolean hasUsername;\n\n    @InjectView(R.id.user) View user;\n    @InjectView(R.id.toolbar) Toolbar toolbar;\n    @InjectView(R.id.imgUser) ImageView imgUser;\n    @InjectView(R.id.lblUser) TextView lblUser;\n    @InjectView(R.id.lblNoUser) TextView lblNoUser;\n    @Optional @InjectView(R.id.drawerLayout) DrawerLayout drawerLayout;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.main);\n        ButterKnife.inject(this);\n\n        Context contextThemeWrapper = new ContextThemeWrapper(this, R.style.Theme_TD_Light);\n        LayoutInflater inflater = LayoutInflater.from(this).cloneInContext(contextThemeWrapper);\n        refreshView = inflater.inflate(R.layout.action_refresh, null);\n\n        initNavigation();\n        updateUser();\n\n        if (favoritesFragment == null) {\n            Bundle args = new Bundle();\n            args.putBoolean(TDConfig.SETTINGS_CHANNEL_NAME, hasUsername);\n\n            favoritesFragment = new FavoritesFragment();\n            favoritesFragment.setArgs(args);\n\n            getSupportFragmentManager()\n                    .beginTransaction()\n                    .add(R.id.content, favoritesFragment)\n                    .commit();\n        } else {\n            replaceFragment(favoritesFragment);\n        }\n    }\n\n    private void initNavigation() {\n        toolbar.setLogo(R.drawable.twitch_logo_white);\n        toolbar.setLogoDescription(R.string.app_name);\n        setSupportActionBar(toolbar);\n\n        if (drawerLayout != null) {\n            toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.navigation_open, R.string.navigation_close);\n            toggle.setDrawerIndicatorEnabled(true);\n            drawerLayout.setDrawerListener(toggle);\n        }\n\n        ListView lstNav = (ListView) findViewById(R.id.lstNav);\n        lstNav.setAdapter(new ArrayAdapter<>(this, R.layout.list_item_navigation, getResources().getStringArray(R.array.navigation)));\n        lstNav.setOnItemClickListener(this);\n    }\n\n    public void updateUser() {\n        username = PreferenceManager.getDefaultSharedPreferences(this).getString(TDConfig.SETTINGS_CHANNEL_NAME, \"\");\n        hasUsername = !username.equals(\"\");\n\n        if (hasUsername) {\n            user.setVisibility(View.VISIBLE);\n            lblUser.setText(username);\n            lblNoUser.setVisibility(View.GONE);\n\n            TDTaskManager.executeTask(this);\n        } else {\n            user.setVisibility(View.GONE);\n            lblNoUser.setVisibility(View.VISIBLE);\n            imgUser.setImageResource(R.drawable.default_channel_logo_medium);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n        if (drawerLayout != null) {\n            toggle.syncState();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        refreshData();\n    }\n\n    private void replaceFragment(Fragment fragment) {\n        replaceFragment(fragment, true);\n    }\n\n    private void replaceFragment(Fragment fragment, boolean backstack) {\n        if (fragment != null && !fragment.isAdded()) {\n            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\n            transaction.replace(R.id.content, fragment);\n            if (backstack) {\n                transaction.addToBackStack(null);\n            }\n            transaction.commitAllowingStateLoss();\n        }\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {\n            String query = intent.getStringExtra(SearchManager.QUERY);\n\n            if (searchFragment == null) {\n                searchFragment = new SearchFragment();\n            }\n            searchFragment.setQuery(query);\n            searchFragment.loadData();\n\n            replaceFragment(searchFragment);\n            Log.d(this, query);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        TDTaskManager.cancelAllTasks();\n        super.onPause();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.main, menu);\n\n        refreshItem = menu.findItem(R.id.menu_refresh);\n        searchItem = menu.findItem(R.id.menu_search);\n\n        // Associate searchable configuration with the SearchView\n        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);\n        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);\n        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));\n        searchView.setOnQueryTextFocusChangeListener(this);\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_refresh:\n                if (!isLoading) {\n                    refreshData();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    public void showChannel(TwitchChannel channel) {\n        if (channelFragment == null) {\n            channelFragment = new ChannelFragment();\n        }\n\n        if (channelFragment.isAdded()) {\n            channelFragment.updateChannel(channel);\n        } else {\n            Bundle arguments = new Bundle();\n            arguments.putSerializable(ChannelFragment.CHANNEL, channel);\n            channelFragment.setArgs(arguments);\n            replaceFragment(channelFragment);\n        }\n    }\n\n    public void showVideo(Bundle args) {\n        if (videoFragment == null) {\n            videoFragment = new VideoFragment();\n        }\n        videoFragment.setArgs(args);\n\n        if (videoFragment.isAdded()) {\n            videoFragment.playVideo();\n        } else {\n            replaceFragment(videoFragment);\n        }\n        MenuItemCompat.collapseActionView(searchItem);\n    }\n\n    public void showPlaylist(TwitchBroadcast broadcast) {\n        if (channelFragment.isAdded()) {\n            channelFragment.showPlaylist(broadcast);\n        }\n    }\n\n    public void showStreams(Bundle args) {\n        if (gameStreamsFragment == null) {\n            gameStreamsFragment = new GameStreamsFragment();\n        }\n        gameStreamsFragment.setArgs(args);\n        replaceFragment(gameStreamsFragment);\n    }\n\n    public void startLoading() {\n        isLoading = true;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, refreshView);\n        }\n    }\n\n    public void stopLoading() {\n        isLoading = false;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, null);\n        }\n    }\n\n    @Override\n    public TwitchChannel startRequest() {\n        return TDServiceImpl.getInstance().getChannel(username);\n    }\n\n    @Override\n    public void onResponse(TwitchChannel response) {\n        if (response != null) {\n            Picasso.with(this)\n                    .load(response.getLogo().getUrl(TwitchLogo.Size.MEDIUM))\n                    .placeholder(R.drawable.default_channel_logo_medium)\n                    .into(imgUser);\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        toast = Toast.makeText(this, title + \": \" + message, Toast.LENGTH_SHORT);\n        toast.show();\n    }\n\n    @Override\n    public boolean isAdded() {\n        return true;\n    }\n\n    @Override\n    public void setTitle(int titleId) {\n        super.setTitle(titleId);\n        if (toolbar != null) {\n            toolbar.setTitle(titleId);\n        }\n    }\n\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    protected void refreshData() {\n        if (favoritesFragment != null && favoritesFragment.isAdded()) {\n            favoritesFragment.refreshData();\n        }\n        if (channelFragment != null && channelFragment.isAdded()) {\n            channelFragment.refreshData();\n        }\n        if (searchFragment != null && searchFragment.isAdded()) {\n            searchFragment.refreshData();\n        }\n        if (gameOverviewFragment != null && gameOverviewFragment.isAdded()) {\n            gameOverviewFragment.refreshData();\n        }\n        if (gameStreamsFragment != null && gameStreamsFragment.isAdded()) {\n            gameStreamsFragment.refreshData();\n        }\n    }\n\n    @Override\n    public void onFocusChange(View view, boolean queryTextFocused) {\n        if (!queryTextFocused) {\n            MenuItemCompat.collapseActionView(searchItem);\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (drawerLayout != null && drawerLayout.isDrawerOpen(Gravity.START)) {\n            drawerLayout.closeDrawers();\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n        switch (position) {\n            case 0:\n                if (favoritesFragment == null) {\n                    favoritesFragment = new FavoritesFragment();\n                }\n                replaceFragment(favoritesFragment);\n                break;\n            case 1:\n                if (gameOverviewFragment == null) {\n                    gameOverviewFragment = new GameOverviewFragment();\n                }\n                replaceFragment(gameOverviewFragment);\n                break;\n            case 2:\n                if (settingsFragment == null) {\n                    settingsFragment = new SettingsFragment();\n                }\n                replaceFragment(settingsFragment);\n                break;\n        }\n        if (drawerLayout != null) {\n            drawerLayout.closeDrawers();\n        }\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchChunk.java\npublic class TwitchChunk extends TwitchBase {\n\n    private String url;\n    private String vod_count_url;\n    private String upkeep;\n    private long length;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getVod_count_url() {\n        return vod_count_url;\n    }\n\n    public void setVod_count_url(String vod_count_url) {\n        this.vod_count_url = vod_count_url;\n    }\n\n    public String getUpkeep() {\n        return upkeep;\n    }\n\n    public void setUpkeep(String upkeep) {\n        this.upkeep = upkeep;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchStreamQuality.java\npublic class TwitchStreamQuality extends TwitchBase {\n\n    private String key;\n    private String name;\n    private int value;\n\n    public TwitchStreamQuality(String key, int value) {\n        this(key, value, key);\n    }\n\n    public TwitchStreamQuality(String key, int value, String name) {\n        this.key = key;\n        this.value = value;\n        this.name = name;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nsrc/main/java/ch/citux/td/ui/adapter/PlaylistAdapter.java\npublic class PlaylistAdapter extends BaseAdapter {\n\n    private LayoutInflater inflater;\n    private List<TwitchChunk> videos;\n    private ArrayList<Integer> played;\n\n    public PlaylistAdapter(Context context, List<TwitchChunk> videos) {\n        super();\n        this.inflater = LayoutInflater.from(context);\n        this.videos = videos;\n        this.played = new ArrayList<Integer>(videos.size());\n    }\n\n    public void setVideos(List<TwitchChunk> videos) {\n        this.videos = videos;\n        if (videos != null && videos.size() > 0) {\n            notifyDataSetChanged();\n        } else {\n            notifyDataSetInvalidated();\n        }\n    }\n\n    public void setPlayed(int position) {\n        played.add(position);\n    }\n\n    @Override\n    public int getCount() {\n        return videos.size();\n    }\n\n    @Override\n    public TwitchChunk getItem(int position) {\n        if (position < videos.size()) {\n            return videos.get(position);\n        }\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        TwitchChunk video = getItem(position);\n        ViewHolder holder;\n        if (convertView == null || convertView.getTag() == null) {\n            holder = new ViewHolder();\n            convertView = inflater.inflate(R.layout.list_item_playlist, parent, false);\n            if (convertView != null) {\n                ButterKnife.inject(holder, convertView);\n            }\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        holder.lblPartIndex.setText(String.valueOf(position + 1));\n        holder.lblPartCount.setText(String.valueOf(getCount()));\n        //TODO holder.lblTitle.setText(video.());\n        holder.chkPlayed.setChecked(played.contains(position));\n        return convertView;\n    }\n\n    class ViewHolder {\n        @InjectView(R.id.lblPartIndex) TextView lblPartIndex;\n        @InjectView(R.id.lblPartCount) TextView lblPartCount;\n        @InjectView(R.id.lblTitle) TextView lblTitle;\n        @InjectView(R.id.chkPlayed) CheckBox chkPlayed;\n    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/VideoFragment.java\npublic class VideoFragment extends TDFragment {//implements MediaPlayer.OnPreparedListener {\n\n    public static final String PLAYLIST = \"playlist\";\n    public static final String TITLE = \"title\";\n    public static final String URL = \"url\";\n\n    @InjectView(android.R.id.empty) EmptyView emptyView;\n    //    @InjectView(R.id.videoView) VideoView videoView;\n    @InjectView(R.id.player) View player;\n    @InjectView(R.id.chat) View chat;\n\n    @Override\n    protected int onCreateView() {\n        return R.layout.video;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        super.setRetainInstance(true);\n\n//        if (((TDActivity) getActivity()).isTablet()) {\n//            emptyView.setImage(R.drawable.ic_glitchicon_white);\n//        }\n\n//        MediaController mediaController = new MediaController(getActivity());\n//        videoView.setMediaController(mediaController);\n//        videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1);\n//        videoView.setOnPreparedListener(this);\n//\n//        onOrientationChange(getResources().getConfiguration().orientation);\n//\n//        playVideo();\n    }\n\n    @Override\n    public void loadData() {\n\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n\n        getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        getSupportActionBar().show();\n    }\n\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n\n//        onOrientationChange(newConfig.orientation);\n    }\n\n    private void onOrientationChange(int orientation) {\n//        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n//            getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().hide();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_STRETCH, 1.77f);\n//            chat.setVisibility(View.GONE);\n//        } else {\n//            getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().show();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1.77f);\n//            chat.setVisibility(View.VISIBLE);\n//        }\n    }\n\n    public void playVideo() {\n\n//        getActivity().setVolumeControlStream(AudioManager.STREAM_MUSIC);\n//        if (getArguments() != null && (!getArguments().containsKey(URL) || !getArguments().containsKey(CHUNKS))) {\n//            getSupportActionBar().setTitle(getArguments().getString(TITLE));\n//\n//            if (getArguments().containsKey(URL)) {\n//                videoView.setVideoURI(Uri.parse(getArguments().getString(URL)));\n//            }\n//            if (getArguments().containsKey(CHUNKS)) {\n//                videoView.setVideoPlaylist(getArguments().getStringArray(CHUNKS));\n//            }\n//            videoView.start();\n//        }\n    }\n\n    @Override\n    public Object startRequest() {\n        return null;\n    }\n\n    @Override\n    public void onResponse(Object response) {\n\n    }\n\n//    @Override\n//    public void onPrepared(MediaPlayer mp) {\n//        emptyView.setVisibility(View.GONE);\n//        player.setVisibility(View.VISIBLE);\n//    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/TDBase.java\npublic interface TDBase {\n\n    public void loadData();\n\n    public void startActivity(Intent intent);\n\n    public SharedPreferences getDefaultSharedPreferences();\n\n    public boolean isAdded();\n\n    public TDActivity getTDActivity();\n\n    public void setArgs(Bundle args);\n\n    public Bundle getArgs();\n}\nsrc/main/java/net/chilicat/m3u8/Element.java\npublic interface Element {\n\n    public String getTitle();\n\n\n    public int getDuration();\n\n    /**\n     * URI to media or playlist.\n     *\n     * @return the URI.\n     */\n    public URI getURI();\n\n    /**\n     * Media can be encrypted.\n     *\n     * @return true if media encrypted.\n     */\n    public boolean isEncrypted();\n\n    /**\n     * Element can be another playlist.\n     *\n     * @return true if element a playlist.\n     */\n    public boolean isPlayList();\n\n    /**\n     * Element is a media file.\n     *\n     * @return true if element a media file and not a playlist.\n     */\n    public boolean isMedia();\n\n    /**\n     * If media is encryped than will this method return a info object.\n     *\n     * @return the info object or null if media not encrypted.\n     */\n    public EncryptionInfo getEncryptionInfo();\n\n    /**\n     * If element a playlist than this method will return a PlaylistInfo object.\n     *\n     * @return a info object or null in case of element is not a playlist.\n     */\n    public PlaylistInfo getPlayListInfo();\n\n    /**\n     * The program date.\n     *\n     * @return -1 in case of program date is not set.\n     */\n    public long getProgramDate();\n\n}\nsrc/main/java/net/chilicat/m3u8/Playlist.java\npublic final class Playlist implements Iterable<Element> {\n\n    public static Playlist parse(Readable readable) throws ParseException {\n        if (readable == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return PlaylistParser.create(PlaylistType.M3U8).parse(readable);\n    }\n\n    public static Playlist parse(String playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new StringReader(playlist));\n    }\n\n    public static Playlist parse(InputStream playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new InputStreamReader(playlist));\n    }\n\n    public static Playlist parse(ReadableByteChannel playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(makeReadable(playlist));\n    }\n\n    private static Readable makeReadable(ReadableByteChannel source) {\n        if (source == null) {\n            throw new NullPointerException(\"source\");\n        }\n\n\n        return Channels.newReader(source,\n                java.nio.charset.Charset.defaultCharset().name());\n    }\n\n    private final List<Element> elements;\n    private final boolean endSet;\n    private final int targetDuration;\n    private int mediaSequenceNumber;\n\n    Playlist(List<Element> elements, boolean endSet, int targetDuration, int mediaSequenceNumber) {\n        if (elements == null) {\n            throw new NullPointerException(\"elements\");\n        }\n        this.targetDuration = targetDuration;\n        this.elements = elements;\n        this.endSet = endSet;\n        this.mediaSequenceNumber = mediaSequenceNumber;\n    }\n\n    public int getTargetDuration() {\n        return targetDuration;\n    }\n\n    public Iterator<Element> iterator() {\n        return elements.iterator();\n    }\n\n    public List<Element> getElements() {\n        return elements;\n    }\n\n    public boolean isEndSet() {\n        return endSet;\n    }\n\n    public int getMediaSequenceNumber() {\n        return mediaSequenceNumber;\n    }\n\n    @Override\n    public String toString() {\n        return \"PlayListImpl{\" +\n                \"elements=\" + elements +\n                \", endSet=\" + endSet +\n                \", targetDuration=\" + targetDuration +\n                \", mediaSequenceNumber=\" + mediaSequenceNumber +\n                '}';\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchAccessToken.java\npublic class TwitchAccessToken extends TwitchBase {\n\n    private String token;\n    private String sig;\n    private String p;\n    private boolean mobile_restricted;\n\n    public String getToken() {\n        return token;\n    }\n\n    public void setToken(String token) {\n        this.token = token;\n    }\n\n    public String getSig() {\n        return sig;\n    }\n\n    public void setSig(String sig) {\n        this.sig = sig;\n    }\n\n    public String getP() {\n        return p;\n    }\n\n    public void setP(String p) {\n        this.p = p;\n    }\n\n    public boolean isMobile_restricted() {\n        return mobile_restricted;\n    }\n\n    public void setMobile_restricted(boolean mobile_restricted) {\n        this.mobile_restricted = mobile_restricted;\n    }\n}\nsrc/main/java/ch/citux/td/config/TDConfig.java\npublic class TDConfig {\n\n    public static final String SETTINGS_CHANNEL_NAME = \"channel_name\";\n    public static final String SETTINGS_LICENSE_DIALOG = \"license_dialog\";\n    public static final String SETTINGS_STREAM_QUALITY = \"stream_quality\";\n\n    public static final String CAST_APPLICATION_ID = \"D25E1BBE\";\n    public static final String KRAKEN_CLIENT_ID = \"sx9d3whtcht2lhrtd6yjia8rv019wxi\";\n\n    public static final String UTF_8 = \"UTF-8\";\n\n    public static final String MIME_FLV = \"video/x-flv\";\n    public static final String MIME_TWITCH = \"application/vnd.twitchtv.v3+json\";\n\n    public static final String URL_API_TWITCH_KRAKEN_BASE = \"https://api.twitch.tv/kraken\";\n    public static final String URL_API_TWITCH_API_BASE = \"https://api.twitch.tv/api\";\n    public static final String URL_API_USHER_BASE = \"http://usher.twitch.tv\";\n\n}\nsrc/main/java/ch/citux/td/data/service/TDServiceImpl.java\npublic class TDServiceImpl implements TwitchAPI, TwitchKraken, TwitchUsher, RestAdapter.Log {\n\n    private static final String TAG = \"TDService\";\n\n    private static TDServiceImpl instance;\n\n    private TwitchAPI twitchAPI;\n    private TwitchUsher twitchUsher;\n    private TwitchKraken twitchKraken;\n\n    private TDServiceImpl() {\n        RestAdapter.Builder builder = new RestAdapter.Builder()\n                .setLog(this)\n                .setLogLevel(BuildConfig.DEBUG ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE)\n                .setConverter(new JacksonConverter());\n\n        RestAdapter apiAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_API_BASE)\n                .build();\n        RestAdapter usherAdapter = builder\n                .setEndpoint(TDConfig.URL_API_USHER_BASE)\n                .build();\n        RestAdapter krakenAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_KRAKEN_BASE)\n                .setRequestInterceptor(new KrakenRequestInterceptor())\n                .build();\n\n        twitchAPI = apiAdapter.create(TwitchAPI.class);\n        twitchUsher = usherAdapter.create(TwitchUsher.class);\n        twitchKraken = krakenAdapter.create(TwitchKraken.class);\n    }\n\n    public static TDServiceImpl getInstance() {\n        if (instance == null) {\n            instance = new TDServiceImpl();\n        }\n        return instance;\n    }\n\n    @Override\n    public void log(String message) {\n        Log.d(TAG, message);\n    }\n\n    private class KrakenRequestInterceptor implements RequestInterceptor {\n        @Override\n        public void intercept(RequestInterceptor.RequestFacade request) {\n            request.addHeader(\"Accept\", TDConfig.MIME_TWITCH);\n            request.addHeader(\"Client-ID\", TDConfig.KRAKEN_CLIENT_ID);\n        }\n    }\n\n    @Override\n    public TwitchFollows getFollows(String username, int offset) {\n        return twitchKraken.getFollows(username, offset);\n    }\n\n    @Override\n    public TwitchChannel getChannel(String channel) {\n        return twitchKraken.getChannel(channel);\n    }\n\n    @Override\n    public TwitchStream getStream(String channel) {\n        return twitchKraken.getStream(channel);\n    }\n\n    @Override\n    public TwitchStream getStreams(String game, int offset) {\n        return twitchKraken.getStreams(game, offset);\n    }\n\n    @Override\n    public TwitchVideos getVideos(String channel, int offset) {\n        return twitchKraken.getVideos(channel, offset);\n    }\n\n    @Override\n    public TwitchStream searchStreams(String query, int offset) {\n        return twitchKraken.searchStreams(query, offset);\n    }\n\n    @Override\n    public TwitchChannels searchChannels(String query, int offset) {\n        return twitchKraken.searchChannels(query, offset);\n    }\n\n    @Override\n    public TwitchGames getTopGames(int limit, int offset) {\n        return twitchKraken.getTopGames(limit, offset);\n    }\n\n    //TwitchAPI\n    @Override\n    public TwitchAccessToken getChannelToken(String channel) {\n        return twitchAPI.getChannelToken(channel);\n    }\n\n    @Override\n    public TwitchAccessToken getVodToken(@Path(\"videoId\") String videoId) {\n        return twitchAPI.getVodToken(videoId);\n    }\n\n    @Override\n    public TwitchBroadcast getVideoPlaylist(@Path(\"id\") String id) {\n        return twitchAPI.getVideoPlaylist(id);\n    }\n\n    //TwitchUsher\n    @Override\n    public Response getChannelPlaylist(String channel, String p, String token, String sig) {\n        return twitchUsher.getChannelPlaylist(channel, p, token, sig);\n    }\n\n    @Override\n    public Response getVodPlaylist(@Path(\"videoId\") String videoId, @Query(\"p\") String p, @Query(\"token\") String token, @Query(\"sig\") String sig) {\n        return twitchUsher.getVodPlaylist(videoId, p, token, sig);\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchPlayList.java\npublic class TwitchPlayList extends TwitchBase {\n\n    public static final TwitchStreamQuality QUALITY_MOBILE = new TwitchStreamQuality(\"mobile\", 1);\n    public static final TwitchStreamQuality QUALITY_LOW = new TwitchStreamQuality(\"low\", 2);\n    public static final TwitchStreamQuality QUALITY_MEDIUM = new TwitchStreamQuality(\"medium\", 3);\n    public static final TwitchStreamQuality QUALITY_HIGH = new TwitchStreamQuality(\"high\", 4);\n    public static final TwitchStreamQuality QUALITY_CHUNKED = new TwitchStreamQuality(\"chunked\", 5, \"source\");\n\n    public static final TwitchStreamQuality[] SUPPORTED_QUALITIES = {\n            QUALITY_MOBILE,\n            QUALITY_LOW,\n            QUALITY_MEDIUM,\n            QUALITY_HIGH,\n            QUALITY_CHUNKED\n    };\n\n    private HashMap<TwitchStreamQuality, String> streams;\n\n    public static TwitchStreamQuality parseQuality(String name) {\n        for (TwitchStreamQuality quality : SUPPORTED_QUALITIES) {\n            if (quality.getName().equalsIgnoreCase(name) || quality.getKey().equalsIgnoreCase(name)) {\n                return quality;\n            }\n        }\n        return null;\n    }\n\n    public String getStream(TwitchStreamQuality quality) {\n        String url = streams.get(quality);\n        if (StringUtils.isEmpty(url)) {\n            url = getBestStream();\n        }\n        return url;\n    }\n\n    public String getBestStream() {\n        TwitchStreamQuality best = new TwitchStreamQuality(\"\", -1);\n\n        for (TwitchStreamQuality quality : streams.keySet()) {\n            if (best.getValue() < quality.getValue()) {\n                best = quality;\n            }\n        }\n\n        if (best.getValue() > -1) {\n            return getStream(best);\n        }\n        return null;\n    }\n\n    public HashMap<TwitchStreamQuality, String> getStreams() {\n        return streams;\n    }\n\n    public void setStreams(HashMap<TwitchStreamQuality, String> streams) {\n        this.streams = streams;\n    }\n}\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport net.chilicat.m3u8.Element;\nimport net.chilicat.m3u8.ParseException;\nimport net.chilicat.m3u8.Playlist;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport ch.citux.td.R;\nimport ch.citux.td.config.TDConfig;\nimport ch.citux.td.data.model.TwitchAccessToken;\nimport ch.citux.td.data.model.TwitchBroadcast;\nimport ch.citux.td.data.model.TwitchChunk;\nimport ch.citux.td.data.model.TwitchChunks;\nimport ch.citux.td.data.model.TwitchPlayList;\nimport ch.citux.td.data.model.TwitchStreamQuality;\nimport ch.citux.td.data.model.TwitchVideo;\nimport ch.citux.td.data.service.TDServiceImpl;\nimport ch.citux.td.data.worker.TDBasicCallback;\nimport ch.citux.td.ui.TDActivity;\nimport ch.citux.td.ui.adapter.PlaylistAdapter;\nimport ch.citux.td.ui.dialogs.ErrorDialogFragment;\nimport ch.citux.td.ui.fragments.TDBase;\nimport ch.citux.td.ui.fragments.VideoFragment;\nimport retrofit.client.Response;\n/*\n * Copyright 2013-2014 Paul St\u00f6hr\n *\n * This file is part of TD.\n *\n * TD is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage ch.citux.td.util;\n\n\n\n\n\npublic class VideoPlayer {\n\n    private static final String TAG = \"VideoPlayer\";\n\n    public static void playVideo(TDActivity activity, TwitchBroadcast broadcast) {\n        Log.d(TAG, \"Playing Playlist'\" + broadcast.getChannel() + \"' with \" + broadcast.getChunks().getLive().size() + \" parts\");\n\n        if (useInternPlayer(activity)) { //built-in Player\n            Bundle args = new Bundle();\n            args.putString(VideoFragment.TITLE, broadcast.getChannel());\n            args.putStringArray(VideoFragment.PLAYLIST, getPlaylistUrls(broadcast));\n            playVideoIntern(activity, args);\n        } else {\n            activity.showPlaylist(broadcast);\n        }\n    }\n\n    private static String[] getPlaylistUrls(TwitchBroadcast broadcast) {\n        if (broadcast != null && broadcast.getChunks() != null && broadcast.getChunks().getLive() != null) {\n            List<TwitchChunk> videos = broadcast.getChunks().getLive();\n            String[] urls = new String[videos.size()];\n            for (int i = 0; i < videos.size(); i++) {\n                urls[i] = videos.get(i).getUrl();\n            }\n            return urls;\n        }\n        return null;\n    }\n\n    public static void playVideo(TDActivity activity, String title, String url) {\n        if (activity != null) {\n            Log.d(TAG, \"Playing '\" + title + \"' from \" + url);\n\n            if (useInternPlayer(activity)) { //built-in Player\n                Log.d(TAG, \"internal\");\n                Bundle args = new Bundle();\n                args.putString(VideoFragment.TITLE, title);\n                args.putString(VideoFragment.URL, url);\n                playVideoIntern(activity, args);\n            } else { //external Player\n                Log.d(TAG, \"external\");\n\n                Intent intent = new Intent(Intent.ACTION_VIEW);Next line of code:\n", "input": "import android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport net.chilicat.m3u8.Element;\nimport net.chilicat.m3u8.ParseException;\nimport net.chilicat.m3u8.Playlist;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport ch.citux.td.R;\nimport ch.citux.td.config.TDConfig;\nimport ch.citux.td.data.model.TwitchAccessToken;\nimport ch.citux.td.data.model.TwitchBroadcast;\nimport ch.citux.td.data.model.TwitchChunk;\nimport ch.citux.td.data.model.TwitchChunks;\nimport ch.citux.td.data.model.TwitchPlayList;\nimport ch.citux.td.data.model.TwitchStreamQuality;\nimport ch.citux.td.data.model.TwitchVideo;\nimport ch.citux.td.data.service.TDServiceImpl;\nimport ch.citux.td.data.worker.TDBasicCallback;\nimport ch.citux.td.ui.TDActivity;\nimport ch.citux.td.ui.adapter.PlaylistAdapter;\nimport ch.citux.td.ui.dialogs.ErrorDialogFragment;\nimport ch.citux.td.ui.fragments.TDBase;\nimport ch.citux.td.ui.fragments.VideoFragment;\nimport retrofit.client.Response;\n/*\n * Copyright 2013-2014 Paul St\u00f6hr\n *\n * This file is part of TD.\n *\n * TD is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage ch.citux.td.util;\n\n\n\n\n\npublic class VideoPlayer {\n\n    private static final String TAG = \"VideoPlayer\";\n\n    public static void playVideo(TDActivity activity, TwitchBroadcast broadcast) {\n        Log.d(TAG, \"Playing Playlist'\" + broadcast.getChannel() + \"' with \" + broadcast.getChunks().getLive().size() + \" parts\");\n\n        if (useInternPlayer(activity)) { //built-in Player\n            Bundle args = new Bundle();\n            args.putString(VideoFragment.TITLE, broadcast.getChannel());\n            args.putStringArray(VideoFragment.PLAYLIST, getPlaylistUrls(broadcast));\n            playVideoIntern(activity, args);\n        } else {\n            activity.showPlaylist(broadcast);\n        }\n    }\n\n    private static String[] getPlaylistUrls(TwitchBroadcast broadcast) {\n        if (broadcast != null && broadcast.getChunks() != null && broadcast.getChunks().getLive() != null) {\n            List<TwitchChunk> videos = broadcast.getChunks().getLive();\n            String[] urls = new String[videos.size()];\n            for (int i = 0; i < videos.size(); i++) {\n                urls[i] = videos.get(i).getUrl();\n            }\n            return urls;\n        }\n        return null;\n    }\n\n    public static void playVideo(TDActivity activity, String title, String url) {\n        if (activity != null) {\n            Log.d(TAG, \"Playing '\" + title + \"' from \" + url);\n\n            if (useInternPlayer(activity)) { //built-in Player\n                Log.d(TAG, \"internal\");\n                Bundle args = new Bundle();\n                args.putString(VideoFragment.TITLE, title);\n                args.putString(VideoFragment.URL, url);\n                playVideoIntern(activity, args);\n            } else { //external Player\n                Log.d(TAG, \"external\");\n\n                Intent intent = new Intent(Intent.ACTION_VIEW);", "context": "src/main/java/ch/citux/td/data/model/TwitchChunks.java\npublic class TwitchChunks extends TwitchBase {\n\n    private List<TwitchChunk> live;\n\n    public List<TwitchChunk> getLive() {\n        return live;\n    }\n\n    public void setLive(List<TwitchChunk> live) {\n        this.live = live;\n    }\n}\nsrc/main/java/ch/citux/td/data/worker/TDBasicCallback.java\npublic abstract class TDBasicCallback<Result> implements TDCallback<Result> {\n\n    private Object caller;\n\n    protected TDBasicCallback(Object caller) {\n        this.caller = caller;\n    }\n\n    @Override\n    public void startLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).startLoading();\n        }\n    }\n\n    @Override\n    public void stopLoading() {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).stopLoading();\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        if (caller instanceof TDListFragment) {\n            ((TDListFragment) caller).onError(title, message);\n        }\n    }\n}\nsrc/main/java/net/chilicat/m3u8/ParseException.java\npublic class ParseException extends Exception {\n    private final String line;\n    private final int lineNumber;\n\n    public ParseException(String line, int lineNumber, Throwable cause) {\n        super(cause);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public ParseException(String line, int lineNumber, String message) {\n        super(message);\n        this.line = line;\n        this.lineNumber = lineNumber;\n    }\n\n    public String getLine() {\n        return line;\n    }\n\n    public int getLineNumber() {\n        return lineNumber;\n    }\n\n    @Override\n    public String getMessage() {\n        return \"Error at line \" + getLineNumber() + \": \" + getLine() + \"\\n\" + super.getMessage();    //To change body of overridden methods use File | Settings | File Templates.\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchBroadcast.java\npublic class TwitchBroadcast extends TwitchBase {\n\n    private String api_id;\n    private String increment_view_count_url;\n    private String path;\n    private String broadcaster_software;\n    private String channel;\n    private String preview_small;\n    private String preview;\n    private TwitchChunks chunks;\n    private long duration;\n    private long start_offset;\n    private long end_offset;\n    private long play_offset;\n    private long vod_ad_frequency;\n    private long vod_ad_length;\n\n    public String getApi_id() {\n        return api_id;\n    }\n\n    public void setApi_id(String api_id) {\n        this.api_id = api_id;\n    }\n\n    public String getIncrement_view_count_url() {\n        return increment_view_count_url;\n    }\n\n    public void setIncrement_view_count_url(String increment_view_count_url) {\n        this.increment_view_count_url = increment_view_count_url;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public String getBroadcaster_software() {\n        return broadcaster_software;\n    }\n\n    public void setBroadcaster_software(String broadcaster_software) {\n        this.broadcaster_software = broadcaster_software;\n    }\n\n    public String getChannel() {\n        return channel;\n    }\n\n    public void setChannel(String channel) {\n        this.channel = channel;\n    }\n\n    public String getPreview_small() {\n        return preview_small;\n    }\n\n    public void setPreview_small(String preview_small) {\n        this.preview_small = preview_small;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public TwitchChunks getChunks() {\n        return chunks;\n    }\n\n    public void setChunks(TwitchChunks chunks) {\n        this.chunks = chunks;\n    }\n\n    public long getDuration() {\n        return duration;\n    }\n\n    public void setDuration(long duration) {\n        this.duration = duration;\n    }\n\n    public long getStart_offset() {\n        return start_offset;\n    }\n\n    public void setStart_offset(long start_offset) {\n        this.start_offset = start_offset;\n    }\n\n    public long getEnd_offset() {\n        return end_offset;\n    }\n\n    public void setEnd_offset(long end_offset) {\n        this.end_offset = end_offset;\n    }\n\n    public long getPlay_offset() {\n        return play_offset;\n    }\n\n    public void setPlay_offset(long play_offset) {\n        this.play_offset = play_offset;\n    }\n\n    public long getVod_ad_frequency() {\n        return vod_ad_frequency;\n    }\n\n    public void setVod_ad_frequency(long vod_ad_frequency) {\n        this.vod_ad_frequency = vod_ad_frequency;\n    }\n\n    public long getVod_ad_length() {\n        return vod_ad_length;\n    }\n\n    public void setVod_ad_length(long vod_ad_length) {\n        this.vod_ad_length = vod_ad_length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchVideo.java\npublic class TwitchVideo extends TwitchBase {\n\n    private String _id;\n    private String title;\n    private String description;\n    private long broadcast_id;\n    private Date recorded_at;\n    private String game;\n    private long length;\n    private String preview;\n    private String url;\n    private long views;\n    private TwitchChannel channel;\n\n    public String get_id() {\n        return _id;\n    }\n\n    public void set_id(String _id) {\n        this._id = _id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public long getBroadcast_id() {\n        return broadcast_id;\n    }\n\n    public void setBroadcast_id(long broadcast_id) {\n        this.broadcast_id = broadcast_id;\n    }\n\n    public Date getRecorded_at() {\n        return recorded_at;\n    }\n\n    public void setRecorded_at(Date recorded_at) {\n        this.recorded_at = recorded_at;\n    }\n\n    public String getGame() {\n        return game;\n    }\n\n    public void setGame(String game) {\n        this.game = game;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n\n    public String getPreview() {\n        return preview;\n    }\n\n    public void setPreview(String preview) {\n        this.preview = preview;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public long getViews() {\n        return views;\n    }\n\n    public void setViews(long views) {\n        this.views = views;\n    }\n\n    public TwitchChannel getChannel() {\n        return channel;\n    }\n\n    public void setChannel(TwitchChannel channel) {\n        this.channel = channel;\n    }\n}\nsrc/main/java/ch/citux/td/ui/dialogs/ErrorDialogFragment.java\npublic class ErrorDialogFragment extends DialogFragment {\n\n    private static final String FRAGMENT_TAG = \"ErrorDialogFragment\";\n    private static final String BUNDLE_TITLE = \"title\";\n    private static final String BUNDLE_MESSAGE = \"message\";\n    private DialogInterface.OnClickListener mOnClickListener;\n    private OnCancelListener mOnCancelListener;\n\n    private static ErrorDialogFragment newInstance(String title, String message,\n                                                   DialogInterface.OnClickListener onClickListener, OnCancelListener onCancelListener) {\n        ErrorDialogFragment dialogFragment = new ErrorDialogFragment();\n        dialogFragment.mOnClickListener = onClickListener;\n\n        Bundle args = new Bundle();\n        args.putString(BUNDLE_TITLE, title);\n        args.putString(BUNDLE_MESSAGE, message);\n        dialogFragment.setArguments(args);\n\n        return dialogFragment;\n    }\n\n    public static void dismiss(FragmentActivity activity) {\n        FragmentManager fragmentManager = activity.getSupportFragmentManager();\n        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n        Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n        if (prev != null) {\n            fragmentTransaction.remove(prev);\n        }\n        fragmentTransaction.commit();\n    }\n\n    @Override\n    public Dialog onCreateDialog(Bundle savedInstanceState) {\n        Bundle args = getArguments();\n        AlertDialog.Builder b = new AlertDialog.Builder(getActivity());\n        b.setTitle(args.getString(BUNDLE_TITLE));\n        b.setMessage(args.getString(BUNDLE_MESSAGE));\n        setCancelable(true);\n        b.setNeutralButton(getActivity().getString(android.R.string.ok), mOnClickListener);\n        return b.create();\n    }\n\n    @Override\n    public void onCancel(DialogInterface dialog) {\n        if (mOnCancelListener != null) {\n            mOnCancelListener.onCancel();\n        }\n    }\n\n    public interface OnCancelListener {\n        public void onCancel();\n    }\n\n    public static class ErrorDialogFragmentBuilder {\n        private FragmentActivity mActivity;\n        private String mTitle;\n        private String mMessage;\n        private DialogInterface.OnClickListener mOnClickListener;\n        private OnCancelListener mOnCancelListener;\n\n        public ErrorDialogFragmentBuilder(FragmentActivity activity) {\n            if (activity != null) {\n                mActivity = activity;\n                mTitle = activity.getString(R.string.dialog_error_title);\n            }\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(int resId) {\n            mTitle = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setTitle(String text) {\n            mTitle = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(int resId) {\n            mMessage = mActivity.getString(resId);\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setMessage(String text) {\n            mMessage = text;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnClickListener(DialogInterface.OnClickListener onClickListener) {\n            mOnClickListener = onClickListener;\n            return this;\n        }\n\n        public ErrorDialogFragmentBuilder setOnCancelListener(OnCancelListener onCancelListener) {\n            mOnCancelListener = onCancelListener;\n            return this;\n        }\n\n        public void show() {\n            FragmentManager fragmentManager = mActivity.getSupportFragmentManager();\n            FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n\n            Fragment prev = fragmentManager.findFragmentByTag(FRAGMENT_TAG);\n            if (prev != null) {\n                fragmentTransaction.remove(prev);\n            }\n            fragmentTransaction.addToBackStack(null);\n\n            ErrorDialogFragment.newInstance(mTitle, mMessage, mOnClickListener, mOnCancelListener)\n                    .show(fragmentManager, FRAGMENT_TAG);\n        }\n    }\n}\nsrc/main/java/ch/citux/td/ui/TDActivity.java\npublic class TDActivity extends ActionBarActivity implements TDCallback<TwitchChannel>, View.OnFocusChangeListener, AdapterView.OnItemClickListener {\n\n    private FavoritesFragment favoritesFragment;\n    private GameOverviewFragment gameOverviewFragment;\n    private GameStreamsFragment gameStreamsFragment;\n    private ChannelFragment channelFragment;\n    private SearchFragment searchFragment;\n    private VideoFragment videoFragment;\n    private SettingsFragment settingsFragment;\n\n    private ActionBarDrawerToggle toggle;\n    private MenuItem refreshItem;\n    private MenuItem searchItem;\n    private View refreshView;\n    private String username;\n    private Toast toast;\n    private boolean isLoading;\n    private boolean hasUsername;\n\n    @InjectView(R.id.user) View user;\n    @InjectView(R.id.toolbar) Toolbar toolbar;\n    @InjectView(R.id.imgUser) ImageView imgUser;\n    @InjectView(R.id.lblUser) TextView lblUser;\n    @InjectView(R.id.lblNoUser) TextView lblNoUser;\n    @Optional @InjectView(R.id.drawerLayout) DrawerLayout drawerLayout;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.main);\n        ButterKnife.inject(this);\n\n        Context contextThemeWrapper = new ContextThemeWrapper(this, R.style.Theme_TD_Light);\n        LayoutInflater inflater = LayoutInflater.from(this).cloneInContext(contextThemeWrapper);\n        refreshView = inflater.inflate(R.layout.action_refresh, null);\n\n        initNavigation();\n        updateUser();\n\n        if (favoritesFragment == null) {\n            Bundle args = new Bundle();\n            args.putBoolean(TDConfig.SETTINGS_CHANNEL_NAME, hasUsername);\n\n            favoritesFragment = new FavoritesFragment();\n            favoritesFragment.setArgs(args);\n\n            getSupportFragmentManager()\n                    .beginTransaction()\n                    .add(R.id.content, favoritesFragment)\n                    .commit();\n        } else {\n            replaceFragment(favoritesFragment);\n        }\n    }\n\n    private void initNavigation() {\n        toolbar.setLogo(R.drawable.twitch_logo_white);\n        toolbar.setLogoDescription(R.string.app_name);\n        setSupportActionBar(toolbar);\n\n        if (drawerLayout != null) {\n            toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.navigation_open, R.string.navigation_close);\n            toggle.setDrawerIndicatorEnabled(true);\n            drawerLayout.setDrawerListener(toggle);\n        }\n\n        ListView lstNav = (ListView) findViewById(R.id.lstNav);\n        lstNav.setAdapter(new ArrayAdapter<>(this, R.layout.list_item_navigation, getResources().getStringArray(R.array.navigation)));\n        lstNav.setOnItemClickListener(this);\n    }\n\n    public void updateUser() {\n        username = PreferenceManager.getDefaultSharedPreferences(this).getString(TDConfig.SETTINGS_CHANNEL_NAME, \"\");\n        hasUsername = !username.equals(\"\");\n\n        if (hasUsername) {\n            user.setVisibility(View.VISIBLE);\n            lblUser.setText(username);\n            lblNoUser.setVisibility(View.GONE);\n\n            TDTaskManager.executeTask(this);\n        } else {\n            user.setVisibility(View.GONE);\n            lblNoUser.setVisibility(View.VISIBLE);\n            imgUser.setImageResource(R.drawable.default_channel_logo_medium);\n        }\n    }\n\n    @Override\n    protected void onPostCreate(Bundle savedInstanceState) {\n        super.onPostCreate(savedInstanceState);\n        if (drawerLayout != null) {\n            toggle.syncState();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        refreshData();\n    }\n\n    private void replaceFragment(Fragment fragment) {\n        replaceFragment(fragment, true);\n    }\n\n    private void replaceFragment(Fragment fragment, boolean backstack) {\n        if (fragment != null && !fragment.isAdded()) {\n            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\n            transaction.replace(R.id.content, fragment);\n            if (backstack) {\n                transaction.addToBackStack(null);\n            }\n            transaction.commitAllowingStateLoss();\n        }\n    }\n\n    @Override\n    protected void onNewIntent(Intent intent) {\n        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {\n            String query = intent.getStringExtra(SearchManager.QUERY);\n\n            if (searchFragment == null) {\n                searchFragment = new SearchFragment();\n            }\n            searchFragment.setQuery(query);\n            searchFragment.loadData();\n\n            replaceFragment(searchFragment);\n            Log.d(this, query);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        TDTaskManager.cancelAllTasks();\n        super.onPause();\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuInflater inflater = getMenuInflater();\n        inflater.inflate(R.menu.main, menu);\n\n        refreshItem = menu.findItem(R.id.menu_refresh);\n        searchItem = menu.findItem(R.id.menu_search);\n\n        // Associate searchable configuration with the SearchView\n        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);\n        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);\n        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));\n        searchView.setOnQueryTextFocusChangeListener(this);\n\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_refresh:\n                if (!isLoading) {\n                    refreshData();\n                }\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    public void showChannel(TwitchChannel channel) {\n        if (channelFragment == null) {\n            channelFragment = new ChannelFragment();\n        }\n\n        if (channelFragment.isAdded()) {\n            channelFragment.updateChannel(channel);\n        } else {\n            Bundle arguments = new Bundle();\n            arguments.putSerializable(ChannelFragment.CHANNEL, channel);\n            channelFragment.setArgs(arguments);\n            replaceFragment(channelFragment);\n        }\n    }\n\n    public void showVideo(Bundle args) {\n        if (videoFragment == null) {\n            videoFragment = new VideoFragment();\n        }\n        videoFragment.setArgs(args);\n\n        if (videoFragment.isAdded()) {\n            videoFragment.playVideo();\n        } else {\n            replaceFragment(videoFragment);\n        }\n        MenuItemCompat.collapseActionView(searchItem);\n    }\n\n    public void showPlaylist(TwitchBroadcast broadcast) {\n        if (channelFragment.isAdded()) {\n            channelFragment.showPlaylist(broadcast);\n        }\n    }\n\n    public void showStreams(Bundle args) {\n        if (gameStreamsFragment == null) {\n            gameStreamsFragment = new GameStreamsFragment();\n        }\n        gameStreamsFragment.setArgs(args);\n        replaceFragment(gameStreamsFragment);\n    }\n\n    public void startLoading() {\n        isLoading = true;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, refreshView);\n        }\n    }\n\n    public void stopLoading() {\n        isLoading = false;\n        if (refreshItem != null) {\n            MenuItemCompat.setActionView(refreshItem, null);\n        }\n    }\n\n    @Override\n    public TwitchChannel startRequest() {\n        return TDServiceImpl.getInstance().getChannel(username);\n    }\n\n    @Override\n    public void onResponse(TwitchChannel response) {\n        if (response != null) {\n            Picasso.with(this)\n                    .load(response.getLogo().getUrl(TwitchLogo.Size.MEDIUM))\n                    .placeholder(R.drawable.default_channel_logo_medium)\n                    .into(imgUser);\n        }\n    }\n\n    @Override\n    public void onError(String title, String message) {\n        toast = Toast.makeText(this, title + \": \" + message, Toast.LENGTH_SHORT);\n        toast.show();\n    }\n\n    @Override\n    public boolean isAdded() {\n        return true;\n    }\n\n    @Override\n    public void setTitle(int titleId) {\n        super.setTitle(titleId);\n        if (toolbar != null) {\n            toolbar.setTitle(titleId);\n        }\n    }\n\n    @Override\n    public void setTitle(CharSequence title) {\n        super.setTitle(title);\n        if (toolbar != null) {\n            toolbar.setTitle(title);\n        }\n    }\n\n    protected void refreshData() {\n        if (favoritesFragment != null && favoritesFragment.isAdded()) {\n            favoritesFragment.refreshData();\n        }\n        if (channelFragment != null && channelFragment.isAdded()) {\n            channelFragment.refreshData();\n        }\n        if (searchFragment != null && searchFragment.isAdded()) {\n            searchFragment.refreshData();\n        }\n        if (gameOverviewFragment != null && gameOverviewFragment.isAdded()) {\n            gameOverviewFragment.refreshData();\n        }\n        if (gameStreamsFragment != null && gameStreamsFragment.isAdded()) {\n            gameStreamsFragment.refreshData();\n        }\n    }\n\n    @Override\n    public void onFocusChange(View view, boolean queryTextFocused) {\n        if (!queryTextFocused) {\n            MenuItemCompat.collapseActionView(searchItem);\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (drawerLayout != null && drawerLayout.isDrawerOpen(Gravity.START)) {\n            drawerLayout.closeDrawers();\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n        switch (position) {\n            case 0:\n                if (favoritesFragment == null) {\n                    favoritesFragment = new FavoritesFragment();\n                }\n                replaceFragment(favoritesFragment);\n                break;\n            case 1:\n                if (gameOverviewFragment == null) {\n                    gameOverviewFragment = new GameOverviewFragment();\n                }\n                replaceFragment(gameOverviewFragment);\n                break;\n            case 2:\n                if (settingsFragment == null) {\n                    settingsFragment = new SettingsFragment();\n                }\n                replaceFragment(settingsFragment);\n                break;\n        }\n        if (drawerLayout != null) {\n            drawerLayout.closeDrawers();\n        }\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchChunk.java\npublic class TwitchChunk extends TwitchBase {\n\n    private String url;\n    private String vod_count_url;\n    private String upkeep;\n    private long length;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getVod_count_url() {\n        return vod_count_url;\n    }\n\n    public void setVod_count_url(String vod_count_url) {\n        this.vod_count_url = vod_count_url;\n    }\n\n    public String getUpkeep() {\n        return upkeep;\n    }\n\n    public void setUpkeep(String upkeep) {\n        this.upkeep = upkeep;\n    }\n\n    public long getLength() {\n        return length;\n    }\n\n    public void setLength(long length) {\n        this.length = length;\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchStreamQuality.java\npublic class TwitchStreamQuality extends TwitchBase {\n\n    private String key;\n    private String name;\n    private int value;\n\n    public TwitchStreamQuality(String key, int value) {\n        this(key, value, key);\n    }\n\n    public TwitchStreamQuality(String key, int value, String name) {\n        this.key = key;\n        this.value = value;\n        this.name = name;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\nsrc/main/java/ch/citux/td/ui/adapter/PlaylistAdapter.java\npublic class PlaylistAdapter extends BaseAdapter {\n\n    private LayoutInflater inflater;\n    private List<TwitchChunk> videos;\n    private ArrayList<Integer> played;\n\n    public PlaylistAdapter(Context context, List<TwitchChunk> videos) {\n        super();\n        this.inflater = LayoutInflater.from(context);\n        this.videos = videos;\n        this.played = new ArrayList<Integer>(videos.size());\n    }\n\n    public void setVideos(List<TwitchChunk> videos) {\n        this.videos = videos;\n        if (videos != null && videos.size() > 0) {\n            notifyDataSetChanged();\n        } else {\n            notifyDataSetInvalidated();\n        }\n    }\n\n    public void setPlayed(int position) {\n        played.add(position);\n    }\n\n    @Override\n    public int getCount() {\n        return videos.size();\n    }\n\n    @Override\n    public TwitchChunk getItem(int position) {\n        if (position < videos.size()) {\n            return videos.get(position);\n        }\n        return null;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        TwitchChunk video = getItem(position);\n        ViewHolder holder;\n        if (convertView == null || convertView.getTag() == null) {\n            holder = new ViewHolder();\n            convertView = inflater.inflate(R.layout.list_item_playlist, parent, false);\n            if (convertView != null) {\n                ButterKnife.inject(holder, convertView);\n            }\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        holder.lblPartIndex.setText(String.valueOf(position + 1));\n        holder.lblPartCount.setText(String.valueOf(getCount()));\n        //TODO holder.lblTitle.setText(video.());\n        holder.chkPlayed.setChecked(played.contains(position));\n        return convertView;\n    }\n\n    class ViewHolder {\n        @InjectView(R.id.lblPartIndex) TextView lblPartIndex;\n        @InjectView(R.id.lblPartCount) TextView lblPartCount;\n        @InjectView(R.id.lblTitle) TextView lblTitle;\n        @InjectView(R.id.chkPlayed) CheckBox chkPlayed;\n    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/VideoFragment.java\npublic class VideoFragment extends TDFragment {//implements MediaPlayer.OnPreparedListener {\n\n    public static final String PLAYLIST = \"playlist\";\n    public static final String TITLE = \"title\";\n    public static final String URL = \"url\";\n\n    @InjectView(android.R.id.empty) EmptyView emptyView;\n    //    @InjectView(R.id.videoView) VideoView videoView;\n    @InjectView(R.id.player) View player;\n    @InjectView(R.id.chat) View chat;\n\n    @Override\n    protected int onCreateView() {\n        return R.layout.video;\n    }\n\n    @Override\n    public void onActivityCreated(Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        super.setRetainInstance(true);\n\n//        if (((TDActivity) getActivity()).isTablet()) {\n//            emptyView.setImage(R.drawable.ic_glitchicon_white);\n//        }\n\n//        MediaController mediaController = new MediaController(getActivity());\n//        videoView.setMediaController(mediaController);\n//        videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1);\n//        videoView.setOnPreparedListener(this);\n//\n//        onOrientationChange(getResources().getConfiguration().orientation);\n//\n//        playVideo();\n    }\n\n    @Override\n    public void loadData() {\n\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n\n        getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        getSupportActionBar().show();\n    }\n\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n\n//        onOrientationChange(newConfig.orientation);\n    }\n\n    private void onOrientationChange(int orientation) {\n//        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\n//            getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().hide();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_STRETCH, 1.77f);\n//            chat.setVisibility(View.GONE);\n//        } else {\n//            getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);\n//            getSupportActionBar().show();\n//            videoView.setVideoLayout(VideoView.VIDEO_LAYOUT_SCALE, 1.77f);\n//            chat.setVisibility(View.VISIBLE);\n//        }\n    }\n\n    public void playVideo() {\n\n//        getActivity().setVolumeControlStream(AudioManager.STREAM_MUSIC);\n//        if (getArguments() != null && (!getArguments().containsKey(URL) || !getArguments().containsKey(CHUNKS))) {\n//            getSupportActionBar().setTitle(getArguments().getString(TITLE));\n//\n//            if (getArguments().containsKey(URL)) {\n//                videoView.setVideoURI(Uri.parse(getArguments().getString(URL)));\n//            }\n//            if (getArguments().containsKey(CHUNKS)) {\n//                videoView.setVideoPlaylist(getArguments().getStringArray(CHUNKS));\n//            }\n//            videoView.start();\n//        }\n    }\n\n    @Override\n    public Object startRequest() {\n        return null;\n    }\n\n    @Override\n    public void onResponse(Object response) {\n\n    }\n\n//    @Override\n//    public void onPrepared(MediaPlayer mp) {\n//        emptyView.setVisibility(View.GONE);\n//        player.setVisibility(View.VISIBLE);\n//    }\n}\nsrc/main/java/ch/citux/td/ui/fragments/TDBase.java\npublic interface TDBase {\n\n    public void loadData();\n\n    public void startActivity(Intent intent);\n\n    public SharedPreferences getDefaultSharedPreferences();\n\n    public boolean isAdded();\n\n    public TDActivity getTDActivity();\n\n    public void setArgs(Bundle args);\n\n    public Bundle getArgs();\n}\nsrc/main/java/net/chilicat/m3u8/Element.java\npublic interface Element {\n\n    public String getTitle();\n\n\n    public int getDuration();\n\n    /**\n     * URI to media or playlist.\n     *\n     * @return the URI.\n     */\n    public URI getURI();\n\n    /**\n     * Media can be encrypted.\n     *\n     * @return true if media encrypted.\n     */\n    public boolean isEncrypted();\n\n    /**\n     * Element can be another playlist.\n     *\n     * @return true if element a playlist.\n     */\n    public boolean isPlayList();\n\n    /**\n     * Element is a media file.\n     *\n     * @return true if element a media file and not a playlist.\n     */\n    public boolean isMedia();\n\n    /**\n     * If media is encryped than will this method return a info object.\n     *\n     * @return the info object or null if media not encrypted.\n     */\n    public EncryptionInfo getEncryptionInfo();\n\n    /**\n     * If element a playlist than this method will return a PlaylistInfo object.\n     *\n     * @return a info object or null in case of element is not a playlist.\n     */\n    public PlaylistInfo getPlayListInfo();\n\n    /**\n     * The program date.\n     *\n     * @return -1 in case of program date is not set.\n     */\n    public long getProgramDate();\n\n}\nsrc/main/java/net/chilicat/m3u8/Playlist.java\npublic final class Playlist implements Iterable<Element> {\n\n    public static Playlist parse(Readable readable) throws ParseException {\n        if (readable == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return PlaylistParser.create(PlaylistType.M3U8).parse(readable);\n    }\n\n    public static Playlist parse(String playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new StringReader(playlist));\n    }\n\n    public static Playlist parse(InputStream playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(new InputStreamReader(playlist));\n    }\n\n    public static Playlist parse(ReadableByteChannel playlist) throws ParseException {\n        if (playlist == null) {\n            throw new NullPointerException(\"playlist\");\n        }\n        return parse(makeReadable(playlist));\n    }\n\n    private static Readable makeReadable(ReadableByteChannel source) {\n        if (source == null) {\n            throw new NullPointerException(\"source\");\n        }\n\n\n        return Channels.newReader(source,\n                java.nio.charset.Charset.defaultCharset().name());\n    }\n\n    private final List<Element> elements;\n    private final boolean endSet;\n    private final int targetDuration;\n    private int mediaSequenceNumber;\n\n    Playlist(List<Element> elements, boolean endSet, int targetDuration, int mediaSequenceNumber) {\n        if (elements == null) {\n            throw new NullPointerException(\"elements\");\n        }\n        this.targetDuration = targetDuration;\n        this.elements = elements;\n        this.endSet = endSet;\n        this.mediaSequenceNumber = mediaSequenceNumber;\n    }\n\n    public int getTargetDuration() {\n        return targetDuration;\n    }\n\n    public Iterator<Element> iterator() {\n        return elements.iterator();\n    }\n\n    public List<Element> getElements() {\n        return elements;\n    }\n\n    public boolean isEndSet() {\n        return endSet;\n    }\n\n    public int getMediaSequenceNumber() {\n        return mediaSequenceNumber;\n    }\n\n    @Override\n    public String toString() {\n        return \"PlayListImpl{\" +\n                \"elements=\" + elements +\n                \", endSet=\" + endSet +\n                \", targetDuration=\" + targetDuration +\n                \", mediaSequenceNumber=\" + mediaSequenceNumber +\n                '}';\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchAccessToken.java\npublic class TwitchAccessToken extends TwitchBase {\n\n    private String token;\n    private String sig;\n    private String p;\n    private boolean mobile_restricted;\n\n    public String getToken() {\n        return token;\n    }\n\n    public void setToken(String token) {\n        this.token = token;\n    }\n\n    public String getSig() {\n        return sig;\n    }\n\n    public void setSig(String sig) {\n        this.sig = sig;\n    }\n\n    public String getP() {\n        return p;\n    }\n\n    public void setP(String p) {\n        this.p = p;\n    }\n\n    public boolean isMobile_restricted() {\n        return mobile_restricted;\n    }\n\n    public void setMobile_restricted(boolean mobile_restricted) {\n        this.mobile_restricted = mobile_restricted;\n    }\n}\nsrc/main/java/ch/citux/td/config/TDConfig.java\npublic class TDConfig {\n\n    public static final String SETTINGS_CHANNEL_NAME = \"channel_name\";\n    public static final String SETTINGS_LICENSE_DIALOG = \"license_dialog\";\n    public static final String SETTINGS_STREAM_QUALITY = \"stream_quality\";\n\n    public static final String CAST_APPLICATION_ID = \"D25E1BBE\";\n    public static final String KRAKEN_CLIENT_ID = \"sx9d3whtcht2lhrtd6yjia8rv019wxi\";\n\n    public static final String UTF_8 = \"UTF-8\";\n\n    public static final String MIME_FLV = \"video/x-flv\";\n    public static final String MIME_TWITCH = \"application/vnd.twitchtv.v3+json\";\n\n    public static final String URL_API_TWITCH_KRAKEN_BASE = \"https://api.twitch.tv/kraken\";\n    public static final String URL_API_TWITCH_API_BASE = \"https://api.twitch.tv/api\";\n    public static final String URL_API_USHER_BASE = \"http://usher.twitch.tv\";\n\n}\nsrc/main/java/ch/citux/td/data/service/TDServiceImpl.java\npublic class TDServiceImpl implements TwitchAPI, TwitchKraken, TwitchUsher, RestAdapter.Log {\n\n    private static final String TAG = \"TDService\";\n\n    private static TDServiceImpl instance;\n\n    private TwitchAPI twitchAPI;\n    private TwitchUsher twitchUsher;\n    private TwitchKraken twitchKraken;\n\n    private TDServiceImpl() {\n        RestAdapter.Builder builder = new RestAdapter.Builder()\n                .setLog(this)\n                .setLogLevel(BuildConfig.DEBUG ? RestAdapter.LogLevel.FULL : RestAdapter.LogLevel.NONE)\n                .setConverter(new JacksonConverter());\n\n        RestAdapter apiAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_API_BASE)\n                .build();\n        RestAdapter usherAdapter = builder\n                .setEndpoint(TDConfig.URL_API_USHER_BASE)\n                .build();\n        RestAdapter krakenAdapter = builder\n                .setEndpoint(TDConfig.URL_API_TWITCH_KRAKEN_BASE)\n                .setRequestInterceptor(new KrakenRequestInterceptor())\n                .build();\n\n        twitchAPI = apiAdapter.create(TwitchAPI.class);\n        twitchUsher = usherAdapter.create(TwitchUsher.class);\n        twitchKraken = krakenAdapter.create(TwitchKraken.class);\n    }\n\n    public static TDServiceImpl getInstance() {\n        if (instance == null) {\n            instance = new TDServiceImpl();\n        }\n        return instance;\n    }\n\n    @Override\n    public void log(String message) {\n        Log.d(TAG, message);\n    }\n\n    private class KrakenRequestInterceptor implements RequestInterceptor {\n        @Override\n        public void intercept(RequestInterceptor.RequestFacade request) {\n            request.addHeader(\"Accept\", TDConfig.MIME_TWITCH);\n            request.addHeader(\"Client-ID\", TDConfig.KRAKEN_CLIENT_ID);\n        }\n    }\n\n    @Override\n    public TwitchFollows getFollows(String username, int offset) {\n        return twitchKraken.getFollows(username, offset);\n    }\n\n    @Override\n    public TwitchChannel getChannel(String channel) {\n        return twitchKraken.getChannel(channel);\n    }\n\n    @Override\n    public TwitchStream getStream(String channel) {\n        return twitchKraken.getStream(channel);\n    }\n\n    @Override\n    public TwitchStream getStreams(String game, int offset) {\n        return twitchKraken.getStreams(game, offset);\n    }\n\n    @Override\n    public TwitchVideos getVideos(String channel, int offset) {\n        return twitchKraken.getVideos(channel, offset);\n    }\n\n    @Override\n    public TwitchStream searchStreams(String query, int offset) {\n        return twitchKraken.searchStreams(query, offset);\n    }\n\n    @Override\n    public TwitchChannels searchChannels(String query, int offset) {\n        return twitchKraken.searchChannels(query, offset);\n    }\n\n    @Override\n    public TwitchGames getTopGames(int limit, int offset) {\n        return twitchKraken.getTopGames(limit, offset);\n    }\n\n    //TwitchAPI\n    @Override\n    public TwitchAccessToken getChannelToken(String channel) {\n        return twitchAPI.getChannelToken(channel);\n    }\n\n    @Override\n    public TwitchAccessToken getVodToken(@Path(\"videoId\") String videoId) {\n        return twitchAPI.getVodToken(videoId);\n    }\n\n    @Override\n    public TwitchBroadcast getVideoPlaylist(@Path(\"id\") String id) {\n        return twitchAPI.getVideoPlaylist(id);\n    }\n\n    //TwitchUsher\n    @Override\n    public Response getChannelPlaylist(String channel, String p, String token, String sig) {\n        return twitchUsher.getChannelPlaylist(channel, p, token, sig);\n    }\n\n    @Override\n    public Response getVodPlaylist(@Path(\"videoId\") String videoId, @Query(\"p\") String p, @Query(\"token\") String token, @Query(\"sig\") String sig) {\n        return twitchUsher.getVodPlaylist(videoId, p, token, sig);\n    }\n}\nsrc/main/java/ch/citux/td/data/model/TwitchPlayList.java\npublic class TwitchPlayList extends TwitchBase {\n\n    public static final TwitchStreamQuality QUALITY_MOBILE = new TwitchStreamQuality(\"mobile\", 1);\n    public static final TwitchStreamQuality QUALITY_LOW = new TwitchStreamQuality(\"low\", 2);\n    public static final TwitchStreamQuality QUALITY_MEDIUM = new TwitchStreamQuality(\"medium\", 3);\n    public static final TwitchStreamQuality QUALITY_HIGH = new TwitchStreamQuality(\"high\", 4);\n    public static final TwitchStreamQuality QUALITY_CHUNKED = new TwitchStreamQuality(\"chunked\", 5, \"source\");\n\n    public static final TwitchStreamQuality[] SUPPORTED_QUALITIES = {\n            QUALITY_MOBILE,\n            QUALITY_LOW,\n            QUALITY_MEDIUM,\n            QUALITY_HIGH,\n            QUALITY_CHUNKED\n    };\n\n    private HashMap<TwitchStreamQuality, String> streams;\n\n    public static TwitchStreamQuality parseQuality(String name) {\n        for (TwitchStreamQuality quality : SUPPORTED_QUALITIES) {\n            if (quality.getName().equalsIgnoreCase(name) || quality.getKey().equalsIgnoreCase(name)) {\n                return quality;\n            }\n        }\n        return null;\n    }\n\n    public String getStream(TwitchStreamQuality quality) {\n        String url = streams.get(quality);\n        if (StringUtils.isEmpty(url)) {\n            url = getBestStream();\n        }\n        return url;\n    }\n\n    public String getBestStream() {\n        TwitchStreamQuality best = new TwitchStreamQuality(\"\", -1);\n\n        for (TwitchStreamQuality quality : streams.keySet()) {\n            if (best.getValue() < quality.getValue()) {\n                best = quality;\n            }\n        }\n\n        if (best.getValue() > -1) {\n            return getStream(best);\n        }\n        return null;\n    }\n\n    public HashMap<TwitchStreamQuality, String> getStreams() {\n        return streams;\n    }\n\n    public void setStreams(HashMap<TwitchStreamQuality, String> streams) {\n        this.streams = streams;\n    }\n}\n", "answers": ["                intent.setDataAndType(Uri.parse(url), TDConfig.MIME_FLV);"], "pred": "    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n    External Player\n", "length": 3615, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "b3e2346d898f5d979d88e1ef30c8d97a9e53c92308800882"}
{"prompt": "Please complete the code given below. \nForkMe-Mobile/app/src/main/java/dlei/forkme/model/LocationData.java\npublic class LocationData {\n\n    private Double latitude;\n    private Double longitude;\n    private Integer id;\n\n    public Double getLatitude() {\n        return latitude;\n    }\n\n    public void setLatitude(Double latitude) {\n        this.latitude = latitude;\n    }\n\n    public Double getlongitude() {\n        return longitude;\n    }\n\n    public void setlongitude(Double _longitude) {\n        this.longitude = longitude;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n     public void setId(Integer id) {\n        this.id = id;\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/DatabaseHelper.java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    public static DatabaseHelper sDbInstance = null;\n\n    public static final String sDatabaseName = \"AppSettings\";\n    public static final int sDatabaseVersion = 1;\n\n    private DatabaseHelper(Context context) {\n        super(context, sDatabaseName, null, sDatabaseVersion);\n    }\n\n    /**\n     * Singleton pattern so only 1 object of DatabaseHelper exists.\n     * @param context activity context.\n     * @return instance of DatabaseHelper.\n     */\n    public static synchronized DatabaseHelper getDbInstance(Context context) {\n        if (sDbInstance == null) {\n            sDbInstance = new DatabaseHelper(context);\n            Log.d(\"DatabaseHelper: \", \"getDbInstance() created new instance\");\n        }\n        return sDbInstance;\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n        try {\n            sqLiteDatabase.execSQL(AppSettings.CREATE_TABLE_SQL);\n            Log.d(\"DatabaseHelper: \", \"onCreate() created db\");\n        } catch (SQLException e) {\n            Log.wtf(\"Error: \", String.format(\"Create Table Statement: %s\\nException: %s\",\n                    AppSettings.CREATE_TABLE_SQL, e));\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n        try {\n            sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + AppSettings.TABLE_NAME); // Drop table.\n            onCreate(sqLiteDatabase); // Re make table.\n        } catch (SQLException e) {\n            // Shouldn't happen, if it does log what a terrible message.\n            Log.wtf(\"Error: \", String.format(\"onUpdate Error, Exception %s\", e));\n        }\n        // db.close();  // Close database connection.\n    }\n\n    /**\n     * Insert settings for a user into persistant storage.\n     */\n    public void insertSettings() {\n        if (AppSettings.sUserLogin.equals(\"\")) {\n            Log.wtf(\"Error: \", \"DatabaseHelper.insertSettings(): user log in is null\");\n            return;\n        }\n        Log.i(\"DatabaseHelper: \", \"insertSettings(): inserting settings\");\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.USER_ID_COL, AppSettings.sUserLogin);\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        values.put(AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.sLocationDisabledForever);\n        values.put(AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.sFindPeopleMessage);\n        values.put(AppSettings.PRIVATE_REPOS_COL, AppSettings.sShowPrivateRepositories);\n        long result = db.insert(AppSettings.TABLE_NAME, null, values);\n        if (result == -1) {\n            Log.w(\"Error: \", String.format(\"Adding settings for user %s\", AppSettings.sUserLogin));\n        }\n    }\n\n    /**\n     * Update language for a user in persistant storage.\n     */\n    public void updateLanguage() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update timeframe preference for a user in persistant storage.\n     */\n    public void updateTimeframe() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update stort by preference for a user in persistant storage.\n     */\n    public void updateSortBy() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Loads settings for a user from SQLite db.\n     * @throws NoDataException Thrown when no data returned.\n     * @throws TooMuchDataException Thrown when too much data returned.\n     */\n    public void loadSettings() throws NoDataException, TooMuchDataException{\n        SQLiteDatabase db = this.getWritableDatabase();\n\n        String baseQuery = \"SELECT %s, %s, %s, %s, %s, %s from %s WHERE %s=?\";\n\n        String query = String.format(baseQuery,\n                AppSettings.TIMEFRAME_COL, AppSettings.SORT_BY_COL, AppSettings.LANGUAGE_COL,\n                AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.PRIVATE_REPOS_COL,\n                AppSettings.TABLE_NAME,\n                AppSettings.USER_ID_COL);\n        Log.i(\"UserLogin: \", AppSettings.sUserLogin);\n\n        Cursor cursor = db.rawQuery(query, new String[]{AppSettings.sUserLogin});\n\n        cursor.moveToFirst();\n        int rows = cursor.getCount();\n        if (rows == 0) {\n            cursor.close();\n            db.close();\n            throw new NoDataException(String.format(\n                    \"User with login %s does not exist\", AppSettings.sUserLogin));\n        } else if (rows > 1) {\n            cursor.close();\n            db.close();\n            throw new TooMuchDataException(String.format(\n                    \"Only 1 row should be returned for user %s\", AppSettings.sUserLogin));\n        } else {\n            // Update settings for a user.\n            Log.i(\"Check has data worked: \", \"Language: \" + cursor.getString(2));\n            Log.i(\"Check has data worked: \", \"Timeframe: \" + cursor.getString(1));\n\n            AppSettings.setTimeframe(cursor.getString(0));\n            AppSettings.setSortBy(cursor.getString(1));\n            AppSettings.setLanguage(cursor.getString(2));\n            AppSettings.setLocationDisabledForever(cursor.getInt(3));\n            AppSettings.setFindPeopleAllowedMessage(cursor.getString(4));\n            AppSettings.setShowPrivateRepositories(cursor.getInt(5));\n            cursor.close();\n            db.close();\n        }\n\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/ForkMeBackendApi.java\npublic interface ForkMeBackendApi {\n\n    // Get all repositories v1.\n    @GET(\"/all_repos\")\n    Call<RepositoryResponse> getAllRepositories();\n\n    // Get single repository v1.\n    @GET(\"/all_repos/repositories/{id}\")\n    Call<Repository> getRepository(@Path(\"id\") int id);\n\n    // Get all repositories v2.\n    @GET(\"/repositories\")\n    Call<List<Repository>> getRepositoriesArray();\n\n    // Post location data v2.\n    @POST(\"/locations\")\n    Call<ResponseBody> postLocation(@Body PostLocationDataBody data);\n\n    // Get developers v2.\n    @GET(\"/developers/{login}\")\n    Call<List<DeveloperContactInfo>> getDevelopers(@Path(\"login\") String login);\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/LocationHelper.java\npublic class LocationHelper {\n\n    /**\n     * Checks if location permissions has been granted to application.\n     * @param context Activity context.\n     * @return true if has location permissions, else false.\n     */\n    public static boolean hasLocationPermissions(Context context) {\n\n        boolean hasLocationPermissions = ContextCompat\n                .checkSelfPermission(context,\n                        Manifest.permission.ACCESS_FINE_LOCATION\n                ) == PackageManager.PERMISSION_GRANTED;\n        return hasLocationPermissions;\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/BaseUrls.java\npublic class BaseUrls {\n    public static String githubApi = \"https://api.github.com/\";\n    public static String forkMeBackendApi = \"https://forkme-backend-api2.herokuapp.com/\";\n    public static String forkMeBackendApiDeprecated = \"https://forkme-backend.herokuapp.com/\";\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/state/AppSettings.java\npublic class AppSettings {\n    // Setting attributes.\n    public static String sLanguage = \"All\";\n    public static String sSortBy = \"Stars\";\n    public static String sTimeframe = \"1 Month\";\n    public static String sUserLogin = \"\";\n    public static int sLocationDisabledForever = 0;\n    public static String sFindPeopleMessage = \"N/A\";\n    public static int sShowPrivateRepositories = 0;\n    public static String sOAuthToken = \"\";\n    public static String sUserName = \"\";\n    public static String sUserAvatarUrl = \"\";\n    public static String sUserEmail;\n\n    // Database attributes.\n    public static final String TABLE_NAME = \"settings\";\n    public static final String TIMEFRAME_COL = \"timeframe\";\n    public static final String SORT_BY_COL = \"sort_by\";\n    public static final String LANGUAGE_COL = \"language\";\n    public static final String LOCATION_DISABLED_FOREVER_COL = \"location_disabled_forever\";\n    public static final String FIND_PEOPLE_MESSAGE_COL = \"message\";\n    public static final String PRIVATE_REPOS_COL = \"private_repos\";\n    public static final String USER_ID_COL = \"user\";\n\n    public static final String CREATE_TABLE_SQL =\n            \"CREATE TABLE \" +\n            TABLE_NAME + \" (\" +\n            USER_ID_COL + SqlSyntax.TYPE_STRING + SqlSyntax.PRIMARY_KEY + \", \" +\n            TIMEFRAME_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            SORT_BY_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LANGUAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LOCATION_DISABLED_FOREVER_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL + \", \" +\n            FIND_PEOPLE_MESSAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            PRIVATE_REPOS_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL +\n            \")\";\n\n    public static void setLanguage(String language) {\n        sLanguage = language;\n    }\n\n    public static void setSortBy(String sortBy) {\n        sSortBy = sortBy;\n    }\n\n    public static void setTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n    }\n\n    public static void setLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sLocationDisabledForever = i;\n    }\n\n    public static void setFindPeopleAllowedMessage(String findPeopleAllowedMessage) {\n        sFindPeopleMessage = findPeopleAllowedMessage;\n    }\n\n    public static void setShowPrivateRepositories(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sShowPrivateRepositories = i;\n    }\n\n    public static void updateLanguage(String language) {\n        sLanguage = language;\n        Log.i(\"AppSettings: \", \"updateLanguage(): \" + language);\n    }\n\n    public static void updateTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n        Log.i(\"AppSettings: \", \"updateTimeframe(): \" + timeframe);\n    }\n\n    public static void updateSortBy(String sortBy) {\n        sSortBy = sortBy;\n        Log.i(\"AppSettings: \", \"updateSortBy(): \" + sortBy);\n    }\n\n    public static void updateLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"updateLocationDisabledForever(): Invalid value \" + i);\n            return;\n        }\n        Log.i(\"AppSettings: \", \"updateLocationDisabledForever(): \" + i);\n        sLocationDisabledForever = i;\n    }\n\n    public static void setOAuthToken(String token) {\n        sOAuthToken = token;\n    }\n\n    public static void setUserLogin(String userLogin) {\n        sUserLogin = userLogin;\n    }\n\n    public static void setUserName(String userName) {\n        sUserName = userName;\n    }\n\n    public static void setUserAvatarUrl(String userAvatarUrl) {\n        sUserAvatarUrl  = userAvatarUrl;\n    }\n\n    public static void setUserEmail(String email) { sUserEmail = email; }\n\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkAsyncCheck.java\npublic class NetworkAsyncCheck extends AsyncTask<Void, Void, Boolean> {\n    private View view;\n\n    public NetworkAsyncCheck(View view) {\n        this.view = view;\n        Log.i(\"NetworkAsyncCheck: \", \"Starting\");\n    }\n\n    protected Boolean doInBackground(Void... params) {\n        Log.i(\"NetworkAsyncCheck: \", \"Doing\");\n        try {\n            InetAddress ipAddress = InetAddress.getByName(\"www.google.com\");\n            return !ipAddress.equals(\"\") ? Boolean.TRUE : Boolean.FALSE;\n        } catch (Exception e) {\n            return Boolean.FALSE;\n        }\n    }\n\n    protected void onPostExecute(Boolean result) {\n        Log.i(\"NetWorkASyncCheck: \", \" Done\");\n        if (result == Boolean.FALSE) {\n            Snackbar.make(view, String.format(Locale.getDefault(), NetworkHelper.noConnectionMessage, \"the internet\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(view.getContext(), R.color.colorAccent))\n                    .show();\n        }\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkHelper.java\npublic class NetworkHelper {\n\n    static String noConnectionMessage = \"Please connect to %s, this app requires internet access.\";\n\n    /**\n     * Return null if not connected to a network, else returns an async task to check the network has internet connection.\n     * Note: This checks for both valid network and valid internet connection.\n     * @param view any view in the activity that called this, used to make snackbar.\n     * @return null or NetworkHelper.NetworkAsyncCheck.\n     */\n    public static NetworkAsyncCheck checkNetworkConnection(View view) {\n        Context context = view.getContext();\n        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n        boolean isConnectedToNetwork = activeNetwork != null &&\n                activeNetwork.isConnectedOrConnecting();\n\n        if (!isConnectedToNetwork) {\n            Snackbar.make(view, String.format(Locale.getDefault(), noConnectionMessage, \"a network\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(context, R.color.colorAccent))\n                    .show();\n            return null;\n        }\n        return new NetworkAsyncCheck(view);\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/TooMuchDataException.java\npublic class TooMuchDataException extends Exception {\n    public TooMuchDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/NoDataException.java\npublic class NoDataException extends Exception {\n    public NoDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/model/json/PostLocationDataBody.java\npublic class PostLocationDataBody {\n    String login;\n    double latitude;\n    double longitude;\n    String message;\n    String email;\n    String name;\n    String avatarUrl;\n\n    public PostLocationDataBody(String login, double latitude, double longitude, String message,\n                                String email, String name, String avatarUrl) {\n        this.login = login;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.message = message;\n        this.email = email;\n        this.name = name;\n        this.avatarUrl = avatarUrl;\n    }\n}\nimport android.Manifest;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.PackageManager;\nimport android.location.Location;\nimport android.location.LocationListener;\nimport android.location.LocationManager;\nimport android.support.design.widget.Snackbar;\nimport android.support.design.widget.TextInputEditText;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.os.Bundle;\nimport android.support.v7.widget.AppCompatButton;\nimport android.support.v7.widget.AppCompatSpinner;\nimport android.support.v7.widget.AppCompatTextView;\nimport android.support.v7.widget.SwitchCompat;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.CompoundButton;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Locale;\nimport dlei.forkme.R;\nimport dlei.forkme.datastore.DatabaseHelper;\nimport dlei.forkme.datastore.NoDataException;\nimport dlei.forkme.datastore.TooMuchDataException;\nimport dlei.forkme.endpoints.BaseUrls;\nimport dlei.forkme.endpoints.ForkMeBackendApi;\nimport dlei.forkme.helpers.LocationHelper;\nimport dlei.forkme.helpers.NetworkAsyncCheck;\nimport dlei.forkme.helpers.NetworkHelper;\nimport dlei.forkme.model.LocationData;\nimport dlei.forkme.model.json.PostLocationDataBody;\nimport dlei.forkme.state.AppSettings;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport retrofit2.Call;\nimport retrofit2.Callback;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n                        .create()\n                        .show();\n            }  else {\n                // No explanation needed, we can request the permission.\n                ActivityCompat.requestPermissions(this,\n                        new String[]{Manifest.permission. ACCESS_FINE_LOCATION},\n                        MY_PERMISSIONS_REQUEST_LOCATION);\n            }\n        } else {\n            Log.wtf(\"SettingActivity: \", \" askForLocationPermissions() Already have permissions.\");\n            getLocation();\n        }\n    }\n\n\n    /**\n     * Called when the user responds to a permission request.\n     * @param requestCode code assigned to permission request.\n     * @param permissions permissions requested.\n     * @param grantResults results of permission requests.\n     */\n    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {\n        switch (requestCode) {\n            case MY_PERMISSIONS_REQUEST_LOCATION: {\n                // If request is cancelled, the result arrays are empty.\n                if (grantResults.length > 0\n                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    // Permission is granted.\n                    Log.d(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: granted\");\n                    String isCheckedStr = \"True\";\n                    mSwitchText.setText(isCheckedStr);\n                    mLocationSwitch.setClickable(false);\n                    // Only enable to turn of locations if locations permissions is revoked from outside.\n                } else {\n                    // Permission denied.\n                    Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: denied, test: \" + permissions[0]);\n\n                    boolean showRationale = shouldShowRequestPermissionRationale(permissions[0]);\n                    if (!showRationale) {\n                        // User also selected never show again.\n                        Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResultI() \" +\n                                \"Location Permissions: never show again clicked, disabled forever.\");\n                        // Disable switch button.\n                        mLocationSwitch.setEnabled(false);\n                        mSwitchText.setText(getResources().getText(R.string.disabled));\n                        // Make LocationDisabledForever true.\n                        AppSettings.updateLocationDisabledForever(1);\n                    }\n                    // Update switch to be false.\n                    mLocationSwitch.setChecked(false);\n                }\n                return;\n            }\n\n        }\n\n    }\n\n    // Location code adapted from:\n    // https://stackoverflow.com/questions/10524381/gps-android-get-positioning-only-once\n    // https://stackoverflow.com/questions/40142331/how-to-request-location-permission-on-android-6/40142454\n\n    /**\n     * Determine if location should be asked from GPS. We only want to get location once so we can determine\n     * what city the user is in. Only get new location if the old location if more than 2 days old.\n     */\n    public void getLocation() {\n        try {\n            Location location = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\n            // location time retrieved > time in milliseconds - 2000 (less than 2 days old).\n            // 1.4 days.\n            if (location != null && location.getTime() < Calendar.getInstance().getTimeInMillis() + 2 * 60 * 1000) {\n                // Use olg location.\n                Log.d(\"SettingActivity: \", \"getLocation(): Old location, latitude: \" + location.getLatitude() +\n                        \", longitude: \" + location.getLongitude() + \", time: \" + location.getTime());\n                postLocationInformation(location);\n            } else {\n                // Ask for location updates.\n                Log.d(\"SettingActivity: \", \"getLocation(): Request location updates.\");\n                // Bug fix for not being called onLocationChanged()\n                // https://stackoverflow.com/questions/9007600/onlocationchanged-callback-is-never-called\n                mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);\n                mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, this);\n            }\n        } catch (SecurityException e) {\n            Log.wtf(\"SettingActivity: \", \"Failed \" + e.getMessage());\n            return;\n        }\n    }\n\n    /**\n     * Location updates have been requested, this is triggered when we get a location update.\n     * We stop updates after this one update.\n     * @param location new location.\n     */\n    public void onLocationChanged(Location location) {\n        Log.d(\"SettingActivity: \", \"onLocationChanged() called\");\n        if (location != null) {\n            Log.d(\"SettingActivity: \", \"onLocationChanged(): Location update, latitude: \"\n                    + location.getLatitude() + \", longitude: \" + location.getLongitude());\n            mLocationManager.removeUpdates(this);   // Stop updates.\n            postLocationInformation(location);\n\n        }\n    }\n\n    // Required functions for location.\n    public void onProviderDisabled(String arg0) {}\n    public void onProviderEnabled(String arg0) {}\n    public void onStatusChanged(String arg0, int arg1, Bundle arg2) {}\n\n    /**\n     * Post location along with user information to ForkMe backend.\n     * @param location retrieved from GPS.\n     */\n    public void postLocationInformation(Location location) {\n        double latitude = location.getLatitude();\n        double longitude = location.getLongitude();Next line of code:\n", "input": "import android.Manifest;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.pm.PackageManager;\nimport android.location.Location;\nimport android.location.LocationListener;\nimport android.location.LocationManager;\nimport android.support.design.widget.Snackbar;\nimport android.support.design.widget.TextInputEditText;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.os.Bundle;\nimport android.support.v7.widget.AppCompatButton;\nimport android.support.v7.widget.AppCompatSpinner;\nimport android.support.v7.widget.AppCompatTextView;\nimport android.support.v7.widget.SwitchCompat;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.CompoundButton;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Locale;\nimport dlei.forkme.R;\nimport dlei.forkme.datastore.DatabaseHelper;\nimport dlei.forkme.datastore.NoDataException;\nimport dlei.forkme.datastore.TooMuchDataException;\nimport dlei.forkme.endpoints.BaseUrls;\nimport dlei.forkme.endpoints.ForkMeBackendApi;\nimport dlei.forkme.helpers.LocationHelper;\nimport dlei.forkme.helpers.NetworkAsyncCheck;\nimport dlei.forkme.helpers.NetworkHelper;\nimport dlei.forkme.model.LocationData;\nimport dlei.forkme.model.json.PostLocationDataBody;\nimport dlei.forkme.state.AppSettings;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport retrofit2.Call;\nimport retrofit2.Callback;\nimport retrofit2.Retrofit;\nimport retrofit2.converter.gson.GsonConverterFactory;\n                        .create()\n                        .show();\n            }  else {\n                // No explanation needed, we can request the permission.\n                ActivityCompat.requestPermissions(this,\n                        new String[]{Manifest.permission. ACCESS_FINE_LOCATION},\n                        MY_PERMISSIONS_REQUEST_LOCATION);\n            }\n        } else {\n            Log.wtf(\"SettingActivity: \", \" askForLocationPermissions() Already have permissions.\");\n            getLocation();\n        }\n    }\n\n\n    /**\n     * Called when the user responds to a permission request.\n     * @param requestCode code assigned to permission request.\n     * @param permissions permissions requested.\n     * @param grantResults results of permission requests.\n     */\n    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {\n        switch (requestCode) {\n            case MY_PERMISSIONS_REQUEST_LOCATION: {\n                // If request is cancelled, the result arrays are empty.\n                if (grantResults.length > 0\n                        && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    // Permission is granted.\n                    Log.d(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: granted\");\n                    String isCheckedStr = \"True\";\n                    mSwitchText.setText(isCheckedStr);\n                    mLocationSwitch.setClickable(false);\n                    // Only enable to turn of locations if locations permissions is revoked from outside.\n                } else {\n                    // Permission denied.\n                    Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResult() \" +\n                            \"Location Permissions: denied, test: \" + permissions[0]);\n\n                    boolean showRationale = shouldShowRequestPermissionRationale(permissions[0]);\n                    if (!showRationale) {\n                        // User also selected never show again.\n                        Log.wtf(\"SettingsActivity: \", \"onRequestPermissionsResultI() \" +\n                                \"Location Permissions: never show again clicked, disabled forever.\");\n                        // Disable switch button.\n                        mLocationSwitch.setEnabled(false);\n                        mSwitchText.setText(getResources().getText(R.string.disabled));\n                        // Make LocationDisabledForever true.\n                        AppSettings.updateLocationDisabledForever(1);\n                    }\n                    // Update switch to be false.\n                    mLocationSwitch.setChecked(false);\n                }\n                return;\n            }\n\n        }\n\n    }\n\n    // Location code adapted from:\n    // https://stackoverflow.com/questions/10524381/gps-android-get-positioning-only-once\n    // https://stackoverflow.com/questions/40142331/how-to-request-location-permission-on-android-6/40142454\n\n    /**\n     * Determine if location should be asked from GPS. We only want to get location once so we can determine\n     * what city the user is in. Only get new location if the old location if more than 2 days old.\n     */\n    public void getLocation() {\n        try {\n            Location location = mLocationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);\n            // location time retrieved > time in milliseconds - 2000 (less than 2 days old).\n            // 1.4 days.\n            if (location != null && location.getTime() < Calendar.getInstance().getTimeInMillis() + 2 * 60 * 1000) {\n                // Use olg location.\n                Log.d(\"SettingActivity: \", \"getLocation(): Old location, latitude: \" + location.getLatitude() +\n                        \", longitude: \" + location.getLongitude() + \", time: \" + location.getTime());\n                postLocationInformation(location);\n            } else {\n                // Ask for location updates.\n                Log.d(\"SettingActivity: \", \"getLocation(): Request location updates.\");\n                // Bug fix for not being called onLocationChanged()\n                // https://stackoverflow.com/questions/9007600/onlocationchanged-callback-is-never-called\n                mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, this);\n                mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, this);\n            }\n        } catch (SecurityException e) {\n            Log.wtf(\"SettingActivity: \", \"Failed \" + e.getMessage());\n            return;\n        }\n    }\n\n    /**\n     * Location updates have been requested, this is triggered when we get a location update.\n     * We stop updates after this one update.\n     * @param location new location.\n     */\n    public void onLocationChanged(Location location) {\n        Log.d(\"SettingActivity: \", \"onLocationChanged() called\");\n        if (location != null) {\n            Log.d(\"SettingActivity: \", \"onLocationChanged(): Location update, latitude: \"\n                    + location.getLatitude() + \", longitude: \" + location.getLongitude());\n            mLocationManager.removeUpdates(this);   // Stop updates.\n            postLocationInformation(location);\n\n        }\n    }\n\n    // Required functions for location.\n    public void onProviderDisabled(String arg0) {}\n    public void onProviderEnabled(String arg0) {}\n    public void onStatusChanged(String arg0, int arg1, Bundle arg2) {}\n\n    /**\n     * Post location along with user information to ForkMe backend.\n     * @param location retrieved from GPS.\n     */\n    public void postLocationInformation(Location location) {\n        double latitude = location.getLatitude();\n        double longitude = location.getLongitude();", "context": "ForkMe-Mobile/app/src/main/java/dlei/forkme/model/LocationData.java\npublic class LocationData {\n\n    private Double latitude;\n    private Double longitude;\n    private Integer id;\n\n    public Double getLatitude() {\n        return latitude;\n    }\n\n    public void setLatitude(Double latitude) {\n        this.latitude = latitude;\n    }\n\n    public Double getlongitude() {\n        return longitude;\n    }\n\n    public void setlongitude(Double _longitude) {\n        this.longitude = longitude;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n     public void setId(Integer id) {\n        this.id = id;\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/DatabaseHelper.java\npublic class DatabaseHelper extends SQLiteOpenHelper {\n\n    public static DatabaseHelper sDbInstance = null;\n\n    public static final String sDatabaseName = \"AppSettings\";\n    public static final int sDatabaseVersion = 1;\n\n    private DatabaseHelper(Context context) {\n        super(context, sDatabaseName, null, sDatabaseVersion);\n    }\n\n    /**\n     * Singleton pattern so only 1 object of DatabaseHelper exists.\n     * @param context activity context.\n     * @return instance of DatabaseHelper.\n     */\n    public static synchronized DatabaseHelper getDbInstance(Context context) {\n        if (sDbInstance == null) {\n            sDbInstance = new DatabaseHelper(context);\n            Log.d(\"DatabaseHelper: \", \"getDbInstance() created new instance\");\n        }\n        return sDbInstance;\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n        try {\n            sqLiteDatabase.execSQL(AppSettings.CREATE_TABLE_SQL);\n            Log.d(\"DatabaseHelper: \", \"onCreate() created db\");\n        } catch (SQLException e) {\n            Log.wtf(\"Error: \", String.format(\"Create Table Statement: %s\\nException: %s\",\n                    AppSettings.CREATE_TABLE_SQL, e));\n        }\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n        try {\n            sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + AppSettings.TABLE_NAME); // Drop table.\n            onCreate(sqLiteDatabase); // Re make table.\n        } catch (SQLException e) {\n            // Shouldn't happen, if it does log what a terrible message.\n            Log.wtf(\"Error: \", String.format(\"onUpdate Error, Exception %s\", e));\n        }\n        // db.close();  // Close database connection.\n    }\n\n    /**\n     * Insert settings for a user into persistant storage.\n     */\n    public void insertSettings() {\n        if (AppSettings.sUserLogin.equals(\"\")) {\n            Log.wtf(\"Error: \", \"DatabaseHelper.insertSettings(): user log in is null\");\n            return;\n        }\n        Log.i(\"DatabaseHelper: \", \"insertSettings(): inserting settings\");\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.USER_ID_COL, AppSettings.sUserLogin);\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        values.put(AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.sLocationDisabledForever);\n        values.put(AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.sFindPeopleMessage);\n        values.put(AppSettings.PRIVATE_REPOS_COL, AppSettings.sShowPrivateRepositories);\n        long result = db.insert(AppSettings.TABLE_NAME, null, values);\n        if (result == -1) {\n            Log.w(\"Error: \", String.format(\"Adding settings for user %s\", AppSettings.sUserLogin));\n        }\n    }\n\n    /**\n     * Update language for a user in persistant storage.\n     */\n    public void updateLanguage() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.LANGUAGE_COL, AppSettings.sLanguage);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update timeframe preference for a user in persistant storage.\n     */\n    public void updateTimeframe() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.TIMEFRAME_COL, AppSettings.sTimeframe);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Update stort by preference for a user in persistant storage.\n     */\n    public void updateSortBy() {\n        SQLiteDatabase db = this.getWritableDatabase();\n        ContentValues values = new ContentValues();\n        values.put(AppSettings.SORT_BY_COL, AppSettings.sSortBy);\n        db.update(AppSettings.TABLE_NAME, values, AppSettings.USER_ID_COL + \"='\" + AppSettings.sUserLogin +\"'\",\n                null);\n        db.close();\n    }\n\n    /**\n     * Loads settings for a user from SQLite db.\n     * @throws NoDataException Thrown when no data returned.\n     * @throws TooMuchDataException Thrown when too much data returned.\n     */\n    public void loadSettings() throws NoDataException, TooMuchDataException{\n        SQLiteDatabase db = this.getWritableDatabase();\n\n        String baseQuery = \"SELECT %s, %s, %s, %s, %s, %s from %s WHERE %s=?\";\n\n        String query = String.format(baseQuery,\n                AppSettings.TIMEFRAME_COL, AppSettings.SORT_BY_COL, AppSettings.LANGUAGE_COL,\n                AppSettings.LOCATION_DISABLED_FOREVER_COL, AppSettings.FIND_PEOPLE_MESSAGE_COL, AppSettings.PRIVATE_REPOS_COL,\n                AppSettings.TABLE_NAME,\n                AppSettings.USER_ID_COL);\n        Log.i(\"UserLogin: \", AppSettings.sUserLogin);\n\n        Cursor cursor = db.rawQuery(query, new String[]{AppSettings.sUserLogin});\n\n        cursor.moveToFirst();\n        int rows = cursor.getCount();\n        if (rows == 0) {\n            cursor.close();\n            db.close();\n            throw new NoDataException(String.format(\n                    \"User with login %s does not exist\", AppSettings.sUserLogin));\n        } else if (rows > 1) {\n            cursor.close();\n            db.close();\n            throw new TooMuchDataException(String.format(\n                    \"Only 1 row should be returned for user %s\", AppSettings.sUserLogin));\n        } else {\n            // Update settings for a user.\n            Log.i(\"Check has data worked: \", \"Language: \" + cursor.getString(2));\n            Log.i(\"Check has data worked: \", \"Timeframe: \" + cursor.getString(1));\n\n            AppSettings.setTimeframe(cursor.getString(0));\n            AppSettings.setSortBy(cursor.getString(1));\n            AppSettings.setLanguage(cursor.getString(2));\n            AppSettings.setLocationDisabledForever(cursor.getInt(3));\n            AppSettings.setFindPeopleAllowedMessage(cursor.getString(4));\n            AppSettings.setShowPrivateRepositories(cursor.getInt(5));\n            cursor.close();\n            db.close();\n        }\n\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/ForkMeBackendApi.java\npublic interface ForkMeBackendApi {\n\n    // Get all repositories v1.\n    @GET(\"/all_repos\")\n    Call<RepositoryResponse> getAllRepositories();\n\n    // Get single repository v1.\n    @GET(\"/all_repos/repositories/{id}\")\n    Call<Repository> getRepository(@Path(\"id\") int id);\n\n    // Get all repositories v2.\n    @GET(\"/repositories\")\n    Call<List<Repository>> getRepositoriesArray();\n\n    // Post location data v2.\n    @POST(\"/locations\")\n    Call<ResponseBody> postLocation(@Body PostLocationDataBody data);\n\n    // Get developers v2.\n    @GET(\"/developers/{login}\")\n    Call<List<DeveloperContactInfo>> getDevelopers(@Path(\"login\") String login);\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/LocationHelper.java\npublic class LocationHelper {\n\n    /**\n     * Checks if location permissions has been granted to application.\n     * @param context Activity context.\n     * @return true if has location permissions, else false.\n     */\n    public static boolean hasLocationPermissions(Context context) {\n\n        boolean hasLocationPermissions = ContextCompat\n                .checkSelfPermission(context,\n                        Manifest.permission.ACCESS_FINE_LOCATION\n                ) == PackageManager.PERMISSION_GRANTED;\n        return hasLocationPermissions;\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/endpoints/BaseUrls.java\npublic class BaseUrls {\n    public static String githubApi = \"https://api.github.com/\";\n    public static String forkMeBackendApi = \"https://forkme-backend-api2.herokuapp.com/\";\n    public static String forkMeBackendApiDeprecated = \"https://forkme-backend.herokuapp.com/\";\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/state/AppSettings.java\npublic class AppSettings {\n    // Setting attributes.\n    public static String sLanguage = \"All\";\n    public static String sSortBy = \"Stars\";\n    public static String sTimeframe = \"1 Month\";\n    public static String sUserLogin = \"\";\n    public static int sLocationDisabledForever = 0;\n    public static String sFindPeopleMessage = \"N/A\";\n    public static int sShowPrivateRepositories = 0;\n    public static String sOAuthToken = \"\";\n    public static String sUserName = \"\";\n    public static String sUserAvatarUrl = \"\";\n    public static String sUserEmail;\n\n    // Database attributes.\n    public static final String TABLE_NAME = \"settings\";\n    public static final String TIMEFRAME_COL = \"timeframe\";\n    public static final String SORT_BY_COL = \"sort_by\";\n    public static final String LANGUAGE_COL = \"language\";\n    public static final String LOCATION_DISABLED_FOREVER_COL = \"location_disabled_forever\";\n    public static final String FIND_PEOPLE_MESSAGE_COL = \"message\";\n    public static final String PRIVATE_REPOS_COL = \"private_repos\";\n    public static final String USER_ID_COL = \"user\";\n\n    public static final String CREATE_TABLE_SQL =\n            \"CREATE TABLE \" +\n            TABLE_NAME + \" (\" +\n            USER_ID_COL + SqlSyntax.TYPE_STRING + SqlSyntax.PRIMARY_KEY + \", \" +\n            TIMEFRAME_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            SORT_BY_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LANGUAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            LOCATION_DISABLED_FOREVER_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL + \", \" +\n            FIND_PEOPLE_MESSAGE_COL + SqlSyntax.TYPE_STRING + SqlSyntax.NOT_NULL + \", \" +\n            PRIVATE_REPOS_COL + SqlSyntax.TYPE_INTEGER + SqlSyntax.NOT_NULL +\n            \")\";\n\n    public static void setLanguage(String language) {\n        sLanguage = language;\n    }\n\n    public static void setSortBy(String sortBy) {\n        sSortBy = sortBy;\n    }\n\n    public static void setTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n    }\n\n    public static void setLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sLocationDisabledForever = i;\n    }\n\n    public static void setFindPeopleAllowedMessage(String findPeopleAllowedMessage) {\n        sFindPeopleMessage = findPeopleAllowedMessage;\n    }\n\n    public static void setShowPrivateRepositories(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"setShowPrivateRepositories: Invalid value \" + i);\n            return;\n        }\n        sShowPrivateRepositories = i;\n    }\n\n    public static void updateLanguage(String language) {\n        sLanguage = language;\n        Log.i(\"AppSettings: \", \"updateLanguage(): \" + language);\n    }\n\n    public static void updateTimeframe(String timeframe) {\n        sTimeframe = timeframe;\n        Log.i(\"AppSettings: \", \"updateTimeframe(): \" + timeframe);\n    }\n\n    public static void updateSortBy(String sortBy) {\n        sSortBy = sortBy;\n        Log.i(\"AppSettings: \", \"updateSortBy(): \" + sortBy);\n    }\n\n    public static void updateLocationDisabledForever(int i) {\n        if (i > 1 || i < 0) {\n            Log.wtf(\"AppSettings: \", \"updateLocationDisabledForever(): Invalid value \" + i);\n            return;\n        }\n        Log.i(\"AppSettings: \", \"updateLocationDisabledForever(): \" + i);\n        sLocationDisabledForever = i;\n    }\n\n    public static void setOAuthToken(String token) {\n        sOAuthToken = token;\n    }\n\n    public static void setUserLogin(String userLogin) {\n        sUserLogin = userLogin;\n    }\n\n    public static void setUserName(String userName) {\n        sUserName = userName;\n    }\n\n    public static void setUserAvatarUrl(String userAvatarUrl) {\n        sUserAvatarUrl  = userAvatarUrl;\n    }\n\n    public static void setUserEmail(String email) { sUserEmail = email; }\n\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkAsyncCheck.java\npublic class NetworkAsyncCheck extends AsyncTask<Void, Void, Boolean> {\n    private View view;\n\n    public NetworkAsyncCheck(View view) {\n        this.view = view;\n        Log.i(\"NetworkAsyncCheck: \", \"Starting\");\n    }\n\n    protected Boolean doInBackground(Void... params) {\n        Log.i(\"NetworkAsyncCheck: \", \"Doing\");\n        try {\n            InetAddress ipAddress = InetAddress.getByName(\"www.google.com\");\n            return !ipAddress.equals(\"\") ? Boolean.TRUE : Boolean.FALSE;\n        } catch (Exception e) {\n            return Boolean.FALSE;\n        }\n    }\n\n    protected void onPostExecute(Boolean result) {\n        Log.i(\"NetWorkASyncCheck: \", \" Done\");\n        if (result == Boolean.FALSE) {\n            Snackbar.make(view, String.format(Locale.getDefault(), NetworkHelper.noConnectionMessage, \"the internet\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(view.getContext(), R.color.colorAccent))\n                    .show();\n        }\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/helpers/NetworkHelper.java\npublic class NetworkHelper {\n\n    static String noConnectionMessage = \"Please connect to %s, this app requires internet access.\";\n\n    /**\n     * Return null if not connected to a network, else returns an async task to check the network has internet connection.\n     * Note: This checks for both valid network and valid internet connection.\n     * @param view any view in the activity that called this, used to make snackbar.\n     * @return null or NetworkHelper.NetworkAsyncCheck.\n     */\n    public static NetworkAsyncCheck checkNetworkConnection(View view) {\n        Context context = view.getContext();\n        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n\n        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n        boolean isConnectedToNetwork = activeNetwork != null &&\n                activeNetwork.isConnectedOrConnecting();\n\n        if (!isConnectedToNetwork) {\n            Snackbar.make(view, String.format(Locale.getDefault(), noConnectionMessage, \"a network\"), Snackbar.LENGTH_INDEFINITE)\n                    .setAction(\"CLOSE\", new View.OnClickListener() {\n                        @Override\n                        public void onClick(View view) {}\n                    })\n                    .setActionTextColor(ContextCompat.getColor(context, R.color.colorAccent))\n                    .show();\n            return null;\n        }\n        return new NetworkAsyncCheck(view);\n    }\n\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/TooMuchDataException.java\npublic class TooMuchDataException extends Exception {\n    public TooMuchDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/datastore/NoDataException.java\npublic class NoDataException extends Exception {\n    public NoDataException(String s) {\n        super(s);\n    }\n}\nForkMe-Mobile/app/src/main/java/dlei/forkme/model/json/PostLocationDataBody.java\npublic class PostLocationDataBody {\n    String login;\n    double latitude;\n    double longitude;\n    String message;\n    String email;\n    String name;\n    String avatarUrl;\n\n    public PostLocationDataBody(String login, double latitude, double longitude, String message,\n                                String email, String name, String avatarUrl) {\n        this.login = login;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.message = message;\n        this.email = email;\n        this.name = name;\n        this.avatarUrl = avatarUrl;\n    }\n}\n", "answers": ["        PostLocationDataBody dataBody = new PostLocationDataBody("], "pred": "        \"Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location information to Post location", "length": 2035, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "31be7d5ae81230c8f97a65a4360e143cd828be77c08f3863"}
{"prompt": "Please complete the code given below. \nnn_dataflow/tests/pipeline_test/test_pipeline_fixture.py\nclass TestPipelineFixture(unittest.TestCase):\n    ''' Base fixture class for layer pipeline tests. '''\n\n    def setUp(self):\n\n        self.net = {}\n\n        net = Network('net1')\n        # Linear.\n        net.set_input_layer(InputLayer(10, 1))\n        net.add('0', FCLayer(10, 20))\n        net.add('1', FCLayer(20, 30))\n        net.add('1p', PoolingLayer(30, 1, 1))\n        net.add('2', FCLayer(30, 40))\n        net.add('3', FCLayer(40, 50))\n        self.net[net.net_name] = net\n\n        net = Network('net2')\n        # Long linear.\n        net.set_input_layer(InputLayer(1, 1))\n        for idx in range(16):\n            net.add(str(idx), FCLayer(1, 1))\n        self.net[net.net_name] = net\n\n        net = Network('net3')\n        # Fork.\n        # /0-2\\   /6- 7- 8\\\n        #   x  4-5         12\n        # \\1-3/   \\9-10-11/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('1', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('2', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('2p', PoolingLayer(1, 1, 1))\n        net.add('3', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('4', FCLayer(2, 1), prevs=('2p', '3'))\n        net.add('5', FCLayer(1, 1))\n        net.add('5p', PoolingLayer(1, 1, 1))\n        net.add('6', FCLayer(1, 1), prevs='5p')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(1, 1), prevs='5p')\n        net.add('10', FCLayer(1, 1))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('8', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net4')\n        # Complex fork.\n        #          /5       \\\n        # 0-1-2-3-4-6-7-8-10-14\n        #              \\9/\n        #          \\11-12   /\n        #          \\13      /\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1))\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1))\n        net.add('4', FCLayer(1, 1))\n        net.add('5', FCLayer(1, 1), prevs='4')\n        net.add('6', FCLayer(1, 1), prevs='4')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1), prevs='7')\n        net.add('9', FCLayer(1, 1), prevs='7')\n        net.add('10', FCLayer(1, 1))\n        net.add('10p', PoolingLayer(2, 1, 1), prevs=('8', '10'))\n        net.add('11', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('12', FCLayer(1, 1))\n        net.add('13', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('14', FCLayer(5, 1), prevs=('5', '10p', '12', '13'))\n        self.net[net.net_name] = net\n\n        net = Network('net5')\n        # Corner cases.\n        #  ----\\\n        # //1-2\\ 7-8\\\n        # 0-3-4-x   10-11-12\n        #  \\ \\5/ 9 /  \\__/\n        #   6--/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(1, 1), prevs='3')\n        net.add('5', FCLayer(1, 1), prevs='3')\n        net.add('6', FCLayer(1, 1), prevs='0')\n        net.add('7', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('10', FCLayer(2, 1), prevs=('8', '9'))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('10', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net6')\n        # Fmap sizes.\n        net.set_input_layer(InputLayer(1, 24))\n        net.add('0', ConvLayer(1, 1, 24, 3))\n        net.add('1', ConvLayer(1, 1, 12, 3, strd=2))\n        net.add('1p', PoolingLayer(1, 6, 2))\n        net.add('2', ConvLayer(1, 1, 6, 3))\n        net.add('3', ConvLayer(1, 1, 6, 3, strd=4), prevs=('0'))\n        self.net[net.net_name] = net\n\n        net = Network('net7')\n        # Topological order: see a visited vertex again.\n        #  /---\n        # 0-1-\\\\\n        #  \\2--2p\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='0')\n        net.add('2p', PoolingLayer(3, 1, 1), prevs=('0', '1', '2'))\n        self.net[net.net_name] = net\n\n        net = Network('net8')\n        # Forward to the middle.\n        #    /-\\\n        # 0-1-2-2p-4-4p\n        #  \\-3------/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='1')\n        net.add('2p', PoolingLayer(2, 1, 1), prevs=('1', '2'))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(2, 1), prevs='2p')\n        net.add('4p', PoolingLayer(2, 1, 1), prevs=('3', '4'))\n        self.net[net.net_name] = net\n\n        net = Network('net9')\n        # Previous layers include input and others.\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(2, 1), prevs=(net.INPUT_LAYER_KEY, '0'))\n        self.net[net.net_name] = net\n\n        # Real networks.\n        for net_name in all_networks():\n            self.net[net_name] = import_network(net_name)\n\n        self.batch_size = 16\n\n        self.resource = Resource(\n            proc_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.PROC),\n            dram_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.DRAM),\n            src_data_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dst_data_region=NodeRegion(origin=PhyDim2(0, 4), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dim_array=PhyDim2(16, 16), size_gbuf=65536, size_regf=64,\n            array_bus_width=float('inf'), dram_bandwidth=float('inf'),\n            no_time_mux=False)\n\n        part = PartitionScheme(order=range(pe.NUM), pdims=[(1, 1)] * pe.NUM)\n        self.ofmap_layout = DataLayout(\n            frngs=(FmapRange((0, 0, 0, 0), (2, 4, 16, 16)),),\n            regions=(NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(1, 1),\n                                type=NodeRegion.DRAM),),\n            parts=(part,))\n\n\n    def _make_ilp(self, network):\n        ''' Make an InterLayerPipeline instance. '''\n        return InterLayerPipeline(network, self.batch_size, self.resource)\n\n    def _make_segment(self, vseg, network, temporal=False, max_util_drop=None,\n                      with_opt=True):\n        ''' Convert vertex segment to (layer) segment. '''\n        kwargs = {}\n        if max_util_drop is not None:\n            kwargs['max_util_drop'] = max_util_drop\n        if not with_opt:\n            kwargs['with_opt'] = False\n        ilp = self._make_ilp(network)\n        seg = tuple(ilp.dag_vertex_list[vidx] for vidx in vseg)\n        if temporal:\n            seg = (sum(seg, tuple()),)\n        return PipelineSegment(seg, ilp.network, ilp.batch_size, ilp.resource,\n                               **kwargs)\n\n    def _make_sched_res(self, sched_seq, time, top_ti=1, top_to=1, top_tb=1,\n                        top_ord=range(le.NUM), dram_time=0, num_nodes=4):\n        scheme = OrderedDict()\n        scheme['cost'] = 1.234 + 9.876\n        scheme['time'] = max(time, dram_time)\n        scheme['num_nodes'] = num_nodes\n        scheme['proc_time'] = time\n        scheme['bus_time'] = 0\n        scheme['dram_time'] = dram_time\n        scheme['ti'] = [top_ti, 1, 1]\n        scheme['to'] = [top_to, 1, 1]\n        scheme['tb'] = [top_tb, 1, 1]\n        scheme['tvals'] = [[top_ti, top_to, top_tb], [1] * 3, [1] * 3]\n        scheme['orders'] = [top_ord, range(le.NUM), range(le.NUM)]\n        return SchedulingResult(scheme=scheme,\n                                ofmap_layout=self.ofmap_layout,\n                                sched_seq=sched_seq)\n\n    def _gen_all_segment(self, network, **kwargs):\n        '''\n        Generate all segments directly from all layers and all vertex segments.\n        '''\n        # pylint: disable=protected-access\n        ilp = self._make_ilp(network)\n        for layer in network:\n            yield PipelineSegment(((layer,),), ilp.network, ilp.batch_size,\n                                  ilp.resource)\n        for vseg in ilp._gen_vseg():\n            segment = self._make_segment(vseg, network, **kwargs)\n            if len(segment) == 1 and len(segment[0]) == 1:\n                continue\n            yield segment\n\n    def _validate_allocation(self, segment, allocation):\n        ''' Validate segment resource allocation. '''\n\n        # Match segment.\n        self.assertEqual(len(allocation), len(segment))\n        for ltpl, rtpl in zip(segment, allocation):\n            self.assertEqual(len(rtpl), len(ltpl))\n            self.assertTrue(all(isinstance(r, Resource) for r in rtpl))\n\n        # Number of nodes.\n        nodes = []  # number of nodes.\n        for rtpl in allocation:\n            nodes.append(rtpl[0].proc_region.dim.size())\n        self.assertEqual(sum(nodes), self.resource.proc_region.dim.size())\n\n        # Temporal schedules share processing region; spatial schedules use\n        # non-overlapped processing regions.\n        used_proc_nodes = set()  # used processing nodes\n        for rtpl in allocation:\n            proc_region = rtpl[0].proc_region\n            self.assertTrue(all(r.proc_region == proc_region for r in rtpl))\n            for n in proc_region.iter_node():\n                self.assertTrue(self.resource.proc_region.contains_node(n),\n                                '_validate_allocation: node {} outside of '\n                                'the processing region {}'\n                                .format(n, self.resource.proc_region))\n                self.assertNotIn(n, used_proc_nodes,\n                                 '_validate_allocation: node {} has been '\n                                 'used.'.format(n))\n                used_proc_nodes.add(n)\n\n        # Data liveness.\n        data_regions = {}  # layers that have data currently on-chip\n        for ltpl, rtpl in zip(segment, allocation):\n\n            for l, r in zip(ltpl, rtpl):\n\n                # Check data source.\n                prev_layers = segment.network.prevs(l)\n\n                for pl in prev_layers:\n                    if pl not in data_regions:\n                        # Previous layer is not on-chip, from memory.\n                        # Try find a layer responsible to fetch shared mem src.\n                        try:\n                            sh_sp_idx = next((i for i in range(len(allocation))\n                                              if allocation[i][0].proc_region\n                                              == r.src_data_region))\n                        except StopIteration:\n                            # No shared mem src.\n                            self.assertEqual(\n                                r.src_data_region,\n                                self.resource.src_data_region,\n                                '_validate_allocation: layer {}\\'s prev {} '\n                                'is not on-chip, should be from {}, but {}.'\n                                .format(l, pl, self.resource.src_data_region,\n                                        r.src_data_region))\n                        else:\n                            # There exists shared mem src.\n                            sh_l = segment[sh_sp_idx][0]\n                            self.assertEqual(segment.network.prevs(l),\n                                             segment.network.prevs(sh_l),\n                                             '_validate_allocation: layer {} '\n                                             'expects on-chip mem src sharing '\n                                             'with {}, but prevs differ.'\n                                             .format(l, sh_l))\n                    elif data_regions[pl] != r.proc_region:\n                        # Previous layer is on-chip and not local.\n                        self.assertEqual(\n                            r.src_data_region, data_regions[pl],\n                            '_validate_allocation: layer {}\\'s prev {} '\n                            'is on-chip, should be from {}, but {}.'\n                            .format(l, pl, data_regions[pl],\n                                    r.src_data_region))\n\n                # Update data based on destination.\n                # Local or store back to memory. Both will be available on-chip.\n                self.assertTrue(r.dst_data_region == r.proc_region\n                                or r.dst_data_region\n                                == self.resource.dst_data_region,\n                                '_validate_allocation: data can only '\n                                'be local or storing back to mem.')\n                # Overwrite.\n                local_node_set = set(r.proc_region.iter_node())\n                data_regions = {pl: data_regions[pl] for pl in data_regions\n                                if local_node_set.isdisjoint(\n                                    data_regions[pl].iter_node())}\n                data_regions[l] = r.proc_region\n\n    def _validate_constraint(self, segment, constraint):\n        ''' Validate segment scheduling constraint. '''\n        # pylint: disable=too-many-branches\n\n        # Match segment.\n        self.assertEqual(len(constraint), len(segment))\n        for ltpl, ctpl in zip(segment, constraint):\n            self.assertEqual(len(ctpl), len(ltpl))\n            self.assertTrue(all(isinstance(c, SchedulingConstraint)\n                                for c in ctpl))\n\n        # Same top tb.\n        top_tb = constraint[0][0].topbat\n        self.assertTrue(all(c.topbat == top_tb\n                            for ctpl in constraint for c in ctpl))\n\n        # Top tb is a factor of batch size.\n        if top_tb:\n            self.assertEqual((segment.batch_size) % top_tb, 0)\n\n        # Data availability.\n\n        seg_layers = set(l for ltpl in segment for l in ltpl)\n\n        class OutAccPat():\n            ''' Output data access pattern types. '''\n            # pylint: disable=too-few-public-methods\n            ANY = 0   # can access in any way\n            DBF = -1  # must double-buffer\n            # SEQ: use any positive value to represent sequential access with\n            # certain number of groups.\n\n        # Available data in each spatial subregions. Each is represented by a\n        # tuple of layer name and its output data access pattern.\n        avail_data = [(None, OutAccPat.ANY) for _ in segment]\n\n        # Get groups of layers sharing the same memory source.\n        prevs2layers = {}\n        for ltpl in segment:\n            l = ltpl[0]\n            prevs2layers.setdefault(segment.network.prevs(l), []).append(l)\n        sh_mem_src_groups = [ls for ps, ls in prevs2layers.items()\n                             if not seg_layers.intersection(ps) and len(ls) > 1]\n        sh_mem_src_topifms = [None] * len(sh_mem_src_groups)\n\n        # Whether to defer fully buffering output.\n        fb_out = False\n        fb_out_conv = None\n\n        for sp_idx, (ltpl, ctpl) in enumerate(zip(segment, constraint)):\n\n            self.assertFalse(fb_out,\n                             '_validate_constraint: deferring fully buffering '\n                             'from {} should not cross spatial scheduling {}.'\n                             .format(fb_out_conv, sp_idx - 1))\n\n            for tm_idx, (layer, cstr) in enumerate(zip(ltpl, ctpl)):\n\n                # Source data and their access patterns.\n                prev_layers = segment.network.prevs(layer)\n                prev_oaps = []\n                for pl in prev_layers:\n                    if pl not in seg_layers:\n                        # Off-chip sources.\n                        poap = OutAccPat.ANY\n                    elif pl in ltpl:\n                        # On-chip and local.\n                        self.assertEqual(avail_data[sp_idx][0], pl,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'local source data {} not available, '\n                                         'maybe not the immediate previous.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                        poap = avail_data[sp_idx][1]\n                    else:\n                        # On-chip and neighbor.\n                        poap = next((avail_data[p_sp_idx][1]\n                                     for p_sp_idx in range(sp_idx)\n                                     if avail_data[p_sp_idx][0] == pl),\n                                    None)\n                        self.assertFalse(poap is None,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'neighbor source data {} not '\n                                         'available on-chip.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                    prev_oaps.append(poap)\n                # Only buffer input if having source on-chip.\n                has_src = not seg_layers.isdisjoint(prev_layers)\n\n                # The single SEQ source.\n                seq = None\n                # str is greater than all numbers, see\n                # https://docs.python.org/2/library/stdtypes.html#comparisons\n                seq_prev_oaps = [poap for poap in prev_oaps \\\n                                 if isinstance(poap, str) or \\\n                                    (isinstance(poap, int) and poap > 0)]\n                if seq_prev_oaps:\n                    self.assertEqual(len(seq_prev_oaps), 1,\n                                     '_validate_constraint: layer {} ({}) '\n                                     'has multiple SEQ input.'\n                                     '\\nsrcs: {}, oaps: {}'\n                                     .format(layer, (sp_idx, tm_idx),\n                                             prev_layers, prev_oaps))\n                    seq = seq_prev_oaps[0]\n\n                # Destination data.\n                # Only buffer output if having destination on-chip.\n                next_layers = segment.network.nexts(layer)\n                has_dst = not seg_layers.isdisjoint(next_layers)\n\n                # Validation.\n\n                for g_idx, group in enumerate(sh_mem_src_groups):\n                    if layer in group:\n                        if sh_mem_src_topifms[g_idx] is None:\n                            sh_mem_src_topifms[g_idx] = cstr.topifm\n                        self.assertEqual(sh_mem_src_topifms[g_idx], cstr.topifm,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'share memory source with {}, but has '\n                                         'mismatched topifm {} with {}.'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 group, cstr.topifm,\n                                                 sh_mem_src_topifms[g_idx]))\n                        break\n                else:\n                    if not has_src:\n                        self.assertEqual(cstr.topifm, 0,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'should not constrain input as it '\n                                         'does not have on-chip sources.'\n                                         .format(layer, (sp_idx, tm_idx)))\n\n                if isinstance(segment.network[layer], ConvLayer):\n\n                    self.assertFalse(fb_out,\n                                     '_validate_constraint: deferring fully '\n                                     'buffering from {} has not been realized.'\n                                     .format(fb_out_conv))\n\n                    if any(pl in ltpl for pl in prev_layers):\n                        # Local source.\n                        lcl_poap = avail_data[sp_idx][1]\n                        self.assertIn(lcl_poap, (OutAccPat.DBF, OutAccPat.ANY),\n                                      '_validate_constraint: layer {} ({}) '\n                                      'local source data {} must fully '\n                                      'buffer output.'\n                                      .format(layer, (sp_idx, tm_idx),\n                                              lcl_poap))\n\n                    # DBF source.\n                    if OutAccPat.DBF in prev_oaps:\n                        # Must fully buffer CONV input.\n                        self.assertEqual(cstr.topifm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input is not fully buffered but has '\n                                         'DBF source.\\nsrcs: {}, oaps: {}'\n                                         '\\n{}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps,\n                                                 cstr))\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Cannot be lazily updated.\n                        self.assertNotIsInstance(\n                            seq, str,\n                            '_validate_constraint: CONV layer {} ({}) cannot '\n                            'use lazy update (from {})'\n                            .format(layer, (sp_idx, tm_idx), seq))\n                        # Must match SEQ.\n                        self.assertEqual(cstr.topifm, seq,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input groups ({}) and its SEQ src '\n                                         'output groups ({}) are mismatched.'\n                                         '\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 cstr.topifm, seq,\n                                                 prev_layers, prev_oaps))\n                        # Also must fully buffer CONV output.\n                        self.assertEqual(cstr.topofm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'output is not fully buffered but has '\n                                         'SEQ source.\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps))\n                        # Deferred apply to the last layer in the group.\n                        fb_out = True\n                        fb_out_conv = layer\n\n                    oap = None\n                    if cstr.topofm == 1:\n                        if cstr.topifm == 1:\n                            # Fully buffer both, can access output in any way.\n                            # This is fine as we require to buffer either input\n                            # or output for CONV (see below).\n                            oap = OutAccPat.ANY\n                        else:\n                            oap = OutAccPat.DBF\n                    elif has_dst and cstr.topofm > 0:\n                        oap = cstr.topofm\n                        if has_src:\n                            self.assertEqual(cstr.topifm, 1,\n                                             '_validate_constraint: layer {} '\n                                             '({}) has on-chip src and dst '\n                                             'but neither input nor output '\n                                             'are fully buffered.\\ncstr: {}.'\n                                             .format(layer, (sp_idx, tm_idx),\n                                                     cstr))\n                    elif has_dst:\n                        # Lazy update, record layer name as seq.\n                        oap = layer\n\n                else:\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Must match SEQ, or fully buffer output.\n                        self.assertTrue(cstr.topofm == seq or cstr.topofm == 1\n                                        or seq in cstr.update_dict,\n                                        '_validate_constraint: layer {} ({}) '\n                                        'output is not fully buffered, and '\n                                        'groups ({}) and its SEQ src output '\n                                        'groups ({}) are mismatched, and '\n                                        'lazy update is not used.'\n                                        '\\nsrcs: {}, oaps: {}'\n                                        .format(layer, (sp_idx, tm_idx),\n                                                cstr.topofm, seq,\n                                                prev_layers, prev_oaps))\n\n                    if cstr.topofm == 1:\n                        # Fully buffer output.\n                        oap = OutAccPat.DBF\n                    elif isinstance(seq, str):\n                        # Lazy update.\n                        oap = seq\n                    else:\n                        # SEQ output.\n                        oap = cstr.topofm\n\n                # Realize deferred fully buffering output.\n                if cstr.topofm == 1:\n                    fb_out = False  # reset\n\n                # Overwrite the previous temporal scheduling.\n                avail_data[sp_idx] = (layer, oap)\nnn_dataflow/core/network.py\nclass Network():\n    '''\n    NN topology. Support DAG structure of layers.\n    '''\n\n    INPUT_LAYER_KEY = '__INPUT__'\n\n    def __init__(self, net_name):\n        self.net_name = net_name\n        self.layer_dict = OrderedDict()\n        self.prevs_dict = {}\n        self.nexts_dict = {}\n        self.ext_dict = OrderedDict()\n\n    def set_input_layer(self, input_layer):\n        '''\n        Set the input layer.\n        '''\n        if self.INPUT_LAYER_KEY in self.layer_dict:\n            raise KeyError('Network: only one input layer is allowed.')\n\n        if not isinstance(input_layer, InputLayer):\n            raise TypeError('Network: input_layer must be an InputLayer '\n                            'instance.')\n\n        self.layer_dict[self.INPUT_LAYER_KEY] = input_layer\n\n    def input_layer(self):\n        '''\n        Get the input layer.\n        '''\n        return self.layer_dict[self.INPUT_LAYER_KEY]\n\n    def add(self, layer_name, layer, prevs=None):\n        '''\n        Add a named layer, with optional previous layer(s).\n\n        If previous layer(s) is not given, assume it follows the last added\n        layer.\n        '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            raise RuntimeError('Network: must first set input layer.')\n\n        if layer_name in self.layer_dict:\n            raise KeyError('Network: layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, Layer):\n            raise TypeError('Network: layer must be a Layer instance.')\n\n        # First figure out previous layers.\n        if prevs:\n            # Ensure `prevs` as a tuple.\n            if isinstance(prevs, str):\n                prevs = (prevs,)\n            else:\n                prevs = tuple(prevs)\n            # Ensure previous layers are already added.\n            for p in prevs:\n                try:\n                    self.__getitem__(p)\n                except KeyError:\n                    raise KeyError('Network: given previous layer {} '\n                                   'has not been added to the network'.\n                                   format(p))\n        else:\n            prevs = (list(self.layer_dict.keys())[-1],)\n\n        self.layer_dict[layer_name] = layer\n        self.prevs_dict[layer_name] = prevs\n\n        # Ensure dimension matching between layers.\n        try:\n            self._check_prevs(layer_name)\n        except ValueError:\n            del self.layer_dict[layer_name]\n            del self.prevs_dict[layer_name]\n            raise\n\n        for p in prevs:\n            self.nexts_dict.setdefault(p, []).append(layer_name)\n\n    def add_ext(self, layer_name, layer):\n        '''\n        Add a named external layer.\n        '''\n        if layer_name in self.ext_dict:\n            raise KeyError('Network: external layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, InputLayer):\n            raise TypeError('Network: external layer must be an InputLayer '\n                            'instance.')\n\n        self.ext_dict[layer_name] = layer\n\n    def prevs(self, layer_name):\n        '''\n        Get the previous layers of the given layer name.\n\n        Return a tuple of all the previous layer names. Use `None` to represent\n        the input layer in the returned tuple.\n        '''\n        if layer_name == self.INPUT_LAYER_KEY:\n            raise ValueError('Network: cannot get previous layers for '\n                             'input layer.')\n        if layer_name in self.ext_dict:\n            raise ValueError('Network: cannot get previous layers for '\n                             'external layers.')\n\n        prevs = tuple(None if p == self.INPUT_LAYER_KEY else p\n                      for p in self.prevs_dict[layer_name])\n        assert prevs\n\n        return prevs\n\n    def nexts(self, layer_name):\n        '''\n        Get the next layers of the given layer name, i.e., the layers that need\n        the output of this layer.\n\n        Return a tuple of all the next layer names. Use `None` to represent the\n        output of the last layer in the returned tuple.\n        '''\n        try:\n            nexts = tuple(self.nexts_dict[layer_name])\n        except KeyError:\n            nexts = tuple([None])\n        assert nexts\n\n        return nexts\n\n    def firsts(self):\n        '''\n        Get a tuple of the first layers, i.e., those with only the input layer\n        or external layers as their previous layers.\n\n        If a layer has other layers besides the input/external layers as its\n        previous layers, it does not count as a first layer.\n        '''\n        input_ext_layers = set([None]).union(self.ext_layers())\n        firsts = []\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            if input_ext_layers.issuperset(prevs):\n                firsts.append(layer_name)\n        return tuple(firsts)\n\n    def lasts(self):\n        '''\n        Get a tuple of the last layers, i.e., those with no next layer.\n        '''\n        lasts = []\n        for layer_name in self:\n            nexts = self.nexts(layer_name)\n            if nexts == (None,):\n                lasts.append(layer_name)\n        return tuple(lasts)\n\n    def ext_layers(self):\n        '''\n        Get a tuple of the external layers.\n        '''\n        return tuple(self.ext_dict.keys())\n\n    def _check_prevs(self, layer_name):\n        '''\n        Check the previous layers of the given layer name.\n        '''\n        layer = self.layer_dict[layer_name]\n\n        prevs = self.prevs_dict[layer_name]\n        assert prevs\n\n        # Compare the ifmap dimensions of this layer, with all the ofmaps of\n        # the previous layers.\n        sum_nfmaps = 0\n\n        for p in prevs:\n            pl = self.__getitem__(p)\n\n            # Ensure fmap sizes match. Allow padding.\n            if not layer.is_valid_padding_sifm((pl.hofm, pl.wofm)):\n                raise ValueError('Network: {}, a previous layer of {}, '\n                                 'has mismatch fmap size: {} vs. {}.'\n                                 .format(p, layer_name,\n                                         (pl.hofm, pl.wofm),\n                                         (layer.hofm, layer.wofm)))\n\n            sum_nfmaps += pl.nofm\n\n        if sum_nfmaps != layer.nifm:\n            raise ValueError('Network: {} cannot be the previous layers of {}.'\n                             .format(' | '.join(prevs), layer_name))\n\n    def __contains__(self, layer_name):\n        ''' Whether the network contains a layer. '''\n        return layer_name in self.layer_dict or layer_name in self.ext_dict\n\n    def __len__(self):\n        ''' Number of layers in the network. '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            assert not self.layer_dict\n            return 0\n        return len(self.layer_dict) - 1\n\n    def __iter__(self):\n        ''' Iterate through layer names. '''\n        for layer_name in self.layer_dict.keys():\n            if layer_name == self.INPUT_LAYER_KEY:\n                continue\n            yield layer_name\n\n    def __getitem__(self, layer_name):\n        ''' Get the layer by name. '''\n        try:\n            return self.layer_dict[layer_name]\n        except KeyError:\n            try:\n                return self.ext_dict[layer_name]\n            except KeyError as e:\n                raise KeyError('Network: {} layer not found.'.format(str(e)))\n\n    def __str__(self):\n        str_ = 'Network: {}\\n'.format(self.net_name)\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            prev_str = ' | '.join(['None' if n is None else n for n in prevs])\n            str_ += '  Layer {} <- {}\\n'.format(layer_name, prev_str)\n        return str_\nnn_dataflow/core/layer.py\nclass ConvLayer(Layer):\n    '''\n    NN convolutional layer parameters.\n\n    nifm (C): # ifmap channels\n    nofm (M): # ofmap channels\n    hifm, wifm (H): ifmap height/width\n    hofm, wofm (E): ofmap height/width\n    hfil, wfil (R): weight filter width/height\n    htrd, wtrd (U): stride height/width\n    '''\n\n    def __init__(self, nifm, nofm, sofm, sfil, strd=1):\n        super(ConvLayer, self).__init__(nofm, sofm, strd=strd)\n\n        if isinstance(sfil, int):\n            hfil = sfil\n            wfil = sfil\n        elif len(sfil) == 2:\n            hfil = sfil[0]\n            wfil = sfil[1]\n        else:\n            raise ValueError('ConvLayer: sfil is invalid ({}), '\n                             'needs to be either one integer or '\n                             'a pair of integers'.format(sfil))\n\n        self.hfil = hfil\n        self.wfil = wfil\n\n        hifm = self.hfil + (self.hofm - 1) * self.htrd\n        wifm = self.wfil + (self.wofm - 1) * self.wtrd\n        self.inlayer = Layer(nifm, (hifm, wifm))\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops(le.IFM, le.OFM)\n        dls[de.IFM] = DataDimLoops(le.IFM, le.BAT)\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return self.inlayer\n\n    def ops_per_neuron(self):\n        # 2D convolution across all ifmap channels.\n        return self.hfil * self.wfil * self.nifm\n\n    def filter_size(self, word_size=1):\n        '''\n        Get size of one weight filter.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.hfil * self.wfil * word_size\n\n    def total_filter_size(self, word_size=1):\n        '''\n        Get total size of all weight filters.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.nifm * self.nofm * self.filter_size(word_size)\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sfil={}'.format(repr((self.hfil, self.wfil))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/layer.py\nclass FCLayer(ConvLayer):\n    '''\n    NN fully-connected layer parameters.\n\n    As a special case of CONVLayer.\n\n    hifm = hfil, wifm = wfil, strd = 1, hofm = wofm = 1\n    '''\n\n    def __init__(self, nifm, nofm, sfil=1):\n        super(FCLayer, self).__init__(nifm, nofm, 1, sfil)\n        assert self.hofm == 1 and self.wofm == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sfil={}'.format(repr((self.hfil, self.wfil)))]))\nnn_dataflow/core/inter_layer_pipeline.py\nclass InterLayerPipeline():\n    '''\n    Inter-layer pipeline.\n    '''\n\n    def __init__(self, network, batch_size, resource, max_util_drop=0.05):\n        if not isinstance(network, Network):\n            raise TypeError('InterLayerPipeline: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('InterLayerPipeline: resource must be '\n                            'a Resource instance.')\n        if not 0 <= max_util_drop <= 1:\n            raise ValueError('InterLayerPipeline: max_util_drop must be '\n                             'between [0, 1].')\n\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n\n        self._calc_sched_dag()\n\n        # Vertices starting from which we have generated the segments.\n        self.seg_vertex_done = set()\n\n    def ordered_layer_list(self):\n        '''\n        Get a list of the layers in their topological order in the scheduling\n        DAG.\n        '''\n        return list(sum(self.dag_vertex_list, tuple()))\n\n    def gen_segment(self, options):\n        '''\n        Generate all valid inter-layer pipelining segments.\n        '''\n\n        kwargs = {'network': self.network,\n                  'batch_size': self.batch_size,\n                  'resource': self.resource,\n                  'max_util_drop': self.max_util_drop,\n                  'with_opt': options.layer_pipeline_opt,\n                 }\n\n        # No pipelining, each layer sequentially occupies the whole resource.\n        for layer in self.network:\n            seg = ((layer,),)\n            segment = PipelineSegment(seg, **kwargs)\n            assert segment.valid\n            yield segment\n\n        # Pipelining.\n        for vseg in self._gen_vseg():\n\n            if len(vseg) > options.layer_pipeline_max_degree:\n                continue\n\n            if len(vseg) == 1 and len(self.dag_vertex_list[vseg[0]]) == 1:\n                # An individual layer, already returned in no-pipelining case.\n                continue\n\n            # Use set to eliminate duplicates.\n            seg_cands = set()\n\n            if options.partition_interlayer:\n                # Spatial pipelining.\n                seg = tuple(self.dag_vertex_list[vidx] for vidx in vseg)\n                seg_cands.add(seg)\n\n            if options.hw_gbuf_save_writeback:\n                # Temporal pipelining.\n                # Reduce the spatial dimension.\n                seg = (tuple(itertools.chain.from_iterable(\n                    self.dag_vertex_list[vidx] for vidx in vseg)),)\n                seg_cands.add(seg)\n\n            # Determine segment allocation.\n            for seg in seg_cands:\n                segment = PipelineSegment(seg, **kwargs)\n                if segment.valid:\n                    yield segment\n\n    def _gen_vseg(self, vertex_idx=0, done=None):\n        '''\n        Generate vertex segments starting from vertex `vertex_idx`. Yield a\n        tuple of the vertices in the segment.\n\n        `done` is a set of vertices which have already been scheduled and the\n        output is already in memory.\n\n        Rules:\n\n        1. If a vertex does not share any dependencies with the current\n        segment, i.e., none of its previous vertices is in the current segment\n        or among the previous vertices of the current segment, we do not add it\n        to the segment, because there is no benefit to co-locate them.\n\n        2. If a vertex has multiple previous vertices, at most one of them\n        can be in the same segment as this vertex, because the output data\n        availability timing of multiple previous vertices may not match.\n\n        3. If a vertex has multiple next vertices, either all or at most one of\n        them can be NOT in the same segment as this vertex, because only\n        including a small subset saves little data write-back to memory.\n        '''\n\n        vseg = tuple()\n\n        if not done:\n            done = set()\n            # Reset.\n            self.seg_vertex_done = set()\n\n        if self.dag_input_vertex not in done:\n            # Input layer is always in memory.\n            done.add(self.dag_input_vertex)\n\n        # The frontier is the vertex to be considered to be added to the\n        # current segment.\n        for frontier in range(vertex_idx, len(self.dag_vertex_list)):\n\n            # Check whether the frontier can be added to the current segment.\n\n            frontier_prevs = self.dag_prev_dict[frontier]\n\n            # Whether the frontier share dependencies with the current segment,\n            # if the segment is not empty.\n            share_deps = not vseg or not frontier_prevs.isdisjoint(\n                set.union(set(vseg), *[self.dag_prev_dict[i] for i in vseg]))\n\n            # Whether multiple previous vertices are in the current segment.\n            multi_prevs = len(frontier_prevs.intersection(vseg)) > 1\n\n            if not share_deps or multi_prevs:\n                # Not sharing any dependencies (rule 1), or multiple previous\n                # vertices in the current segment (rule 2).\n\n                # Make sure the current segment is not empty.\n                assert vseg\n                # Not extend the segment any more. Note that the current\n                # segment has already been yielded, as well as the recursion,\n                # in the last iteration.\n                break\n\n            # Extend the segment.\n            vseg += (frontier,)\n\n            # Check whether the segment is valid.\n\n            for idx in vseg:\n                nexts = self.dag_next_dict[idx]\n\n                # The next vertices should either all or at most one not in the\n                # segment (rule 3).\n                if not nexts.isdisjoint(vseg) \\\n                        and len(nexts.difference(vseg)) > 1:\n                    # The segment is invalid. Need to add more vertices.\n                    break\n            else:\n                # The segment is valid.\n                yield vseg\n\n                # Skip if have done.\n                if frontier + 1 in self.seg_vertex_done:\n                    continue\n\n                # Recursion.\n                for tpl in self._gen_vseg(frontier + 1, done.union(vseg)):\n                    yield tpl\n\n        assert vertex_idx not in self.seg_vertex_done\n        self.seg_vertex_done.add(vertex_idx)\n\n    def _calc_sched_dag(self):\n        '''\n        Build the scheduling DAG of the network. We merge layers with no\n        filters into their last previous layer, so a DAG vertex can contain one\n        or more layers.\n\n        We order and index the DAG vertices in their depth-first topological\n        order. This will also be the order to schedule the layers.\n\n        Also establish two dicts for the previous and next vertices of each DAG\n        vertex.\n\n        In summary, the attributes initialized include: `dag_input_vertex`,\n        `dag_vertex_list`, `dag_vertex_dict`, `dag_prev_dict`, `dag_next_dict`.\n        '''\n\n        # Vertex of the input layer.\n        self.dag_input_vertex = -1\n\n        # The DAG vertex set. Each vertex is a merged layer tuples, represented\n        # by their layer names. Use a list type to make modification easier.\n        dag_vertex_set = []\n\n        for layer_name in self.network:\n            layer = self.network[layer_name]\n\n            if isinstance(layer, ConvLayer):\n                dag_vertex_set.append((layer_name,))\n\n            else:\n                prevs = set(self.network.prevs(layer_name))\n                assert prevs\n\n                # Find and merge to a vertex if that vertex only contains one\n                # previous layer at the last, because non-last previous layer\n                # will not have its data available to be used for this layer.\n                # Also the previous layer can only have this one next layer,\n                # because its data will be overwritten by this layer locally.\n\n                # Check vertices in the reversed order.\n                for idx in reversed(range(len(dag_vertex_set))):\n                    vhead = dag_vertex_set[idx][:-1]\n                    vtail = dag_vertex_set[idx][-1]\n                    if prevs.isdisjoint(vhead) and vtail in prevs \\\n                            and len(self.network.nexts(vtail)) == 1:\n                        dag_vertex_set[idx] += (layer_name,)\n                        break\n                else:\n                    # No valid vertex to merge.\n                    dag_vertex_set.append((layer_name,))\n\n        assert sum(len(v) for v in dag_vertex_set) == len(self.network)\n\n        # The DAG vertex list in the topological order.\n        self.dag_vertex_list = self._topological_order(dag_vertex_set)\n\n        # Make a directory from layer name to DAG vertex index.\n        self.dag_vertex_dict = {}\n\n        for vidx, v in enumerate(self.dag_vertex_list):\n            for layer_name in v:\n                assert layer_name not in self.dag_vertex_dict\n                self.dag_vertex_dict[layer_name] = vidx\n\n        # Add the input layer.\n        self.dag_vertex_dict[self.network.INPUT_LAYER_KEY] = \\\n                self.dag_input_vertex\n        # Add the external layers.\n        for ext_layer in self.network.ext_layers():\n            self.dag_vertex_dict[ext_layer] = self.dag_input_vertex\n\n        # The previous and next relationship of the DAG vertices.\n        self.dag_prev_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n        self.dag_next_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n\n        for layer_name in self.network:\n            vidx = self.dag_vertex_dict[layer_name]\n\n            # Previous layers.\n            for p in self.network.prevs(layer_name):\n                pvidx = self.dag_vertex_dict[p] \\\n                        if p and p not in self.network.ext_layers() \\\n                        else self.dag_input_vertex\n                if pvidx != vidx:\n                    self.dag_prev_dict[vidx].add(pvidx)\n\n            # Next layers.\n            for n in self.network.nexts(layer_name):\n                if not n:\n                    continue\n                nvidx = self.dag_vertex_dict[n]\n                if nvidx != vidx:\n                    self.dag_next_dict[vidx].add(nvidx)\n\n        # Add next layers of the input layer.\n        self.dag_next_dict[self.dag_input_vertex] = set()\n        for vidx in self.dag_prev_dict:\n            if self.dag_input_vertex in self.dag_prev_dict[vidx]:\n                self.dag_next_dict[self.dag_input_vertex].add(vidx)\n\n    def _topological_order(self, dag_vertex_set):\n        '''\n        Order the DAG vertices in topological order using DFS.\n\n        Specifically, The backtrace order of the depth-first search is the\n        inverse of the topological order. See\n        https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n        '''\n\n        # The visited layers in the DFS order.\n        visited = []\n        # The unseen pending layers.\n        unseen = set(dag_vertex_set)\n        # The layers that have been seen, but not visited due to unvisited\n        # previous layers.\n        seen = set()\n\n        def _dfs(vertex):\n            assert vertex not in seen\n            if vertex in visited:\n                return\n\n            unseen.discard(vertex)\n            seen.add(vertex)\n\n            nexts = []\n            for l in vertex:\n                for n in self.network.nexts(l):\n                    if n and n not in vertex and n not in nexts:\n                        nexts.append(n)\n\n            # Visit next layers in the reversed order, so the reversed visit\n            # order has the original order.\n            next_vertices = []\n            for n in reversed(nexts):\n                for nv in unseen:\n                    if n in nv:\n                        next_vertices.append(nv)\n\n            for nv in next_vertices:\n                _dfs(nv)\n\n            visited.append(vertex)\n            seen.remove(vertex)\n\n        # Start from the first layers.\n        start_vertices = []\n        for l in reversed(self.network.firsts()):\n            for v in unseen:\n                if l in v:\n                    start_vertices.append(v)\n        for v in start_vertices:\n            _dfs(v)\n        assert not unseen\n        assert not seen\n\n        return list(reversed(visited))\nnn_dataflow/core/layer.py\nclass InputLayer(Layer):\n    '''\n    NN input layer parameters.\n    '''\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops()\n        dls[de.IFM] = DataDimLoops()\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return None\n\n    def ops_per_neuron(self):\n        return 0\nnn_dataflow/core/pipeline_segment.py\nclass PipelineSegment():\n    '''\n    Inter-layer pipeline segment.\n\n    Segment is a two-level layer hierarchy, where the first level is spatially\n    scheduled and the second level is temporally scheduled.\n    '''\n\n    # pylint: disable=too-many-instance-attributes\n\n    # Scheduling index in the segment, as a tuple of spatial and temporal\n    # scheduling indices.\n    SchedIndex = namedtuple('SchedIndex', ['sp_idx', 'tm_idx'])\n\n    def __init__(self, seg, network, batch_size, resource, max_util_drop=0.05,\n                 with_opt=True):\n        if not isinstance(seg, tuple):\n            raise TypeError('PipelineSegment: seg must be a tuple.')\n        for ltpl in seg:\n            if not isinstance(ltpl, tuple):\n                raise TypeError('PipelineSegment: seg must be a tuple '\n                                'of sub-tuples.')\n\n        if not isinstance(network, Network):\n            raise TypeError('PipelineSegment: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('PipelineSegment: resource must be '\n                            'a Resource instance.')\n\n        self.seg = seg\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n        self.with_opt = with_opt\n\n        self.valid = self._init_deps()\n        if not self.valid:\n            return\n\n        # Resource allocation.\n        self.valid = self._alloc_resource(max_util_drop=max_util_drop)\n        if not self.valid:\n            return\n\n        # Scheduling constraints.\n        self.valid = self._init_sym_cstrs()\n        if not self.valid:\n            return\n\n    def allocation(self):\n        '''\n        Get resource allocation, as a tuple of sub-tuples corresponding to the\n        layers in the segment.\n        '''\n        if not self.valid:\n            return None\n        return self.alloc\n\n    def gen_constraint(self, max_time_overhead=float('inf')):\n        '''\n        Generate scheduling constraint for the segment, as a tuple of\n        sub-tuples of SchedulingConstraint instances, corresponding to the\n        layers in the segment.\n\n        Yield the segment constraint tuple, and hints for pruning.\n\n        Pruning hints are the top-level loop blocking factors. Smaller hints\n        indicate better (lower) cost, and larger hints indicate better segment\n        timing (with lower time overhead). Constraints with smaller hints are\n        generated before those with larger hints. So if a constraint results in\n        a valid scheduling, the later ones with all hints larger than its can\n        be pruned.\n        '''\n        syms = self.cstr_symvals.keys()\n        vals = self.cstr_symvals.values()\n        assert syms and vals\n\n        # Sort from small to large.\n        # This is not a strict ordering, but we guarantee that if all values in\n        # hint A are larger than the corresponding values in hint B, A will be\n        # generated after B.\n        vals = [sorted(v) for v in vals]\n        syms = list(syms)\n\n        if self.cstr_topbat_idx is not None:\n            # Tovhd =  (1 + 1/to + 1 + 1/to + ...) / tb\n            #       >= (1 + 1 + ...) / tb = num_sp_fbs / tb\n            min_topbat = 1. * self.cstr_num_sp_fbs / max_time_overhead\n            pos = self.cstr_topbat_idx\n            vals[pos] = [t for t in vals[pos] if t >= min_topbat]\n\n        for valp in itertools.product(*vals):\n\n            constraint = tuple()\n\n            for atpl in self._subs_symargs(self.cstr_symargs,\n                                           tuple(zip(syms, valp))):\n                ctpl = tuple()\n                for a in atpl:\n                    # Construct kwargs, adjust the types of the values.\n                    kwargs = {}\n                    kwargs['topbat'] = int(a.get('topbat', 0))\n                    kwargs['fbifm'] = bool(a.get('fbifm', False))\n                    if not kwargs['fbifm']:\n                        kwargs['topifm'] = int(a.get('topifm', 0))\n                    kwargs['fbofm'] = bool(a.get('fbofm', False))\n                    if not kwargs['fbofm']:\n                        kwargs['topofm'] = int(a.get('topofm', 0))\n                    kwargs['update_dict'] = a.get('update_dict')\n\n                    c = Cstr(**kwargs)\n                    ctpl += (c,)\n                constraint += (ctpl,)\n\n            if None in valp:\n                assert len(valp) == 1\n                hints = (1,)\n            else:\n                hints = tuple(valp)\n\n            yield constraint, hints\n\n    def __getitem__(self, index):\n        return self.seg[index]\n\n    def __iter__(self):\n        return self.seg.__iter__()\n\n    def __len__(self):\n        return len(self.seg)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            # pylint: disable=protected-access\n            return self._key_attrs() == other._key_attrs()\n        return NotImplemented\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash(tuple(self._key_attrs()))\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'seg={}'.format(repr(self.seg)),\n                'network={}'.format(repr(self.network)),\n                'batch_size={}'.format(repr(self.batch_size)),\n                'resource={}'.format(repr(self.resource)),\n                'max_util_drop={}'.format(repr(self.max_util_drop)),\n                'with_opt={}'.format(repr(self.with_opt))]))\n\n    def _key_attrs(self):\n        ''' Used for comparison. '''\n        return (self.seg, self.network, self.batch_size, self.resource,\n                self.max_util_drop, self.with_opt)\n\n    def _init_deps(self):\n        '''\n        Initialize the dependency relationship of the layers in the segment as\n        a mapping of the scheduling indices, and check validation. Return\n        whether the segment is valid to schedule.\n\n        We categorize dependencies to 3 categories:\n        - local: with the same spatial index but different temporal indices;\n        - neighbor: with different spatial indices but in the same segment;\n        - memory: in different segments, from/to memory.\n\n        The values of the src/dst dicts are tuples of indices of the neighbor\n        dependencies. A layer can have at most one neighbor source (must be a\n        last temporal scheduled layer), but may have multiple neighbor\n        destinations (could be temporal scheduled in the middle). Also, all\n        layers with the same spatial index can have at most one neighbor\n        source.\n\n        Special index `None` means memory dependency, i.e., from/to memory.\n        Memory sources and neighbor sources must be mutual exclusive, in order\n        to correctly set the src data regions; memory destinations and neighbor\n        destinations can co-exist.\n\n        Local dependencies are omitted, as by default each layer has its\n        immediately previous layer as local source and immediately next layer\n        as local destination.\n\n        Construct an ifmap forwarding dict for shared memory source data. It\n        maps previous layer name tuples, to a list of scheduling indices of all\n        layers in this segment that share these exact previous layers. The\n        first in the list is responsible to fetch the previous layer data and\n        to forward them to others. We allow shared memory source data between\n        two layers only when both layers have memory dependency only (so their\n        temporal indices must be 0), and their previous layers are exactly the\n        same.\n\n        Construct an ofmap forwarding dict for multiple destinations of both\n        on-chip and off-chip. It maps the scheduling index of a layer in this\n        segment that has both memory and neighbor/local destinations (so needs\n        to store its ofmaps back to memory), to a list of scheduling indices of\n        all layers in this segment that accepts its ofmaps as ifmaps. Neighbor\n        dependencies are only between the last temporal one and the first\n        temporal ones; local dependencies are only between adjacent temporal\n        ones.\n        '''\n\n        self.src_dict = [[None for _ in ltpl] for ltpl in self.seg]\n        self.dst_dict = [[None for _ in ltpl] for ltpl in self.seg]\n\n        self.ifm_fwd_dict = {}\n        self.ofm_fwd_dict = {}\n\n        # Mapping from layer to spatial/temporal indices in the segment.\n        layer2idx = {l: PipelineSegment.SchedIndex(sp_idx, tm_idx)\n                     for sp_idx, ltpl in enumerate(self.seg)\n                     for tm_idx, l in enumerate(ltpl)}\n\n        # Mapping from previous layer tuple to layer.\n        prevs2layer = {}\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            single_nbr_src = None\n\n            for tm_idx, l in enumerate(ltpl):\n\n                assert layer2idx[l] == (sp_idx, tm_idx)\n\n                # Sources.\n                src = tuple()\n\n                prevs = self.network.prevs(l)\n                assert all(p not in layer2idx or layer2idx[p] < layer2idx[l]\n                           for p in prevs)\n                mem_src = [p for p in prevs if p not in layer2idx]\n                lcl_src = [p for p in prevs if p not in mem_src\n                           and layer2idx[p].sp_idx == sp_idx]\n                nbr_src = [p for p in prevs if p not in mem_src + lcl_src]\n\n                # Ensure single local source to be the immediately previous.\n                # Check at the destination so here are assertions.\n                if not lcl_src:\n                    assert tm_idx == 0\n                else:\n                    assert len(lcl_src) == 1 \\\n                            and layer2idx[lcl_src[0]].tm_idx == tm_idx - 1\n\n                # Mutual exclusive.\n                if mem_src and nbr_src:\n                    # We now allow each spatial scheduling (vertex) to have\n                    # both memory source and neighbor source when generating\n                    # segments. But each single layer cannot have both;\n                    # otherwise there would be multiple source data regions.\n                    return False\n\n                if mem_src:\n                    # Memory source.\n                    src += (None,)\n                if nbr_src:\n                    # Neighbor source.\n                    # Single neighbor source to be the last temporal scheduled.\n                    assert len(nbr_src) == 1\n                    prev_idx = layer2idx[nbr_src[0]]\n                    assert prev_idx.tm_idx == len(self.seg[prev_idx.sp_idx]) - 1\n                    # Single neighbor source across this spatial scheduling.\n                    if single_nbr_src is not None:\n                        return False\n                    single_nbr_src = prev_idx\n                    src += (prev_idx,)\n\n                # Shared memory source.\n                if mem_src and not lcl_src:\n                    assert not nbr_src\n                    assert tm_idx == 0\n                    if prevs in prevs2layer:\n                        fet_idx = layer2idx[prevs2layer[prevs]]\n                        self.ifm_fwd_dict.setdefault(prevs, [fet_idx]).append(\n                            layer2idx[l])\n                    else:\n                        prevs2layer[prevs] = l\n\n                # Destinations.\n                dst = tuple()\n\n                nexts = self.network.nexts(l)\n                assert all(n not in layer2idx or layer2idx[n] > layer2idx[l]\n                           for n in nexts)\n                mem_dst = [n for n in nexts if n not in layer2idx]\n                lcl_dst = [n for n in nexts if n not in mem_dst\n                           and layer2idx[n].sp_idx == sp_idx]\n                nbr_dst = [n for n in nexts if n not in mem_dst + lcl_dst]\n\n                # Ensure single local destination to be the immediate next.\n                if not lcl_dst:\n                    if tm_idx != len(ltpl) - 1:\n                        # Not utilize local data, sub-optimal.\n                        return False\n                else:\n                    if len(lcl_dst) != 1 \\\n                            or layer2idx[lcl_dst[0]].tm_idx != tm_idx + 1:\n                        # Local data will not be available if not adjacent.\n                        return False\n\n                # Mutual exclusive.\n                # Now they can co-exist.\n                # assert not mem_dst or not nbr_dst\n                if mem_dst and nbr_dst:\n                    assert tm_idx == len(ltpl) - 1\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[n]\n                                                       for n in nbr_dst]\n                if mem_dst and lcl_dst:\n                    assert not nbr_dst\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[lcl_dst[0]]]\n\n                if mem_dst:\n                    # Memory destination.\n                    dst += (None,)\n                if nbr_dst:\n                    # Neighbor destinations.\n                    # This layer is the last temporal scheduled.\n                    assert tm_idx == len(ltpl) - 1\n                    dst += tuple(layer2idx[n] for n in nbr_dst)\n\n                # Basic pipelining requires a linear structure (on-chip).\n                if not self.with_opt:\n                    if len(nbr_src) + len(lcl_src) > 1 \\\n                            or len(nbr_dst) + len(lcl_dst) > 1 \\\n                            or ((sp_idx, tm_idx) != (0, 0)\n                                    and not nbr_src and not lcl_src):\n                        return False\n\n                self.src_dict[sp_idx][tm_idx] = src\n                self.dst_dict[sp_idx][tm_idx] = dst\n\n        return True\n\n    def _alloc_resource(self, max_util_drop=0.05):\n        '''\n        Decide the resource allocation. Return whether the allocation succeeds.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        self.alloc = tuple()\n\n        # Allocate processing subregions.\n        subregions = self._alloc_proc(max_util_drop=max_util_drop)\n        if not subregions:\n            return False\n\n        no_time_mux = len(self.network) == sum(len(ltpl) for ltpl in self.seg)\n        # All layers that have model filters must be spatially scheduled.\n        if no_time_mux:\n            for ltpl in self.seg:\n                if len([l for l in ltpl\n                        if isinstance(self.network[l], ConvLayer)]) > 1:\n                    no_time_mux = False\n                    break\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Resource for the subregion.\n            rtpl = tuple()\n\n            for tm_idx, _ in enumerate(ltpl):\n\n                # Processing region.\n                proc_region = subregions[sp_idx]\n\n                # Data source.\n                src = self.src_dict[sp_idx][tm_idx]\n                if None in src:\n                    # Data source is memory.\n                    assert src == (None,)\n                    src_data_region = self.resource.src_data_region\n                    for sh_idx_list in self.ifm_fwd_dict.values():\n                        # Find shared memory source to use forwarding.\n                        if (sp_idx, tm_idx) in sh_idx_list[1:]:\n                            src_data_region = subregions[sh_idx_list[0].sp_idx]\n                            break\n                elif src:\n                    # Data source is neighbor.\n                    assert len(src) == 1\n                    src_data_region = subregions[src[0].sp_idx]\n                else:\n                    # Data source is all local.\n                    src_data_region = proc_region\n\n                # Data destination.\n                dst = self.dst_dict[sp_idx][tm_idx]\n                if None in dst:\n                    # Data destination is memory.\n                    # assert dst == (None,)\n                    # Now we can have both memory and neighbor destinations. If\n                    # they co-exist, we need to store them locally and also\n                    # store back to memory. In this case the dst data region is\n                    # set to memory.\n                    dst_data_region = self.resource.dst_data_region\n                elif dst:\n                    # Data destinations are neighbors.\n                    # Put data in local. The next layers will fetch.\n                    dst_data_region = proc_region\n                else:\n                    # Data destination is all local.\n                    dst_data_region = proc_region\n\n                # Make resource.\n                # Note that DRAM bandwidth is not split here. We optimistically\n                # assume each layer can use the full DRAM bandwidth at\n                # different time. We adjust this assumption when calculating\n                # the segment timing.\n                rtpl += (self.resource._replace(\n                    proc_region=proc_region,\n                    src_data_region=src_data_region,\n                    dst_data_region=dst_data_region,\n                    no_time_mux=no_time_mux),)\n\n            assert len(rtpl) == len(ltpl)\n            self.alloc += (rtpl,)\n        assert len(self.alloc) == len(self.seg)\n\n        return True\n\n    def _alloc_proc(self, max_util_drop=0.05):\n        '''\n        Allocate processing subregions for the segment.\n\n        Return a list of processing subregions corresponding to the first-level\n        (spatial scheduled) layers in the segment. Return None if allocation\n        failed.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        # Spatial allocation.\n        proc_region = self.resource.proc_region\n        dim_nodes = proc_region.dim\n        total_nodes = dim_nodes.size()\n\n        # Number of operations of each spatial allocation.\n        ops = [sum(self.network[l].total_ops() for l in ltpl)\n               for ltpl in self.seg]\n\n        # Enforce a common factor among the numbers of nodes allocated to all\n        # vertices in the segment. Such common factor is likely to be the\n        # common height of the vertex node regions.\n        common_factor_list = [cf for cf, _ in util.factorize(dim_nodes.h, 2)]\n\n        for cf in sorted(common_factor_list, reverse=True):\n            # Pick the largest common factor within the utilization constraint.\n\n            # Number of nodes of each vertex should be approximate to the\n            # number of ops of the vertex.\n            nodes_raw = [o * 1. / sum(ops) * total_nodes for o in ops]\n\n            # Round to the common factor multiples.\n            assert total_nodes % cf == 0\n            nodes = [max(1, int(round(nr / cf))) * cf for nr in nodes_raw]\n            # Fix margin.\n            while sum(nodes) != total_nodes:\n                diff = [n - nr for n, nr in zip(nodes, nodes_raw)]\n                if sum(nodes) > total_nodes:\n                    # Decrease the nodes for the vertex with the maximum\n                    # positive difference.\n                    idx, _ = max(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] -= cf\n                else:\n                    # Increase the nodes for the vertex with the minimum\n                    # negative difference.\n                    idx, _ = min(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] += cf\n\n            if 0 in nodes:\n                continue\n\n            # Utilization.\n            time = max(o * 1. / n for o, n in zip(ops, nodes))\n            utilization = sum(ops) / time / sum(nodes)\n            assert utilization < 1 + 1e-6\n\n            if utilization >= 1 - max_util_drop:\n                # Found\n                break\n\n        else:\n            # Not found.\n            return None\n\n        # Allocate in the processing region according to the number of nodes.\n        subregions = proc_region.allocate(nodes)\n        assert subregions\n        assert len(subregions) == len(self.seg)\n        if len(subregions) == 1:\n            assert subregions[0] == proc_region\n\n        return subregions\n\n    def _init_sym_cstrs(self):\n        '''\n        Initialize the symbolic scheduling constraints for the layers in the\n        segment, by constructing a nested lists of dicts `cstr_symargs` whose\n        values can be symbolic expressions for the keyword arguments of layers\n        in the segment, and a dict `cstr_symvals` mapping each symbol to its\n        possible numerical values.\n\n        Rules for constraints.\n\n        - Top BAT loop factor.\n\n        With a single layer, there is no constraint on the top BAT loop factor.\n        Otherwise all layers must share the same factor, namely `topbat_shr`.\n\n        - Fmap forwarding and fully buffering.\n\n        Only CONV layers require to fully buffer fmaps. Local-region layers\n        process data in a streaming manner.\n\n        Each CONV layer, and all local-region layers immediately following it\n        within the same spatial scheduling, are made into a group G.\n\n        (initial) if G is both the first spatial and the first temporal\n        scheduling with a CONV layer, it can choose whether to fully buffer\n        ofmaps or not. This is a configuration to explore, namely `fbofm_init`.\n        We decide its value by choosing the one that gives the fewer fully\n        buffered inter-spatial pairs on the critical forwarding path, and the\n        smaller maximum fully buffered data size.\n\n        (within-group) within G, the CONV layer, and all local-region layers,\n        should use the same top OFM factors (IFM factors are automatically\n        determined by OFM factors in local-region layers), unless CONV ofmaps\n        need to be fully buffered, in which case, the CONV layer and the last\n        layer in G fully buffer ofmaps (top OFM factor is 1), and other layers\n        still use the same top OFM factors but can be different than 1.\n\n        (inter-temporal) if G has a source from G' in the same spatial\n        scheduling (which must be immediately before G), G should fully buffer\n        ifmaps, and G' should fully buffer ofmaps.\n\n        (inter-spatial) if G has a source from G' in another spatial scheduling\n        (where the source must be the last temporal scheduling in G' and that\n        spatial scheduling),\n        (a) if G' already fully buffers ofmaps, make G fully buffer ifmaps.\n        (b) otherwise, make G fully buffer ofmaps (do not require G' to fully\n            buffer ifmaps; leave it to other rules, e.g. inter-temporal, to\n            decide); forward data between G' and G, by matching their top O/IFM\n            factors (biasing this case for smaller pipeline filling delay).\n        Notice the destination can be: (1) the leading CONV layer, whose top\n        IFM factor is constrained; (2) a local-region layer, where we constrain\n        the top OFM factors of this group (except otherwise constrained by\n        fully buffering ofmaps).\n        '''\n        # pylint: disable=too-many-branches\n\n        # Symbolic variables mapping to numerical values.\n        symvals = dict()\n\n        # Top BAT loop factor.\n        topbat = symbols('topbat_shr', integer=True)\n        symvals[topbat] = [t for t, _ in util.factorize(self.batch_size, 2)]\n\n        # Whether the initial CONV layer fully buffers ofmaps.\n        fbofm_init = symbols('fbofm_init')\n        symvals[fbofm_init] = [False, True]\n\n        def _layer_topofm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ofmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ofmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nofm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        def _layer_topifm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ifmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ifmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nifm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        # Layer constraint kwargs.\n        symargs = [[{'topbat': topbat} for _ in ltpl] for ltpl in self.seg]\n\n        # Candidates for critical forwarding path between spatial scheduling.\n        sp_crit_path_cands = set()\n        sp_crit_path_cands.add((0,))  # init with the first spatial.\n\n        # The last CONV layer index.\n        last_conv = PipelineSegment.SchedIndex(-1, 0)\n\n        # Whether the current group needs to fully buffer ofmap. Delayed apply\n        # to the last layer in the group.\n        curr_fbofm = False\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Initial topofm, in case of a non-CONV starting layer.\n            curr_topofm = symbols('topofm_{}_s'.format(sp_idx), integer=True)\n            symvals[curr_topofm] = _layer_topofm_vals(ltpl[0])\n\n            for tm_idx, l in enumerate(ltpl):\n\n                layer = self.network[l]\n                curr_sa = symargs[sp_idx][tm_idx]\n\n                # Neighbor source dependency.\n                nsrc_sa = None\n                src_deps = self.src_dict[sp_idx][tm_idx]\n                if any(s is not None for s in src_deps):\n                    assert len(src_deps) == 1\n                    nbr_src = src_deps[0]\n                    assert nbr_src.sp_idx < sp_idx\n                    nsrc_sa = symargs[nbr_src.sp_idx][nbr_src.tm_idx]\n                    assert nsrc_sa  # not empty, used to test nbr src exists.\n                    # Set critical path candidates.\n                    new_cands = set()\n                    for cand in sp_crit_path_cands:\n                        if cand[-1] == nbr_src.sp_idx:\n                            new_cands.add(cand + (sp_idx,))\n                    sp_crit_path_cands |= new_cands\n\n                if isinstance(layer, ConvLayer):\n                    # Conv layer.\n\n                    # The last group may require to fully buffer ofmaps.\n                    # Delayed apply to the immediate previous layer.\n                    if curr_fbofm is not False:\n                        assert last_conv >= (0, 0)\n                        if last_conv.sp_idx == sp_idx:\n                            assert tm_idx > 0\n                            lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        else:\n                            lsrc_sa = symargs[last_conv.sp_idx][-1]\n                        lsrc_sa['fbofm'] = curr_fbofm\n                    # Reset.\n                    curr_fbofm = False\n\n                    # New topofm for a new group.\n                    curr_topofm = symbols('topofm_{}_{}'.format(sp_idx, tm_idx),\n                                          integer=True)\n                    symvals[curr_topofm] = _layer_topofm_vals(l)\n\n                    # Set topofm.\n                    curr_sa['topofm'] = curr_topofm\n\n                    if sp_idx == last_conv.sp_idx:\n                        # Rule inter-temporal.\n                        assert tm_idx > 0\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = True\n                        # Make the last group fully buffer ofmaps.\n                        last_sa = symargs[sp_idx][last_conv.tm_idx]\n                        lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        last_sa['fbofm'] = True\n                        lsrc_sa['fbofm'] = True\n\n                    elif nsrc_sa:\n                        # Rule inter-spatial.\n                        # We only look at this rule when inter-temporal rule\n                        # does not apply and the ifmaps of this group are not\n                        # yet required to fully buffer.\n                        if not self.with_opt:\n                            # Basic pipelining requires fully buffering all\n                            # pairs of neighbor src/dst.\n                            nsrc_sa['fbofm'] = True\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        # (a): if the source already fully buffers ofmaps.\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = symeq(nsrc_fbofm, True)\n                        # (b)-(1): otherwise.\n                        # Make this group fully buffer ofmaps.\n                        curr_sa['fbofm'] = symeq(nsrc_fbofm, False)\n                        curr_fbofm = symeq(nsrc_fbofm, False)  # delayed apply.\n                        # Match top OFM/IFM factors.\n                        curr_sa['topifm'] = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_sa.get('topifm', 0), True))\n\n                    elif last_conv < (0, 0):\n                        # The first CONV layer.\n                        # Rule initial.\n                        curr_sa['fbofm'] = fbofm_init\n                        curr_fbofm = fbofm_init\n\n                    last_conv = PipelineSegment.SchedIndex(sp_idx, tm_idx)\n\n                else:\n                    # Non-Conv layer.\n\n                    if nsrc_sa:\n                        # Rule inter-spatial, (b)-(2).\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        curr_topofm = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_topofm, True))\n                        # Also backtrace this group.\n                        for bt_idx in range(last_conv.tm_idx, tm_idx):\n                            symargs[sp_idx][bt_idx]['topofm'] = curr_topofm\n\n                    # Rule within-group.\n                    curr_sa['topofm'] = curr_topofm\n\n                # If this layer has no on-chip destinations, cancel the\n                # requirement to fully buffer ofmaps.\n                if all(d is None for d in self.dst_dict[sp_idx][tm_idx]) \\\n                        and tm_idx == len(ltpl) - 1:\n                    curr_sa.pop('fbofm', False)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Get critical forwarding path between spatial scheduling.\n        # The critical path has the longest forwarding chain.\n        sp_crit_path = max(sp_crit_path_cands, key=len)\n\n        # Check maximum fully-buffering size, and decide fbofm_init.\n        opt_val = None\n        opt_key = (float('inf'),) * 2  # (num of fb pairs, max fb size)\n        num_sp_fbs = 0\n        for val in symvals.get(fbofm_init, [False]):\n            subs_symargs = self._subs_symargs(symargs, fbofm_init, val)\n            maxsz = 0\n            numfb = 0\n            for sp_idx, (ltpl, atpl) in enumerate(zip(self.seg, subs_symargs)):\n                ms = max(itertools.chain(\n                    ((self.network[l].total_ofmap_size() if a.get('fbofm')\n                      else 0)\n                     + (self.network[l].total_ifmap_size() if a.get('fbifm')\n                        else 0)\n                     for l, a in zip(ltpl, atpl)),\n                    [0]))  # safe max with default.\n                if ms > self.alloc[sp_idx][0].proc_region.dim.size() \\\n                        * self.alloc[sp_idx][0].size_gbuf:\n                    break\n                maxsz = max(maxsz, ms)\n                if sp_idx in sp_crit_path and atpl[-1].get('fbofm', False):\n                    numfb += 1\n            else:\n                key = (numfb, maxsz)\n                if key < opt_key:\n                    opt_val, opt_key = val, key\n                    num_sp_fbs = numfb\n        if opt_val is None:\n            return False\n        # Use the optimal value.\n        symvals[fbofm_init] = [opt_val]\n        self._simplify_symargs(symargs, symvals)\n\n        # Shared memory source must have the same topifm.\n        for sh_idx_list in self.ifm_fwd_dict.values():\n            assert len(sh_idx_list) > 1\n            fet_sp_idx = sh_idx_list[0].sp_idx\n            sh_symarg_list = [symargs[idx.sp_idx][0] for idx in sh_idx_list]\n\n            # Must have no constraint on ifmaps access from memory.\n            assert all(not sa.get('fbifm', False) and not sa.get('topifm', 0)\n                       for sa in sh_symarg_list)\n\n            # Cannot constrain both topifm and topofm.\n            if any(sa.get('fbofm', False) or sa.get('topofm', 0)\n                   for sa in sh_symarg_list):\n                sh_kwargs = {'fbifm': True}\n            else:\n                topifm = symbols('topifm_{}'.format(fet_sp_idx), integer=True)\n                symvals[topifm] = _layer_topifm_vals(self.seg[fet_sp_idx][0])\n                sh_kwargs = {'topifm': topifm}\n\n            # Set constraints.\n            for sa in sh_symarg_list:\n                sa.update(sh_kwargs)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Turn constraints into lazily updated rules.\n        self._lazify_topofm_symargs(symargs, symvals)\n        # Cannot simplify any more as update_dict is not sympifi-able.\n\n        # Sort symbol dict.\n        symvals = OrderedDict(sorted(((s, symvals[s]) for s in symvals),\n                                     key=lambda item: str(item[0])))\n\n        if not symvals:\n            # Must add a dummy symbol so iterative substitution can happen.\n            symvals[symbols('_dummy')] = [None]\n\n        self.cstr_symargs = symargs\n        self.cstr_symvals = symvals\n        self.cstr_num_sp_fbs = num_sp_fbs\n        try:\n            self.cstr_topbat_idx = list(symvals.keys()).index(topbat)\n        except ValueError:\n            self.cstr_topbat_idx = None\n\n        return True\n\n    @staticmethod\n    def _simplify_symargs_one_pass(symargs, symvals):\n        '''\n        Simplify symargs and symvals in-place:\n        - If fbi/ofm is False, then remove it.\n        - If fbi/ofm is True, then remove topi/ofm.\n        - If a symbol can take only one value, then substitute it.\n        - If a symbol only occurs once, then remove its constraint.\n\n        Return whether the symargs and symvals are already simplified.\n        '''\n        for a in itertools.chain.from_iterable(symargs):\n            is_fbifm = a.get('fbifm')\n            is_fbofm = a.get('fbofm')\n            # pylint: disable=singleton-comparison\n            # lhs may be symbolic, see\n            # docs.sympy.org/latest/modules/logic.html#sympy.logic.boolalg.BooleanTrue\n            if is_fbifm == True:\n                a.pop('topifm', 0)\n            if is_fbifm == False:\n                a.pop('fbifm', False)\n            if is_fbofm == True:\n                a.pop('topofm', 0)\n            if is_fbofm == False:\n                a.pop('fbofm', False)\n\n        subs_dict = {}\n\n        # Possible values for symbols.\n        subs_dict.update(\n            (s, symvals[s][0]) for s in symvals if len(symvals[s]) == 1)\n\n        # Count the occurrence of symbols in all args (values).\n        symcnts = Counter(\n            s for a in itertools.chain.from_iterable(symargs)\n            for val in a.values() for s in symtuple(val).free_symbols)\n        assert set(symcnts.keys()).issubset(symvals.keys())\n        subs_dict.update((s, None)\n                         for s in set(symvals.keys()) - set(symcnts.keys()))\n        subs_dict.update((s, 0 if str(s).startswith('top') else False)\n                         for s in symcnts if symcnts[s] <= 1)\n\n        # Substitute symbols and remove from symbol dict.\n        for a in itertools.chain.from_iterable(symargs):\n            for k in a:\n                a[k] = symtuple(a[k]).subs(subs_dict)[0]\n        for s in subs_dict:\n            del symvals[s]\n\n        return not subs_dict\n\n    def _simplify_symargs(self, symargs, symvals):\n        ''' Simplify symargs and symvals in-place iteratively. '''\n        while not self._simplify_symargs_one_pass(symargs, symvals):\n            pass\n        used_syms = symtuple(\n            *[symtuple(*a.values())\n              for a in itertools.chain.from_iterable(symargs)]).free_symbols\n        assert set(used_syms) == set(symvals.keys())\n        assert all(val for val in symvals.values())\n\n    @staticmethod\n    def _subs_symargs(symargs, *subs_args):\n        '''\n        Substitute symbols. The additional arguments are passed to subs().\n\n        Return a new substituted copy without modifying the original one.\n        '''\n        # sympify=False is necessary because there may be str in the values.\n        return [[dict((k, symtuple(a[k], sympify=False).subs(*subs_args)[0])\n                      for k in a) for a in atpl] for atpl in symargs]\n\n    class TopOfmUpdateLambda(symbasic):\n        ''' A sympifi-able lambda function to lazily update topofm. '''\n        # pylint: disable=no-init\n        def __new__(cls, *args):\n            return super(PipelineSegment.TopOfmUpdateLambda, cls).__new__(cls)\n        def __call__(self, arg_s, arg_r):\n            setattr(arg_s, 'topofm', arg_r.scheme['to'][0])\n\n    def _lazify_topofm_symargs(self, symargs, symvals):\n        '''\n        Turn qualified topofm constraints into lazily updated rules.\n\n        If a symbol is only used as the topofm constraint by a single CONV\n        layer and some local-region layers, we can turn it into a lazily update\n        rule.\n        '''\n        sym2conv = {}  # symbol --> the only CONV layer using it.\n        sym2lrs = {}   # symbol --> list of local-region layer using it.\n        unqual_syms = set()  # symbols used by two or more CONV layers.\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            layer = self.network[l]\n            if isinstance(layer, ConvLayer):\n                topofm = a.get('topofm', 0)\n                topifm = a.get('topifm', 0)\n                for s in symtuple(topofm, topifm).free_symbols:\n                    if s not in unqual_syms:\n                        if s in sym2conv:\n                            # If a symbol is used in two CONV layers, it cannot\n                            # be lazily updated.\n                            del sym2conv[s]\n                            sym2lrs.pop(s, [])\n                            unqual_syms.add(s)\n                        elif topofm == s:\n                            assert s not in sym2lrs\n                            sym2conv[s] = l\n            else:\n                topofm = a.get('topofm', 0)\n                if topofm in sym2conv:\n                    sym2lrs.setdefault(topofm, []).append(l)\n        assert 0 not in sym2conv and 0 not in sym2lrs\n\n        syms = sym2conv.keys()  # symbols to be lazily updated.\n        lr2conv = {}  # local-region layer to the CONV layer constraining it.\n        for s in syms:\n            for lr in sym2lrs.get(s, []):\n                lr2conv[lr] = sym2conv[s]\n        lconvs = set(lr2conv.values())  # CONV layer whose topofm to be removed.\n\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            if l in lconvs:\n                # Remove CONV topofm.\n                assert sym2conv[a['topofm']] == l\n                del a['topofm']\n            elif l in lr2conv:\n                # Link local-region layer to the CONV layer.\n                lconv = lr2conv[l]\n                assert sym2conv[a['topofm']] == lconv\n                del a['topofm']\n                a['update_dict'] = {\n                    lconv: PipelineSegment.TopOfmUpdateLambda()}\n\n        for s in syms:\n            del symvals[s]\nnn_dataflow/core/option.py\nclass Option(namedtuple('Option', OPTION_LIST)):\n    '''\n    Schedule options.\n    '''\n\n    def __new__(cls, *args, **kwargs):\n\n        if len(args) > len(OPTION_LIST):\n            raise TypeError('Option: can take at most {} arguments ({} given).'\n                            .format(len(OPTION_LIST), len(args)))\n\n        if not set(kwargs).issubset(OPTION_LIST):\n            raise TypeError('Option: got an unexpected keyword argument {}.'\n                            .format(next(k for k in kwargs\n                                         if k not in OPTION_LIST)))\n\n        # Combine args and kwargs.\n        kwdict = kwargs.copy()\n        for k, v in zip(OPTION_LIST, args):\n            if k in kwdict:\n                raise TypeError('Option: got multiple values for '\n                                'keyword argument {}.'\n                                .format(k))\n            kwdict[k] = v\n\n        kwdict.setdefault('sw_gbuf_bypass', (False,) * de.NUM)\n        kwdict.setdefault('sw_solve_loopblocking', False)\n        kwdict.setdefault('hw_access_forwarding', False)\n        kwdict.setdefault('hw_gbuf_sharing', False)\n        kwdict.setdefault('hw_gbuf_save_writeback', False)\n        kwdict.setdefault('partition_hybrid', False)\n        kwdict.setdefault('partition_batch', False)\n        kwdict.setdefault('partition_ifmaps', False)\n        kwdict.setdefault('partition_interlayer', False)\n        kwdict.setdefault('layer_pipeline_time_ovhd', float('inf'))\n        kwdict.setdefault('layer_pipeline_max_degree', float('inf'))\n        kwdict.setdefault('layer_pipeline_opt', True)\n        kwdict.setdefault('opt_goal', 'e')\n        kwdict.setdefault('ntops', 1)\n        kwdict.setdefault('nprocesses', 1)\n        kwdict.setdefault('verbose', False)\n\n        assert set(kwdict) == set(OPTION_LIST)\n\n        ntp = super(Option, cls).__new__(cls, **kwdict)\n\n        if not isinstance(ntp.sw_gbuf_bypass, tuple):\n            raise TypeError('Option: sw_gbuf_bypass must be a tuple')\n        if len(ntp.sw_gbuf_bypass) != de.NUM:\n            raise ValueError('Option: sw_gbuf_bypass must have length {}'\n                             .format(de.NUM))\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_sharing cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.hw_access_forwarding and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: hw_access_forwarding is implied by '\n                             'hw_gbuf_sharing, thus cannot be both enabled.')\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_save_writeback:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_save_writeback cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.partition_ifmaps and not ntp.partition_hybrid:\n            raise ValueError('Option: partition_ifmaps requires '\n                             'partition_hybrid to be set.')\n\n        if not isinstance(ntp.layer_pipeline_time_ovhd, (int, float)):\n            raise KeyError('Option: layer_pipeline_time_ovhd must be a '\n                           'number.')\n        if ntp.layer_pipeline_time_ovhd < 0:\n            raise ValueError('Option: layer_pipeline_time_ovhd must be '\n                             'positive.')\n\n        if not isinstance(ntp.layer_pipeline_max_degree, (int, float)):\n            raise KeyError('Option: layer_pipeline_max_degree must be a '\n                           'number.')\n        if ntp.layer_pipeline_max_degree < 0:\n            raise ValueError('Option: layer_pipeline_max_degree must be '\n                             'positive.')\n\n        if ntp.opt_goal not in ['e', 'd', 'ed']:\n            raise ValueError('Option: opt_goal is invalid, must be one of '\n                             '\\'e\\', \\'d\\', and \\'ed\\'.')\n\n        return ntp\n\n    @staticmethod\n    def option_list():\n        ''' List of options. '''\n        return OPTION_LIST\nnn_dataflow/core/layer.py\nclass PoolingLayer(LocalRegionLayer):\n    '''\n    NN pooling layer parameters.\n\n    As a special case of LocalRegionLayer.\n\n    nreg = ntrd = 1\n    '''\n\n    def __init__(self, nofm, sofm, sreg, strd=None):\n        if strd is None:\n            strd = sreg\n        super(PoolingLayer, self).__init__(nofm, sofm, 1, sreg,\n                                           ntrd=1, strd=strd)\n        assert self.nreg == 1\n        assert self.ntrd == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sreg={}'.format(repr((self.hreg, self.wreg))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/phy_dim2.py\nclass PhyDim2(namedtuple('PhyDim2', ['h', 'w'])):\n    '''\n    Denote a physical 2D dimension.\n    '''\n\n    def size(self):\n        ''' Total size. '''\n        return int(reduce(mul, self, 1))\n\n    def hop_dist(self, other):\n        ''' Hop distance between twn coordinate. '''\n        if not isinstance(other, PhyDim2):\n            raise TypeError('PhyDim2: hop_dist only applies on two PhyDim2 '\n                            'instances.')\n        return abs(self.h - other.h) + abs(self.w - other.w)\n\n    def __add__(self, other):\n        ''' Return element-wise `self + other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(add, self, other))\n\n    def __sub__(self, other):\n        ''' Return element-wise `self - other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(sub, self, other))\n\n    def __neg__(self):\n        ''' Return element-wise negative. '''\n        return PhyDim2(*map(neg, self))\n\n    def __mul__(self, other):\n        ''' Return element-wise `self * other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(mul, self, other))\n\n    __rmul__ = __mul__\nimport re\nfrom nn_dataflow.core import InputLayer, ConvLayer, FCLayer, PoolingLayer\nfrom nn_dataflow.core import InterLayerPipeline\nfrom nn_dataflow.core import Network\nfrom nn_dataflow.core import Option\nfrom nn_dataflow.core import PhyDim2\nfrom nn_dataflow.core import PipelineSegment\nfrom . import TestPipelineFixture\n\"\"\" $lic$\nCopyright (C) 2016-2020 by Tsinghua University and The Board of Trustees of\nStanford University\n\nThis program is free software: you can redistribute it and/or modify it under\nthe terms of the Modified BSD-3 License as published by the Open Source\nInitiative.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE. See the BSD-3 License for more details.\n\nYou should have received a copy of the Modified BSD-3 License along with this\nprogram. If not, see <https://opensource.org/licenses/BSD-3-Clause>.\n\"\"\"\n\n\n\n\nclass TestInterLayerPipeline(TestPipelineFixture):\n    ''' Tests for InterLayerPipeline. '''\n\n    def test_valid_args(self):\n        ''' Valid arguments. '''\nNext line of code:\n", "input": "import re\nfrom nn_dataflow.core import InputLayer, ConvLayer, FCLayer, PoolingLayer\nfrom nn_dataflow.core import InterLayerPipeline\nfrom nn_dataflow.core import Network\nfrom nn_dataflow.core import Option\nfrom nn_dataflow.core import PhyDim2\nfrom nn_dataflow.core import PipelineSegment\nfrom . import TestPipelineFixture\n\"\"\" $lic$\nCopyright (C) 2016-2020 by Tsinghua University and The Board of Trustees of\nStanford University\n\nThis program is free software: you can redistribute it and/or modify it under\nthe terms of the Modified BSD-3 License as published by the Open Source\nInitiative.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE. See the BSD-3 License for more details.\n\nYou should have received a copy of the Modified BSD-3 License along with this\nprogram. If not, see <https://opensource.org/licenses/BSD-3-Clause>.\n\"\"\"\n\n\n\n\nclass TestInterLayerPipeline(TestPipelineFixture):\n    ''' Tests for InterLayerPipeline. '''\n\n    def test_valid_args(self):\n        ''' Valid arguments. '''\n", "context": "nn_dataflow/tests/pipeline_test/test_pipeline_fixture.py\nclass TestPipelineFixture(unittest.TestCase):\n    ''' Base fixture class for layer pipeline tests. '''\n\n    def setUp(self):\n\n        self.net = {}\n\n        net = Network('net1')\n        # Linear.\n        net.set_input_layer(InputLayer(10, 1))\n        net.add('0', FCLayer(10, 20))\n        net.add('1', FCLayer(20, 30))\n        net.add('1p', PoolingLayer(30, 1, 1))\n        net.add('2', FCLayer(30, 40))\n        net.add('3', FCLayer(40, 50))\n        self.net[net.net_name] = net\n\n        net = Network('net2')\n        # Long linear.\n        net.set_input_layer(InputLayer(1, 1))\n        for idx in range(16):\n            net.add(str(idx), FCLayer(1, 1))\n        self.net[net.net_name] = net\n\n        net = Network('net3')\n        # Fork.\n        # /0-2\\   /6- 7- 8\\\n        #   x  4-5         12\n        # \\1-3/   \\9-10-11/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('1', FCLayer(1, 1), prevs=net.INPUT_LAYER_KEY)\n        net.add('2', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('2p', PoolingLayer(1, 1, 1))\n        net.add('3', FCLayer(2, 1), prevs=('0', '1'))\n        net.add('4', FCLayer(2, 1), prevs=('2p', '3'))\n        net.add('5', FCLayer(1, 1))\n        net.add('5p', PoolingLayer(1, 1, 1))\n        net.add('6', FCLayer(1, 1), prevs='5p')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(1, 1), prevs='5p')\n        net.add('10', FCLayer(1, 1))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('8', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net4')\n        # Complex fork.\n        #          /5       \\\n        # 0-1-2-3-4-6-7-8-10-14\n        #              \\9/\n        #          \\11-12   /\n        #          \\13      /\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1))\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1))\n        net.add('4', FCLayer(1, 1))\n        net.add('5', FCLayer(1, 1), prevs='4')\n        net.add('6', FCLayer(1, 1), prevs='4')\n        net.add('7', FCLayer(1, 1))\n        net.add('8', FCLayer(1, 1), prevs='7')\n        net.add('9', FCLayer(1, 1), prevs='7')\n        net.add('10', FCLayer(1, 1))\n        net.add('10p', PoolingLayer(2, 1, 1), prevs=('8', '10'))\n        net.add('11', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('12', FCLayer(1, 1))\n        net.add('13', PoolingLayer(1, 1, 1), prevs='4')\n        net.add('14', FCLayer(5, 1), prevs=('5', '10p', '12', '13'))\n        self.net[net.net_name] = net\n\n        net = Network('net5')\n        # Corner cases.\n        #  ----\\\n        # //1-2\\ 7-8\\\n        # 0-3-4-x   10-11-12\n        #  \\ \\5/ 9 /  \\__/\n        #   6--/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(1, 1), prevs='3')\n        net.add('5', FCLayer(1, 1), prevs='3')\n        net.add('6', FCLayer(1, 1), prevs='0')\n        net.add('7', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('8', FCLayer(1, 1))\n        net.add('9', FCLayer(5, 1), prevs=('0', '2', '4', '5', '6'))\n        net.add('10', FCLayer(2, 1), prevs=('8', '9'))\n        net.add('11', FCLayer(1, 1))\n        net.add('12', FCLayer(2, 1), prevs=('10', '11'))\n        self.net[net.net_name] = net\n\n        net = Network('net6')\n        # Fmap sizes.\n        net.set_input_layer(InputLayer(1, 24))\n        net.add('0', ConvLayer(1, 1, 24, 3))\n        net.add('1', ConvLayer(1, 1, 12, 3, strd=2))\n        net.add('1p', PoolingLayer(1, 6, 2))\n        net.add('2', ConvLayer(1, 1, 6, 3))\n        net.add('3', ConvLayer(1, 1, 6, 3, strd=4), prevs=('0'))\n        self.net[net.net_name] = net\n\n        net = Network('net7')\n        # Topological order: see a visited vertex again.\n        #  /---\n        # 0-1-\\\\\n        #  \\2--2p\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='0')\n        net.add('2p', PoolingLayer(3, 1, 1), prevs=('0', '1', '2'))\n        self.net[net.net_name] = net\n\n        net = Network('net8')\n        # Forward to the middle.\n        #    /-\\\n        # 0-1-2-2p-4-4p\n        #  \\-3------/\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(1, 1), prevs='0')\n        net.add('2', FCLayer(1, 1), prevs='1')\n        net.add('2p', PoolingLayer(2, 1, 1), prevs=('1', '2'))\n        net.add('3', FCLayer(1, 1), prevs='0')\n        net.add('4', FCLayer(2, 1), prevs='2p')\n        net.add('4p', PoolingLayer(2, 1, 1), prevs=('3', '4'))\n        self.net[net.net_name] = net\n\n        net = Network('net9')\n        # Previous layers include input and others.\n        net.set_input_layer(InputLayer(1, 1))\n        net.add('0', FCLayer(1, 1))\n        net.add('1', FCLayer(2, 1), prevs=(net.INPUT_LAYER_KEY, '0'))\n        self.net[net.net_name] = net\n\n        # Real networks.\n        for net_name in all_networks():\n            self.net[net_name] = import_network(net_name)\n\n        self.batch_size = 16\n\n        self.resource = Resource(\n            proc_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.PROC),\n            dram_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 8),\n                                   type=NodeRegion.DRAM),\n            src_data_region=NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dst_data_region=NodeRegion(origin=PhyDim2(0, 4), dim=PhyDim2(8, 4),\n                                       type=NodeRegion.DRAM),\n            dim_array=PhyDim2(16, 16), size_gbuf=65536, size_regf=64,\n            array_bus_width=float('inf'), dram_bandwidth=float('inf'),\n            no_time_mux=False)\n\n        part = PartitionScheme(order=range(pe.NUM), pdims=[(1, 1)] * pe.NUM)\n        self.ofmap_layout = DataLayout(\n            frngs=(FmapRange((0, 0, 0, 0), (2, 4, 16, 16)),),\n            regions=(NodeRegion(origin=PhyDim2(0, 0), dim=PhyDim2(1, 1),\n                                type=NodeRegion.DRAM),),\n            parts=(part,))\n\n\n    def _make_ilp(self, network):\n        ''' Make an InterLayerPipeline instance. '''\n        return InterLayerPipeline(network, self.batch_size, self.resource)\n\n    def _make_segment(self, vseg, network, temporal=False, max_util_drop=None,\n                      with_opt=True):\n        ''' Convert vertex segment to (layer) segment. '''\n        kwargs = {}\n        if max_util_drop is not None:\n            kwargs['max_util_drop'] = max_util_drop\n        if not with_opt:\n            kwargs['with_opt'] = False\n        ilp = self._make_ilp(network)\n        seg = tuple(ilp.dag_vertex_list[vidx] for vidx in vseg)\n        if temporal:\n            seg = (sum(seg, tuple()),)\n        return PipelineSegment(seg, ilp.network, ilp.batch_size, ilp.resource,\n                               **kwargs)\n\n    def _make_sched_res(self, sched_seq, time, top_ti=1, top_to=1, top_tb=1,\n                        top_ord=range(le.NUM), dram_time=0, num_nodes=4):\n        scheme = OrderedDict()\n        scheme['cost'] = 1.234 + 9.876\n        scheme['time'] = max(time, dram_time)\n        scheme['num_nodes'] = num_nodes\n        scheme['proc_time'] = time\n        scheme['bus_time'] = 0\n        scheme['dram_time'] = dram_time\n        scheme['ti'] = [top_ti, 1, 1]\n        scheme['to'] = [top_to, 1, 1]\n        scheme['tb'] = [top_tb, 1, 1]\n        scheme['tvals'] = [[top_ti, top_to, top_tb], [1] * 3, [1] * 3]\n        scheme['orders'] = [top_ord, range(le.NUM), range(le.NUM)]\n        return SchedulingResult(scheme=scheme,\n                                ofmap_layout=self.ofmap_layout,\n                                sched_seq=sched_seq)\n\n    def _gen_all_segment(self, network, **kwargs):\n        '''\n        Generate all segments directly from all layers and all vertex segments.\n        '''\n        # pylint: disable=protected-access\n        ilp = self._make_ilp(network)\n        for layer in network:\n            yield PipelineSegment(((layer,),), ilp.network, ilp.batch_size,\n                                  ilp.resource)\n        for vseg in ilp._gen_vseg():\n            segment = self._make_segment(vseg, network, **kwargs)\n            if len(segment) == 1 and len(segment[0]) == 1:\n                continue\n            yield segment\n\n    def _validate_allocation(self, segment, allocation):\n        ''' Validate segment resource allocation. '''\n\n        # Match segment.\n        self.assertEqual(len(allocation), len(segment))\n        for ltpl, rtpl in zip(segment, allocation):\n            self.assertEqual(len(rtpl), len(ltpl))\n            self.assertTrue(all(isinstance(r, Resource) for r in rtpl))\n\n        # Number of nodes.\n        nodes = []  # number of nodes.\n        for rtpl in allocation:\n            nodes.append(rtpl[0].proc_region.dim.size())\n        self.assertEqual(sum(nodes), self.resource.proc_region.dim.size())\n\n        # Temporal schedules share processing region; spatial schedules use\n        # non-overlapped processing regions.\n        used_proc_nodes = set()  # used processing nodes\n        for rtpl in allocation:\n            proc_region = rtpl[0].proc_region\n            self.assertTrue(all(r.proc_region == proc_region for r in rtpl))\n            for n in proc_region.iter_node():\n                self.assertTrue(self.resource.proc_region.contains_node(n),\n                                '_validate_allocation: node {} outside of '\n                                'the processing region {}'\n                                .format(n, self.resource.proc_region))\n                self.assertNotIn(n, used_proc_nodes,\n                                 '_validate_allocation: node {} has been '\n                                 'used.'.format(n))\n                used_proc_nodes.add(n)\n\n        # Data liveness.\n        data_regions = {}  # layers that have data currently on-chip\n        for ltpl, rtpl in zip(segment, allocation):\n\n            for l, r in zip(ltpl, rtpl):\n\n                # Check data source.\n                prev_layers = segment.network.prevs(l)\n\n                for pl in prev_layers:\n                    if pl not in data_regions:\n                        # Previous layer is not on-chip, from memory.\n                        # Try find a layer responsible to fetch shared mem src.\n                        try:\n                            sh_sp_idx = next((i for i in range(len(allocation))\n                                              if allocation[i][0].proc_region\n                                              == r.src_data_region))\n                        except StopIteration:\n                            # No shared mem src.\n                            self.assertEqual(\n                                r.src_data_region,\n                                self.resource.src_data_region,\n                                '_validate_allocation: layer {}\\'s prev {} '\n                                'is not on-chip, should be from {}, but {}.'\n                                .format(l, pl, self.resource.src_data_region,\n                                        r.src_data_region))\n                        else:\n                            # There exists shared mem src.\n                            sh_l = segment[sh_sp_idx][0]\n                            self.assertEqual(segment.network.prevs(l),\n                                             segment.network.prevs(sh_l),\n                                             '_validate_allocation: layer {} '\n                                             'expects on-chip mem src sharing '\n                                             'with {}, but prevs differ.'\n                                             .format(l, sh_l))\n                    elif data_regions[pl] != r.proc_region:\n                        # Previous layer is on-chip and not local.\n                        self.assertEqual(\n                            r.src_data_region, data_regions[pl],\n                            '_validate_allocation: layer {}\\'s prev {} '\n                            'is on-chip, should be from {}, but {}.'\n                            .format(l, pl, data_regions[pl],\n                                    r.src_data_region))\n\n                # Update data based on destination.\n                # Local or store back to memory. Both will be available on-chip.\n                self.assertTrue(r.dst_data_region == r.proc_region\n                                or r.dst_data_region\n                                == self.resource.dst_data_region,\n                                '_validate_allocation: data can only '\n                                'be local or storing back to mem.')\n                # Overwrite.\n                local_node_set = set(r.proc_region.iter_node())\n                data_regions = {pl: data_regions[pl] for pl in data_regions\n                                if local_node_set.isdisjoint(\n                                    data_regions[pl].iter_node())}\n                data_regions[l] = r.proc_region\n\n    def _validate_constraint(self, segment, constraint):\n        ''' Validate segment scheduling constraint. '''\n        # pylint: disable=too-many-branches\n\n        # Match segment.\n        self.assertEqual(len(constraint), len(segment))\n        for ltpl, ctpl in zip(segment, constraint):\n            self.assertEqual(len(ctpl), len(ltpl))\n            self.assertTrue(all(isinstance(c, SchedulingConstraint)\n                                for c in ctpl))\n\n        # Same top tb.\n        top_tb = constraint[0][0].topbat\n        self.assertTrue(all(c.topbat == top_tb\n                            for ctpl in constraint for c in ctpl))\n\n        # Top tb is a factor of batch size.\n        if top_tb:\n            self.assertEqual((segment.batch_size) % top_tb, 0)\n\n        # Data availability.\n\n        seg_layers = set(l for ltpl in segment for l in ltpl)\n\n        class OutAccPat():\n            ''' Output data access pattern types. '''\n            # pylint: disable=too-few-public-methods\n            ANY = 0   # can access in any way\n            DBF = -1  # must double-buffer\n            # SEQ: use any positive value to represent sequential access with\n            # certain number of groups.\n\n        # Available data in each spatial subregions. Each is represented by a\n        # tuple of layer name and its output data access pattern.\n        avail_data = [(None, OutAccPat.ANY) for _ in segment]\n\n        # Get groups of layers sharing the same memory source.\n        prevs2layers = {}\n        for ltpl in segment:\n            l = ltpl[0]\n            prevs2layers.setdefault(segment.network.prevs(l), []).append(l)\n        sh_mem_src_groups = [ls for ps, ls in prevs2layers.items()\n                             if not seg_layers.intersection(ps) and len(ls) > 1]\n        sh_mem_src_topifms = [None] * len(sh_mem_src_groups)\n\n        # Whether to defer fully buffering output.\n        fb_out = False\n        fb_out_conv = None\n\n        for sp_idx, (ltpl, ctpl) in enumerate(zip(segment, constraint)):\n\n            self.assertFalse(fb_out,\n                             '_validate_constraint: deferring fully buffering '\n                             'from {} should not cross spatial scheduling {}.'\n                             .format(fb_out_conv, sp_idx - 1))\n\n            for tm_idx, (layer, cstr) in enumerate(zip(ltpl, ctpl)):\n\n                # Source data and their access patterns.\n                prev_layers = segment.network.prevs(layer)\n                prev_oaps = []\n                for pl in prev_layers:\n                    if pl not in seg_layers:\n                        # Off-chip sources.\n                        poap = OutAccPat.ANY\n                    elif pl in ltpl:\n                        # On-chip and local.\n                        self.assertEqual(avail_data[sp_idx][0], pl,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'local source data {} not available, '\n                                         'maybe not the immediate previous.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                        poap = avail_data[sp_idx][1]\n                    else:\n                        # On-chip and neighbor.\n                        poap = next((avail_data[p_sp_idx][1]\n                                     for p_sp_idx in range(sp_idx)\n                                     if avail_data[p_sp_idx][0] == pl),\n                                    None)\n                        self.assertFalse(poap is None,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'neighbor source data {} not '\n                                         'available on-chip.'\n                                         .format(layer, (sp_idx, tm_idx), pl))\n                    prev_oaps.append(poap)\n                # Only buffer input if having source on-chip.\n                has_src = not seg_layers.isdisjoint(prev_layers)\n\n                # The single SEQ source.\n                seq = None\n                # str is greater than all numbers, see\n                # https://docs.python.org/2/library/stdtypes.html#comparisons\n                seq_prev_oaps = [poap for poap in prev_oaps \\\n                                 if isinstance(poap, str) or \\\n                                    (isinstance(poap, int) and poap > 0)]\n                if seq_prev_oaps:\n                    self.assertEqual(len(seq_prev_oaps), 1,\n                                     '_validate_constraint: layer {} ({}) '\n                                     'has multiple SEQ input.'\n                                     '\\nsrcs: {}, oaps: {}'\n                                     .format(layer, (sp_idx, tm_idx),\n                                             prev_layers, prev_oaps))\n                    seq = seq_prev_oaps[0]\n\n                # Destination data.\n                # Only buffer output if having destination on-chip.\n                next_layers = segment.network.nexts(layer)\n                has_dst = not seg_layers.isdisjoint(next_layers)\n\n                # Validation.\n\n                for g_idx, group in enumerate(sh_mem_src_groups):\n                    if layer in group:\n                        if sh_mem_src_topifms[g_idx] is None:\n                            sh_mem_src_topifms[g_idx] = cstr.topifm\n                        self.assertEqual(sh_mem_src_topifms[g_idx], cstr.topifm,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'share memory source with {}, but has '\n                                         'mismatched topifm {} with {}.'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 group, cstr.topifm,\n                                                 sh_mem_src_topifms[g_idx]))\n                        break\n                else:\n                    if not has_src:\n                        self.assertEqual(cstr.topifm, 0,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'should not constrain input as it '\n                                         'does not have on-chip sources.'\n                                         .format(layer, (sp_idx, tm_idx)))\n\n                if isinstance(segment.network[layer], ConvLayer):\n\n                    self.assertFalse(fb_out,\n                                     '_validate_constraint: deferring fully '\n                                     'buffering from {} has not been realized.'\n                                     .format(fb_out_conv))\n\n                    if any(pl in ltpl for pl in prev_layers):\n                        # Local source.\n                        lcl_poap = avail_data[sp_idx][1]\n                        self.assertIn(lcl_poap, (OutAccPat.DBF, OutAccPat.ANY),\n                                      '_validate_constraint: layer {} ({}) '\n                                      'local source data {} must fully '\n                                      'buffer output.'\n                                      .format(layer, (sp_idx, tm_idx),\n                                              lcl_poap))\n\n                    # DBF source.\n                    if OutAccPat.DBF in prev_oaps:\n                        # Must fully buffer CONV input.\n                        self.assertEqual(cstr.topifm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input is not fully buffered but has '\n                                         'DBF source.\\nsrcs: {}, oaps: {}'\n                                         '\\n{}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps,\n                                                 cstr))\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Cannot be lazily updated.\n                        self.assertNotIsInstance(\n                            seq, str,\n                            '_validate_constraint: CONV layer {} ({}) cannot '\n                            'use lazy update (from {})'\n                            .format(layer, (sp_idx, tm_idx), seq))\n                        # Must match SEQ.\n                        self.assertEqual(cstr.topifm, seq,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'input groups ({}) and its SEQ src '\n                                         'output groups ({}) are mismatched.'\n                                         '\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 cstr.topifm, seq,\n                                                 prev_layers, prev_oaps))\n                        # Also must fully buffer CONV output.\n                        self.assertEqual(cstr.topofm, 1,\n                                         '_validate_constraint: layer {} ({}) '\n                                         'output is not fully buffered but has '\n                                         'SEQ source.\\nsrcs: {}, oaps: {}'\n                                         .format(layer, (sp_idx, tm_idx),\n                                                 prev_layers, prev_oaps))\n                        # Deferred apply to the last layer in the group.\n                        fb_out = True\n                        fb_out_conv = layer\n\n                    oap = None\n                    if cstr.topofm == 1:\n                        if cstr.topifm == 1:\n                            # Fully buffer both, can access output in any way.\n                            # This is fine as we require to buffer either input\n                            # or output for CONV (see below).\n                            oap = OutAccPat.ANY\n                        else:\n                            oap = OutAccPat.DBF\n                    elif has_dst and cstr.topofm > 0:\n                        oap = cstr.topofm\n                        if has_src:\n                            self.assertEqual(cstr.topifm, 1,\n                                             '_validate_constraint: layer {} '\n                                             '({}) has on-chip src and dst '\n                                             'but neither input nor output '\n                                             'are fully buffered.\\ncstr: {}.'\n                                             .format(layer, (sp_idx, tm_idx),\n                                                     cstr))\n                    elif has_dst:\n                        # Lazy update, record layer name as seq.\n                        oap = layer\n\n                else:\n\n                    # SEQ source.\n                    if seq and has_dst:\n                        # Must match SEQ, or fully buffer output.\n                        self.assertTrue(cstr.topofm == seq or cstr.topofm == 1\n                                        or seq in cstr.update_dict,\n                                        '_validate_constraint: layer {} ({}) '\n                                        'output is not fully buffered, and '\n                                        'groups ({}) and its SEQ src output '\n                                        'groups ({}) are mismatched, and '\n                                        'lazy update is not used.'\n                                        '\\nsrcs: {}, oaps: {}'\n                                        .format(layer, (sp_idx, tm_idx),\n                                                cstr.topofm, seq,\n                                                prev_layers, prev_oaps))\n\n                    if cstr.topofm == 1:\n                        # Fully buffer output.\n                        oap = OutAccPat.DBF\n                    elif isinstance(seq, str):\n                        # Lazy update.\n                        oap = seq\n                    else:\n                        # SEQ output.\n                        oap = cstr.topofm\n\n                # Realize deferred fully buffering output.\n                if cstr.topofm == 1:\n                    fb_out = False  # reset\n\n                # Overwrite the previous temporal scheduling.\n                avail_data[sp_idx] = (layer, oap)\nnn_dataflow/core/network.py\nclass Network():\n    '''\n    NN topology. Support DAG structure of layers.\n    '''\n\n    INPUT_LAYER_KEY = '__INPUT__'\n\n    def __init__(self, net_name):\n        self.net_name = net_name\n        self.layer_dict = OrderedDict()\n        self.prevs_dict = {}\n        self.nexts_dict = {}\n        self.ext_dict = OrderedDict()\n\n    def set_input_layer(self, input_layer):\n        '''\n        Set the input layer.\n        '''\n        if self.INPUT_LAYER_KEY in self.layer_dict:\n            raise KeyError('Network: only one input layer is allowed.')\n\n        if not isinstance(input_layer, InputLayer):\n            raise TypeError('Network: input_layer must be an InputLayer '\n                            'instance.')\n\n        self.layer_dict[self.INPUT_LAYER_KEY] = input_layer\n\n    def input_layer(self):\n        '''\n        Get the input layer.\n        '''\n        return self.layer_dict[self.INPUT_LAYER_KEY]\n\n    def add(self, layer_name, layer, prevs=None):\n        '''\n        Add a named layer, with optional previous layer(s).\n\n        If previous layer(s) is not given, assume it follows the last added\n        layer.\n        '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            raise RuntimeError('Network: must first set input layer.')\n\n        if layer_name in self.layer_dict:\n            raise KeyError('Network: layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, Layer):\n            raise TypeError('Network: layer must be a Layer instance.')\n\n        # First figure out previous layers.\n        if prevs:\n            # Ensure `prevs` as a tuple.\n            if isinstance(prevs, str):\n                prevs = (prevs,)\n            else:\n                prevs = tuple(prevs)\n            # Ensure previous layers are already added.\n            for p in prevs:\n                try:\n                    self.__getitem__(p)\n                except KeyError:\n                    raise KeyError('Network: given previous layer {} '\n                                   'has not been added to the network'.\n                                   format(p))\n        else:\n            prevs = (list(self.layer_dict.keys())[-1],)\n\n        self.layer_dict[layer_name] = layer\n        self.prevs_dict[layer_name] = prevs\n\n        # Ensure dimension matching between layers.\n        try:\n            self._check_prevs(layer_name)\n        except ValueError:\n            del self.layer_dict[layer_name]\n            del self.prevs_dict[layer_name]\n            raise\n\n        for p in prevs:\n            self.nexts_dict.setdefault(p, []).append(layer_name)\n\n    def add_ext(self, layer_name, layer):\n        '''\n        Add a named external layer.\n        '''\n        if layer_name in self.ext_dict:\n            raise KeyError('Network: external layer {} already exists.'\n                           .format(layer_name))\n\n        if not isinstance(layer, InputLayer):\n            raise TypeError('Network: external layer must be an InputLayer '\n                            'instance.')\n\n        self.ext_dict[layer_name] = layer\n\n    def prevs(self, layer_name):\n        '''\n        Get the previous layers of the given layer name.\n\n        Return a tuple of all the previous layer names. Use `None` to represent\n        the input layer in the returned tuple.\n        '''\n        if layer_name == self.INPUT_LAYER_KEY:\n            raise ValueError('Network: cannot get previous layers for '\n                             'input layer.')\n        if layer_name in self.ext_dict:\n            raise ValueError('Network: cannot get previous layers for '\n                             'external layers.')\n\n        prevs = tuple(None if p == self.INPUT_LAYER_KEY else p\n                      for p in self.prevs_dict[layer_name])\n        assert prevs\n\n        return prevs\n\n    def nexts(self, layer_name):\n        '''\n        Get the next layers of the given layer name, i.e., the layers that need\n        the output of this layer.\n\n        Return a tuple of all the next layer names. Use `None` to represent the\n        output of the last layer in the returned tuple.\n        '''\n        try:\n            nexts = tuple(self.nexts_dict[layer_name])\n        except KeyError:\n            nexts = tuple([None])\n        assert nexts\n\n        return nexts\n\n    def firsts(self):\n        '''\n        Get a tuple of the first layers, i.e., those with only the input layer\n        or external layers as their previous layers.\n\n        If a layer has other layers besides the input/external layers as its\n        previous layers, it does not count as a first layer.\n        '''\n        input_ext_layers = set([None]).union(self.ext_layers())\n        firsts = []\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            if input_ext_layers.issuperset(prevs):\n                firsts.append(layer_name)\n        return tuple(firsts)\n\n    def lasts(self):\n        '''\n        Get a tuple of the last layers, i.e., those with no next layer.\n        '''\n        lasts = []\n        for layer_name in self:\n            nexts = self.nexts(layer_name)\n            if nexts == (None,):\n                lasts.append(layer_name)\n        return tuple(lasts)\n\n    def ext_layers(self):\n        '''\n        Get a tuple of the external layers.\n        '''\n        return tuple(self.ext_dict.keys())\n\n    def _check_prevs(self, layer_name):\n        '''\n        Check the previous layers of the given layer name.\n        '''\n        layer = self.layer_dict[layer_name]\n\n        prevs = self.prevs_dict[layer_name]\n        assert prevs\n\n        # Compare the ifmap dimensions of this layer, with all the ofmaps of\n        # the previous layers.\n        sum_nfmaps = 0\n\n        for p in prevs:\n            pl = self.__getitem__(p)\n\n            # Ensure fmap sizes match. Allow padding.\n            if not layer.is_valid_padding_sifm((pl.hofm, pl.wofm)):\n                raise ValueError('Network: {}, a previous layer of {}, '\n                                 'has mismatch fmap size: {} vs. {}.'\n                                 .format(p, layer_name,\n                                         (pl.hofm, pl.wofm),\n                                         (layer.hofm, layer.wofm)))\n\n            sum_nfmaps += pl.nofm\n\n        if sum_nfmaps != layer.nifm:\n            raise ValueError('Network: {} cannot be the previous layers of {}.'\n                             .format(' | '.join(prevs), layer_name))\n\n    def __contains__(self, layer_name):\n        ''' Whether the network contains a layer. '''\n        return layer_name in self.layer_dict or layer_name in self.ext_dict\n\n    def __len__(self):\n        ''' Number of layers in the network. '''\n        if self.INPUT_LAYER_KEY not in self.layer_dict:\n            assert not self.layer_dict\n            return 0\n        return len(self.layer_dict) - 1\n\n    def __iter__(self):\n        ''' Iterate through layer names. '''\n        for layer_name in self.layer_dict.keys():\n            if layer_name == self.INPUT_LAYER_KEY:\n                continue\n            yield layer_name\n\n    def __getitem__(self, layer_name):\n        ''' Get the layer by name. '''\n        try:\n            return self.layer_dict[layer_name]\n        except KeyError:\n            try:\n                return self.ext_dict[layer_name]\n            except KeyError as e:\n                raise KeyError('Network: {} layer not found.'.format(str(e)))\n\n    def __str__(self):\n        str_ = 'Network: {}\\n'.format(self.net_name)\n        for layer_name in self:\n            prevs = self.prevs(layer_name)\n            prev_str = ' | '.join(['None' if n is None else n for n in prevs])\n            str_ += '  Layer {} <- {}\\n'.format(layer_name, prev_str)\n        return str_\nnn_dataflow/core/layer.py\nclass ConvLayer(Layer):\n    '''\n    NN convolutional layer parameters.\n\n    nifm (C): # ifmap channels\n    nofm (M): # ofmap channels\n    hifm, wifm (H): ifmap height/width\n    hofm, wofm (E): ofmap height/width\n    hfil, wfil (R): weight filter width/height\n    htrd, wtrd (U): stride height/width\n    '''\n\n    def __init__(self, nifm, nofm, sofm, sfil, strd=1):\n        super(ConvLayer, self).__init__(nofm, sofm, strd=strd)\n\n        if isinstance(sfil, int):\n            hfil = sfil\n            wfil = sfil\n        elif len(sfil) == 2:\n            hfil = sfil[0]\n            wfil = sfil[1]\n        else:\n            raise ValueError('ConvLayer: sfil is invalid ({}), '\n                             'needs to be either one integer or '\n                             'a pair of integers'.format(sfil))\n\n        self.hfil = hfil\n        self.wfil = wfil\n\n        hifm = self.hfil + (self.hofm - 1) * self.htrd\n        wifm = self.wfil + (self.wofm - 1) * self.wtrd\n        self.inlayer = Layer(nifm, (hifm, wifm))\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops(le.IFM, le.OFM)\n        dls[de.IFM] = DataDimLoops(le.IFM, le.BAT)\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return self.inlayer\n\n    def ops_per_neuron(self):\n        # 2D convolution across all ifmap channels.\n        return self.hfil * self.wfil * self.nifm\n\n    def filter_size(self, word_size=1):\n        '''\n        Get size of one weight filter.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.hfil * self.wfil * word_size\n\n    def total_filter_size(self, word_size=1):\n        '''\n        Get total size of all weight filters.\n\n        If `word_size` is set to word byte size, return size in bytes.\n        '''\n        return self.nifm * self.nofm * self.filter_size(word_size)\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sfil={}'.format(repr((self.hfil, self.wfil))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/layer.py\nclass FCLayer(ConvLayer):\n    '''\n    NN fully-connected layer parameters.\n\n    As a special case of CONVLayer.\n\n    hifm = hfil, wifm = wfil, strd = 1, hofm = wofm = 1\n    '''\n\n    def __init__(self, nifm, nofm, sfil=1):\n        super(FCLayer, self).__init__(nifm, nofm, 1, sfil)\n        assert self.hofm == 1 and self.wofm == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nifm={}'.format(repr(self.nifm)),\n                'nofm={}'.format(repr(self.nofm)),\n                'sfil={}'.format(repr((self.hfil, self.wfil)))]))\nnn_dataflow/core/inter_layer_pipeline.py\nclass InterLayerPipeline():\n    '''\n    Inter-layer pipeline.\n    '''\n\n    def __init__(self, network, batch_size, resource, max_util_drop=0.05):\n        if not isinstance(network, Network):\n            raise TypeError('InterLayerPipeline: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('InterLayerPipeline: resource must be '\n                            'a Resource instance.')\n        if not 0 <= max_util_drop <= 1:\n            raise ValueError('InterLayerPipeline: max_util_drop must be '\n                             'between [0, 1].')\n\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n\n        self._calc_sched_dag()\n\n        # Vertices starting from which we have generated the segments.\n        self.seg_vertex_done = set()\n\n    def ordered_layer_list(self):\n        '''\n        Get a list of the layers in their topological order in the scheduling\n        DAG.\n        '''\n        return list(sum(self.dag_vertex_list, tuple()))\n\n    def gen_segment(self, options):\n        '''\n        Generate all valid inter-layer pipelining segments.\n        '''\n\n        kwargs = {'network': self.network,\n                  'batch_size': self.batch_size,\n                  'resource': self.resource,\n                  'max_util_drop': self.max_util_drop,\n                  'with_opt': options.layer_pipeline_opt,\n                 }\n\n        # No pipelining, each layer sequentially occupies the whole resource.\n        for layer in self.network:\n            seg = ((layer,),)\n            segment = PipelineSegment(seg, **kwargs)\n            assert segment.valid\n            yield segment\n\n        # Pipelining.\n        for vseg in self._gen_vseg():\n\n            if len(vseg) > options.layer_pipeline_max_degree:\n                continue\n\n            if len(vseg) == 1 and len(self.dag_vertex_list[vseg[0]]) == 1:\n                # An individual layer, already returned in no-pipelining case.\n                continue\n\n            # Use set to eliminate duplicates.\n            seg_cands = set()\n\n            if options.partition_interlayer:\n                # Spatial pipelining.\n                seg = tuple(self.dag_vertex_list[vidx] for vidx in vseg)\n                seg_cands.add(seg)\n\n            if options.hw_gbuf_save_writeback:\n                # Temporal pipelining.\n                # Reduce the spatial dimension.\n                seg = (tuple(itertools.chain.from_iterable(\n                    self.dag_vertex_list[vidx] for vidx in vseg)),)\n                seg_cands.add(seg)\n\n            # Determine segment allocation.\n            for seg in seg_cands:\n                segment = PipelineSegment(seg, **kwargs)\n                if segment.valid:\n                    yield segment\n\n    def _gen_vseg(self, vertex_idx=0, done=None):\n        '''\n        Generate vertex segments starting from vertex `vertex_idx`. Yield a\n        tuple of the vertices in the segment.\n\n        `done` is a set of vertices which have already been scheduled and the\n        output is already in memory.\n\n        Rules:\n\n        1. If a vertex does not share any dependencies with the current\n        segment, i.e., none of its previous vertices is in the current segment\n        or among the previous vertices of the current segment, we do not add it\n        to the segment, because there is no benefit to co-locate them.\n\n        2. If a vertex has multiple previous vertices, at most one of them\n        can be in the same segment as this vertex, because the output data\n        availability timing of multiple previous vertices may not match.\n\n        3. If a vertex has multiple next vertices, either all or at most one of\n        them can be NOT in the same segment as this vertex, because only\n        including a small subset saves little data write-back to memory.\n        '''\n\n        vseg = tuple()\n\n        if not done:\n            done = set()\n            # Reset.\n            self.seg_vertex_done = set()\n\n        if self.dag_input_vertex not in done:\n            # Input layer is always in memory.\n            done.add(self.dag_input_vertex)\n\n        # The frontier is the vertex to be considered to be added to the\n        # current segment.\n        for frontier in range(vertex_idx, len(self.dag_vertex_list)):\n\n            # Check whether the frontier can be added to the current segment.\n\n            frontier_prevs = self.dag_prev_dict[frontier]\n\n            # Whether the frontier share dependencies with the current segment,\n            # if the segment is not empty.\n            share_deps = not vseg or not frontier_prevs.isdisjoint(\n                set.union(set(vseg), *[self.dag_prev_dict[i] for i in vseg]))\n\n            # Whether multiple previous vertices are in the current segment.\n            multi_prevs = len(frontier_prevs.intersection(vseg)) > 1\n\n            if not share_deps or multi_prevs:\n                # Not sharing any dependencies (rule 1), or multiple previous\n                # vertices in the current segment (rule 2).\n\n                # Make sure the current segment is not empty.\n                assert vseg\n                # Not extend the segment any more. Note that the current\n                # segment has already been yielded, as well as the recursion,\n                # in the last iteration.\n                break\n\n            # Extend the segment.\n            vseg += (frontier,)\n\n            # Check whether the segment is valid.\n\n            for idx in vseg:\n                nexts = self.dag_next_dict[idx]\n\n                # The next vertices should either all or at most one not in the\n                # segment (rule 3).\n                if not nexts.isdisjoint(vseg) \\\n                        and len(nexts.difference(vseg)) > 1:\n                    # The segment is invalid. Need to add more vertices.\n                    break\n            else:\n                # The segment is valid.\n                yield vseg\n\n                # Skip if have done.\n                if frontier + 1 in self.seg_vertex_done:\n                    continue\n\n                # Recursion.\n                for tpl in self._gen_vseg(frontier + 1, done.union(vseg)):\n                    yield tpl\n\n        assert vertex_idx not in self.seg_vertex_done\n        self.seg_vertex_done.add(vertex_idx)\n\n    def _calc_sched_dag(self):\n        '''\n        Build the scheduling DAG of the network. We merge layers with no\n        filters into their last previous layer, so a DAG vertex can contain one\n        or more layers.\n\n        We order and index the DAG vertices in their depth-first topological\n        order. This will also be the order to schedule the layers.\n\n        Also establish two dicts for the previous and next vertices of each DAG\n        vertex.\n\n        In summary, the attributes initialized include: `dag_input_vertex`,\n        `dag_vertex_list`, `dag_vertex_dict`, `dag_prev_dict`, `dag_next_dict`.\n        '''\n\n        # Vertex of the input layer.\n        self.dag_input_vertex = -1\n\n        # The DAG vertex set. Each vertex is a merged layer tuples, represented\n        # by their layer names. Use a list type to make modification easier.\n        dag_vertex_set = []\n\n        for layer_name in self.network:\n            layer = self.network[layer_name]\n\n            if isinstance(layer, ConvLayer):\n                dag_vertex_set.append((layer_name,))\n\n            else:\n                prevs = set(self.network.prevs(layer_name))\n                assert prevs\n\n                # Find and merge to a vertex if that vertex only contains one\n                # previous layer at the last, because non-last previous layer\n                # will not have its data available to be used for this layer.\n                # Also the previous layer can only have this one next layer,\n                # because its data will be overwritten by this layer locally.\n\n                # Check vertices in the reversed order.\n                for idx in reversed(range(len(dag_vertex_set))):\n                    vhead = dag_vertex_set[idx][:-1]\n                    vtail = dag_vertex_set[idx][-1]\n                    if prevs.isdisjoint(vhead) and vtail in prevs \\\n                            and len(self.network.nexts(vtail)) == 1:\n                        dag_vertex_set[idx] += (layer_name,)\n                        break\n                else:\n                    # No valid vertex to merge.\n                    dag_vertex_set.append((layer_name,))\n\n        assert sum(len(v) for v in dag_vertex_set) == len(self.network)\n\n        # The DAG vertex list in the topological order.\n        self.dag_vertex_list = self._topological_order(dag_vertex_set)\n\n        # Make a directory from layer name to DAG vertex index.\n        self.dag_vertex_dict = {}\n\n        for vidx, v in enumerate(self.dag_vertex_list):\n            for layer_name in v:\n                assert layer_name not in self.dag_vertex_dict\n                self.dag_vertex_dict[layer_name] = vidx\n\n        # Add the input layer.\n        self.dag_vertex_dict[self.network.INPUT_LAYER_KEY] = \\\n                self.dag_input_vertex\n        # Add the external layers.\n        for ext_layer in self.network.ext_layers():\n            self.dag_vertex_dict[ext_layer] = self.dag_input_vertex\n\n        # The previous and next relationship of the DAG vertices.\n        self.dag_prev_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n        self.dag_next_dict = dict((vidx, set()) for vidx\n                                  in range(len(self.dag_vertex_list)))\n\n        for layer_name in self.network:\n            vidx = self.dag_vertex_dict[layer_name]\n\n            # Previous layers.\n            for p in self.network.prevs(layer_name):\n                pvidx = self.dag_vertex_dict[p] \\\n                        if p and p not in self.network.ext_layers() \\\n                        else self.dag_input_vertex\n                if pvidx != vidx:\n                    self.dag_prev_dict[vidx].add(pvidx)\n\n            # Next layers.\n            for n in self.network.nexts(layer_name):\n                if not n:\n                    continue\n                nvidx = self.dag_vertex_dict[n]\n                if nvidx != vidx:\n                    self.dag_next_dict[vidx].add(nvidx)\n\n        # Add next layers of the input layer.\n        self.dag_next_dict[self.dag_input_vertex] = set()\n        for vidx in self.dag_prev_dict:\n            if self.dag_input_vertex in self.dag_prev_dict[vidx]:\n                self.dag_next_dict[self.dag_input_vertex].add(vidx)\n\n    def _topological_order(self, dag_vertex_set):\n        '''\n        Order the DAG vertices in topological order using DFS.\n\n        Specifically, The backtrace order of the depth-first search is the\n        inverse of the topological order. See\n        https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n        '''\n\n        # The visited layers in the DFS order.\n        visited = []\n        # The unseen pending layers.\n        unseen = set(dag_vertex_set)\n        # The layers that have been seen, but not visited due to unvisited\n        # previous layers.\n        seen = set()\n\n        def _dfs(vertex):\n            assert vertex not in seen\n            if vertex in visited:\n                return\n\n            unseen.discard(vertex)\n            seen.add(vertex)\n\n            nexts = []\n            for l in vertex:\n                for n in self.network.nexts(l):\n                    if n and n not in vertex and n not in nexts:\n                        nexts.append(n)\n\n            # Visit next layers in the reversed order, so the reversed visit\n            # order has the original order.\n            next_vertices = []\n            for n in reversed(nexts):\n                for nv in unseen:\n                    if n in nv:\n                        next_vertices.append(nv)\n\n            for nv in next_vertices:\n                _dfs(nv)\n\n            visited.append(vertex)\n            seen.remove(vertex)\n\n        # Start from the first layers.\n        start_vertices = []\n        for l in reversed(self.network.firsts()):\n            for v in unseen:\n                if l in v:\n                    start_vertices.append(v)\n        for v in start_vertices:\n            _dfs(v)\n        assert not unseen\n        assert not seen\n\n        return list(reversed(visited))\nnn_dataflow/core/layer.py\nclass InputLayer(Layer):\n    '''\n    NN input layer parameters.\n    '''\n\n    @staticmethod\n    def data_loops():\n        dls = [None] * de.NUM\n        dls[de.FIL] = DataDimLoops()\n        dls[de.IFM] = DataDimLoops()\n        dls[de.OFM] = DataDimLoops(le.OFM, le.BAT)\n        return tuple(dls)\n\n    def input_layer(self):\n        return None\n\n    def ops_per_neuron(self):\n        return 0\nnn_dataflow/core/pipeline_segment.py\nclass PipelineSegment():\n    '''\n    Inter-layer pipeline segment.\n\n    Segment is a two-level layer hierarchy, where the first level is spatially\n    scheduled and the second level is temporally scheduled.\n    '''\n\n    # pylint: disable=too-many-instance-attributes\n\n    # Scheduling index in the segment, as a tuple of spatial and temporal\n    # scheduling indices.\n    SchedIndex = namedtuple('SchedIndex', ['sp_idx', 'tm_idx'])\n\n    def __init__(self, seg, network, batch_size, resource, max_util_drop=0.05,\n                 with_opt=True):\n        if not isinstance(seg, tuple):\n            raise TypeError('PipelineSegment: seg must be a tuple.')\n        for ltpl in seg:\n            if not isinstance(ltpl, tuple):\n                raise TypeError('PipelineSegment: seg must be a tuple '\n                                'of sub-tuples.')\n\n        if not isinstance(network, Network):\n            raise TypeError('PipelineSegment: network must be '\n                            'a Network instance.')\n        if not isinstance(resource, Resource):\n            raise TypeError('PipelineSegment: resource must be '\n                            'a Resource instance.')\n\n        self.seg = seg\n        self.network = network\n        self.batch_size = batch_size\n        self.resource = resource\n        self.max_util_drop = max_util_drop\n        self.with_opt = with_opt\n\n        self.valid = self._init_deps()\n        if not self.valid:\n            return\n\n        # Resource allocation.\n        self.valid = self._alloc_resource(max_util_drop=max_util_drop)\n        if not self.valid:\n            return\n\n        # Scheduling constraints.\n        self.valid = self._init_sym_cstrs()\n        if not self.valid:\n            return\n\n    def allocation(self):\n        '''\n        Get resource allocation, as a tuple of sub-tuples corresponding to the\n        layers in the segment.\n        '''\n        if not self.valid:\n            return None\n        return self.alloc\n\n    def gen_constraint(self, max_time_overhead=float('inf')):\n        '''\n        Generate scheduling constraint for the segment, as a tuple of\n        sub-tuples of SchedulingConstraint instances, corresponding to the\n        layers in the segment.\n\n        Yield the segment constraint tuple, and hints for pruning.\n\n        Pruning hints are the top-level loop blocking factors. Smaller hints\n        indicate better (lower) cost, and larger hints indicate better segment\n        timing (with lower time overhead). Constraints with smaller hints are\n        generated before those with larger hints. So if a constraint results in\n        a valid scheduling, the later ones with all hints larger than its can\n        be pruned.\n        '''\n        syms = self.cstr_symvals.keys()\n        vals = self.cstr_symvals.values()\n        assert syms and vals\n\n        # Sort from small to large.\n        # This is not a strict ordering, but we guarantee that if all values in\n        # hint A are larger than the corresponding values in hint B, A will be\n        # generated after B.\n        vals = [sorted(v) for v in vals]\n        syms = list(syms)\n\n        if self.cstr_topbat_idx is not None:\n            # Tovhd =  (1 + 1/to + 1 + 1/to + ...) / tb\n            #       >= (1 + 1 + ...) / tb = num_sp_fbs / tb\n            min_topbat = 1. * self.cstr_num_sp_fbs / max_time_overhead\n            pos = self.cstr_topbat_idx\n            vals[pos] = [t for t in vals[pos] if t >= min_topbat]\n\n        for valp in itertools.product(*vals):\n\n            constraint = tuple()\n\n            for atpl in self._subs_symargs(self.cstr_symargs,\n                                           tuple(zip(syms, valp))):\n                ctpl = tuple()\n                for a in atpl:\n                    # Construct kwargs, adjust the types of the values.\n                    kwargs = {}\n                    kwargs['topbat'] = int(a.get('topbat', 0))\n                    kwargs['fbifm'] = bool(a.get('fbifm', False))\n                    if not kwargs['fbifm']:\n                        kwargs['topifm'] = int(a.get('topifm', 0))\n                    kwargs['fbofm'] = bool(a.get('fbofm', False))\n                    if not kwargs['fbofm']:\n                        kwargs['topofm'] = int(a.get('topofm', 0))\n                    kwargs['update_dict'] = a.get('update_dict')\n\n                    c = Cstr(**kwargs)\n                    ctpl += (c,)\n                constraint += (ctpl,)\n\n            if None in valp:\n                assert len(valp) == 1\n                hints = (1,)\n            else:\n                hints = tuple(valp)\n\n            yield constraint, hints\n\n    def __getitem__(self, index):\n        return self.seg[index]\n\n    def __iter__(self):\n        return self.seg.__iter__()\n\n    def __len__(self):\n        return len(self.seg)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            # pylint: disable=protected-access\n            return self._key_attrs() == other._key_attrs()\n        return NotImplemented\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash(tuple(self._key_attrs()))\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'seg={}'.format(repr(self.seg)),\n                'network={}'.format(repr(self.network)),\n                'batch_size={}'.format(repr(self.batch_size)),\n                'resource={}'.format(repr(self.resource)),\n                'max_util_drop={}'.format(repr(self.max_util_drop)),\n                'with_opt={}'.format(repr(self.with_opt))]))\n\n    def _key_attrs(self):\n        ''' Used for comparison. '''\n        return (self.seg, self.network, self.batch_size, self.resource,\n                self.max_util_drop, self.with_opt)\n\n    def _init_deps(self):\n        '''\n        Initialize the dependency relationship of the layers in the segment as\n        a mapping of the scheduling indices, and check validation. Return\n        whether the segment is valid to schedule.\n\n        We categorize dependencies to 3 categories:\n        - local: with the same spatial index but different temporal indices;\n        - neighbor: with different spatial indices but in the same segment;\n        - memory: in different segments, from/to memory.\n\n        The values of the src/dst dicts are tuples of indices of the neighbor\n        dependencies. A layer can have at most one neighbor source (must be a\n        last temporal scheduled layer), but may have multiple neighbor\n        destinations (could be temporal scheduled in the middle). Also, all\n        layers with the same spatial index can have at most one neighbor\n        source.\n\n        Special index `None` means memory dependency, i.e., from/to memory.\n        Memory sources and neighbor sources must be mutual exclusive, in order\n        to correctly set the src data regions; memory destinations and neighbor\n        destinations can co-exist.\n\n        Local dependencies are omitted, as by default each layer has its\n        immediately previous layer as local source and immediately next layer\n        as local destination.\n\n        Construct an ifmap forwarding dict for shared memory source data. It\n        maps previous layer name tuples, to a list of scheduling indices of all\n        layers in this segment that share these exact previous layers. The\n        first in the list is responsible to fetch the previous layer data and\n        to forward them to others. We allow shared memory source data between\n        two layers only when both layers have memory dependency only (so their\n        temporal indices must be 0), and their previous layers are exactly the\n        same.\n\n        Construct an ofmap forwarding dict for multiple destinations of both\n        on-chip and off-chip. It maps the scheduling index of a layer in this\n        segment that has both memory and neighbor/local destinations (so needs\n        to store its ofmaps back to memory), to a list of scheduling indices of\n        all layers in this segment that accepts its ofmaps as ifmaps. Neighbor\n        dependencies are only between the last temporal one and the first\n        temporal ones; local dependencies are only between adjacent temporal\n        ones.\n        '''\n\n        self.src_dict = [[None for _ in ltpl] for ltpl in self.seg]\n        self.dst_dict = [[None for _ in ltpl] for ltpl in self.seg]\n\n        self.ifm_fwd_dict = {}\n        self.ofm_fwd_dict = {}\n\n        # Mapping from layer to spatial/temporal indices in the segment.\n        layer2idx = {l: PipelineSegment.SchedIndex(sp_idx, tm_idx)\n                     for sp_idx, ltpl in enumerate(self.seg)\n                     for tm_idx, l in enumerate(ltpl)}\n\n        # Mapping from previous layer tuple to layer.\n        prevs2layer = {}\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            single_nbr_src = None\n\n            for tm_idx, l in enumerate(ltpl):\n\n                assert layer2idx[l] == (sp_idx, tm_idx)\n\n                # Sources.\n                src = tuple()\n\n                prevs = self.network.prevs(l)\n                assert all(p not in layer2idx or layer2idx[p] < layer2idx[l]\n                           for p in prevs)\n                mem_src = [p for p in prevs if p not in layer2idx]\n                lcl_src = [p for p in prevs if p not in mem_src\n                           and layer2idx[p].sp_idx == sp_idx]\n                nbr_src = [p for p in prevs if p not in mem_src + lcl_src]\n\n                # Ensure single local source to be the immediately previous.\n                # Check at the destination so here are assertions.\n                if not lcl_src:\n                    assert tm_idx == 0\n                else:\n                    assert len(lcl_src) == 1 \\\n                            and layer2idx[lcl_src[0]].tm_idx == tm_idx - 1\n\n                # Mutual exclusive.\n                if mem_src and nbr_src:\n                    # We now allow each spatial scheduling (vertex) to have\n                    # both memory source and neighbor source when generating\n                    # segments. But each single layer cannot have both;\n                    # otherwise there would be multiple source data regions.\n                    return False\n\n                if mem_src:\n                    # Memory source.\n                    src += (None,)\n                if nbr_src:\n                    # Neighbor source.\n                    # Single neighbor source to be the last temporal scheduled.\n                    assert len(nbr_src) == 1\n                    prev_idx = layer2idx[nbr_src[0]]\n                    assert prev_idx.tm_idx == len(self.seg[prev_idx.sp_idx]) - 1\n                    # Single neighbor source across this spatial scheduling.\n                    if single_nbr_src is not None:\n                        return False\n                    single_nbr_src = prev_idx\n                    src += (prev_idx,)\n\n                # Shared memory source.\n                if mem_src and not lcl_src:\n                    assert not nbr_src\n                    assert tm_idx == 0\n                    if prevs in prevs2layer:\n                        fet_idx = layer2idx[prevs2layer[prevs]]\n                        self.ifm_fwd_dict.setdefault(prevs, [fet_idx]).append(\n                            layer2idx[l])\n                    else:\n                        prevs2layer[prevs] = l\n\n                # Destinations.\n                dst = tuple()\n\n                nexts = self.network.nexts(l)\n                assert all(n not in layer2idx or layer2idx[n] > layer2idx[l]\n                           for n in nexts)\n                mem_dst = [n for n in nexts if n not in layer2idx]\n                lcl_dst = [n for n in nexts if n not in mem_dst\n                           and layer2idx[n].sp_idx == sp_idx]\n                nbr_dst = [n for n in nexts if n not in mem_dst + lcl_dst]\n\n                # Ensure single local destination to be the immediate next.\n                if not lcl_dst:\n                    if tm_idx != len(ltpl) - 1:\n                        # Not utilize local data, sub-optimal.\n                        return False\n                else:\n                    if len(lcl_dst) != 1 \\\n                            or layer2idx[lcl_dst[0]].tm_idx != tm_idx + 1:\n                        # Local data will not be available if not adjacent.\n                        return False\n\n                # Mutual exclusive.\n                # Now they can co-exist.\n                # assert not mem_dst or not nbr_dst\n                if mem_dst and nbr_dst:\n                    assert tm_idx == len(ltpl) - 1\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[n]\n                                                       for n in nbr_dst]\n                if mem_dst and lcl_dst:\n                    assert not nbr_dst\n                    self.ofm_fwd_dict[layer2idx[l]] = [layer2idx[lcl_dst[0]]]\n\n                if mem_dst:\n                    # Memory destination.\n                    dst += (None,)\n                if nbr_dst:\n                    # Neighbor destinations.\n                    # This layer is the last temporal scheduled.\n                    assert tm_idx == len(ltpl) - 1\n                    dst += tuple(layer2idx[n] for n in nbr_dst)\n\n                # Basic pipelining requires a linear structure (on-chip).\n                if not self.with_opt:\n                    if len(nbr_src) + len(lcl_src) > 1 \\\n                            or len(nbr_dst) + len(lcl_dst) > 1 \\\n                            or ((sp_idx, tm_idx) != (0, 0)\n                                    and not nbr_src and not lcl_src):\n                        return False\n\n                self.src_dict[sp_idx][tm_idx] = src\n                self.dst_dict[sp_idx][tm_idx] = dst\n\n        return True\n\n    def _alloc_resource(self, max_util_drop=0.05):\n        '''\n        Decide the resource allocation. Return whether the allocation succeeds.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        self.alloc = tuple()\n\n        # Allocate processing subregions.\n        subregions = self._alloc_proc(max_util_drop=max_util_drop)\n        if not subregions:\n            return False\n\n        no_time_mux = len(self.network) == sum(len(ltpl) for ltpl in self.seg)\n        # All layers that have model filters must be spatially scheduled.\n        if no_time_mux:\n            for ltpl in self.seg:\n                if len([l for l in ltpl\n                        if isinstance(self.network[l], ConvLayer)]) > 1:\n                    no_time_mux = False\n                    break\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Resource for the subregion.\n            rtpl = tuple()\n\n            for tm_idx, _ in enumerate(ltpl):\n\n                # Processing region.\n                proc_region = subregions[sp_idx]\n\n                # Data source.\n                src = self.src_dict[sp_idx][tm_idx]\n                if None in src:\n                    # Data source is memory.\n                    assert src == (None,)\n                    src_data_region = self.resource.src_data_region\n                    for sh_idx_list in self.ifm_fwd_dict.values():\n                        # Find shared memory source to use forwarding.\n                        if (sp_idx, tm_idx) in sh_idx_list[1:]:\n                            src_data_region = subregions[sh_idx_list[0].sp_idx]\n                            break\n                elif src:\n                    # Data source is neighbor.\n                    assert len(src) == 1\n                    src_data_region = subregions[src[0].sp_idx]\n                else:\n                    # Data source is all local.\n                    src_data_region = proc_region\n\n                # Data destination.\n                dst = self.dst_dict[sp_idx][tm_idx]\n                if None in dst:\n                    # Data destination is memory.\n                    # assert dst == (None,)\n                    # Now we can have both memory and neighbor destinations. If\n                    # they co-exist, we need to store them locally and also\n                    # store back to memory. In this case the dst data region is\n                    # set to memory.\n                    dst_data_region = self.resource.dst_data_region\n                elif dst:\n                    # Data destinations are neighbors.\n                    # Put data in local. The next layers will fetch.\n                    dst_data_region = proc_region\n                else:\n                    # Data destination is all local.\n                    dst_data_region = proc_region\n\n                # Make resource.\n                # Note that DRAM bandwidth is not split here. We optimistically\n                # assume each layer can use the full DRAM bandwidth at\n                # different time. We adjust this assumption when calculating\n                # the segment timing.\n                rtpl += (self.resource._replace(\n                    proc_region=proc_region,\n                    src_data_region=src_data_region,\n                    dst_data_region=dst_data_region,\n                    no_time_mux=no_time_mux),)\n\n            assert len(rtpl) == len(ltpl)\n            self.alloc += (rtpl,)\n        assert len(self.alloc) == len(self.seg)\n\n        return True\n\n    def _alloc_proc(self, max_util_drop=0.05):\n        '''\n        Allocate processing subregions for the segment.\n\n        Return a list of processing subregions corresponding to the first-level\n        (spatial scheduled) layers in the segment. Return None if allocation\n        failed.\n\n        `max_util_drop` specifies the maximum utilization drop due to mismatch\n        throughput between layers.\n        '''\n\n        # Spatial allocation.\n        proc_region = self.resource.proc_region\n        dim_nodes = proc_region.dim\n        total_nodes = dim_nodes.size()\n\n        # Number of operations of each spatial allocation.\n        ops = [sum(self.network[l].total_ops() for l in ltpl)\n               for ltpl in self.seg]\n\n        # Enforce a common factor among the numbers of nodes allocated to all\n        # vertices in the segment. Such common factor is likely to be the\n        # common height of the vertex node regions.\n        common_factor_list = [cf for cf, _ in util.factorize(dim_nodes.h, 2)]\n\n        for cf in sorted(common_factor_list, reverse=True):\n            # Pick the largest common factor within the utilization constraint.\n\n            # Number of nodes of each vertex should be approximate to the\n            # number of ops of the vertex.\n            nodes_raw = [o * 1. / sum(ops) * total_nodes for o in ops]\n\n            # Round to the common factor multiples.\n            assert total_nodes % cf == 0\n            nodes = [max(1, int(round(nr / cf))) * cf for nr in nodes_raw]\n            # Fix margin.\n            while sum(nodes) != total_nodes:\n                diff = [n - nr for n, nr in zip(nodes, nodes_raw)]\n                if sum(nodes) > total_nodes:\n                    # Decrease the nodes for the vertex with the maximum\n                    # positive difference.\n                    idx, _ = max(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] -= cf\n                else:\n                    # Increase the nodes for the vertex with the minimum\n                    # negative difference.\n                    idx, _ = min(enumerate(diff), key=lambda tpl: tpl[1])\n                    nodes[idx] += cf\n\n            if 0 in nodes:\n                continue\n\n            # Utilization.\n            time = max(o * 1. / n for o, n in zip(ops, nodes))\n            utilization = sum(ops) / time / sum(nodes)\n            assert utilization < 1 + 1e-6\n\n            if utilization >= 1 - max_util_drop:\n                # Found\n                break\n\n        else:\n            # Not found.\n            return None\n\n        # Allocate in the processing region according to the number of nodes.\n        subregions = proc_region.allocate(nodes)\n        assert subregions\n        assert len(subregions) == len(self.seg)\n        if len(subregions) == 1:\n            assert subregions[0] == proc_region\n\n        return subregions\n\n    def _init_sym_cstrs(self):\n        '''\n        Initialize the symbolic scheduling constraints for the layers in the\n        segment, by constructing a nested lists of dicts `cstr_symargs` whose\n        values can be symbolic expressions for the keyword arguments of layers\n        in the segment, and a dict `cstr_symvals` mapping each symbol to its\n        possible numerical values.\n\n        Rules for constraints.\n\n        - Top BAT loop factor.\n\n        With a single layer, there is no constraint on the top BAT loop factor.\n        Otherwise all layers must share the same factor, namely `topbat_shr`.\n\n        - Fmap forwarding and fully buffering.\n\n        Only CONV layers require to fully buffer fmaps. Local-region layers\n        process data in a streaming manner.\n\n        Each CONV layer, and all local-region layers immediately following it\n        within the same spatial scheduling, are made into a group G.\n\n        (initial) if G is both the first spatial and the first temporal\n        scheduling with a CONV layer, it can choose whether to fully buffer\n        ofmaps or not. This is a configuration to explore, namely `fbofm_init`.\n        We decide its value by choosing the one that gives the fewer fully\n        buffered inter-spatial pairs on the critical forwarding path, and the\n        smaller maximum fully buffered data size.\n\n        (within-group) within G, the CONV layer, and all local-region layers,\n        should use the same top OFM factors (IFM factors are automatically\n        determined by OFM factors in local-region layers), unless CONV ofmaps\n        need to be fully buffered, in which case, the CONV layer and the last\n        layer in G fully buffer ofmaps (top OFM factor is 1), and other layers\n        still use the same top OFM factors but can be different than 1.\n\n        (inter-temporal) if G has a source from G' in the same spatial\n        scheduling (which must be immediately before G), G should fully buffer\n        ifmaps, and G' should fully buffer ofmaps.\n\n        (inter-spatial) if G has a source from G' in another spatial scheduling\n        (where the source must be the last temporal scheduling in G' and that\n        spatial scheduling),\n        (a) if G' already fully buffers ofmaps, make G fully buffer ifmaps.\n        (b) otherwise, make G fully buffer ofmaps (do not require G' to fully\n            buffer ifmaps; leave it to other rules, e.g. inter-temporal, to\n            decide); forward data between G' and G, by matching their top O/IFM\n            factors (biasing this case for smaller pipeline filling delay).\n        Notice the destination can be: (1) the leading CONV layer, whose top\n        IFM factor is constrained; (2) a local-region layer, where we constrain\n        the top OFM factors of this group (except otherwise constrained by\n        fully buffering ofmaps).\n        '''\n        # pylint: disable=too-many-branches\n\n        # Symbolic variables mapping to numerical values.\n        symvals = dict()\n\n        # Top BAT loop factor.\n        topbat = symbols('topbat_shr', integer=True)\n        symvals[topbat] = [t for t, _ in util.factorize(self.batch_size, 2)]\n\n        # Whether the initial CONV layer fully buffers ofmaps.\n        fbofm_init = symbols('fbofm_init')\n        symvals[fbofm_init] = [False, True]\n\n        def _layer_topofm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ofmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ofmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nofm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        def _layer_topifm_vals(layer_name):\n            layer = self.network[layer_name]\n            # We require that the total ifmap size takes at least 5% of the\n            # gbuf capacity of a single node, to avoid too fine blocking.\n            tmax = layer.total_ifmap_size(self.batch_size) \\\n                    / (0.05 * self.resource.size_gbuf)\n            vals = [t for t, _ in util.factorize(layer.nifm, 2)\n                    if t <= tmax or t == 1]\n            assert vals\n            return vals\n\n        # Layer constraint kwargs.\n        symargs = [[{'topbat': topbat} for _ in ltpl] for ltpl in self.seg]\n\n        # Candidates for critical forwarding path between spatial scheduling.\n        sp_crit_path_cands = set()\n        sp_crit_path_cands.add((0,))  # init with the first spatial.\n\n        # The last CONV layer index.\n        last_conv = PipelineSegment.SchedIndex(-1, 0)\n\n        # Whether the current group needs to fully buffer ofmap. Delayed apply\n        # to the last layer in the group.\n        curr_fbofm = False\n\n        for sp_idx, ltpl in enumerate(self.seg):\n\n            # Initial topofm, in case of a non-CONV starting layer.\n            curr_topofm = symbols('topofm_{}_s'.format(sp_idx), integer=True)\n            symvals[curr_topofm] = _layer_topofm_vals(ltpl[0])\n\n            for tm_idx, l in enumerate(ltpl):\n\n                layer = self.network[l]\n                curr_sa = symargs[sp_idx][tm_idx]\n\n                # Neighbor source dependency.\n                nsrc_sa = None\n                src_deps = self.src_dict[sp_idx][tm_idx]\n                if any(s is not None for s in src_deps):\n                    assert len(src_deps) == 1\n                    nbr_src = src_deps[0]\n                    assert nbr_src.sp_idx < sp_idx\n                    nsrc_sa = symargs[nbr_src.sp_idx][nbr_src.tm_idx]\n                    assert nsrc_sa  # not empty, used to test nbr src exists.\n                    # Set critical path candidates.\n                    new_cands = set()\n                    for cand in sp_crit_path_cands:\n                        if cand[-1] == nbr_src.sp_idx:\n                            new_cands.add(cand + (sp_idx,))\n                    sp_crit_path_cands |= new_cands\n\n                if isinstance(layer, ConvLayer):\n                    # Conv layer.\n\n                    # The last group may require to fully buffer ofmaps.\n                    # Delayed apply to the immediate previous layer.\n                    if curr_fbofm is not False:\n                        assert last_conv >= (0, 0)\n                        if last_conv.sp_idx == sp_idx:\n                            assert tm_idx > 0\n                            lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        else:\n                            lsrc_sa = symargs[last_conv.sp_idx][-1]\n                        lsrc_sa['fbofm'] = curr_fbofm\n                    # Reset.\n                    curr_fbofm = False\n\n                    # New topofm for a new group.\n                    curr_topofm = symbols('topofm_{}_{}'.format(sp_idx, tm_idx),\n                                          integer=True)\n                    symvals[curr_topofm] = _layer_topofm_vals(l)\n\n                    # Set topofm.\n                    curr_sa['topofm'] = curr_topofm\n\n                    if sp_idx == last_conv.sp_idx:\n                        # Rule inter-temporal.\n                        assert tm_idx > 0\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = True\n                        # Make the last group fully buffer ofmaps.\n                        last_sa = symargs[sp_idx][last_conv.tm_idx]\n                        lsrc_sa = symargs[sp_idx][tm_idx - 1]\n                        last_sa['fbofm'] = True\n                        lsrc_sa['fbofm'] = True\n\n                    elif nsrc_sa:\n                        # Rule inter-spatial.\n                        # We only look at this rule when inter-temporal rule\n                        # does not apply and the ifmaps of this group are not\n                        # yet required to fully buffer.\n                        if not self.with_opt:\n                            # Basic pipelining requires fully buffering all\n                            # pairs of neighbor src/dst.\n                            nsrc_sa['fbofm'] = True\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        # (a): if the source already fully buffers ofmaps.\n                        # Make this group fully buffer ifmaps.\n                        curr_sa['fbifm'] = symeq(nsrc_fbofm, True)\n                        # (b)-(1): otherwise.\n                        # Make this group fully buffer ofmaps.\n                        curr_sa['fbofm'] = symeq(nsrc_fbofm, False)\n                        curr_fbofm = symeq(nsrc_fbofm, False)  # delayed apply.\n                        # Match top OFM/IFM factors.\n                        curr_sa['topifm'] = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_sa.get('topifm', 0), True))\n\n                    elif last_conv < (0, 0):\n                        # The first CONV layer.\n                        # Rule initial.\n                        curr_sa['fbofm'] = fbofm_init\n                        curr_fbofm = fbofm_init\n\n                    last_conv = PipelineSegment.SchedIndex(sp_idx, tm_idx)\n\n                else:\n                    # Non-Conv layer.\n\n                    if nsrc_sa:\n                        # Rule inter-spatial, (b)-(2).\n                        nsrc_fbofm = nsrc_sa.get('fbofm', False)\n                        curr_topofm = sympiecewise(\n                            (nsrc_sa['topofm'], symeq(nsrc_fbofm, False)),\n                            (curr_topofm, True))\n                        # Also backtrace this group.\n                        for bt_idx in range(last_conv.tm_idx, tm_idx):\n                            symargs[sp_idx][bt_idx]['topofm'] = curr_topofm\n\n                    # Rule within-group.\n                    curr_sa['topofm'] = curr_topofm\n\n                # If this layer has no on-chip destinations, cancel the\n                # requirement to fully buffer ofmaps.\n                if all(d is None for d in self.dst_dict[sp_idx][tm_idx]) \\\n                        and tm_idx == len(ltpl) - 1:\n                    curr_sa.pop('fbofm', False)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Get critical forwarding path between spatial scheduling.\n        # The critical path has the longest forwarding chain.\n        sp_crit_path = max(sp_crit_path_cands, key=len)\n\n        # Check maximum fully-buffering size, and decide fbofm_init.\n        opt_val = None\n        opt_key = (float('inf'),) * 2  # (num of fb pairs, max fb size)\n        num_sp_fbs = 0\n        for val in symvals.get(fbofm_init, [False]):\n            subs_symargs = self._subs_symargs(symargs, fbofm_init, val)\n            maxsz = 0\n            numfb = 0\n            for sp_idx, (ltpl, atpl) in enumerate(zip(self.seg, subs_symargs)):\n                ms = max(itertools.chain(\n                    ((self.network[l].total_ofmap_size() if a.get('fbofm')\n                      else 0)\n                     + (self.network[l].total_ifmap_size() if a.get('fbifm')\n                        else 0)\n                     for l, a in zip(ltpl, atpl)),\n                    [0]))  # safe max with default.\n                if ms > self.alloc[sp_idx][0].proc_region.dim.size() \\\n                        * self.alloc[sp_idx][0].size_gbuf:\n                    break\n                maxsz = max(maxsz, ms)\n                if sp_idx in sp_crit_path and atpl[-1].get('fbofm', False):\n                    numfb += 1\n            else:\n                key = (numfb, maxsz)\n                if key < opt_key:\n                    opt_val, opt_key = val, key\n                    num_sp_fbs = numfb\n        if opt_val is None:\n            return False\n        # Use the optimal value.\n        symvals[fbofm_init] = [opt_val]\n        self._simplify_symargs(symargs, symvals)\n\n        # Shared memory source must have the same topifm.\n        for sh_idx_list in self.ifm_fwd_dict.values():\n            assert len(sh_idx_list) > 1\n            fet_sp_idx = sh_idx_list[0].sp_idx\n            sh_symarg_list = [symargs[idx.sp_idx][0] for idx in sh_idx_list]\n\n            # Must have no constraint on ifmaps access from memory.\n            assert all(not sa.get('fbifm', False) and not sa.get('topifm', 0)\n                       for sa in sh_symarg_list)\n\n            # Cannot constrain both topifm and topofm.\n            if any(sa.get('fbofm', False) or sa.get('topofm', 0)\n                   for sa in sh_symarg_list):\n                sh_kwargs = {'fbifm': True}\n            else:\n                topifm = symbols('topifm_{}'.format(fet_sp_idx), integer=True)\n                symvals[topifm] = _layer_topifm_vals(self.seg[fet_sp_idx][0])\n                sh_kwargs = {'topifm': topifm}\n\n            # Set constraints.\n            for sa in sh_symarg_list:\n                sa.update(sh_kwargs)\n\n        # Simplify.\n        self._simplify_symargs(symargs, symvals)\n\n        # Turn constraints into lazily updated rules.\n        self._lazify_topofm_symargs(symargs, symvals)\n        # Cannot simplify any more as update_dict is not sympifi-able.\n\n        # Sort symbol dict.\n        symvals = OrderedDict(sorted(((s, symvals[s]) for s in symvals),\n                                     key=lambda item: str(item[0])))\n\n        if not symvals:\n            # Must add a dummy symbol so iterative substitution can happen.\n            symvals[symbols('_dummy')] = [None]\n\n        self.cstr_symargs = symargs\n        self.cstr_symvals = symvals\n        self.cstr_num_sp_fbs = num_sp_fbs\n        try:\n            self.cstr_topbat_idx = list(symvals.keys()).index(topbat)\n        except ValueError:\n            self.cstr_topbat_idx = None\n\n        return True\n\n    @staticmethod\n    def _simplify_symargs_one_pass(symargs, symvals):\n        '''\n        Simplify symargs and symvals in-place:\n        - If fbi/ofm is False, then remove it.\n        - If fbi/ofm is True, then remove topi/ofm.\n        - If a symbol can take only one value, then substitute it.\n        - If a symbol only occurs once, then remove its constraint.\n\n        Return whether the symargs and symvals are already simplified.\n        '''\n        for a in itertools.chain.from_iterable(symargs):\n            is_fbifm = a.get('fbifm')\n            is_fbofm = a.get('fbofm')\n            # pylint: disable=singleton-comparison\n            # lhs may be symbolic, see\n            # docs.sympy.org/latest/modules/logic.html#sympy.logic.boolalg.BooleanTrue\n            if is_fbifm == True:\n                a.pop('topifm', 0)\n            if is_fbifm == False:\n                a.pop('fbifm', False)\n            if is_fbofm == True:\n                a.pop('topofm', 0)\n            if is_fbofm == False:\n                a.pop('fbofm', False)\n\n        subs_dict = {}\n\n        # Possible values for symbols.\n        subs_dict.update(\n            (s, symvals[s][0]) for s in symvals if len(symvals[s]) == 1)\n\n        # Count the occurrence of symbols in all args (values).\n        symcnts = Counter(\n            s for a in itertools.chain.from_iterable(symargs)\n            for val in a.values() for s in symtuple(val).free_symbols)\n        assert set(symcnts.keys()).issubset(symvals.keys())\n        subs_dict.update((s, None)\n                         for s in set(symvals.keys()) - set(symcnts.keys()))\n        subs_dict.update((s, 0 if str(s).startswith('top') else False)\n                         for s in symcnts if symcnts[s] <= 1)\n\n        # Substitute symbols and remove from symbol dict.\n        for a in itertools.chain.from_iterable(symargs):\n            for k in a:\n                a[k] = symtuple(a[k]).subs(subs_dict)[0]\n        for s in subs_dict:\n            del symvals[s]\n\n        return not subs_dict\n\n    def _simplify_symargs(self, symargs, symvals):\n        ''' Simplify symargs and symvals in-place iteratively. '''\n        while not self._simplify_symargs_one_pass(symargs, symvals):\n            pass\n        used_syms = symtuple(\n            *[symtuple(*a.values())\n              for a in itertools.chain.from_iterable(symargs)]).free_symbols\n        assert set(used_syms) == set(symvals.keys())\n        assert all(val for val in symvals.values())\n\n    @staticmethod\n    def _subs_symargs(symargs, *subs_args):\n        '''\n        Substitute symbols. The additional arguments are passed to subs().\n\n        Return a new substituted copy without modifying the original one.\n        '''\n        # sympify=False is necessary because there may be str in the values.\n        return [[dict((k, symtuple(a[k], sympify=False).subs(*subs_args)[0])\n                      for k in a) for a in atpl] for atpl in symargs]\n\n    class TopOfmUpdateLambda(symbasic):\n        ''' A sympifi-able lambda function to lazily update topofm. '''\n        # pylint: disable=no-init\n        def __new__(cls, *args):\n            return super(PipelineSegment.TopOfmUpdateLambda, cls).__new__(cls)\n        def __call__(self, arg_s, arg_r):\n            setattr(arg_s, 'topofm', arg_r.scheme['to'][0])\n\n    def _lazify_topofm_symargs(self, symargs, symvals):\n        '''\n        Turn qualified topofm constraints into lazily updated rules.\n\n        If a symbol is only used as the topofm constraint by a single CONV\n        layer and some local-region layers, we can turn it into a lazily update\n        rule.\n        '''\n        sym2conv = {}  # symbol --> the only CONV layer using it.\n        sym2lrs = {}   # symbol --> list of local-region layer using it.\n        unqual_syms = set()  # symbols used by two or more CONV layers.\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            layer = self.network[l]\n            if isinstance(layer, ConvLayer):\n                topofm = a.get('topofm', 0)\n                topifm = a.get('topifm', 0)\n                for s in symtuple(topofm, topifm).free_symbols:\n                    if s not in unqual_syms:\n                        if s in sym2conv:\n                            # If a symbol is used in two CONV layers, it cannot\n                            # be lazily updated.\n                            del sym2conv[s]\n                            sym2lrs.pop(s, [])\n                            unqual_syms.add(s)\n                        elif topofm == s:\n                            assert s not in sym2lrs\n                            sym2conv[s] = l\n            else:\n                topofm = a.get('topofm', 0)\n                if topofm in sym2conv:\n                    sym2lrs.setdefault(topofm, []).append(l)\n        assert 0 not in sym2conv and 0 not in sym2lrs\n\n        syms = sym2conv.keys()  # symbols to be lazily updated.\n        lr2conv = {}  # local-region layer to the CONV layer constraining it.\n        for s in syms:\n            for lr in sym2lrs.get(s, []):\n                lr2conv[lr] = sym2conv[s]\n        lconvs = set(lr2conv.values())  # CONV layer whose topofm to be removed.\n\n        for l, a in zip(itertools.chain.from_iterable(self.seg),\n                        itertools.chain.from_iterable(symargs)):\n            if l in lconvs:\n                # Remove CONV topofm.\n                assert sym2conv[a['topofm']] == l\n                del a['topofm']\n            elif l in lr2conv:\n                # Link local-region layer to the CONV layer.\n                lconv = lr2conv[l]\n                assert sym2conv[a['topofm']] == lconv\n                del a['topofm']\n                a['update_dict'] = {\n                    lconv: PipelineSegment.TopOfmUpdateLambda()}\n\n        for s in syms:\n            del symvals[s]\nnn_dataflow/core/option.py\nclass Option(namedtuple('Option', OPTION_LIST)):\n    '''\n    Schedule options.\n    '''\n\n    def __new__(cls, *args, **kwargs):\n\n        if len(args) > len(OPTION_LIST):\n            raise TypeError('Option: can take at most {} arguments ({} given).'\n                            .format(len(OPTION_LIST), len(args)))\n\n        if not set(kwargs).issubset(OPTION_LIST):\n            raise TypeError('Option: got an unexpected keyword argument {}.'\n                            .format(next(k for k in kwargs\n                                         if k not in OPTION_LIST)))\n\n        # Combine args and kwargs.\n        kwdict = kwargs.copy()\n        for k, v in zip(OPTION_LIST, args):\n            if k in kwdict:\n                raise TypeError('Option: got multiple values for '\n                                'keyword argument {}.'\n                                .format(k))\n            kwdict[k] = v\n\n        kwdict.setdefault('sw_gbuf_bypass', (False,) * de.NUM)\n        kwdict.setdefault('sw_solve_loopblocking', False)\n        kwdict.setdefault('hw_access_forwarding', False)\n        kwdict.setdefault('hw_gbuf_sharing', False)\n        kwdict.setdefault('hw_gbuf_save_writeback', False)\n        kwdict.setdefault('partition_hybrid', False)\n        kwdict.setdefault('partition_batch', False)\n        kwdict.setdefault('partition_ifmaps', False)\n        kwdict.setdefault('partition_interlayer', False)\n        kwdict.setdefault('layer_pipeline_time_ovhd', float('inf'))\n        kwdict.setdefault('layer_pipeline_max_degree', float('inf'))\n        kwdict.setdefault('layer_pipeline_opt', True)\n        kwdict.setdefault('opt_goal', 'e')\n        kwdict.setdefault('ntops', 1)\n        kwdict.setdefault('nprocesses', 1)\n        kwdict.setdefault('verbose', False)\n\n        assert set(kwdict) == set(OPTION_LIST)\n\n        ntp = super(Option, cls).__new__(cls, **kwdict)\n\n        if not isinstance(ntp.sw_gbuf_bypass, tuple):\n            raise TypeError('Option: sw_gbuf_bypass must be a tuple')\n        if len(ntp.sw_gbuf_bypass) != de.NUM:\n            raise ValueError('Option: sw_gbuf_bypass must have length {}'\n                             .format(de.NUM))\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_sharing cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.hw_access_forwarding and ntp.hw_gbuf_sharing:\n            raise ValueError('Option: hw_access_forwarding is implied by '\n                             'hw_gbuf_sharing, thus cannot be both enabled.')\n\n        if ntp.sw_solve_loopblocking and ntp.hw_gbuf_save_writeback:\n            raise ValueError('Option: sw_solve_loopblocking and '\n                             'hw_gbuf_save_writeback cannot be simultaneously '\n                             'enabled.')\n\n        if ntp.partition_ifmaps and not ntp.partition_hybrid:\n            raise ValueError('Option: partition_ifmaps requires '\n                             'partition_hybrid to be set.')\n\n        if not isinstance(ntp.layer_pipeline_time_ovhd, (int, float)):\n            raise KeyError('Option: layer_pipeline_time_ovhd must be a '\n                           'number.')\n        if ntp.layer_pipeline_time_ovhd < 0:\n            raise ValueError('Option: layer_pipeline_time_ovhd must be '\n                             'positive.')\n\n        if not isinstance(ntp.layer_pipeline_max_degree, (int, float)):\n            raise KeyError('Option: layer_pipeline_max_degree must be a '\n                           'number.')\n        if ntp.layer_pipeline_max_degree < 0:\n            raise ValueError('Option: layer_pipeline_max_degree must be '\n                             'positive.')\n\n        if ntp.opt_goal not in ['e', 'd', 'ed']:\n            raise ValueError('Option: opt_goal is invalid, must be one of '\n                             '\\'e\\', \\'d\\', and \\'ed\\'.')\n\n        return ntp\n\n    @staticmethod\n    def option_list():\n        ''' List of options. '''\n        return OPTION_LIST\nnn_dataflow/core/layer.py\nclass PoolingLayer(LocalRegionLayer):\n    '''\n    NN pooling layer parameters.\n\n    As a special case of LocalRegionLayer.\n\n    nreg = ntrd = 1\n    '''\n\n    def __init__(self, nofm, sofm, sreg, strd=None):\n        if strd is None:\n            strd = sreg\n        super(PoolingLayer, self).__init__(nofm, sofm, 1, sreg,\n                                           ntrd=1, strd=strd)\n        assert self.nreg == 1\n        assert self.ntrd == 1\n\n    def __repr__(self):\n        return '{}({})'.format(\n            self.__class__.__name__,\n            ', '.join([\n                'nofm={}'.format(repr(self.nofm)),\n                'sofm={}'.format(repr((self.hofm, self.wofm))),\n                'sreg={}'.format(repr((self.hreg, self.wreg))),\n                'strd={}'.format(repr((self.htrd, self.wtrd)))]))\nnn_dataflow/core/phy_dim2.py\nclass PhyDim2(namedtuple('PhyDim2', ['h', 'w'])):\n    '''\n    Denote a physical 2D dimension.\n    '''\n\n    def size(self):\n        ''' Total size. '''\n        return int(reduce(mul, self, 1))\n\n    def hop_dist(self, other):\n        ''' Hop distance between twn coordinate. '''\n        if not isinstance(other, PhyDim2):\n            raise TypeError('PhyDim2: hop_dist only applies on two PhyDim2 '\n                            'instances.')\n        return abs(self.h - other.h) + abs(self.w - other.w)\n\n    def __add__(self, other):\n        ''' Return element-wise `self + other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(add, self, other))\n\n    def __sub__(self, other):\n        ''' Return element-wise `self - other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(sub, self, other))\n\n    def __neg__(self):\n        ''' Return element-wise negative. '''\n        return PhyDim2(*map(neg, self))\n\n    def __mul__(self, other):\n        ''' Return element-wise `self * other`. '''\n        if not isinstance(other, PhyDim2):\n            other = PhyDim2(other, other)\n        return PhyDim2(*map(mul, self, other))\n\n    __rmul__ = __mul__\n", "answers": ["        ilp = InterLayerPipeline(self.net['net1'], self.batch_size,"], "pred": "    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code: ''' \n    ''' Code:", "length": 9020, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "2aae57de553ed5867969af9a6dd8f670c380c829b2abf753"}
{"prompt": "Please complete the code given below. \nbloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\ntests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\nimport logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n\n\n\n\n\noperations = [\n    (operator.ne, \"!=\"),\n    (operator.eq, \"==\"),\n    (operator.lt, \"<\"),\n    (operator.le, \"<=\"),\n    (operator.gt, \">\"),\n    (operator.ge, \">=\")\n]\n\n\n@pytest.fixture\ndef unpack_kwargs(engine):\n    return {\n        \"attrs\": {\"name\": {\"S\": \"numberoverzero\"}},\n        \"expected\": {User.name, User.joined},\n        \"model\": User,\n        \"engine\": engine,\n        \"context\": {\"engine\": engine, \"extra\": \"foo\"},\n    }\n\n\n# BASE MODEL =============================================================================================== BASE MODEL\n\n\ndef test_default_model_init():\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    user = User(id=\"user_id\", email=\"user@domain.com\")\n    assert user.id == \"user_id\"\n    assert user.email == \"user@domain.com\"\n    assert not hasattr(user, \"name\")\n\n\ndef test_load_default_init(engine):\n    \"\"\"The default model loader uses cls.__new__(cls) method\"\"\"\n    init_called = False\n\nNext line of code:\n", "input": "import logging\nimport operator\nimport pytest\nfrom bloop.conditions import ConditionRenderer\nfrom bloop.exceptions import InvalidModel, InvalidStream\nfrom bloop.models import (\n    BaseModel,\n    Column,\n    GlobalSecondaryIndex,\n    IMeta,\n    Index,\n    LocalSecondaryIndex,\n    bind_column,\n    bind_index,\n    model_created,\n    object_modified,\n    unbind,\n    unpack_from_dynamodb,\n)\nfrom bloop.types import (\n    UUID,\n    Boolean,\n    DateTime,\n    Integer,\n    String,\n    Timestamp,\n    Type,\n)\nfrom ..helpers.models import User, VectorModel\n\n\n\n\n\noperations = [\n    (operator.ne, \"!=\"),\n    (operator.eq, \"==\"),\n    (operator.lt, \"<\"),\n    (operator.le, \"<=\"),\n    (operator.gt, \">\"),\n    (operator.ge, \">=\")\n]\n\n\n@pytest.fixture\ndef unpack_kwargs(engine):\n    return {\n        \"attrs\": {\"name\": {\"S\": \"numberoverzero\"}},\n        \"expected\": {User.name, User.joined},\n        \"model\": User,\n        \"engine\": engine,\n        \"context\": {\"engine\": engine, \"extra\": \"foo\"},\n    }\n\n\n# BASE MODEL =============================================================================================== BASE MODEL\n\n\ndef test_default_model_init():\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    user = User(id=\"user_id\", email=\"user@domain.com\")\n    assert user.id == \"user_id\"\n    assert user.email == \"user@domain.com\"\n    assert not hasattr(user, \"name\")\n\n\ndef test_load_default_init(engine):\n    \"\"\"The default model loader uses cls.__new__(cls) method\"\"\"\n    init_called = False\n\n", "context": "bloop/types.py\nclass Boolean(Type):\n    python_type = bool\n    backing_type = BOOLEAN\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return bool(value)\nbloop/models.py\nclass IMeta:\nclass BaseModel:\n    class Meta(IMeta):\nclass Index:\nclass GlobalSecondaryIndex(Index):\nclass LocalSecondaryIndex(Index):\nclass Column(ComparisonMixin):\n    class UNBOUND:\n        class Meta(IMeta):\n    def __init__(self, **attrs):\n    def __init_subclass__(cls: type, **kwargs):\n    def __repr__(self):\n    def __init__(self, *, projection, hash_key=None, range_key=None, dynamo_name=None, **kwargs):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\n    def hash_key(self):\n    def range_key(self):\n    def keys(self):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __init__(\n            self, *, projection,\n            hash_key, range_key=None,\n            read_units=None, write_units=None,\n            dynamo_name=None, **kwargs):\n    def __init__(self, *, projection, range_key, dynamo_name=None, strict=True, **kwargs):\n    def hash_key(self):\n    def read_units(self):\n    def read_units(self, value):\n    def write_units(self):\n    def write_units(self, value):\n    def __init__(self, typedef, hash_key=False, range_key=False, dynamo_name=None, default=missing):\n    def __copy__(self):\n    def __set_name__(self, owner, name):\n    def __set__(self, obj, value):\n    def __get__(self, obj, type=None):\n    def __delete__(self, obj):\n    def __repr__(self):\n    def name(self):\n    def dynamo_name(self):\ndef subclassof(obj, classinfo):\ndef instanceof(obj, classinfo):\ndef loaded_columns(obj: BaseModel):\ndef unpack_from_dynamodb(*, attrs, expected, model=None, obj=None, engine=None, context=None, **kwargs):\ndef validate_projection(projection):\ndef validate_stream(meta):\ndef validate_encryption(meta):\ndef validate_backups(meta):\ndef validate_billing(meta):\ndef validate_ttl(meta):\ndef unbound_repr(obj):\ndef setdefault(obj, field, default):\ndef ensure_hash(cls) -> None:\ndef initialize_meta(cls: type):\ndef bind_column(model, name, column, force=False, recursive=False, copy=False) -> Column:\ndef bind_index(model, name, index, force=False, recursive=True, copy=False) -> Index:\ndef refresh_index(meta, index) -> None:\ndef unbind(meta, name=None, dynamo_name=None) -> None:\nbloop/types.py\nclass Integer(Number):\n    \"\"\"Truncates values when loading or dumping.\n\n    For example, ``3.14`` in DynamoDB is loaded as ``3``. If a value is ``7.5``\n    locally, it's stored in DynamoDB as ``7``.\n    \"\"\"\n    python_type = int\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        number = super().dynamo_load(value, context=context, **kwargs)\n        return int(number)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = int(value)\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/exceptions.py\nclass InvalidModel(BloopException, ValueError):\n    \"\"\"This is not a valid Model.\"\"\"\nbloop/types.py\nclass DateTime(String):\n    \"\"\"Always stored in DynamoDB using the :data:`~bloop.types.FIXED_ISO8601_FORMAT` format.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(DateTime)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import DateTime  # becomes:\n            from bloop.ext.pendulum import DateTime\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        dt = datetime.datetime.strptime(value, FIXED_ISO8601_FORMAT)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return dt.replace(tzinfo=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        dt = value.astimezone(tz=datetime.timezone.utc)\n        return dt.strftime(FIXED_ISO8601_FORMAT)\nbloop/exceptions.py\nclass InvalidStream(BloopException, ValueError):\n    \"\"\"This is not a valid stream definition.\"\"\"\nbloop/types.py\nclass UUID(String):\n    python_type = uuid.UUID\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return uuid.UUID(value)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        return str(value)\ntests/helpers/models.py\nclass VectorModel(BaseModel):\n    name = Column(String, hash_key=True)\n    list_str = Column(List(String))\n    set_str = Column(Set(String))\n    map_nested = Column(Map(**{\n        \"bytes\": Binary,\n        \"str\": String,\n        \"map\": Map(**{\n            \"int\": Integer,\n            \"str\": String\n        })\n    }))\n    some_int = Column(Integer)\n    some_bytes = Column(Binary)\nbloop/types.py\nclass Type:\n    \"\"\"Abstract base type.\"\"\"\n\n    python_type = None\n    backing_type = None\n\n    def supports_operation(self, operation: str) -> bool:\n        \"\"\"\n        Used to ensure a conditional operation is supported by this type.\n\n        By default, uses a hardcoded table of operations that maps to each backing DynamoDB type.\n\n        You can override this method to implement your own conditional operators, or to dynamically\n        adjust which operations your type supports.\n        \"\"\"\n        return operation in OPERATION_SUPPORT_BY_TYPE[self.backing_type]\n\n    def __init__(self):\n        if not hasattr(self, \"inner_typedef\"):\n            self.inner_typedef = self\n        super().__init__()\n\n    def __getitem__(self, key):\n        raise RuntimeError(f\"{self!r} does not support document paths\")\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        \"\"\"Converts a local value into a DynamoDB value.\n\n        For example, to store a string enum as an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors.index(value.lower())\n        \"\"\"\n        raise NotImplementedError\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        \"\"\"Converts a DynamoDB value into a local value.\n\n        For example, to load a string enum from an integer:\n\n        .. code-block:: python\n\n            def dynamo_dump(self, value, *, context, **kwargs):\n                colors = [\"red\", \"blue\", \"green\"]\n                return colors[value]\n        \"\"\"\n        raise NotImplementedError\n\n    def _dump(self, value, **kwargs):\n        \"\"\"Entry point for serializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_dump`.\n\n        This wraps the return value of :func:`~bloop.types.Type.dynamo_dump` in DynamoDB's wire format.\n        For example, serializing a string enum to an int:\n\n        .. code-block:: python\n\n            value = \"green\"\n            # dynamo_dump(\"green\") = 2\n            _dump(value) == {\"N\": 2}\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_dump`.  This can happen when dumping eg. a sparse\n        :class:`~.bloop.types.Map`, or a missing (not set) value.\n        \"\"\"\n        wrapped = actions.wrap(value)\n        value = self.dynamo_dump(wrapped.value, **kwargs)\n        if value is None:\n            return actions.wrap(None)\n        else:\n            value = {self.backing_type: value}\n            return wrapped.type.new_action(value)\n\n    def _load(self, value, **kwargs):\n        \"\"\"Entry point for deserializing values.  Most custom types should use :func:`~bloop.types.Type.dynamo_load`.\n\n        This unpacks DynamoDB's wire format and calls :func:`~bloop.types.Type.dynamo_load` on the inner value.\n        For example, deserializing an int to a string enum:\n\n        .. code-block:: python\n\n            value = {\"N\": 2}\n            # dynamo_load(2) = \"green\"\n            _load(value) == \"green\"\n\n        If a complex type calls this function with ``None``, it will forward ``None`` to\n        :func:`~bloop.types.Type.dynamo_load`.  This can happen when loading eg. a sparse :class:`~bloop.types.Map`.\n        \"\"\"\n        if value is not None:\n            value = next(iter(value.values()))\n        return self.dynamo_load(value, **kwargs)\n\n    def __repr__(self):\n        # Render class python types by name\n        python_type = self.python_type\n        if isinstance(python_type, type):\n            python_type = python_type.__name__\n\n        return \"<{}[{}:{}]>\".format(\n            self.__class__.__name__,\n            self.backing_type, python_type\n        )\ntests/helpers/models.py\nclass User(BaseModel):\n    id = Column(String, hash_key=True)\n    age = Column(Integer)\n    name = Column(String)\n    email = Column(String)\n    joined = Column(DateTime, dynamo_name=\"j\")\n    by_email = GlobalSecondaryIndex(hash_key=\"email\", projection=\"all\")\nbloop/types.py\nclass Timestamp(Integer):\n    \"\"\"Stores the unix (epoch) time in seconds.  Milliseconds are truncated to 0 on load and save.\n\n    Naive datetimes (``tzinfo is None``) are not supported, and trying to use one will raise ``ValueError``.\n\n    .. code-block:: python\n\n        from datetime import datetime, timedelta, timezone\n\n        class Model(Base):\n            id = Column(Integer, hash_key=True)\n            date = Column(Timestamp)\n        engine.bind()\n\n        obj = Model(id=1, date=datetime.now(timezone.utc))\n        engine.save(obj)\n\n        one_day_ago = datetime.now(timezone.utc) - timedelta(days=1)\n\n        query = engine.query(\n            Model,\n            key=Model.id==1,\n            filter=Model.date >= one_day_ago)\n\n        query.first().date\n\n    .. note::\n\n        To use common datetime libraries such as `arrow`_, `delorean`_, or `pendulum`_,\n        see :ref:`DateTime and Timestamp Extensions <user-extensions-datetime>` in the user guide.  These\n        are drop-in replacements and support non-utc timezones:\n\n        .. code-block:: python\n\n            from bloop import Timestamp  # becomes:\n            from bloop.ext.pendulum import Timestamp\n\n    .. _arrow: http://crsmithdev.com/arrow\n    .. _delorean: https://delorean.readthedocs.io/en/latest/\n    .. _pendulum: https://pendulum.eustace.io\n    \"\"\"\n    python_type = datetime.datetime\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        value = super().dynamo_load(value, context=context, **kwargs)\n        # we assume all stored values are utc, so we simply force timezone to utc\n        # without changing the day/time values\n        return datetime.datetime.fromtimestamp(value, tz=datetime.timezone.utc)\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if value is None:\n            return None\n        if value.tzinfo is None:\n            raise ValueError(\n                \"naive datetime instances are not supported.  You can set a timezone with either \"\n                \"your_dt.replace(tzinfo=) or your_dt.astimezone(tz=).  WARNING: calling astimezone on a naive \"\n                \"datetime will assume the naive datetime is in the system's timezone, even though \"\n                \"datetime.utcnow() creates a naive object!  You almost certainly don't want to do that.\"\n            )\n        value = value.timestamp()\n        return super().dynamo_dump(value, context=context, **kwargs)\nbloop/conditions.py\nclass ConditionRenderer:\n    # noinspection PyUnresolvedReferences\n    \"\"\"Renders collections of :class:`~bloop.conditions.BaseCondition` into DynamoDB's wire format for expressions,\n    including:\n\n    * ``\"ConditionExpression\"`` -- used in conditional operations\n    * ``\"FilterExpression\"`` -- used in queries and scans to ignore results that don't match the filter\n    * ``\"KeyConditionExpressions\"`` -- used to describe a query's hash (and range) key(s)\n    * ``\"ProjectionExpression\"`` -- used to include a subset of possible columns in the results of a query or scan\n    * ``\"UpdateExpression\"`` -- used to save objects\n\n    Normally, you will only need to call :func:`~bloop.conditions.ConditionRenderer.render` to handle any combination\n    of conditions.  You can also call each individual ``render_*`` function to control how multiple conditions of\n    each type are applied.\n\n    You can collect the rendered condition at any time through :attr:`~bloop.conditions.ConditionRenderer.rendered`.\n\n    .. code-block:: python\n\n        >>> renderer.render(obj=user, atomic=True)\n        >>> renderer.output\n        {'ConditionExpression': '((#n0 = :v1) AND (attribute_not_exists(#n2)) AND (#n4 = :v5))',\n         'ExpressionAttributeNames': {'#n0': 'age', '#n2': 'email', '#n4': 'id'},\n         'ExpressionAttributeValues': {':v1': {'N': '3'}, ':v5': {'S': 'some-user-id'}}}\n\n\n    :param engine: Used to dump values in conditions into the appropriate wire format.\n    :type engine: :class:`~bloop.engine.Engine`\n    \"\"\"\n    def __init__(self, engine):\n        self.refs = ReferenceTracker(engine)\n        self.engine = engine\n        self.expressions = {}\n\n    def render(self, obj=None, condition=None, update=False, filter=None, projection=None, key=None):\n        \"\"\"Main entry point for rendering multiple expressions.  All parameters are optional, except obj when\n        atomic or update are True.\n\n        :param obj: *(Optional)* An object to render an atomic condition or update expression for.  Required if\n            update or atomic are true.  Default is False.\n        :param condition: *(Optional)* Rendered as a \"ConditionExpression\" for a conditional operation.\n            If atomic is True, the two are rendered in an AND condition.  Default is None.\n        :type condition: :class:`~bloop.conditions.BaseCondition`\n        :param bool update: *(Optional)*  True if an \"UpdateExpression\" should be rendered for ``obj``.\n            Default is False.\n        :param filter: *(Optional)* A filter condition for a query or scan, rendered as a \"FilterExpression\".\n            Default is None.\n        :type filter: :class:`~bloop.conditions.BaseCondition`\n        :param projection: *(Optional)* A set of Columns to include in a query or scan, rendered as a\n            \"ProjectionExpression\".  Default is None.\n        :type projection: set :class:`~bloop.models.Column`\n        :param key: *(Optional)* A key condition for queries, rendered as a \"KeyConditionExpression\".  Default is None.\n        :type key: :class:`~bloop.conditions.BaseCondition`\n        \"\"\"\n        if update and not obj:\n            raise InvalidCondition(\"An object is required to render updates.\")\n\n        if filter:\n            self.filter_expression(filter)\n\n        if projection:\n            self.projection_expression(projection)\n\n        if key:\n            self.key_expression(key)\n\n        # Condition requires a bit of work, because either one can be empty/false\n        if condition:\n            self.condition_expression(condition)\n\n        if update:\n            self.update_expression(obj)\n\n    def condition_expression(self, condition):\n        self.expressions[\"ConditionExpression\"] = condition.render(self)\n\n    def filter_expression(self, condition):\n        self.expressions[\"FilterExpression\"] = condition.render(self)\n\n    def key_expression(self, condition):\n        self.expressions[\"KeyConditionExpression\"] = condition.render(self)\n\n    def projection_expression(self, columns):\n        included = set()\n        ref_names = []\n        for column in columns:\n            if column in included:\n                continue\n            included.add(column)\n            ref = self.refs.any_ref(column=column)\n            ref_names.append(ref.name)\n        self.expressions[\"ProjectionExpression\"] = \", \".join(ref_names)\n\n    def update_expression(self, obj):\n        updates = {\n            ActionType.Add: [],\n            ActionType.Delete: [],\n            ActionType.Remove: [],\n            ActionType.Set: [],\n        }\n        for column in sorted(\n                # Don't include key columns in an UpdateExpression\n                filter(lambda c: c not in obj.Meta.keys, global_tracking[obj]),\n                key=lambda c: c.dynamo_name):\n            name_ref = self.refs.any_ref(column=column)\n            value_ref = self.refs.any_ref(column=column, value=getattr(obj, column.name, None))\n            update_type = value_ref.action.type\n            # Can't set to an empty value, force to a Remove\n            if is_empty(value_ref) or update_type is ActionType.Remove:\n                self.refs.pop_refs(value_ref)\n                update_type = ActionType.Remove\n                value_ref = None\n            updates[update_type].append((name_ref, value_ref))\n\n        expressions = []\n        for update_type, refs in updates.items():\n            if not refs:\n                continue\n            k = update_type.wire_key.upper()\n            r = update_type.render\n            expressions.append(f\"{k} \" + \", \".join(r(*ref) for ref in refs))\n        if expressions:\n            self.expressions[\"UpdateExpression\"] = \" \".join(e.strip() for e in expressions)\n\n    @property\n    def output(self):\n        \"\"\"The wire format for all conditions that have been rendered.\n        A new :class:`~bloop.conditions.ConditionRenderer` should be used for each operation.\"\"\"\n        expressions = {k: v for (k, v) in self.expressions.items() if v is not None}\n        if self.refs.attr_names:\n            expressions[\"ExpressionAttributeNames\"] = self.refs.attr_names\n        if self.refs.attr_values:\n            expressions[\"ExpressionAttributeValues\"] = self.refs.attr_values\n        return expressions\nbloop/types.py\nclass String(Type):\n    python_type = str\n    backing_type = STRING\n\n    def dynamo_load(self, value, *, context, **kwargs):\n        if not value:\n            return \"\"\n        return value\n\n    def dynamo_dump(self, value, *, context, **kwargs):\n        if not value:\n            return None\n        return value\n", "answers": ["    class Blob(BaseModel):"], "pred": "    \"\"\"Missing attributes are set to `None`\"\"\"\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    \"\"\"Missing attributes are set to `None`\"\"\"\n    \"\"\"Missing attributes are set to `None", "length": 2045, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "8857338affe2d9fe32dc189b478b4aa891b3905618953f5b"}
{"prompt": "Please complete the code given below. \nelementpath/xpath_nodes.py\nclass TypedAttribute(XPathNode):\n    \"\"\"\n    A class for processing typed attribute nodes.\n\n    :param attribute: the origin AttributeNode instance.\n    :param xsd_type: the reference XSD type.\n    :param value: the types value.\n    \"\"\"\n    def __init__(self, attribute: AttributeNode, xsd_type: Any, value: Any) -> None:\n        self.attribute = attribute\n        self.xsd_type = xsd_type\n        self.value = value\n        self.parent = attribute.parent\n\n    @property\n    def kind(self) -> str:\n        return 'attribute'\n\n    @property\n    def name(self) -> str:\n        return self.attribute.name\n\n    def as_item(self) -> Tuple[str, Any]:\n        return self.attribute.name, self.value\n\n    def __repr__(self) -> str:\n        return '%s(name=%r)' % (self.__class__.__name__, self.attribute.name)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.attribute == other.attribute and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.attribute, self.value))\nelementpath/xpath_nodes.py\nclass XPathNode:\n\n    name: Any = None\n    value: Any = None\n    parent: Optional[ElementNode] = None\n\n    @property\n    def kind(self) -> str:\n        raise NotImplementedError()\nelementpath/xpath_token.py\nclass XPathToken(Token[XPathTokenType]):\n    \"\"\"Base class for XPath tokens.\"\"\"\n    parser: XPathParserType\n    xsd_types: Optional[Dict[str, Union[XsdTypeProtocol, List[XsdTypeProtocol]]]]\n    namespace: Optional[str]\n    occurrence: Optional[str]\n\n    xsd_types = None  # for XPath 2.0+ XML Schema types labeling\n    namespace = None  # for namespace binding of names and wildcards\n    occurrence = None  # occurrence indicator for item types\n\n    def __call__(self, context: Optional[XPathContext] = None) -> Any:\n        return self.evaluate(context)\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        \"\"\"\n        Evaluate default method for XPath tokens.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        return [x for x in self.select(context)]\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        \"\"\"\n        Select operator that generates XPath results.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        item = self.evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\n\n    def __str__(self) -> str:\n        symbol, label = self.symbol, self.label\n        if symbol == '$':\n            return '$%s variable reference' % (self[0].value if self._items else '')\n        elif symbol == ',':\n            return 'comma operator' if self.parser.version > '1.0' else 'comma symbol'\n        elif symbol == 'function':\n            return str(label)\n        elif label.endswith('function') or label in ('axis', 'sequence type', 'kind test'):\n            return '%r %s' % (symbol, str(label))\n        return super(XPathToken, self).__str__()\n\n    @property\n    def source(self) -> str:\n        symbol = self.symbol\n        if self.label == 'axis':\n            # For XPath 2.0 'attribute' multi-role token ('kind test', 'axis')\n            return '%s::%s' % (symbol, self[0].source)\n        elif symbol == ':':\n            if self.occurrence:\n                return str(self.value) + self.occurrence\n            else:\n                return str(self.value)\n        elif symbol == '(':\n            return '()' if not self else '(%s)' % self[0].source\n        elif symbol == '[':\n            return '%s[%s]' % (self[0].source, self[1].source)\n        elif symbol == ',':\n            return '%s, %s' % (self[0].source, self[1].source)\n        elif symbol == '$':\n            return '$%s' % self[0].source\n        elif symbol == '{':\n            return '{%s}%s' % (self[0].value, self[1].value)\n        elif symbol == 'if':\n            return 'if (%s) then %s else %s' % (self[0].source, self[1].source, self[2].source)\n        elif symbol == 'instance':\n            return '%s instance of %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'treat':\n            return '%s treat as %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'for':\n            return 'for %s return %s' % (\n                ', '.join('%s in %s' % (self[k].source, self[k + 1].source)\n                          for k in range(0, len(self) - 1, 2)),\n                self[-1].source\n            )\n        return super(XPathToken, self).source\n\n    @property\n    def child_axis(self) -> bool:\n        \"\"\"Is `True` if the token apply child axis for default, `False` otherwise.\"\"\"\n        if self.symbol not in _CHILD_AXIS_TOKENS:\n            return False\n        elif self.symbol == '[':\n            return self._items[0].child_axis\n        elif self.symbol != ':':\n            return True\n        return not self._items[1].label.endswith('function')\n\n    ###\n    # Tokens tree analysis methods\n    def iter_leaf_elements(self) -> Iterator[str]:\n        \"\"\"\n        Iterates through the leaf elements of the token tree if there are any,\n        returning QNames in prefixed format. A leaf element is an element\n        positioned at last path step. Does not consider kind tests and wildcards.\n        \"\"\"\n        if self.symbol in ('(name)', ':'):\n            yield cast(str, self.value)\n        elif self.symbol in ('//', '/'):\n            if self._items[-1].symbol in _LEAF_ELEMENTS_TOKENS:\n                yield from self._items[-1].iter_leaf_elements()\n\n        elif self.symbol in ('[',):\n            yield from self._items[0].iter_leaf_elements()\n        else:\n            for tk in self._items:\n                yield from tk.iter_leaf_elements()\n\n    ###\n    # Dynamic context methods\n    def get_argument(self, context: Optional[XPathContext],\n                     index: int = 0,\n                     required: bool = False,\n                     default_to_context: bool = False,\n                     default: Optional[AtomicValueType] = None,\n                     cls: Optional[Type[Any]] = None,\n                     promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Get the argument value of a function of constructor token. A zero length sequence is\n        converted to a `None` value. If the function has no argument returns the context's\n        item if the dynamic context is not `None`.\n\n        :param context: the dynamic context.\n        :param index: an index for select the argument to be got, the first for default.\n        :param required: if set to `True` missing or empty sequence arguments are not allowed.\n        :param default_to_context: if set to `True` then the item of the dynamic context is \\\n        returned when the argument is missing.\n        :param default: the default value returned in case the argument is an empty sequence. \\\n        If not provided returns `None`.\n        :param cls: if a type is provided performs a type checking on item.\n        :param promote: a class or a tuple of classes that are promoted to `cls` class.\n        \"\"\"\n        item: Union[None, ElementProtocol, DocumentProtocol, XPathNode, AnyAtomicType]\n\n        try:\n            selector = self._items[index].select\n        except IndexError:\n            if default_to_context:\n                if context is None:\n                    raise self.missing_context() from None\n                item = context.item if context.item is not None else context.root\n            elif required:\n                msg = \"missing %s argument\" % ordinal(index + 1)\n                raise self.error('XPST0017', msg) from None\n            else:\n                return default\n        else:\n            item = None\n            for k, result in enumerate(selector(copy(context))):\n                if k == 0:\n                    item = result\n                elif self.parser.compatibility_mode:\n                    break\n                elif isinstance(context, XPathSchemaContext):\n                    # Multiple schema nodes are ignored but do not raise. The target\n                    # of schema context selection is XSD type association and multiple\n                    # node coherency is already checked at schema level.\n                    break\n                else:\n                    raise self.wrong_context_type(\n                        \"a sequence of more than one item is not allowed as argument\"\n                    )\n            else:\n                if item is None:\n                    if not required:\n                        return default\n                    ord_arg = ordinal(index + 1)\n                    msg = \"A not empty sequence required for {} argument\"\n                    raise self.error('XPTY0004', msg.format(ord_arg))\n\n        if cls is not None:\n            return self.validated_value(item, cls, promote)\n        return item\n\n    def validated_value(self, item: Any, cls: Type[Any],\n                        promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Type promotion checking (see \"function conversion rules\" in XPath 2.0 language definition)\n        \"\"\"\n        if isinstance(item, (cls, ValueToken)):\n            return item\n        elif promote and isinstance(item, promote):\n            return cls(item)\n\n        if self.parser.compatibility_mode:\n            if issubclass(cls, str):\n                return self.string_value(item)\n            elif issubclass(cls, float) or issubclass(float, cls):\n                return self.number_value(item)\n\n        if issubclass(cls, XPathToken) or self.parser.version == '1.0':\n            code = 'XPTY0004'\n        else:\n            value = self.data_value(item)\n            if isinstance(value, cls):\n                return value\n            elif isinstance(value, AnyURI) and issubclass(cls, str):\n                return cls(value)\n            elif isinstance(value, UntypedAtomic):\n                try:\n                    return cls(value)\n                except (TypeError, ValueError):\n                    pass\n\n            code = 'FOTY0012' if value is None else 'XPTY0004'\n\n        message = \"item type is {!r} instead of {!r}\"\n        raise self.error(code, message.format(type(item), cls))\n\n    def select_data_values(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[Optional[AtomicValueType]]:\n        \"\"\"\n        Yields data value of selected items.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            yield self.data_value(item)\n\n    def atomization(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[AtomicValueType]:\n        \"\"\"\n        Helper method for value atomization of a sequence.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-atomization\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            value = self.data_value(item)\n            if value is None:\n                msg = \"argument node {!r} does not have a typed value\"\n                raise self.error('FOTY0012', msg.format(item))\n            else:\n                yield value\n\n    def get_atomized_operand(self, context: Optional[XPathContext] = None) \\\n            -> Optional[AtomicValueType]:\n        \"\"\"\n        Get the atomized value for an XPath operator.\n\n        :param context: the XPath dynamic context.\n        :return: the atomized value of a single length sequence or `None` if the sequence is empty.\n        \"\"\"\n        selector = iter(self.atomization(context))\n        try:\n            value = next(selector)\n        except StopIteration:\n            return None\n        else:\n            item = getattr(context, 'item', None)\n\n            try:\n                next(selector)\n            except StopIteration:\n                if isinstance(value, UntypedAtomic):\n                    value = str(value)\n\n                if not isinstance(context, XPathSchemaContext) and \\\n                        item is not None and \\\n                        self.xsd_types and \\\n                        isinstance(value, str):\n\n                    xsd_type = self.get_xsd_type(item)\n                    if xsd_type is None or xsd_type.name in _XSD_SPECIAL_TYPES:\n                        pass\n                    else:\n                        try:\n                            value = xsd_type.decode(value)\n                        except (TypeError, ValueError):\n                            msg = \"Type {!r} is not appropriate for the context\"\n                            raise self.wrong_context_type(msg.format(type(value)))\n\n                return value\n            else:\n                msg = \"atomized operand is a sequence of length greater than one\"\n                raise self.wrong_context_type(msg)\n\n    def iter_comparison_data(self, context: XPathContext) -> Iterator[OperandsType]:\n        \"\"\"\n        Generates comparison data couples for the general comparison of sequences.\n        Different sequences maybe generated with an XPath 2.0 parser, depending on\n        compatibility mode setting.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-general-comparisons\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if self.parser.compatibility_mode:\n            operand1 = [x for x in self._items[0].select(copy(context))]\n            operand2 = [x for x in self._items[1].select(copy(context))]\n\n            # Boolean comparison if one of the results is a single boolean value (1.)\n            try:\n                if isinstance(operand1[0], bool):\n                    if len(operand1) == 1:\n                        yield operand1[0], self.boolean_value(operand2)\n                        return\n                if isinstance(operand2[0], bool):\n                    if len(operand2) == 1:\n                        yield self.boolean_value(operand1), operand2[0]\n                        return\n            except IndexError:\n                return\n\n            # Converts to float for lesser-greater operators (3.)\n            if self.symbol in ('<', '<=', '>', '>='):\n                yield from product(\n                    map(float, map(self.data_value, operand1)),  # type: ignore[arg-type]\n                    map(float, map(self.data_value, operand2)),  # type: ignore[arg-type]\n                )\n                return\n            elif self.parser.version == '1.0':\n                yield from product(map(self.data_value, operand1), map(self.data_value, operand2))\n                return\n\n        for values in product(map(self.data_value, self._items[0].select(copy(context))),\n                              map(self.data_value, self._items[1].select(copy(context)))):\n            if any(isinstance(x, bool) for x in values):\n                if any(isinstance(x, (str, Integer)) for x in values):\n                    msg = \"cannot compare {!r} and {!r}\"\n                    raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, Integer) for x in values) and \\\n                    any(isinstance(x, str) for x in values):\n                msg = \"cannot compare {!r} and {!r}\"\n                raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, float) for x in values):\n                if isinstance(values[0], decimal.Decimal):\n                    yield float(values[0]), values[1]\n                    continue\n                elif isinstance(values[1], decimal.Decimal):\n                    yield values[0], float(values[1])\n                    continue\n\n            yield values\n\n    def select_results(self, context: Optional[XPathContext]) -> Iterator[SelectResultType]:\n        \"\"\"\n        Generates formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if context is not None:\n            self.parser.check_variables(context.variables)\n\n        for result in self.select(context):\n            if not isinstance(result, XPathNode):\n                yield result\n            elif isinstance(result, (TextNode, AttributeNode)):\n                yield result.value\n            elif isinstance(result, TypedElement):\n                yield result.elem\n            elif isinstance(result, TypedAttribute):\n                if is_schema_node(result.attribute.value):\n                    yield result.attribute.value\n                else:\n                    yield result.value\n            elif isinstance(result, NamespaceNode):  # pragma: no cover\n                if self.parser.compatibility_mode:\n                    yield result.prefix, result.uri\n                else:\n                    yield result.uri\n\n    def get_results(self, context: XPathContext) \\\n            -> Union[List[Any], AtomicValueType]:\n        \"\"\"\n        Returns formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        :return: a list or a simple datatype when the result is a single simple type \\\n        generated by a literal or function token.\n        \"\"\"\n        results = [x for x in self.select_results(context)]\n        if len(results) == 1:\n            res = results[0]\n            if isinstance(res, (bool, int, float, Decimal)):\n                return res\n            elif is_etree_element(res) or is_document_node(res) or is_schema_node(res):\n                return results\n            elif self.label in ('function', 'literal'):\n                return cast(AtomicValueType, res)\n            else:\n                return results\n        else:\n            return results\n\n    def get_operands(self, context: XPathContext, cls: Optional[Type[Any]] = None) \\\n            -> OperandsType:\n        \"\"\"\n        Returns the operands for a binary operator. Float arguments are converted\n        to decimal if the other argument is a `Decimal` instance.\n\n        :param context: the XPath dynamic context.\n        :param cls: if a type is provided performs a type checking on item.\n        :return: a couple of values representing the operands. If any operand \\\n        is not available returns a `(None, None)` couple.\n        \"\"\"\n        op1 = self.get_argument(context, cls=cls)\n        if op1 is None:\n            return None, None\n        elif is_element_node(op1):\n            op1 = self._items[0].data_value(op1)\n\n        op2 = self.get_argument(context, index=1, cls=cls)\n        if op2 is None:\n            return None, None\n        elif is_element_node(op2):\n            op2 = self._items[1].data_value(op2)\n\n        if isinstance(op1, AbstractDateTime) and isinstance(op2, AbstractDateTime):\n            if context is not None and context.timezone is not None:\n                if op1.tzinfo is None:\n                    op1.tzinfo = context.timezone\n                if op2.tzinfo is None:\n                    op2.tzinfo = context.timezone\n        else:\n            if isinstance(op1, UntypedAtomic):\n                op1 = self.cast_to_double(op1.value)\n                if isinstance(op2, Decimal):\n                    return op1, float(op2)\n            if isinstance(op2, UntypedAtomic):\n                op2 = self.cast_to_double(op2.value)\n                if isinstance(op1, Decimal):\n                    return float(op1), op2\n\n        if isinstance(op1, float):\n            if isinstance(op2, Duration):\n                return Decimal(op1), op2\n            if isinstance(op2, Decimal):\n                return op1, type(op1)(op2)\n        if isinstance(op2, float):\n            if isinstance(op1, Duration):\n                return op1, Decimal(op2)\n            if isinstance(op1, Decimal):\n                return type(op2)(op1), op2\n\n        return op1, op2\n\n    def get_absolute_uri(self, uri: str,\n                         base_uri: Optional[str] = None,\n                         as_string: bool = True) -> Union[str, AnyURI]:\n        \"\"\"\n        Obtains an absolute URI from the argument and the static context.\n\n        :param uri: a string representing an URI.\n        :param base_uri: an alternative base URI, otherwise the base_uri \\\n        of the static context is used.\n        :param as_string: if `True` then returns the URI as a string, otherwise \\\n        returns the URI as xs:anyURI instance.\n        :returns: the argument if it's an absolute URI. Otherwise returns the URI\n        obtained by the join o the base_uri of the static context with the\n        argument. Returns the argument if the base_uri is `None'.\n        \"\"\"\n        if not base_uri:\n            base_uri = self.parser.base_uri\n\n        uri_parts: urllib.parse.ParseResult = urllib.parse.urlparse(uri)\n        if uri_parts.scheme or uri_parts.netloc or base_uri is None:\n            return uri if as_string else AnyURI(uri)\n\n        base_uri_parts: urllib.parse.SplitResult = urllib.parse.urlsplit(base_uri)\n        if base_uri_parts.fragment or not base_uri_parts.scheme and \\\n                not base_uri_parts.netloc and not base_uri_parts.path.startswith('/'):\n            raise self.error('FORG0002', '{!r} is not suitable as base URI'.format(base_uri))\n\n        if uri_parts.path.startswith('/') and base_uri_parts.path not in ('', '/'):\n            return uri if as_string else AnyURI(uri)\n\n        if as_string:\n            return urllib.parse.urljoin(base_uri, uri)\n        return AnyURI(urllib.parse.urljoin(base_uri, uri))\n\n    def get_namespace(self, prefix: str) -> str:\n        \"\"\"\n        Resolves a prefix to a namespace raising an error (FONS0004) if the\n        prefix is not found in the namespace map.\n        \"\"\"\n        try:\n            return self.parser.namespaces[prefix]\n        except KeyError as err:\n            msg = 'no namespace found for prefix %r' % str(err)\n            raise self.error('FONS0004', msg) from None\n\n    def bind_namespace(self, namespace: str) -> None:\n        \"\"\"\n        Bind a token with a namespace. The token has to be a name, a name wildcard,\n        a function or a constructor, otherwise a syntax error is raised. Functions\n        and constructors must be limited to its namespaces.\n        \"\"\"\n        if self.symbol in ('(name)', '*'):\n            pass\n        elif namespace == self.parser.function_namespace:\n            if self.label != 'function':\n                msg = \"a name, a wildcard or a function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'function'\n        elif namespace == XSD_NAMESPACE:\n            if self.label != 'constructor function':\n                msg = \"a name, a wildcard or a constructor function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'constructor function'\n        elif namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            if self.label != 'math function':\n                msg = \"a name, a wildcard or a math function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'math function'\n        else:\n            msg = \"a name, a wildcard or a function expected\"\n            raise self.wrong_syntax(msg, code='XPST0017')\n\n        self.namespace = namespace\n\n    def adjust_datetime(self, context: XPathContext, cls: Type[DatetimeValueType]) \\\n            -> Optional[Union[DatetimeValueType, DayTimeDuration]]:\n        \"\"\"\n        XSD datetime adjust function helper.\n\n        :param context: the XPath dynamic context.\n        :param cls: the XSD datetime subclass to use.\n        :return: an empty list if there is only one argument that is the empty sequence \\\n        or the adjusted XSD datetime instance.\n        \"\"\"\n        timezone: Optional[Any]\n        item: Optional[DatetimeValueType]\n        _item: Union[DatetimeValueType, DayTimeDuration]\n\n        if len(self) == 1:\n            item = self.get_argument(context, cls=cls)\n            if item is None:\n                return None\n            timezone = getattr(context, 'timezone', None)\n        else:\n            item = self.get_argument(context, cls=cls)\n            timezone = self.get_argument(context, 1, cls=DayTimeDuration)\n\n            if timezone is not None:\n                try:\n                    timezone = Timezone.fromduration(timezone)\n                except ValueError as err:\n                    raise self.error('FODT0003', str(err)) from None\n            if item is None:\n                return None\n\n        _item = item\n        _tzinfo = _item.tzinfo\n        try:\n            if _tzinfo is not None and timezone is not None:\n                if isinstance(_item, DateTime10):\n                    _item += timezone.offset\n                elif not isinstance(item, Date10):\n                    _item += timezone.offset - _tzinfo.offset\n                elif timezone.offset < _tzinfo.offset:\n                    _item -= timezone.offset - _tzinfo.offset\n                    _item -= DayTimeDuration.fromstring('P1D')\n        except OverflowError as err:\n            raise self.error('FODT0001', str(err)) from None\n\n        if not isinstance(_item, DayTimeDuration):\n            _item.tzinfo = timezone\n        return _item\n\n    @contextlib.contextmanager\n    def use_locale(self, collation: str) -> Iterator[None]:\n        \"\"\"A context manager for use a locale setting for string comparison in a code block.\"\"\"\n        loc = locale.getlocale(locale.LC_COLLATE)\n        if collation == UNICODE_CODEPOINT_COLLATION or collation == 'collation/codepoint':\n            collation = 'en_US.UTF-8'\n        elif collation is None:\n            raise self.error('XPTY0004', 'collation cannot be an empty sequence')\n\n        try:\n            locale.setlocale(locale.LC_COLLATE, collation)\n        except locale.Error:\n            raise self.error('FOCH0002', 'Unsupported collation %r' % collation) from None\n        else:\n            yield\n        finally:\n            locale.setlocale(locale.LC_COLLATE, loc)\n\n    ###\n    # XSD types related methods\n    def select_xsd_nodes(self, schema_context: XPathSchemaContext, name: str) \\\n            -> Iterator[Union[None, TypedElement, TypedAttribute, XMLSchemaProtocol]]:\n        \"\"\"\n        Selector for XSD nodes (elements, attributes and schemas). If there is\n        a match with an attribute or an element the node's type is added to\n        matching types of the token. For each matching elements or attributes\n        yields tuple nodes containing the node, its type and a compatible value\n        for doing static evaluation. For matching schemas yields the original\n        instance.\n\n        :param schema_context: an XPathSchemaContext instance.\n        :param name: a QName in extended format.\n        \"\"\"\n        xsd_node: Any\n        for xsd_node in schema_context.iter_children_or_self():\n            if xsd_node is None:\n                if name == XSD_SCHEMA == schema_context.root.tag:\n                    yield None\n                continue  # pragma: no cover\n\n            try:\n                if isinstance(xsd_node, AttributeNode):\n                    if isinstance(xsd_node.value, str):\n                        if xsd_node.name != name:\n                            continue\n                        xsd_node = schema_context.root.maps.attributes.get(name)\n                        if xsd_node is None:\n                            continue\n                    elif xsd_node.value.is_matching(name):\n                        if xsd_node.name is None:\n                            # node is an XSD attribute wildcard\n                            xsd_node = schema_context.root.maps.attributes.get(name)\n                            if xsd_node is None:\n                                continue\n                    else:\n                        continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedAttribute(xsd_node, xsd_type, value)\n\n                elif name == XSD_SCHEMA == xsd_node.tag:\n                    # The element is a schema\n                    yield xsd_node\n\n                elif xsd_node.is_matching(name, self.parser.default_namespace):\n                    if xsd_node.name is None:\n                        # node is an XSD element wildcard\n                        xsd_node = schema_context.root.maps.elements.get(name)\n                        if xsd_node is None:\n                            continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedElement(xsd_node, xsd_type, value)\n\n            except AttributeError:\n                pass\n\n    def add_xsd_type(self, item: Any) -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Adds an XSD type association from an item. The association is\n        added using the item's name and type.\n        \"\"\"\n        if isinstance(item, AttributeNode):\n            item = item.value\n        elif isinstance(item, TypedAttribute):\n            item = item.attribute.value\n        elif isinstance(item, TypedElement):\n            item = item.elem\n\n        if not is_schema_node(item):\n            return None\n\n        name: str = item.name\n        xsd_type: XsdTypeProtocol = item.type\n\n        if self.xsd_types is None:\n            self.xsd_types = {name: xsd_type}\n        else:\n            obj = self.xsd_types.get(name)\n            if obj is None:\n                self.xsd_types[name] = xsd_type\n            elif not isinstance(obj, list):\n                if obj is not xsd_type:\n                    self.xsd_types[name] = [obj, xsd_type]\n            elif xsd_type not in obj:\n                obj.append(xsd_type)\n\n        return xsd_type\n\n    def get_xsd_type(self, item: Union[str, PrincipalNodeType]) \\\n            -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Returns the XSD type associated with an item. Match by item's name\n        and XSD validity. Returns `None` if no XSD type is matching.\n\n        :param item: a string or an AttributeNode or an element.\n        \"\"\"\n        if not self.xsd_types or isinstance(self.xsd_types, AbstractSchemaProxy):\n            return None\n        elif isinstance(item, str):\n            xsd_type = self.xsd_types.get(item)\n        elif isinstance(item, AttributeNode):\n            xsd_type = self.xsd_types.get(item.name)\n        elif isinstance(item, (TypedAttribute, TypedElement)):\n            return cast(XsdTypeProtocol, item.xsd_type)\n        else:\n            xsd_type = self.xsd_types.get(item.tag)\n\n        x: XsdTypeProtocol\n        if not xsd_type:\n            return None\n        elif not isinstance(xsd_type, list):\n            return xsd_type\n        elif isinstance(item, AttributeNode):\n            for x in xsd_type:\n                if x.is_valid(item.value):\n                    return x\n        elif is_etree_element(item):\n            for x in xsd_type:\n                if x.is_simple():\n                    if x.is_valid(item.text):  # type: ignore[union-attr]\n                        return x\n                elif x.is_valid(item):\n                    return x\n\n        return xsd_type[0]\n\n    def get_typed_node(self, item: PrincipalNodeType) -> PrincipalNodeType:\n        \"\"\"\n        Returns a typed node if the item is matching an XSD type.\n\n        Ref:\n          https://www.w3.org/TR/xpath20/#id-processing-model\n          https://www.w3.org/TR/xpath20/#id-static-analysis\n          https://www.w3.org/TR/xquery-semantics/\n\n        :param item: an untyped attribute or element.\n        :return: a typed AttributeNode/ElementNode if the argument is matching \\\n        any associated XSD type.\n        \"\"\"\n        if isinstance(item, (TypedAttribute, TypedElement)):\n            return item\n\n        xsd_type = self.get_xsd_type(item)\n        if not xsd_type:\n            return item\n        elif xsd_type.name in _XSD_SPECIAL_TYPES:\n            if isinstance(item, AttributeNode):\n                if not isinstance(item.value, str):\n                    return TypedAttribute(item, xsd_type, UntypedAtomic(''))\n                return TypedAttribute(item, xsd_type, UntypedAtomic(item.value))\n            return TypedElement(item, xsd_type, UntypedAtomic(item.text or ''))\n\n        elif isinstance(item, AttributeNode):\n            pass\n        elif xsd_type.has_mixed_content():\n            value = UntypedAtomic(item.text or '')\n            return TypedElement(item, xsd_type, value)\n        elif xsd_type.is_element_only():\n            return TypedElement(item, xsd_type, None)\n        elif xsd_type.is_empty():\n            return TypedElement(item, xsd_type, None)\n        elif item.get(XSI_NIL) and getattr(xsd_type.parent, 'nillable', None):\n            return TypedElement(item, xsd_type, None)\n\n        if self.parser.xsd_version == '1.0':\n            atomic_types = xsd10_atomic_types\n        else:\n            atomic_types = xsd11_atomic_types\n\n        try:\n            builder: Any = atomic_types[xsd_type.name]\n        except KeyError:\n            if self.parser.schema is None:\n                builder = UntypedAtomic\n            else:\n                try:\n                    primitive_type = self.parser.schema.get_primitive_type(xsd_type)\n                    builder = atomic_types[primitive_type.name]\n                except KeyError:\n                    builder = UntypedAtomic\n                else:\n                    if isinstance(builder, (AbstractDateTime, Duration)):\n                        builder = builder.fromstring\n                    elif issubclass(builder, QName):\n                        builder = self.cast_to_qname\n        else:\n            if issubclass(builder, (AbstractDateTime, Duration)):\n                builder = builder.fromstring\n            elif issubclass(builder, QName):\n                builder = self.cast_to_qname\n\n        if isinstance(item, AttributeNode):\n            if xsd_type.is_valid(item.value):\n                return TypedAttribute(item, xsd_type, builder(item.value))\n        elif item.text is not None:\n            if xsd_type.is_valid(item.text):\n                return TypedElement(item, xsd_type, builder(item.text))\n        elif item.get(XSI_NIL) in ('1', 'true'):\n            return TypedElement(item, atomic_types[XSD_ANY_ATOMIC_TYPE], '')\n\n        msg = \"Type {!r} does not match sequence type of {!r}\"\n        raise self.wrong_sequence_type(msg.format(xsd_type, item)) from None\n\n    def cast_to_qname(self, qname: str) -> QName:\n        \"\"\"Cast a prefixed qname string to a QName object.\"\"\"\n        try:\n            if ':' not in qname:\n                return QName(self.parser.namespaces.get(''), qname.strip())\n            pfx, _ = qname.strip().split(':')\n            return QName(self.parser.namespaces[pfx], qname)\n        except ValueError:\n            msg = 'invalid value {!r} for an xs:QName'.format(qname.strip())\n            raise self.error('FORG0001', msg)\n        except KeyError as err:\n            raise self.error('FONS0004', 'no namespace found for prefix {}'.format(err))\n\n    def cast_to_double(self, value: Union[SupportsFloat, str]) -> float:\n        \"\"\"Cast a value to xs:double.\"\"\"\n        try:\n            if self.parser.xsd_version == '1.0':\n                return cast(float, DoubleProxy10(value))\n            return cast(float, DoubleProxy(value))\n        except ValueError as err:\n            raise self.error('FORG0001', str(err))  # str or UntypedAtomic\n\n    def cast_to_primitive_type(self, obj: Any, type_name: str) -> Any:\n        if obj is None or not type_name.startswith('xs:') or type_name.count(':') != 1:\n            return obj\n\n        values = obj if isinstance(obj, list) else [obj]\n        if not values:\n            return obj\n\n        if type_name[-1] in '+*?':\n            type_name = type_name[:-1]\n\n        result = []\n        for v in values:\n            if self.parser.is_instance(v, XSD_DECIMAL):\n                if type_name == 'xs:double':\n                    result.append(float(v))\n                    continue\n                elif type_name == 'xs:float':\n                    if self.parser.xsd_version == '1.0':\n                        result.append(Float10(v))\n                    else:\n                        result.append(Float(v))\n                    continue\n\n            result.append(v)\n\n        if isinstance(obj, list) or len(result) > 1:\n            return result\n        return result[0]\n\n    ###\n    # XPath data accessors base functions\n    def boolean_value(self, obj: Any) -> bool:\n        \"\"\"\n        The effective boolean value, as computed by fn:boolean().\n        \"\"\"\n        if isinstance(obj, list):\n            if not obj:\n                return False\n            elif is_xpath_node(obj[0]):\n                return True\n            elif len(obj) > 1:\n                message = \"effective boolean value is not defined for a sequence \" \\\n                          \"of two or more items not starting with an XPath node.\"\n                raise self.error('FORG0006', message)\n            else:\n                obj = obj[0]\n\n        if isinstance(obj, (int, str, UntypedAtomic, AnyURI)):  # Include bool\n            return bool(obj)\n        elif isinstance(obj, (float, Decimal)):\n            return False if math.isnan(obj) else bool(obj)\n        elif obj is None:\n            return False\n        elif is_xpath_node(obj):\n            return True\n        else:\n            message = \"effective boolean value is not defined for {!r}.\".format(type(obj))\n            raise self.error('FORG0006', message)\n\n    def data_value(self, obj: Any) -> Optional[AtomicValueType]:\n        \"\"\"\n        The typed value, as computed by fn:data() on each item.\n        Returns an instance of UntypedAtomic for untyped data.\n\n        https://www.w3.org/TR/xpath20/#dt-typed-value\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TextNode):\n                return UntypedAtomic(obj.value)\n            elif isinstance(obj, AttributeNode) and isinstance(obj.value, str):\n                return UntypedAtomic(obj.value)\n            return cast(Optional[AtomicValueType], obj.value)  # a typed node or a NamespaceNode\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0013', f\"{obj.label!r} has no typed value\")\n\n        elif is_schema_node(obj):\n            return self.parser.get_atomic_value(obj.type)\n\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return UntypedAtomic(''.join(etree_iter_strings(obj)))\n            else:\n                return None\n        elif is_document_node(obj):\n            value = ''.join(etree_iter_strings(obj.getroot()))\n            return UntypedAtomic(value)\n        else:\n            return cast(AtomicValueType, obj)\n\n    def string_value(self, obj: Any) -> str:\n        \"\"\"\n        The string value, as computed by fn:string().\n        \"\"\"\n        if obj is None:\n            return ''\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TypedElement):\n                if obj.value is None:\n                    return ''.join(etree_iter_strings(obj))\n                return str(obj.value)\n            elif isinstance(obj, (AttributeNode, TypedAttribute)):\n                return str(obj.value)\n            else:\n                return cast(str, obj.value)  # TextNode or NamespaceNode\n        elif is_schema_node(obj):\n            return str(self.parser.get_atomic_value(obj.type))\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return ''.join(etree_iter_strings(obj))\n        elif is_document_node(obj):\n            return ''.join(etree_iter_strings(obj.getroot()))\n        elif isinstance(obj, bool):\n            return 'true' if obj else 'false'\n        elif isinstance(obj, Decimal):\n            value = format(obj, 'f')\n            if '.' in value:\n                return value.rstrip('0').rstrip('.')\n            return value\n\n        elif isinstance(obj, float):\n            if math.isnan(obj):\n                return 'NaN'\n            elif math.isinf(obj):\n                return str(obj).upper()\n\n            value = str(obj)\n            if '.' in value:\n                value = value.rstrip('0').rstrip('.')\n            if '+' in value:\n                value = value.replace('+', '')\n            if 'e' in value:\n                return value.upper()\n            return value\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0014', f\"{obj.label!r} has no string value\")\n\n        return str(obj)\n\n    def number_value(self, obj: Any) -> float:\n        \"\"\"\n        The numeric value, as computed by fn:number() on each item. Returns a float value.\n        \"\"\"\n        try:\n            return float(self.string_value(obj) if is_xpath_node(obj) else obj)\n        except (TypeError, ValueError):\n            return float('nan')\n\n    ###\n    # Error handling helpers\n    def error_code(self, code: str) -> str:\n        \"\"\"Returns a prefixed error code.\"\"\"\n        if self.parser.namespaces.get('err') == XQT_ERRORS_NAMESPACE:\n            return 'err:%s' % code\n\n        for pfx, uri in self.parser.namespaces.items():\n            if uri == XQT_ERRORS_NAMESPACE:\n                return '%s:%s' % (pfx, code) if pfx else code\n\n        return code  # returns an unprefixed code (without prefix the namespace is not checked)\n\n    def error(self, code: Union[str, QName],\n              message_or_error: Union[None, str, Exception] = None) -> ElementPathError:\n        \"\"\"\n        Returns an XPath error instance related with a code. An XPath/XQuery/XSLT\n        error code is an alphanumeric token starting with four uppercase letters\n        and ending with four digits.\n\n        :param code: the error code as QName or string.\n        :param message_or_error: an optional custom message or an exception.\n        \"\"\"\n        namespace: Optional[str]\n\n        if isinstance(code, QName):\n            namespace = code.uri\n            code = code.local_name\n        elif ':' not in code:\n            namespace = None\n        else:\n            try:\n                prefix, code = code.split(':')\n            except ValueError:\n                raise ElementPathValueError(\n                    message='%r is not a prefixed name' % code,\n                    code=self.error_code('XPTY0004'),\n                    token=self,\n                )\n            else:\n                namespace = self.parser.namespaces.get(prefix)\n\n        if namespace and namespace != XQT_ERRORS_NAMESPACE:\n            raise ElementPathValueError(\n                message='%r namespace is required' % XQT_ERRORS_NAMESPACE,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        try:\n            error_class, default_message = XPATH_ERROR_CODES[code]\n        except KeyError:\n            raise ElementPathValueError(\n                message='unknown XPath error code %r' % code,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        if message_or_error is None:\n            message = default_message\n        elif isinstance(message_or_error, str):\n            message = message_or_error\n        elif isinstance(message_or_error, ElementPathError):\n            message = message_or_error.message\n        else:\n            message = str(message_or_error)\n\n        return error_class(message, code=self.error_code(code), token=self)\n\n    # Shortcuts for XPath errors, only the wrong_syntax\n    def expected(self, *symbols: str,\n                 message: Optional[str] = None,\n                 code: str = 'XPST0003') -> None:\n        if symbols and self.symbol not in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def unexpected(self, *symbols: str,\n                   message: Optional[str] = None,\n                   code: str = 'XPST0003') -> None:\n        if not symbols or self.symbol in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def wrong_syntax(self, message: Optional[str] = None,  # type: ignore[override]\n                     code: str = 'XPST0003') -> ElementPathError:\n        if self.label == 'function':\n            code = 'XPST0017'\n\n        if message:\n            return self.error(code, message)\n\n        error = super(XPathToken, self).wrong_syntax(message)\n        return self.error(code, str(error))\n\n    def wrong_value(self, message: Optional[str] = None) -> ElementPathValueError:\n        return cast(ElementPathValueError, self.error('FOCA0002', message))\n\n    def wrong_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('FORG0006', message))\n\n    def missing_context(self, message: Optional[str] = None) -> MissingContextError:\n        return cast(MissingContextError, self.error('XPDY0002', message))\n\n    def wrong_context_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPTY0004', message))\n\n    def missing_name(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0008', message))\n\n    def missing_axis(self, message: Optional[str] = None) \\\n            -> Union[ElementPathNameError, ElementPathSyntaxError]:\n        if self.parser.compatibility_mode:\n            return cast(ElementPathNameError, self.error('XPST0010', message))\n        return cast(ElementPathSyntaxError, self.error('XPST0003', message))\n\n    def wrong_nargs(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPST0017', message))\n\n    def wrong_sequence_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPDY0050', message))\n\n    def unknown_atomic_type(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0051', message))\nelementpath/namespaces.py\nXSD_NAMESPACE = \"http://www.w3.org/2001/XMLSchema\"\nelementpath/xpath_token.py\nclass ValueToken(XPathToken):\n    \"\"\"\n    A dummy token for encapsulating a value.\n    \"\"\"\n    symbol = '(value)'\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return self.value\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        if isinstance(self.value, list):\n            yield from self.value\n        elif self.value is not None:\n            yield self.value\nelementpath/xpath30/xpath30_parser.py\nclass XPath30Parser(XPath2Parser):\n    \"\"\"\n    XPath 3.0 expression parser class. Accepts all XPath 2.0 options as keyword\n    arguments, but the *strict* option is ignored because XPath 3.0+ has braced\n    URI literals and the expanded name syntax is not compatible.\n\n    :param args: the same positional arguments of class :class:`XPath2Parser`.\n    :param decimal_formats: a mapping with statically known decimal formats.\n    :param kwargs: the same keyword arguments of class :class:`XPath2Parser`.\n    \"\"\"\n    version = '3.0'\n\n    SYMBOLS = XPath2Parser.SYMBOLS | {\n        'Q{',  # see BracedURILiteral rule\n        '||',  # concat operator\n        '!',   # Simple map operator\n\n        # Math functions (trigonometric and exponential)\n        'pi', 'exp', 'exp10', 'log', 'log10', 'pow', 'sqrt',\n        'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'atan2',\n\n        # Formatting functions\n        'format-integer', 'format-number', 'format-dateTime',\n        'format-date', 'format-time',\n\n        # String functions that use regular expressions\n        'analyze-string',\n\n        # Functions and operators on nodes\n        'path', 'has-children', 'innermost', 'outermost',\n\n        # Functions and operators on sequences\n        'head', 'tail', 'generate-id', 'uri-collection',\n        'unparsed-text', 'unparsed-text-lines', 'unparsed-text-available',\n        'environment-variable', 'available-environment-variables',\n\n        # Parsing and serializing\n        'parse-xml', 'parse-xml-fragment', 'serialize',\n\n        # Higher-order functions\n        'function-lookup', 'function-name', 'function-arity', '#', '?',\n        'for-each', 'filter', 'fold-left', 'fold-right', 'for-each-pair',\n\n        # Expressions and node type functions\n        'function', 'let', ':=', 'namespace-node',\n\n        # XSD list-types constructor functions\n        'ENTITIES', 'IDREFS', 'NMTOKENS',\n    }\n\n    DEFAULT_NAMESPACES = {\n        'math': XPATH_MATH_FUNCTIONS_NAMESPACE, **XPath2Parser.DEFAULT_NAMESPACES\n    }\n    PATH_STEP_SYMBOLS = {\n        '(integer)', '(string)', '(float)', '(decimal)', '(name)',\n        '*', '@', '..', '.', '(', '{', 'Q{', '$',\n    }\n\n    decimal_formats: DecimalFormatsType = {\n        None: {\n            'decimal-separator': '.',\n            'grouping-separator': ',',\n            'exponent-separator': 'e',\n            'infinity': 'Infinity',\n            'minus-sign': '-',\n            'NaN': 'NaN',\n            'percent': '%',\n            'per-mille': '\u2030',\n            'zero-digit': '0',\n            'digit': '#',\n            'pattern-separator': ';',\n        }\n    }\n\n    # https://www.w3.org/TR/xpath-30/#id-reserved-fn-names\n    RESERVED_FUNCTION_NAMES = {\n        'attribute', 'comment', 'document-node', 'element', 'empty-sequence',\n        'function', 'if', 'item', 'namespace-node', 'node', 'processing-instruction',\n        'schema-attribute', 'schema-element', 'switch', 'text', 'typeswitch',\n    }\n\n    function_signatures = XPath2Parser.function_signatures.copy()\n\n    def __init__(self, *args: Any, decimal_formats: Optional[DecimalFormatsType] = None,\n                 **kwargs: Any) -> None:\n        kwargs.pop('strict', None)\n        super(XPath30Parser, self).__init__(*args, **kwargs)\n\n        if decimal_formats is not None:\n            self.decimal_formats = deepcopy(self.decimal_formats)\n\n            for k, v in decimal_formats.items():\n                if k is not None:\n                    self.decimal_formats[k] = self.decimal_formats[None].copy()\n                    self.decimal_formats[k].update(v)\n\n            if None in decimal_formats:\n                self.decimal_formats[None].update(decimal_formats[None])\nelementpath/xpath_nodes.py\nclass TypedElement(XPathNode):\n    \"\"\"\n    A class for processing typed element nodes.\n\n    :param elem: the linked element. Can be an Element, or an XSD element \\\n    when XPath is applied on a schema.\n    :param xsd_type: the reference XSD type.\n    :param value: the decoded value. Can be `None` for empty or element-only elements.\"\n    \"\"\"\n    def __init__(self, elem: ElementProtocol, xsd_type: Any, value: Any) -> None:\n        self.elem = elem\n        self.xsd_type = xsd_type\n        self.value = value\n\n    @property\n    def kind(self) -> str:\n        return 'element'\n\n    @property\n    def name(self) -> str:\n        return self.elem.tag\n\n    @property\n    def tag(self) -> str:\n        return self.elem.tag\n\n    def __repr__(self) -> str:\n        return '%s(tag=%r)' % (self.__class__.__name__, self.elem.tag)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.elem is other.elem and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.elem, self.value))\nelementpath/xpath_context.py\nclass XPathSchemaContext(XPathContext):\n    \"\"\"\n    The XPath dynamic context base class for schema bounded parsers. Use this class\n    as dynamic context for schema instances in order to perform a schema-based type\n    checking during the static analysis phase. Don't use this as dynamic context on\n    XML instances.\n    \"\"\"\n    iter_children_or_self: Callable[..., Iterator[Union[XsdElementProtocol, XMLSchemaProtocol]]]\n    root: XMLSchemaProtocol\nelementpath/datatypes/qname.py\nclass QName(AbstractQName):\n    name = 'QName'\nelementpath/namespaces.py\nXPATH_FUNCTIONS_NAMESPACE = \"http://www.w3.org/2005/xpath-functions\"\nelementpath/xpath_token.py\nclass XPathFunction(XPathToken):\n    \"\"\"\n    A token for processing XPath functions.\n    \"\"\"\n    _name: Optional[QName] = None\n    pattern = r'(?<!\\$)\\b[^\\d\\W][\\w.\\-\\xb7\\u0300-\\u036F\\u203F\\u2040]*' \\\n              r'(?=\\s*(?:\\(\\:.*\\:\\))?\\s*\\((?!\\:))'\n\n    sequence_types: Tuple[str, ...] = ()\n    \"Sequence types of arguments and of the return value of the function.\"\n\n    nargs: NargsType = None\n    \"Number of arguments: a single value or a couple with None that means unbounded.\"\n\n    body: Optional[XPathToken] = None\n    \"Body of anonymous inline function.\"\n\n    variables: Optional[Dict[str, Any]] = None\n    \"Optional variables linked by let and for expressions.\"\n\n    def __init__(self, parser: 'XPath1Parser', nargs: Optional[int] = None) -> None:\n        super().__init__(parser)\n        if isinstance(nargs, int) and nargs != self.nargs:\n            if nargs < 0:\n                raise self.error('XPST0017', 'number of arguments must be non negative')\n            elif self.nargs is None:\n                self.nargs = nargs\n            elif isinstance(self.nargs, int):\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            elif self.nargs[0] > nargs or self.nargs[1] is not None and self.nargs[1] < nargs:\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            else:\n                self.nargs = nargs\n\n    def __call__(self, context: Optional[XPathContext] = None,\n                 argument_list: Optional[Union[\n                     XPathToken,\n                     List[Union[XPathToken, AtomicValueType]],\n                     Tuple[Union[XPathToken, AtomicValueType], ...]\n                 ]] = None) -> Any:\n\n        args: List[Any] = []\n        if isinstance(argument_list, (list, tuple)):\n            args.extend(argument_list)\n        elif isinstance(argument_list, XPathToken):\n            tk = argument_list\n            while True:\n                if tk.symbol == ',':\n                    args.append(tk[1].evaluate(context))\n                    tk = tk[0]\n                else:\n                    args.append(tk.evaluate(context))\n                    break\n            args.reverse()\n\n        # Check provided argument with arity\n        if self.nargs is None or self.nargs == len(args):\n            pass\n        elif isinstance(self.nargs, tuple):\n            if len(args) < self.nargs[0]:\n                raise self.error('XPTY0004', \"missing required arguments\")\n            elif self.nargs[1] is not None and len(args) > self.nargs[1]:\n                raise self.error('XPTY0004', \"too many arguments\")\n        elif self.nargs > len(args):\n            raise self.error('XPTY0004', \"missing required arguments\")\n        else:\n            raise self.error('XPTY0004', \"too many arguments\")\n\n        context = copy(context)\n        if self.variables is not None and context is not None:\n            context.variables.update(self.variables)\n\n        if self.symbol == 'function':\n            if context is None:\n                raise self.missing_context()\n            elif not args and self:\n                if context.item is None:\n                    if is_document_node(context.root):\n                        context.item = cast(DocumentProtocol, context.root).getroot()\n                    else:\n                        context.item = context.root\n\n                args.append(context.item)\n\n            partial_function = False\n            if self.variables is None:\n                self.variables = {}\n\n            for variable, sequence_type, value in zip(self, self.sequence_types, args):\n                varname = cast(str, variable[0].value)\n\n                if isinstance(value, XPathToken) and value.symbol == '?':\n                    partial_function = True\n                    continue\n                elif isinstance(value, XPathFunction) and sequence_type.startswith('function('):\n                    if not value.match_function_test(sequence_type, as_argument=True):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                elif not self.parser.match_sequence_type(value, sequence_type):\n                    value = self.cast_to_primitive_type(value, sequence_type)\n                    if not self.parser.match_sequence_type(value, sequence_type):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                context.variables[varname] = self.variables[varname] = value\n\n            if partial_function:\n                return self\n\n        elif self.label == 'partial function':\n            for value, tk in zip(args, filter(lambda x: x.symbol == '?', self)):\n                if isinstance(value, XPathToken):\n                    tk.value = value.evaluate(context)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    tk.value = value\n        else:\n            self.clear()\n            for value in args:\n                if isinstance(value, XPathToken):\n                    self.append(value)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    self.append(ValueToken(self.parser, value=value))\n\n            if any(tk.symbol == '?' for tk in self._items):\n                self._partial_function()\n                return self\n\n        if isinstance(self.label, MultiLabel):\n            # Disambiguate multi-label tokens\n            if self.namespace == XSD_NAMESPACE and \\\n                    'constructor function' in self.label.values:\n                self.label = 'constructor function'\n            else:\n                for label in self.label.values:\n                    if label.endswith('function'):\n                        self.label = label\n                        break\n\n        if self.label == 'partial function':\n            result = self._partial_evaluate(context)\n        elif self.body is not None:\n            assert self.label == 'inline function'\n            result = self.body.evaluate(context)\n        else:\n            result = self.evaluate(context)\n\n        if isinstance(result, XPathToken) and result.symbol == '?':\n            pass\n        elif not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n            result = self.cast_to_primitive_type(result, self.sequence_types[-1])\n            if not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n                msg = \"{!r} does not match sequence type {}\"\n                self.parser.match_sequence_type(result, self.sequence_types[-1])\n                raise self.error('XPTY0004', msg.format(result, self.sequence_types[-1]))\n\n        return result\n\n    @property\n    def source(self) -> str:\n        if self.label == 'function test':\n            if len(self.sequence_types) == 1 and self.sequence_types[0] == '*':\n                return 'function(*)'\n            else:\n                return 'function(%s) as %s' % (\n                    ', '.join(self.sequence_types[:-1]), self.sequence_types[-1]\n                )\n        elif self.label in ('sequence type', 'kind test', ''):\n            return '%s(%s)%s' % (\n                self.symbol, ', '.join(item.source for item in self), self.occurrence or ''\n            )\n        return '%s(%s)' % (self.symbol, ', '.join(item.source for item in self))\n\n    @property\n    def name(self) -> Optional[QName]:\n        if self._name is not None:\n            return self._name\n        elif self.symbol == 'function':\n            return None\n        elif self.label == 'partial function':\n            return None\n        elif not self.namespace or self.namespace == XPATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_FUNCTIONS_NAMESPACE, 'fn:%s' % self.symbol)\n        elif self.namespace == XSD_NAMESPACE:\n            self._name = QName(XSD_NAMESPACE, 'xs:%s' % self.symbol)\n        elif self.namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_MATH_FUNCTIONS_NAMESPACE, 'math:%s' % self.symbol)\n        else:\n            for pfx, uri in self.parser.namespaces.items():\n                if uri == self.namespace:\n                    self._name = QName(uri, f'{pfx}:{self.symbol}')\n                    break\n            else:\n                self._name = QName(self.namespace, self.symbol)\n\n        return self._name\n\n    @property\n    def arity(self) -> int:\n        if isinstance(self.nargs, int):\n            return self.nargs\n        return len(self._items)\n\n    def nud(self) -> 'XPathFunction':\n        code = 'XPST0017' if self.label == 'function' else 'XPST0003'\n        self.value = None\n        self.parser.advance('(')\n        if self.nargs is None:\n            del self._items[:]\n            if self.parser.next_token.symbol in (')', '(end)'):\n                raise self.error(code, 'at least an argument is required')\n            while True:\n                self.append(self.parser.expression(5))\n                if self.parser.next_token.symbol != ',':\n                    break\n                self.parser.advance()\n        elif self.nargs == 0:\n            if self.parser.next_token.symbol != ')':\n                if self.parser.next_token.symbol != '(end)':\n                    raise self.error(code, '%s has no arguments' % str(self))\n                raise self.parser.next_token.wrong_syntax()\n            self.parser.advance()\n            return self\n        else:\n            if isinstance(self.nargs, (tuple, list)):\n                min_args, max_args = self.nargs\n            else:\n                min_args = max_args = self.nargs\n\n            k = 0\n            while k < min_args:\n                if self.parser.next_token.symbol in (')', '(end)'):\n                    msg = 'Too few arguments: expected at least %s arguments' % min_args\n                    raise self.wrong_nargs(msg if min_args > 1 else msg[:-1])\n\n                self._items[k:] = self.parser.expression(5),\n                k += 1\n                if k < min_args:\n                    if self.parser.next_token.symbol == ')':\n                        msg = 'Too few arguments: expected at least %s arguments' % min_args\n                        raise self.error(code, msg if min_args > 1 else msg[:-1])\n                    self.parser.advance(',')\n\n            while max_args is None or k < max_args:\n                if self.parser.next_token.symbol == ',':\n                    self.parser.advance(',')\n                    self._items[k:] = self.parser.expression(5),\n                elif k == 0 and self.parser.next_token.symbol != ')':\n                    self._items[k:] = self.parser.expression(5),\n                else:\n                    break  # pragma: no cover\n                k += 1\n\n            if self.parser.next_token.symbol == ',':\n                msg = 'Too many arguments: expected at most %s arguments' % max_args\n                raise self.error(code, msg if max_args != 1 else msg[:-1])\n\n        self.parser.advance(')')\n        if any(tk.symbol == '?' for tk in self._items):\n            self._partial_function()\n\n        return self\n\n    def match_function_test(self, function_test: str, as_argument: bool = False) -> bool:\n        \"\"\"\n        Match if function signature is a subtype of provided *function_test*.\n        For default return type is covariant and arguments are contravariant.\n        If *as_argument* is `True` the match is inverted and also the return\n        type is considered contravariant.\n\n        References:\n          https://www.w3.org/TR/xpath-31/#id-function-test\n          https://www.w3.org/TR/xpath-31/#id-sequencetype-subtype\n        \"\"\"\n        if not function_test.startswith('function('):\n            return False\n        elif function_test == 'function(*)':\n            return True\n\n        parts = function_test[9:].partition(') as ')\n        if not parts[1] or not parts[2]:\n            return False\n\n        sequence_types = parts[0].split(', ')\n        sequence_types.append(parts[2])\n\n        signature = [x for x in self.sequence_types[:self.arity]]\n        signature.append(self.sequence_types[-1])\n\n        if len(sequence_types) != len(signature):\n            return False\n\n        if as_argument:\n            iterator = zip(sequence_types, signature)\n        else:\n            iterator = zip(signature, sequence_types)\n\n        k = 0\n        for fst, st in iterator:\n            k += 1\n            if not as_argument and k == len(sequence_types):\n                st, fst = fst, st\n\n            if st[-1] in '*+?':\n                st_occurs = st[-1]\n                st = st[:-1]\n            else:\n                st_occurs = ''\n\n            if fst[-1] in '*+?':\n                fst_occurs = fst[-1]\n                fst = fst[:-1]\n            else:\n                fst_occurs = ''\n\n            if st_occurs == fst_occurs or fst_occurs == '*':\n                pass\n            elif not fst_occurs:\n                if st_occurs not in '?*':\n                    return False\n            elif fst_occurs == '+':\n                if st_occurs:\n                    return False\n            elif st_occurs:\n                return False\n\n            if st == fst:\n                continue\n            elif fst == 'item()':\n                continue\n            elif st == 'item()':\n                return False\n            elif fst.startswith('xs:') ^ st.startswith('xs:'):\n                return False\n            elif fst.startswith('xs:'):\n                if not issubclass(xsd11_atomic_types[st[3:]],\n                                  xsd11_atomic_types[fst[3:]]):\n                    return False\n            elif fst != 'node()':\n                return False\n\n        return True\n\n    def _partial_function(self) -> None:\n        \"\"\"Convert a named function to an anonymous partial function.\"\"\"\n        def evaluate(context: Optional[XPathContext] = None) -> Any:\n            return self\n\n        def select(context: Optional[XPathContext] = None) -> Any:\n            yield self\n\n        if self.__class__.evaluate is not XPathToken.evaluate:\n            setattr(self, '_partial_evaluate', self.evaluate)\n        if self.__class__.select is not XPathToken.select:\n            setattr(self, '_partial_select', self.select)\n\n        setattr(self, 'evaluate', evaluate)\n        setattr(self, 'select', select)\n\n        self._name = None\n        self.label = 'partial function'\n        self.nargs = len([tk for tk in self._items if tk.symbol == '?'])\n\n    def _partial_evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return [x for x in self._partial_select(context)]\n\n    def _partial_select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        item = self._partial_evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\nfrom copy import copy\nfrom ..namespaces import XPATH_FUNCTIONS_NAMESPACE, XSD_NAMESPACE\nfrom ..xpath_nodes import TypedElement, TypedAttribute, XPathNode\nfrom ..xpath_token import XPathToken, ValueToken, XPathFunction\nfrom ..xpath_context import XPathSchemaContext\nfrom ..datatypes import QName\nfrom .xpath30_parser import XPath30Parser\n# type: ignore\n\"\"\"\nXPath 3.0 implementation - part 2 (symbols, operators and expressions)\n\"\"\"\n\n\n\n\nregister = XPath30Parser.register\ninfix = XPath30Parser.infix\nmethod = XPath30Parser.method\n\nregister(':=')\n\n###\n# Placeholder symbol (used also for optional occurrence)\n\nXPath30Parser.unregister('?')\nregister('?', bases=(ValueToken,))\n\n\n@method('?')\ndef nud_placeholder_symbol(self):\n    # self.value = self\n    return self\n\n\n@method('?')\ndef evaluate_placeholder_symbol(self, context=None):\n    return self\n\n\n###\n# Braced/expanded QName(s)\n\nXPath30Parser.duplicate('{', 'Q{', pattern=r'Q\\{')\nXPath30Parser.unregister('{')\nXPath30Parser.unregister('}')\nregister('{')\nregister('}', bp=100)\n\n\nXPath30Parser.unregister('(')\n\n\n@method(register('(', lbp=80, rpb=80, label='expression'))\ndef nud_parenthesized_expression(self):\n    if self.parser.next_token.symbol != ')':\n        self[:] = self.parser.expression(),\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef led_parenthesized_expression(self, left):\n    if left.symbol == '(name)':\n        if left.value in self.parser.RESERVED_FUNCTION_NAMES:\n            msg = f\"{left.value!r} is not allowed as function name\"\n            raise left.error('XPST0003', msg)\n        else:\n            raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    elif left.symbol == ':' and left[1].symbol == '(name)':\n        if left[1].namespace == XSD_NAMESPACE:\n            msg = 'unknown constructor function {!r}'.format(left[1].value)\n            raise left[1].error('XPST0017', msg)\n        raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    if self.parser.next_token.symbol != ')':\n        self[:] = left, self.parser.expression()\n    else:\n        self[:] = left,\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef evaluate_parenthesized_expression(self, context=None):\n    if not self:\n        return []\n\n    value = self[0].evaluate(context)\n    if isinstance(value, list) and len(value) == 1:\n        value = value[0]\n\n    if len(self) > 1:\n        if isinstance(value, XPathFunction):\n            return value(context, self[1])\n        elif self[0].symbol == '(':\n            if not isinstance(value, list):\n                return value\n            elif any(not isinstance(x, XPathFunction) for x in value):\n                return value\n\n        if isinstance(value, XPathToken) and value.symbol == '?':\n            return value\n\n        raise self.error('XPTY0004', f'an XPath function expected, not {type(value)!r}')\n\n    if not isinstance(value, XPathFunction) or self[0].span[0] > self.span[0]:\n        return value\n    else:\n        return value(context)\n\n\n@method(infix('||', bp=32))\ndef evaluate_union_operator(self, context=None):\n    return self.string_value(self.get_argument(context)) + \\\n        self.string_value(self.get_argument(context, index=1))\n\n\n@method(infix('!', bp=72))\ndef select_simple_map_operator(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    for context.item in context.inner_focus_select(self[0]):\n        for result in self[1].select(copy(context)):\n            if not isinstance(result, (tuple, XPathNode)) and not hasattr(result, 'tag'):\n                yield result\nNext line of code:\n", "input": "from copy import copy\nfrom ..namespaces import XPATH_FUNCTIONS_NAMESPACE, XSD_NAMESPACE\nfrom ..xpath_nodes import TypedElement, TypedAttribute, XPathNode\nfrom ..xpath_token import XPathToken, ValueToken, XPathFunction\nfrom ..xpath_context import XPathSchemaContext\nfrom ..datatypes import QName\nfrom .xpath30_parser import XPath30Parser\n# type: ignore\n\"\"\"\nXPath 3.0 implementation - part 2 (symbols, operators and expressions)\n\"\"\"\n\n\n\n\nregister = XPath30Parser.register\ninfix = XPath30Parser.infix\nmethod = XPath30Parser.method\n\nregister(':=')\n\n###\n# Placeholder symbol (used also for optional occurrence)\n\nXPath30Parser.unregister('?')\nregister('?', bases=(ValueToken,))\n\n\n@method('?')\ndef nud_placeholder_symbol(self):\n    # self.value = self\n    return self\n\n\n@method('?')\ndef evaluate_placeholder_symbol(self, context=None):\n    return self\n\n\n###\n# Braced/expanded QName(s)\n\nXPath30Parser.duplicate('{', 'Q{', pattern=r'Q\\{')\nXPath30Parser.unregister('{')\nXPath30Parser.unregister('}')\nregister('{')\nregister('}', bp=100)\n\n\nXPath30Parser.unregister('(')\n\n\n@method(register('(', lbp=80, rpb=80, label='expression'))\ndef nud_parenthesized_expression(self):\n    if self.parser.next_token.symbol != ')':\n        self[:] = self.parser.expression(),\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef led_parenthesized_expression(self, left):\n    if left.symbol == '(name)':\n        if left.value in self.parser.RESERVED_FUNCTION_NAMES:\n            msg = f\"{left.value!r} is not allowed as function name\"\n            raise left.error('XPST0003', msg)\n        else:\n            raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    elif left.symbol == ':' and left[1].symbol == '(name)':\n        if left[1].namespace == XSD_NAMESPACE:\n            msg = 'unknown constructor function {!r}'.format(left[1].value)\n            raise left[1].error('XPST0017', msg)\n        raise left.error('XPST0017', 'unknown function {!r}'.format(left.value))\n\n    if self.parser.next_token.symbol != ')':\n        self[:] = left, self.parser.expression()\n    else:\n        self[:] = left,\n    self.parser.advance(')')\n    return self\n\n\n@method('(')\ndef evaluate_parenthesized_expression(self, context=None):\n    if not self:\n        return []\n\n    value = self[0].evaluate(context)\n    if isinstance(value, list) and len(value) == 1:\n        value = value[0]\n\n    if len(self) > 1:\n        if isinstance(value, XPathFunction):\n            return value(context, self[1])\n        elif self[0].symbol == '(':\n            if not isinstance(value, list):\n                return value\n            elif any(not isinstance(x, XPathFunction) for x in value):\n                return value\n\n        if isinstance(value, XPathToken) and value.symbol == '?':\n            return value\n\n        raise self.error('XPTY0004', f'an XPath function expected, not {type(value)!r}')\n\n    if not isinstance(value, XPathFunction) or self[0].span[0] > self.span[0]:\n        return value\n    else:\n        return value(context)\n\n\n@method(infix('||', bp=32))\ndef evaluate_union_operator(self, context=None):\n    return self.string_value(self.get_argument(context)) + \\\n        self.string_value(self.get_argument(context, index=1))\n\n\n@method(infix('!', bp=72))\ndef select_simple_map_operator(self, context=None):\n    if context is None:\n        raise self.missing_context()\n\n    for context.item in context.inner_focus_select(self[0]):\n        for result in self[1].select(copy(context)):\n            if not isinstance(result, (tuple, XPathNode)) and not hasattr(result, 'tag'):\n                yield result\n", "context": "elementpath/xpath_nodes.py\nclass TypedAttribute(XPathNode):\n    \"\"\"\n    A class for processing typed attribute nodes.\n\n    :param attribute: the origin AttributeNode instance.\n    :param xsd_type: the reference XSD type.\n    :param value: the types value.\n    \"\"\"\n    def __init__(self, attribute: AttributeNode, xsd_type: Any, value: Any) -> None:\n        self.attribute = attribute\n        self.xsd_type = xsd_type\n        self.value = value\n        self.parent = attribute.parent\n\n    @property\n    def kind(self) -> str:\n        return 'attribute'\n\n    @property\n    def name(self) -> str:\n        return self.attribute.name\n\n    def as_item(self) -> Tuple[str, Any]:\n        return self.attribute.name, self.value\n\n    def __repr__(self) -> str:\n        return '%s(name=%r)' % (self.__class__.__name__, self.attribute.name)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.attribute == other.attribute and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.attribute, self.value))\nelementpath/xpath_nodes.py\nclass XPathNode:\n\n    name: Any = None\n    value: Any = None\n    parent: Optional[ElementNode] = None\n\n    @property\n    def kind(self) -> str:\n        raise NotImplementedError()\nelementpath/xpath_token.py\nclass XPathToken(Token[XPathTokenType]):\n    \"\"\"Base class for XPath tokens.\"\"\"\n    parser: XPathParserType\n    xsd_types: Optional[Dict[str, Union[XsdTypeProtocol, List[XsdTypeProtocol]]]]\n    namespace: Optional[str]\n    occurrence: Optional[str]\n\n    xsd_types = None  # for XPath 2.0+ XML Schema types labeling\n    namespace = None  # for namespace binding of names and wildcards\n    occurrence = None  # occurrence indicator for item types\n\n    def __call__(self, context: Optional[XPathContext] = None) -> Any:\n        return self.evaluate(context)\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        \"\"\"\n        Evaluate default method for XPath tokens.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        return [x for x in self.select(context)]\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        \"\"\"\n        Select operator that generates XPath results.\n\n        :param context: The XPath dynamic context.\n        \"\"\"\n        item = self.evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\n\n    def __str__(self) -> str:\n        symbol, label = self.symbol, self.label\n        if symbol == '$':\n            return '$%s variable reference' % (self[0].value if self._items else '')\n        elif symbol == ',':\n            return 'comma operator' if self.parser.version > '1.0' else 'comma symbol'\n        elif symbol == 'function':\n            return str(label)\n        elif label.endswith('function') or label in ('axis', 'sequence type', 'kind test'):\n            return '%r %s' % (symbol, str(label))\n        return super(XPathToken, self).__str__()\n\n    @property\n    def source(self) -> str:\n        symbol = self.symbol\n        if self.label == 'axis':\n            # For XPath 2.0 'attribute' multi-role token ('kind test', 'axis')\n            return '%s::%s' % (symbol, self[0].source)\n        elif symbol == ':':\n            if self.occurrence:\n                return str(self.value) + self.occurrence\n            else:\n                return str(self.value)\n        elif symbol == '(':\n            return '()' if not self else '(%s)' % self[0].source\n        elif symbol == '[':\n            return '%s[%s]' % (self[0].source, self[1].source)\n        elif symbol == ',':\n            return '%s, %s' % (self[0].source, self[1].source)\n        elif symbol == '$':\n            return '$%s' % self[0].source\n        elif symbol == '{':\n            return '{%s}%s' % (self[0].value, self[1].value)\n        elif symbol == 'if':\n            return 'if (%s) then %s else %s' % (self[0].source, self[1].source, self[2].source)\n        elif symbol == 'instance':\n            return '%s instance of %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'treat':\n            return '%s treat as %s' % (self[0].source, ''.join(t.source for t in self[1:]))\n        elif symbol == 'for':\n            return 'for %s return %s' % (\n                ', '.join('%s in %s' % (self[k].source, self[k + 1].source)\n                          for k in range(0, len(self) - 1, 2)),\n                self[-1].source\n            )\n        return super(XPathToken, self).source\n\n    @property\n    def child_axis(self) -> bool:\n        \"\"\"Is `True` if the token apply child axis for default, `False` otherwise.\"\"\"\n        if self.symbol not in _CHILD_AXIS_TOKENS:\n            return False\n        elif self.symbol == '[':\n            return self._items[0].child_axis\n        elif self.symbol != ':':\n            return True\n        return not self._items[1].label.endswith('function')\n\n    ###\n    # Tokens tree analysis methods\n    def iter_leaf_elements(self) -> Iterator[str]:\n        \"\"\"\n        Iterates through the leaf elements of the token tree if there are any,\n        returning QNames in prefixed format. A leaf element is an element\n        positioned at last path step. Does not consider kind tests and wildcards.\n        \"\"\"\n        if self.symbol in ('(name)', ':'):\n            yield cast(str, self.value)\n        elif self.symbol in ('//', '/'):\n            if self._items[-1].symbol in _LEAF_ELEMENTS_TOKENS:\n                yield from self._items[-1].iter_leaf_elements()\n\n        elif self.symbol in ('[',):\n            yield from self._items[0].iter_leaf_elements()\n        else:\n            for tk in self._items:\n                yield from tk.iter_leaf_elements()\n\n    ###\n    # Dynamic context methods\n    def get_argument(self, context: Optional[XPathContext],\n                     index: int = 0,\n                     required: bool = False,\n                     default_to_context: bool = False,\n                     default: Optional[AtomicValueType] = None,\n                     cls: Optional[Type[Any]] = None,\n                     promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Get the argument value of a function of constructor token. A zero length sequence is\n        converted to a `None` value. If the function has no argument returns the context's\n        item if the dynamic context is not `None`.\n\n        :param context: the dynamic context.\n        :param index: an index for select the argument to be got, the first for default.\n        :param required: if set to `True` missing or empty sequence arguments are not allowed.\n        :param default_to_context: if set to `True` then the item of the dynamic context is \\\n        returned when the argument is missing.\n        :param default: the default value returned in case the argument is an empty sequence. \\\n        If not provided returns `None`.\n        :param cls: if a type is provided performs a type checking on item.\n        :param promote: a class or a tuple of classes that are promoted to `cls` class.\n        \"\"\"\n        item: Union[None, ElementProtocol, DocumentProtocol, XPathNode, AnyAtomicType]\n\n        try:\n            selector = self._items[index].select\n        except IndexError:\n            if default_to_context:\n                if context is None:\n                    raise self.missing_context() from None\n                item = context.item if context.item is not None else context.root\n            elif required:\n                msg = \"missing %s argument\" % ordinal(index + 1)\n                raise self.error('XPST0017', msg) from None\n            else:\n                return default\n        else:\n            item = None\n            for k, result in enumerate(selector(copy(context))):\n                if k == 0:\n                    item = result\n                elif self.parser.compatibility_mode:\n                    break\n                elif isinstance(context, XPathSchemaContext):\n                    # Multiple schema nodes are ignored but do not raise. The target\n                    # of schema context selection is XSD type association and multiple\n                    # node coherency is already checked at schema level.\n                    break\n                else:\n                    raise self.wrong_context_type(\n                        \"a sequence of more than one item is not allowed as argument\"\n                    )\n            else:\n                if item is None:\n                    if not required:\n                        return default\n                    ord_arg = ordinal(index + 1)\n                    msg = \"A not empty sequence required for {} argument\"\n                    raise self.error('XPTY0004', msg.format(ord_arg))\n\n        if cls is not None:\n            return self.validated_value(item, cls, promote)\n        return item\n\n    def validated_value(self, item: Any, cls: Type[Any],\n                        promote: Optional[ClassCheckType] = None) -> Any:\n        \"\"\"\n        Type promotion checking (see \"function conversion rules\" in XPath 2.0 language definition)\n        \"\"\"\n        if isinstance(item, (cls, ValueToken)):\n            return item\n        elif promote and isinstance(item, promote):\n            return cls(item)\n\n        if self.parser.compatibility_mode:\n            if issubclass(cls, str):\n                return self.string_value(item)\n            elif issubclass(cls, float) or issubclass(float, cls):\n                return self.number_value(item)\n\n        if issubclass(cls, XPathToken) or self.parser.version == '1.0':\n            code = 'XPTY0004'\n        else:\n            value = self.data_value(item)\n            if isinstance(value, cls):\n                return value\n            elif isinstance(value, AnyURI) and issubclass(cls, str):\n                return cls(value)\n            elif isinstance(value, UntypedAtomic):\n                try:\n                    return cls(value)\n                except (TypeError, ValueError):\n                    pass\n\n            code = 'FOTY0012' if value is None else 'XPTY0004'\n\n        message = \"item type is {!r} instead of {!r}\"\n        raise self.error(code, message.format(type(item), cls))\n\n    def select_data_values(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[Optional[AtomicValueType]]:\n        \"\"\"\n        Yields data value of selected items.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            yield self.data_value(item)\n\n    def atomization(self, context: Optional[XPathContext] = None) \\\n            -> Iterator[AtomicValueType]:\n        \"\"\"\n        Helper method for value atomization of a sequence.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-atomization\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        for item in self.select(context):\n            value = self.data_value(item)\n            if value is None:\n                msg = \"argument node {!r} does not have a typed value\"\n                raise self.error('FOTY0012', msg.format(item))\n            else:\n                yield value\n\n    def get_atomized_operand(self, context: Optional[XPathContext] = None) \\\n            -> Optional[AtomicValueType]:\n        \"\"\"\n        Get the atomized value for an XPath operator.\n\n        :param context: the XPath dynamic context.\n        :return: the atomized value of a single length sequence or `None` if the sequence is empty.\n        \"\"\"\n        selector = iter(self.atomization(context))\n        try:\n            value = next(selector)\n        except StopIteration:\n            return None\n        else:\n            item = getattr(context, 'item', None)\n\n            try:\n                next(selector)\n            except StopIteration:\n                if isinstance(value, UntypedAtomic):\n                    value = str(value)\n\n                if not isinstance(context, XPathSchemaContext) and \\\n                        item is not None and \\\n                        self.xsd_types and \\\n                        isinstance(value, str):\n\n                    xsd_type = self.get_xsd_type(item)\n                    if xsd_type is None or xsd_type.name in _XSD_SPECIAL_TYPES:\n                        pass\n                    else:\n                        try:\n                            value = xsd_type.decode(value)\n                        except (TypeError, ValueError):\n                            msg = \"Type {!r} is not appropriate for the context\"\n                            raise self.wrong_context_type(msg.format(type(value)))\n\n                return value\n            else:\n                msg = \"atomized operand is a sequence of length greater than one\"\n                raise self.wrong_context_type(msg)\n\n    def iter_comparison_data(self, context: XPathContext) -> Iterator[OperandsType]:\n        \"\"\"\n        Generates comparison data couples for the general comparison of sequences.\n        Different sequences maybe generated with an XPath 2.0 parser, depending on\n        compatibility mode setting.\n\n        Ref: https://www.w3.org/TR/xpath20/#id-general-comparisons\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if self.parser.compatibility_mode:\n            operand1 = [x for x in self._items[0].select(copy(context))]\n            operand2 = [x for x in self._items[1].select(copy(context))]\n\n            # Boolean comparison if one of the results is a single boolean value (1.)\n            try:\n                if isinstance(operand1[0], bool):\n                    if len(operand1) == 1:\n                        yield operand1[0], self.boolean_value(operand2)\n                        return\n                if isinstance(operand2[0], bool):\n                    if len(operand2) == 1:\n                        yield self.boolean_value(operand1), operand2[0]\n                        return\n            except IndexError:\n                return\n\n            # Converts to float for lesser-greater operators (3.)\n            if self.symbol in ('<', '<=', '>', '>='):\n                yield from product(\n                    map(float, map(self.data_value, operand1)),  # type: ignore[arg-type]\n                    map(float, map(self.data_value, operand2)),  # type: ignore[arg-type]\n                )\n                return\n            elif self.parser.version == '1.0':\n                yield from product(map(self.data_value, operand1), map(self.data_value, operand2))\n                return\n\n        for values in product(map(self.data_value, self._items[0].select(copy(context))),\n                              map(self.data_value, self._items[1].select(copy(context)))):\n            if any(isinstance(x, bool) for x in values):\n                if any(isinstance(x, (str, Integer)) for x in values):\n                    msg = \"cannot compare {!r} and {!r}\"\n                    raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, Integer) for x in values) and \\\n                    any(isinstance(x, str) for x in values):\n                msg = \"cannot compare {!r} and {!r}\"\n                raise TypeError(msg.format(type(values[0]), type(values[1])))\n            elif any(isinstance(x, float) for x in values):\n                if isinstance(values[0], decimal.Decimal):\n                    yield float(values[0]), values[1]\n                    continue\n                elif isinstance(values[1], decimal.Decimal):\n                    yield values[0], float(values[1])\n                    continue\n\n            yield values\n\n    def select_results(self, context: Optional[XPathContext]) -> Iterator[SelectResultType]:\n        \"\"\"\n        Generates formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        \"\"\"\n        if context is not None:\n            self.parser.check_variables(context.variables)\n\n        for result in self.select(context):\n            if not isinstance(result, XPathNode):\n                yield result\n            elif isinstance(result, (TextNode, AttributeNode)):\n                yield result.value\n            elif isinstance(result, TypedElement):\n                yield result.elem\n            elif isinstance(result, TypedAttribute):\n                if is_schema_node(result.attribute.value):\n                    yield result.attribute.value\n                else:\n                    yield result.value\n            elif isinstance(result, NamespaceNode):  # pragma: no cover\n                if self.parser.compatibility_mode:\n                    yield result.prefix, result.uri\n                else:\n                    yield result.uri\n\n    def get_results(self, context: XPathContext) \\\n            -> Union[List[Any], AtomicValueType]:\n        \"\"\"\n        Returns formatted XPath results.\n\n        :param context: the XPath dynamic context.\n        :return: a list or a simple datatype when the result is a single simple type \\\n        generated by a literal or function token.\n        \"\"\"\n        results = [x for x in self.select_results(context)]\n        if len(results) == 1:\n            res = results[0]\n            if isinstance(res, (bool, int, float, Decimal)):\n                return res\n            elif is_etree_element(res) or is_document_node(res) or is_schema_node(res):\n                return results\n            elif self.label in ('function', 'literal'):\n                return cast(AtomicValueType, res)\n            else:\n                return results\n        else:\n            return results\n\n    def get_operands(self, context: XPathContext, cls: Optional[Type[Any]] = None) \\\n            -> OperandsType:\n        \"\"\"\n        Returns the operands for a binary operator. Float arguments are converted\n        to decimal if the other argument is a `Decimal` instance.\n\n        :param context: the XPath dynamic context.\n        :param cls: if a type is provided performs a type checking on item.\n        :return: a couple of values representing the operands. If any operand \\\n        is not available returns a `(None, None)` couple.\n        \"\"\"\n        op1 = self.get_argument(context, cls=cls)\n        if op1 is None:\n            return None, None\n        elif is_element_node(op1):\n            op1 = self._items[0].data_value(op1)\n\n        op2 = self.get_argument(context, index=1, cls=cls)\n        if op2 is None:\n            return None, None\n        elif is_element_node(op2):\n            op2 = self._items[1].data_value(op2)\n\n        if isinstance(op1, AbstractDateTime) and isinstance(op2, AbstractDateTime):\n            if context is not None and context.timezone is not None:\n                if op1.tzinfo is None:\n                    op1.tzinfo = context.timezone\n                if op2.tzinfo is None:\n                    op2.tzinfo = context.timezone\n        else:\n            if isinstance(op1, UntypedAtomic):\n                op1 = self.cast_to_double(op1.value)\n                if isinstance(op2, Decimal):\n                    return op1, float(op2)\n            if isinstance(op2, UntypedAtomic):\n                op2 = self.cast_to_double(op2.value)\n                if isinstance(op1, Decimal):\n                    return float(op1), op2\n\n        if isinstance(op1, float):\n            if isinstance(op2, Duration):\n                return Decimal(op1), op2\n            if isinstance(op2, Decimal):\n                return op1, type(op1)(op2)\n        if isinstance(op2, float):\n            if isinstance(op1, Duration):\n                return op1, Decimal(op2)\n            if isinstance(op1, Decimal):\n                return type(op2)(op1), op2\n\n        return op1, op2\n\n    def get_absolute_uri(self, uri: str,\n                         base_uri: Optional[str] = None,\n                         as_string: bool = True) -> Union[str, AnyURI]:\n        \"\"\"\n        Obtains an absolute URI from the argument and the static context.\n\n        :param uri: a string representing an URI.\n        :param base_uri: an alternative base URI, otherwise the base_uri \\\n        of the static context is used.\n        :param as_string: if `True` then returns the URI as a string, otherwise \\\n        returns the URI as xs:anyURI instance.\n        :returns: the argument if it's an absolute URI. Otherwise returns the URI\n        obtained by the join o the base_uri of the static context with the\n        argument. Returns the argument if the base_uri is `None'.\n        \"\"\"\n        if not base_uri:\n            base_uri = self.parser.base_uri\n\n        uri_parts: urllib.parse.ParseResult = urllib.parse.urlparse(uri)\n        if uri_parts.scheme or uri_parts.netloc or base_uri is None:\n            return uri if as_string else AnyURI(uri)\n\n        base_uri_parts: urllib.parse.SplitResult = urllib.parse.urlsplit(base_uri)\n        if base_uri_parts.fragment or not base_uri_parts.scheme and \\\n                not base_uri_parts.netloc and not base_uri_parts.path.startswith('/'):\n            raise self.error('FORG0002', '{!r} is not suitable as base URI'.format(base_uri))\n\n        if uri_parts.path.startswith('/') and base_uri_parts.path not in ('', '/'):\n            return uri if as_string else AnyURI(uri)\n\n        if as_string:\n            return urllib.parse.urljoin(base_uri, uri)\n        return AnyURI(urllib.parse.urljoin(base_uri, uri))\n\n    def get_namespace(self, prefix: str) -> str:\n        \"\"\"\n        Resolves a prefix to a namespace raising an error (FONS0004) if the\n        prefix is not found in the namespace map.\n        \"\"\"\n        try:\n            return self.parser.namespaces[prefix]\n        except KeyError as err:\n            msg = 'no namespace found for prefix %r' % str(err)\n            raise self.error('FONS0004', msg) from None\n\n    def bind_namespace(self, namespace: str) -> None:\n        \"\"\"\n        Bind a token with a namespace. The token has to be a name, a name wildcard,\n        a function or a constructor, otherwise a syntax error is raised. Functions\n        and constructors must be limited to its namespaces.\n        \"\"\"\n        if self.symbol in ('(name)', '*'):\n            pass\n        elif namespace == self.parser.function_namespace:\n            if self.label != 'function':\n                msg = \"a name, a wildcard or a function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'function'\n        elif namespace == XSD_NAMESPACE:\n            if self.label != 'constructor function':\n                msg = \"a name, a wildcard or a constructor function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'constructor function'\n        elif namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            if self.label != 'math function':\n                msg = \"a name, a wildcard or a math function expected\"\n                raise self.wrong_syntax(msg, code='XPST0017')\n            elif isinstance(self.label, MultiLabel):\n                self.label = 'math function'\n        else:\n            msg = \"a name, a wildcard or a function expected\"\n            raise self.wrong_syntax(msg, code='XPST0017')\n\n        self.namespace = namespace\n\n    def adjust_datetime(self, context: XPathContext, cls: Type[DatetimeValueType]) \\\n            -> Optional[Union[DatetimeValueType, DayTimeDuration]]:\n        \"\"\"\n        XSD datetime adjust function helper.\n\n        :param context: the XPath dynamic context.\n        :param cls: the XSD datetime subclass to use.\n        :return: an empty list if there is only one argument that is the empty sequence \\\n        or the adjusted XSD datetime instance.\n        \"\"\"\n        timezone: Optional[Any]\n        item: Optional[DatetimeValueType]\n        _item: Union[DatetimeValueType, DayTimeDuration]\n\n        if len(self) == 1:\n            item = self.get_argument(context, cls=cls)\n            if item is None:\n                return None\n            timezone = getattr(context, 'timezone', None)\n        else:\n            item = self.get_argument(context, cls=cls)\n            timezone = self.get_argument(context, 1, cls=DayTimeDuration)\n\n            if timezone is not None:\n                try:\n                    timezone = Timezone.fromduration(timezone)\n                except ValueError as err:\n                    raise self.error('FODT0003', str(err)) from None\n            if item is None:\n                return None\n\n        _item = item\n        _tzinfo = _item.tzinfo\n        try:\n            if _tzinfo is not None and timezone is not None:\n                if isinstance(_item, DateTime10):\n                    _item += timezone.offset\n                elif not isinstance(item, Date10):\n                    _item += timezone.offset - _tzinfo.offset\n                elif timezone.offset < _tzinfo.offset:\n                    _item -= timezone.offset - _tzinfo.offset\n                    _item -= DayTimeDuration.fromstring('P1D')\n        except OverflowError as err:\n            raise self.error('FODT0001', str(err)) from None\n\n        if not isinstance(_item, DayTimeDuration):\n            _item.tzinfo = timezone\n        return _item\n\n    @contextlib.contextmanager\n    def use_locale(self, collation: str) -> Iterator[None]:\n        \"\"\"A context manager for use a locale setting for string comparison in a code block.\"\"\"\n        loc = locale.getlocale(locale.LC_COLLATE)\n        if collation == UNICODE_CODEPOINT_COLLATION or collation == 'collation/codepoint':\n            collation = 'en_US.UTF-8'\n        elif collation is None:\n            raise self.error('XPTY0004', 'collation cannot be an empty sequence')\n\n        try:\n            locale.setlocale(locale.LC_COLLATE, collation)\n        except locale.Error:\n            raise self.error('FOCH0002', 'Unsupported collation %r' % collation) from None\n        else:\n            yield\n        finally:\n            locale.setlocale(locale.LC_COLLATE, loc)\n\n    ###\n    # XSD types related methods\n    def select_xsd_nodes(self, schema_context: XPathSchemaContext, name: str) \\\n            -> Iterator[Union[None, TypedElement, TypedAttribute, XMLSchemaProtocol]]:\n        \"\"\"\n        Selector for XSD nodes (elements, attributes and schemas). If there is\n        a match with an attribute or an element the node's type is added to\n        matching types of the token. For each matching elements or attributes\n        yields tuple nodes containing the node, its type and a compatible value\n        for doing static evaluation. For matching schemas yields the original\n        instance.\n\n        :param schema_context: an XPathSchemaContext instance.\n        :param name: a QName in extended format.\n        \"\"\"\n        xsd_node: Any\n        for xsd_node in schema_context.iter_children_or_self():\n            if xsd_node is None:\n                if name == XSD_SCHEMA == schema_context.root.tag:\n                    yield None\n                continue  # pragma: no cover\n\n            try:\n                if isinstance(xsd_node, AttributeNode):\n                    if isinstance(xsd_node.value, str):\n                        if xsd_node.name != name:\n                            continue\n                        xsd_node = schema_context.root.maps.attributes.get(name)\n                        if xsd_node is None:\n                            continue\n                    elif xsd_node.value.is_matching(name):\n                        if xsd_node.name is None:\n                            # node is an XSD attribute wildcard\n                            xsd_node = schema_context.root.maps.attributes.get(name)\n                            if xsd_node is None:\n                                continue\n                    else:\n                        continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedAttribute(xsd_node, xsd_type, value)\n\n                elif name == XSD_SCHEMA == xsd_node.tag:\n                    # The element is a schema\n                    yield xsd_node\n\n                elif xsd_node.is_matching(name, self.parser.default_namespace):\n                    if xsd_node.name is None:\n                        # node is an XSD element wildcard\n                        xsd_node = schema_context.root.maps.elements.get(name)\n                        if xsd_node is None:\n                            continue\n\n                    xsd_type = self.add_xsd_type(xsd_node)\n                    if xsd_type is not None:\n                        value = self.parser.get_atomic_value(xsd_type)\n                        yield TypedElement(xsd_node, xsd_type, value)\n\n            except AttributeError:\n                pass\n\n    def add_xsd_type(self, item: Any) -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Adds an XSD type association from an item. The association is\n        added using the item's name and type.\n        \"\"\"\n        if isinstance(item, AttributeNode):\n            item = item.value\n        elif isinstance(item, TypedAttribute):\n            item = item.attribute.value\n        elif isinstance(item, TypedElement):\n            item = item.elem\n\n        if not is_schema_node(item):\n            return None\n\n        name: str = item.name\n        xsd_type: XsdTypeProtocol = item.type\n\n        if self.xsd_types is None:\n            self.xsd_types = {name: xsd_type}\n        else:\n            obj = self.xsd_types.get(name)\n            if obj is None:\n                self.xsd_types[name] = xsd_type\n            elif not isinstance(obj, list):\n                if obj is not xsd_type:\n                    self.xsd_types[name] = [obj, xsd_type]\n            elif xsd_type not in obj:\n                obj.append(xsd_type)\n\n        return xsd_type\n\n    def get_xsd_type(self, item: Union[str, PrincipalNodeType]) \\\n            -> Optional[XsdTypeProtocol]:\n        \"\"\"\n        Returns the XSD type associated with an item. Match by item's name\n        and XSD validity. Returns `None` if no XSD type is matching.\n\n        :param item: a string or an AttributeNode or an element.\n        \"\"\"\n        if not self.xsd_types or isinstance(self.xsd_types, AbstractSchemaProxy):\n            return None\n        elif isinstance(item, str):\n            xsd_type = self.xsd_types.get(item)\n        elif isinstance(item, AttributeNode):\n            xsd_type = self.xsd_types.get(item.name)\n        elif isinstance(item, (TypedAttribute, TypedElement)):\n            return cast(XsdTypeProtocol, item.xsd_type)\n        else:\n            xsd_type = self.xsd_types.get(item.tag)\n\n        x: XsdTypeProtocol\n        if not xsd_type:\n            return None\n        elif not isinstance(xsd_type, list):\n            return xsd_type\n        elif isinstance(item, AttributeNode):\n            for x in xsd_type:\n                if x.is_valid(item.value):\n                    return x\n        elif is_etree_element(item):\n            for x in xsd_type:\n                if x.is_simple():\n                    if x.is_valid(item.text):  # type: ignore[union-attr]\n                        return x\n                elif x.is_valid(item):\n                    return x\n\n        return xsd_type[0]\n\n    def get_typed_node(self, item: PrincipalNodeType) -> PrincipalNodeType:\n        \"\"\"\n        Returns a typed node if the item is matching an XSD type.\n\n        Ref:\n          https://www.w3.org/TR/xpath20/#id-processing-model\n          https://www.w3.org/TR/xpath20/#id-static-analysis\n          https://www.w3.org/TR/xquery-semantics/\n\n        :param item: an untyped attribute or element.\n        :return: a typed AttributeNode/ElementNode if the argument is matching \\\n        any associated XSD type.\n        \"\"\"\n        if isinstance(item, (TypedAttribute, TypedElement)):\n            return item\n\n        xsd_type = self.get_xsd_type(item)\n        if not xsd_type:\n            return item\n        elif xsd_type.name in _XSD_SPECIAL_TYPES:\n            if isinstance(item, AttributeNode):\n                if not isinstance(item.value, str):\n                    return TypedAttribute(item, xsd_type, UntypedAtomic(''))\n                return TypedAttribute(item, xsd_type, UntypedAtomic(item.value))\n            return TypedElement(item, xsd_type, UntypedAtomic(item.text or ''))\n\n        elif isinstance(item, AttributeNode):\n            pass\n        elif xsd_type.has_mixed_content():\n            value = UntypedAtomic(item.text or '')\n            return TypedElement(item, xsd_type, value)\n        elif xsd_type.is_element_only():\n            return TypedElement(item, xsd_type, None)\n        elif xsd_type.is_empty():\n            return TypedElement(item, xsd_type, None)\n        elif item.get(XSI_NIL) and getattr(xsd_type.parent, 'nillable', None):\n            return TypedElement(item, xsd_type, None)\n\n        if self.parser.xsd_version == '1.0':\n            atomic_types = xsd10_atomic_types\n        else:\n            atomic_types = xsd11_atomic_types\n\n        try:\n            builder: Any = atomic_types[xsd_type.name]\n        except KeyError:\n            if self.parser.schema is None:\n                builder = UntypedAtomic\n            else:\n                try:\n                    primitive_type = self.parser.schema.get_primitive_type(xsd_type)\n                    builder = atomic_types[primitive_type.name]\n                except KeyError:\n                    builder = UntypedAtomic\n                else:\n                    if isinstance(builder, (AbstractDateTime, Duration)):\n                        builder = builder.fromstring\n                    elif issubclass(builder, QName):\n                        builder = self.cast_to_qname\n        else:\n            if issubclass(builder, (AbstractDateTime, Duration)):\n                builder = builder.fromstring\n            elif issubclass(builder, QName):\n                builder = self.cast_to_qname\n\n        if isinstance(item, AttributeNode):\n            if xsd_type.is_valid(item.value):\n                return TypedAttribute(item, xsd_type, builder(item.value))\n        elif item.text is not None:\n            if xsd_type.is_valid(item.text):\n                return TypedElement(item, xsd_type, builder(item.text))\n        elif item.get(XSI_NIL) in ('1', 'true'):\n            return TypedElement(item, atomic_types[XSD_ANY_ATOMIC_TYPE], '')\n\n        msg = \"Type {!r} does not match sequence type of {!r}\"\n        raise self.wrong_sequence_type(msg.format(xsd_type, item)) from None\n\n    def cast_to_qname(self, qname: str) -> QName:\n        \"\"\"Cast a prefixed qname string to a QName object.\"\"\"\n        try:\n            if ':' not in qname:\n                return QName(self.parser.namespaces.get(''), qname.strip())\n            pfx, _ = qname.strip().split(':')\n            return QName(self.parser.namespaces[pfx], qname)\n        except ValueError:\n            msg = 'invalid value {!r} for an xs:QName'.format(qname.strip())\n            raise self.error('FORG0001', msg)\n        except KeyError as err:\n            raise self.error('FONS0004', 'no namespace found for prefix {}'.format(err))\n\n    def cast_to_double(self, value: Union[SupportsFloat, str]) -> float:\n        \"\"\"Cast a value to xs:double.\"\"\"\n        try:\n            if self.parser.xsd_version == '1.0':\n                return cast(float, DoubleProxy10(value))\n            return cast(float, DoubleProxy(value))\n        except ValueError as err:\n            raise self.error('FORG0001', str(err))  # str or UntypedAtomic\n\n    def cast_to_primitive_type(self, obj: Any, type_name: str) -> Any:\n        if obj is None or not type_name.startswith('xs:') or type_name.count(':') != 1:\n            return obj\n\n        values = obj if isinstance(obj, list) else [obj]\n        if not values:\n            return obj\n\n        if type_name[-1] in '+*?':\n            type_name = type_name[:-1]\n\n        result = []\n        for v in values:\n            if self.parser.is_instance(v, XSD_DECIMAL):\n                if type_name == 'xs:double':\n                    result.append(float(v))\n                    continue\n                elif type_name == 'xs:float':\n                    if self.parser.xsd_version == '1.0':\n                        result.append(Float10(v))\n                    else:\n                        result.append(Float(v))\n                    continue\n\n            result.append(v)\n\n        if isinstance(obj, list) or len(result) > 1:\n            return result\n        return result[0]\n\n    ###\n    # XPath data accessors base functions\n    def boolean_value(self, obj: Any) -> bool:\n        \"\"\"\n        The effective boolean value, as computed by fn:boolean().\n        \"\"\"\n        if isinstance(obj, list):\n            if not obj:\n                return False\n            elif is_xpath_node(obj[0]):\n                return True\n            elif len(obj) > 1:\n                message = \"effective boolean value is not defined for a sequence \" \\\n                          \"of two or more items not starting with an XPath node.\"\n                raise self.error('FORG0006', message)\n            else:\n                obj = obj[0]\n\n        if isinstance(obj, (int, str, UntypedAtomic, AnyURI)):  # Include bool\n            return bool(obj)\n        elif isinstance(obj, (float, Decimal)):\n            return False if math.isnan(obj) else bool(obj)\n        elif obj is None:\n            return False\n        elif is_xpath_node(obj):\n            return True\n        else:\n            message = \"effective boolean value is not defined for {!r}.\".format(type(obj))\n            raise self.error('FORG0006', message)\n\n    def data_value(self, obj: Any) -> Optional[AtomicValueType]:\n        \"\"\"\n        The typed value, as computed by fn:data() on each item.\n        Returns an instance of UntypedAtomic for untyped data.\n\n        https://www.w3.org/TR/xpath20/#dt-typed-value\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TextNode):\n                return UntypedAtomic(obj.value)\n            elif isinstance(obj, AttributeNode) and isinstance(obj.value, str):\n                return UntypedAtomic(obj.value)\n            return cast(Optional[AtomicValueType], obj.value)  # a typed node or a NamespaceNode\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0013', f\"{obj.label!r} has no typed value\")\n\n        elif is_schema_node(obj):\n            return self.parser.get_atomic_value(obj.type)\n\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return UntypedAtomic(''.join(etree_iter_strings(obj)))\n            else:\n                return None\n        elif is_document_node(obj):\n            value = ''.join(etree_iter_strings(obj.getroot()))\n            return UntypedAtomic(value)\n        else:\n            return cast(AtomicValueType, obj)\n\n    def string_value(self, obj: Any) -> str:\n        \"\"\"\n        The string value, as computed by fn:string().\n        \"\"\"\n        if obj is None:\n            return ''\n        elif isinstance(obj, XPathNode):\n            if isinstance(obj, TypedElement):\n                if obj.value is None:\n                    return ''.join(etree_iter_strings(obj))\n                return str(obj.value)\n            elif isinstance(obj, (AttributeNode, TypedAttribute)):\n                return str(obj.value)\n            else:\n                return cast(str, obj.value)  # TextNode or NamespaceNode\n        elif is_schema_node(obj):\n            return str(self.parser.get_atomic_value(obj.type))\n        elif hasattr(obj, 'tag'):\n            if is_comment_node(obj) or is_processing_instruction_node(obj):\n                return cast(str, obj.text)\n            elif hasattr(obj, 'attrib') and hasattr(obj, 'text'):\n                return ''.join(etree_iter_strings(obj))\n        elif is_document_node(obj):\n            return ''.join(etree_iter_strings(obj.getroot()))\n        elif isinstance(obj, bool):\n            return 'true' if obj else 'false'\n        elif isinstance(obj, Decimal):\n            value = format(obj, 'f')\n            if '.' in value:\n                return value.rstrip('0').rstrip('.')\n            return value\n\n        elif isinstance(obj, float):\n            if math.isnan(obj):\n                return 'NaN'\n            elif math.isinf(obj):\n                return str(obj).upper()\n\n            value = str(obj)\n            if '.' in value:\n                value = value.rstrip('0').rstrip('.')\n            if '+' in value:\n                value = value.replace('+', '')\n            if 'e' in value:\n                return value.upper()\n            return value\n\n        elif isinstance(obj, XPathFunction):\n            raise self.error('FOTY0014', f\"{obj.label!r} has no string value\")\n\n        return str(obj)\n\n    def number_value(self, obj: Any) -> float:\n        \"\"\"\n        The numeric value, as computed by fn:number() on each item. Returns a float value.\n        \"\"\"\n        try:\n            return float(self.string_value(obj) if is_xpath_node(obj) else obj)\n        except (TypeError, ValueError):\n            return float('nan')\n\n    ###\n    # Error handling helpers\n    def error_code(self, code: str) -> str:\n        \"\"\"Returns a prefixed error code.\"\"\"\n        if self.parser.namespaces.get('err') == XQT_ERRORS_NAMESPACE:\n            return 'err:%s' % code\n\n        for pfx, uri in self.parser.namespaces.items():\n            if uri == XQT_ERRORS_NAMESPACE:\n                return '%s:%s' % (pfx, code) if pfx else code\n\n        return code  # returns an unprefixed code (without prefix the namespace is not checked)\n\n    def error(self, code: Union[str, QName],\n              message_or_error: Union[None, str, Exception] = None) -> ElementPathError:\n        \"\"\"\n        Returns an XPath error instance related with a code. An XPath/XQuery/XSLT\n        error code is an alphanumeric token starting with four uppercase letters\n        and ending with four digits.\n\n        :param code: the error code as QName or string.\n        :param message_or_error: an optional custom message or an exception.\n        \"\"\"\n        namespace: Optional[str]\n\n        if isinstance(code, QName):\n            namespace = code.uri\n            code = code.local_name\n        elif ':' not in code:\n            namespace = None\n        else:\n            try:\n                prefix, code = code.split(':')\n            except ValueError:\n                raise ElementPathValueError(\n                    message='%r is not a prefixed name' % code,\n                    code=self.error_code('XPTY0004'),\n                    token=self,\n                )\n            else:\n                namespace = self.parser.namespaces.get(prefix)\n\n        if namespace and namespace != XQT_ERRORS_NAMESPACE:\n            raise ElementPathValueError(\n                message='%r namespace is required' % XQT_ERRORS_NAMESPACE,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        try:\n            error_class, default_message = XPATH_ERROR_CODES[code]\n        except KeyError:\n            raise ElementPathValueError(\n                message='unknown XPath error code %r' % code,\n                code=self.error_code('XPTY0004'),\n                token=self,\n            )\n\n        if message_or_error is None:\n            message = default_message\n        elif isinstance(message_or_error, str):\n            message = message_or_error\n        elif isinstance(message_or_error, ElementPathError):\n            message = message_or_error.message\n        else:\n            message = str(message_or_error)\n\n        return error_class(message, code=self.error_code(code), token=self)\n\n    # Shortcuts for XPath errors, only the wrong_syntax\n    def expected(self, *symbols: str,\n                 message: Optional[str] = None,\n                 code: str = 'XPST0003') -> None:\n        if symbols and self.symbol not in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def unexpected(self, *symbols: str,\n                   message: Optional[str] = None,\n                   code: str = 'XPST0003') -> None:\n        if not symbols or self.symbol in symbols:\n            raise self.wrong_syntax(message, code)\n\n    def wrong_syntax(self, message: Optional[str] = None,  # type: ignore[override]\n                     code: str = 'XPST0003') -> ElementPathError:\n        if self.label == 'function':\n            code = 'XPST0017'\n\n        if message:\n            return self.error(code, message)\n\n        error = super(XPathToken, self).wrong_syntax(message)\n        return self.error(code, str(error))\n\n    def wrong_value(self, message: Optional[str] = None) -> ElementPathValueError:\n        return cast(ElementPathValueError, self.error('FOCA0002', message))\n\n    def wrong_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('FORG0006', message))\n\n    def missing_context(self, message: Optional[str] = None) -> MissingContextError:\n        return cast(MissingContextError, self.error('XPDY0002', message))\n\n    def wrong_context_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPTY0004', message))\n\n    def missing_name(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0008', message))\n\n    def missing_axis(self, message: Optional[str] = None) \\\n            -> Union[ElementPathNameError, ElementPathSyntaxError]:\n        if self.parser.compatibility_mode:\n            return cast(ElementPathNameError, self.error('XPST0010', message))\n        return cast(ElementPathSyntaxError, self.error('XPST0003', message))\n\n    def wrong_nargs(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPST0017', message))\n\n    def wrong_sequence_type(self, message: Optional[str] = None) -> ElementPathTypeError:\n        return cast(ElementPathTypeError, self.error('XPDY0050', message))\n\n    def unknown_atomic_type(self, message: Optional[str] = None) -> ElementPathNameError:\n        return cast(ElementPathNameError, self.error('XPST0051', message))\nelementpath/namespaces.py\nXSD_NAMESPACE = \"http://www.w3.org/2001/XMLSchema\"\nelementpath/xpath_token.py\nclass ValueToken(XPathToken):\n    \"\"\"\n    A dummy token for encapsulating a value.\n    \"\"\"\n    symbol = '(value)'\n\n    def evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return self.value\n\n    def select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        if isinstance(self.value, list):\n            yield from self.value\n        elif self.value is not None:\n            yield self.value\nelementpath/xpath30/xpath30_parser.py\nclass XPath30Parser(XPath2Parser):\n    \"\"\"\n    XPath 3.0 expression parser class. Accepts all XPath 2.0 options as keyword\n    arguments, but the *strict* option is ignored because XPath 3.0+ has braced\n    URI literals and the expanded name syntax is not compatible.\n\n    :param args: the same positional arguments of class :class:`XPath2Parser`.\n    :param decimal_formats: a mapping with statically known decimal formats.\n    :param kwargs: the same keyword arguments of class :class:`XPath2Parser`.\n    \"\"\"\n    version = '3.0'\n\n    SYMBOLS = XPath2Parser.SYMBOLS | {\n        'Q{',  # see BracedURILiteral rule\n        '||',  # concat operator\n        '!',   # Simple map operator\n\n        # Math functions (trigonometric and exponential)\n        'pi', 'exp', 'exp10', 'log', 'log10', 'pow', 'sqrt',\n        'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'atan2',\n\n        # Formatting functions\n        'format-integer', 'format-number', 'format-dateTime',\n        'format-date', 'format-time',\n\n        # String functions that use regular expressions\n        'analyze-string',\n\n        # Functions and operators on nodes\n        'path', 'has-children', 'innermost', 'outermost',\n\n        # Functions and operators on sequences\n        'head', 'tail', 'generate-id', 'uri-collection',\n        'unparsed-text', 'unparsed-text-lines', 'unparsed-text-available',\n        'environment-variable', 'available-environment-variables',\n\n        # Parsing and serializing\n        'parse-xml', 'parse-xml-fragment', 'serialize',\n\n        # Higher-order functions\n        'function-lookup', 'function-name', 'function-arity', '#', '?',\n        'for-each', 'filter', 'fold-left', 'fold-right', 'for-each-pair',\n\n        # Expressions and node type functions\n        'function', 'let', ':=', 'namespace-node',\n\n        # XSD list-types constructor functions\n        'ENTITIES', 'IDREFS', 'NMTOKENS',\n    }\n\n    DEFAULT_NAMESPACES = {\n        'math': XPATH_MATH_FUNCTIONS_NAMESPACE, **XPath2Parser.DEFAULT_NAMESPACES\n    }\n    PATH_STEP_SYMBOLS = {\n        '(integer)', '(string)', '(float)', '(decimal)', '(name)',\n        '*', '@', '..', '.', '(', '{', 'Q{', '$',\n    }\n\n    decimal_formats: DecimalFormatsType = {\n        None: {\n            'decimal-separator': '.',\n            'grouping-separator': ',',\n            'exponent-separator': 'e',\n            'infinity': 'Infinity',\n            'minus-sign': '-',\n            'NaN': 'NaN',\n            'percent': '%',\n            'per-mille': '\u2030',\n            'zero-digit': '0',\n            'digit': '#',\n            'pattern-separator': ';',\n        }\n    }\n\n    # https://www.w3.org/TR/xpath-30/#id-reserved-fn-names\n    RESERVED_FUNCTION_NAMES = {\n        'attribute', 'comment', 'document-node', 'element', 'empty-sequence',\n        'function', 'if', 'item', 'namespace-node', 'node', 'processing-instruction',\n        'schema-attribute', 'schema-element', 'switch', 'text', 'typeswitch',\n    }\n\n    function_signatures = XPath2Parser.function_signatures.copy()\n\n    def __init__(self, *args: Any, decimal_formats: Optional[DecimalFormatsType] = None,\n                 **kwargs: Any) -> None:\n        kwargs.pop('strict', None)\n        super(XPath30Parser, self).__init__(*args, **kwargs)\n\n        if decimal_formats is not None:\n            self.decimal_formats = deepcopy(self.decimal_formats)\n\n            for k, v in decimal_formats.items():\n                if k is not None:\n                    self.decimal_formats[k] = self.decimal_formats[None].copy()\n                    self.decimal_formats[k].update(v)\n\n            if None in decimal_formats:\n                self.decimal_formats[None].update(decimal_formats[None])\nelementpath/xpath_nodes.py\nclass TypedElement(XPathNode):\n    \"\"\"\n    A class for processing typed element nodes.\n\n    :param elem: the linked element. Can be an Element, or an XSD element \\\n    when XPath is applied on a schema.\n    :param xsd_type: the reference XSD type.\n    :param value: the decoded value. Can be `None` for empty or element-only elements.\"\n    \"\"\"\n    def __init__(self, elem: ElementProtocol, xsd_type: Any, value: Any) -> None:\n        self.elem = elem\n        self.xsd_type = xsd_type\n        self.value = value\n\n    @property\n    def kind(self) -> str:\n        return 'element'\n\n    @property\n    def name(self) -> str:\n        return self.elem.tag\n\n    @property\n    def tag(self) -> str:\n        return self.elem.tag\n\n    def __repr__(self) -> str:\n        return '%s(tag=%r)' % (self.__class__.__name__, self.elem.tag)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and \\\n            self.elem is other.elem and \\\n            self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.elem, self.value))\nelementpath/xpath_context.py\nclass XPathSchemaContext(XPathContext):\n    \"\"\"\n    The XPath dynamic context base class for schema bounded parsers. Use this class\n    as dynamic context for schema instances in order to perform a schema-based type\n    checking during the static analysis phase. Don't use this as dynamic context on\n    XML instances.\n    \"\"\"\n    iter_children_or_self: Callable[..., Iterator[Union[XsdElementProtocol, XMLSchemaProtocol]]]\n    root: XMLSchemaProtocol\nelementpath/datatypes/qname.py\nclass QName(AbstractQName):\n    name = 'QName'\nelementpath/namespaces.py\nXPATH_FUNCTIONS_NAMESPACE = \"http://www.w3.org/2005/xpath-functions\"\nelementpath/xpath_token.py\nclass XPathFunction(XPathToken):\n    \"\"\"\n    A token for processing XPath functions.\n    \"\"\"\n    _name: Optional[QName] = None\n    pattern = r'(?<!\\$)\\b[^\\d\\W][\\w.\\-\\xb7\\u0300-\\u036F\\u203F\\u2040]*' \\\n              r'(?=\\s*(?:\\(\\:.*\\:\\))?\\s*\\((?!\\:))'\n\n    sequence_types: Tuple[str, ...] = ()\n    \"Sequence types of arguments and of the return value of the function.\"\n\n    nargs: NargsType = None\n    \"Number of arguments: a single value or a couple with None that means unbounded.\"\n\n    body: Optional[XPathToken] = None\n    \"Body of anonymous inline function.\"\n\n    variables: Optional[Dict[str, Any]] = None\n    \"Optional variables linked by let and for expressions.\"\n\n    def __init__(self, parser: 'XPath1Parser', nargs: Optional[int] = None) -> None:\n        super().__init__(parser)\n        if isinstance(nargs, int) and nargs != self.nargs:\n            if nargs < 0:\n                raise self.error('XPST0017', 'number of arguments must be non negative')\n            elif self.nargs is None:\n                self.nargs = nargs\n            elif isinstance(self.nargs, int):\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            elif self.nargs[0] > nargs or self.nargs[1] is not None and self.nargs[1] < nargs:\n                raise self.error('XPST0017', 'incongruent number of arguments')\n            else:\n                self.nargs = nargs\n\n    def __call__(self, context: Optional[XPathContext] = None,\n                 argument_list: Optional[Union[\n                     XPathToken,\n                     List[Union[XPathToken, AtomicValueType]],\n                     Tuple[Union[XPathToken, AtomicValueType], ...]\n                 ]] = None) -> Any:\n\n        args: List[Any] = []\n        if isinstance(argument_list, (list, tuple)):\n            args.extend(argument_list)\n        elif isinstance(argument_list, XPathToken):\n            tk = argument_list\n            while True:\n                if tk.symbol == ',':\n                    args.append(tk[1].evaluate(context))\n                    tk = tk[0]\n                else:\n                    args.append(tk.evaluate(context))\n                    break\n            args.reverse()\n\n        # Check provided argument with arity\n        if self.nargs is None or self.nargs == len(args):\n            pass\n        elif isinstance(self.nargs, tuple):\n            if len(args) < self.nargs[0]:\n                raise self.error('XPTY0004', \"missing required arguments\")\n            elif self.nargs[1] is not None and len(args) > self.nargs[1]:\n                raise self.error('XPTY0004', \"too many arguments\")\n        elif self.nargs > len(args):\n            raise self.error('XPTY0004', \"missing required arguments\")\n        else:\n            raise self.error('XPTY0004', \"too many arguments\")\n\n        context = copy(context)\n        if self.variables is not None and context is not None:\n            context.variables.update(self.variables)\n\n        if self.symbol == 'function':\n            if context is None:\n                raise self.missing_context()\n            elif not args and self:\n                if context.item is None:\n                    if is_document_node(context.root):\n                        context.item = cast(DocumentProtocol, context.root).getroot()\n                    else:\n                        context.item = context.root\n\n                args.append(context.item)\n\n            partial_function = False\n            if self.variables is None:\n                self.variables = {}\n\n            for variable, sequence_type, value in zip(self, self.sequence_types, args):\n                varname = cast(str, variable[0].value)\n\n                if isinstance(value, XPathToken) and value.symbol == '?':\n                    partial_function = True\n                    continue\n                elif isinstance(value, XPathFunction) and sequence_type.startswith('function('):\n                    if not value.match_function_test(sequence_type, as_argument=True):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                elif not self.parser.match_sequence_type(value, sequence_type):\n                    value = self.cast_to_primitive_type(value, sequence_type)\n                    if not self.parser.match_sequence_type(value, sequence_type):\n                        msg = \"argument {!r}: {} does not match sequence type {}\"\n                        raise self.error('XPTY0004', msg.format(varname, value, sequence_type))\n\n                context.variables[varname] = self.variables[varname] = value\n\n            if partial_function:\n                return self\n\n        elif self.label == 'partial function':\n            for value, tk in zip(args, filter(lambda x: x.symbol == '?', self)):\n                if isinstance(value, XPathToken):\n                    tk.value = value.evaluate(context)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    tk.value = value\n        else:\n            self.clear()\n            for value in args:\n                if isinstance(value, XPathToken):\n                    self.append(value)\n                else:\n                    assert not isinstance(value, Token), \"An atomic value or None expected\"\n                    self.append(ValueToken(self.parser, value=value))\n\n            if any(tk.symbol == '?' for tk in self._items):\n                self._partial_function()\n                return self\n\n        if isinstance(self.label, MultiLabel):\n            # Disambiguate multi-label tokens\n            if self.namespace == XSD_NAMESPACE and \\\n                    'constructor function' in self.label.values:\n                self.label = 'constructor function'\n            else:\n                for label in self.label.values:\n                    if label.endswith('function'):\n                        self.label = label\n                        break\n\n        if self.label == 'partial function':\n            result = self._partial_evaluate(context)\n        elif self.body is not None:\n            assert self.label == 'inline function'\n            result = self.body.evaluate(context)\n        else:\n            result = self.evaluate(context)\n\n        if isinstance(result, XPathToken) and result.symbol == '?':\n            pass\n        elif not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n            result = self.cast_to_primitive_type(result, self.sequence_types[-1])\n            if not self.parser.match_sequence_type(result, self.sequence_types[-1]):\n                msg = \"{!r} does not match sequence type {}\"\n                self.parser.match_sequence_type(result, self.sequence_types[-1])\n                raise self.error('XPTY0004', msg.format(result, self.sequence_types[-1]))\n\n        return result\n\n    @property\n    def source(self) -> str:\n        if self.label == 'function test':\n            if len(self.sequence_types) == 1 and self.sequence_types[0] == '*':\n                return 'function(*)'\n            else:\n                return 'function(%s) as %s' % (\n                    ', '.join(self.sequence_types[:-1]), self.sequence_types[-1]\n                )\n        elif self.label in ('sequence type', 'kind test', ''):\n            return '%s(%s)%s' % (\n                self.symbol, ', '.join(item.source for item in self), self.occurrence or ''\n            )\n        return '%s(%s)' % (self.symbol, ', '.join(item.source for item in self))\n\n    @property\n    def name(self) -> Optional[QName]:\n        if self._name is not None:\n            return self._name\n        elif self.symbol == 'function':\n            return None\n        elif self.label == 'partial function':\n            return None\n        elif not self.namespace or self.namespace == XPATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_FUNCTIONS_NAMESPACE, 'fn:%s' % self.symbol)\n        elif self.namespace == XSD_NAMESPACE:\n            self._name = QName(XSD_NAMESPACE, 'xs:%s' % self.symbol)\n        elif self.namespace == XPATH_MATH_FUNCTIONS_NAMESPACE:\n            self._name = QName(XPATH_MATH_FUNCTIONS_NAMESPACE, 'math:%s' % self.symbol)\n        else:\n            for pfx, uri in self.parser.namespaces.items():\n                if uri == self.namespace:\n                    self._name = QName(uri, f'{pfx}:{self.symbol}')\n                    break\n            else:\n                self._name = QName(self.namespace, self.symbol)\n\n        return self._name\n\n    @property\n    def arity(self) -> int:\n        if isinstance(self.nargs, int):\n            return self.nargs\n        return len(self._items)\n\n    def nud(self) -> 'XPathFunction':\n        code = 'XPST0017' if self.label == 'function' else 'XPST0003'\n        self.value = None\n        self.parser.advance('(')\n        if self.nargs is None:\n            del self._items[:]\n            if self.parser.next_token.symbol in (')', '(end)'):\n                raise self.error(code, 'at least an argument is required')\n            while True:\n                self.append(self.parser.expression(5))\n                if self.parser.next_token.symbol != ',':\n                    break\n                self.parser.advance()\n        elif self.nargs == 0:\n            if self.parser.next_token.symbol != ')':\n                if self.parser.next_token.symbol != '(end)':\n                    raise self.error(code, '%s has no arguments' % str(self))\n                raise self.parser.next_token.wrong_syntax()\n            self.parser.advance()\n            return self\n        else:\n            if isinstance(self.nargs, (tuple, list)):\n                min_args, max_args = self.nargs\n            else:\n                min_args = max_args = self.nargs\n\n            k = 0\n            while k < min_args:\n                if self.parser.next_token.symbol in (')', '(end)'):\n                    msg = 'Too few arguments: expected at least %s arguments' % min_args\n                    raise self.wrong_nargs(msg if min_args > 1 else msg[:-1])\n\n                self._items[k:] = self.parser.expression(5),\n                k += 1\n                if k < min_args:\n                    if self.parser.next_token.symbol == ')':\n                        msg = 'Too few arguments: expected at least %s arguments' % min_args\n                        raise self.error(code, msg if min_args > 1 else msg[:-1])\n                    self.parser.advance(',')\n\n            while max_args is None or k < max_args:\n                if self.parser.next_token.symbol == ',':\n                    self.parser.advance(',')\n                    self._items[k:] = self.parser.expression(5),\n                elif k == 0 and self.parser.next_token.symbol != ')':\n                    self._items[k:] = self.parser.expression(5),\n                else:\n                    break  # pragma: no cover\n                k += 1\n\n            if self.parser.next_token.symbol == ',':\n                msg = 'Too many arguments: expected at most %s arguments' % max_args\n                raise self.error(code, msg if max_args != 1 else msg[:-1])\n\n        self.parser.advance(')')\n        if any(tk.symbol == '?' for tk in self._items):\n            self._partial_function()\n\n        return self\n\n    def match_function_test(self, function_test: str, as_argument: bool = False) -> bool:\n        \"\"\"\n        Match if function signature is a subtype of provided *function_test*.\n        For default return type is covariant and arguments are contravariant.\n        If *as_argument* is `True` the match is inverted and also the return\n        type is considered contravariant.\n\n        References:\n          https://www.w3.org/TR/xpath-31/#id-function-test\n          https://www.w3.org/TR/xpath-31/#id-sequencetype-subtype\n        \"\"\"\n        if not function_test.startswith('function('):\n            return False\n        elif function_test == 'function(*)':\n            return True\n\n        parts = function_test[9:].partition(') as ')\n        if not parts[1] or not parts[2]:\n            return False\n\n        sequence_types = parts[0].split(', ')\n        sequence_types.append(parts[2])\n\n        signature = [x for x in self.sequence_types[:self.arity]]\n        signature.append(self.sequence_types[-1])\n\n        if len(sequence_types) != len(signature):\n            return False\n\n        if as_argument:\n            iterator = zip(sequence_types, signature)\n        else:\n            iterator = zip(signature, sequence_types)\n\n        k = 0\n        for fst, st in iterator:\n            k += 1\n            if not as_argument and k == len(sequence_types):\n                st, fst = fst, st\n\n            if st[-1] in '*+?':\n                st_occurs = st[-1]\n                st = st[:-1]\n            else:\n                st_occurs = ''\n\n            if fst[-1] in '*+?':\n                fst_occurs = fst[-1]\n                fst = fst[:-1]\n            else:\n                fst_occurs = ''\n\n            if st_occurs == fst_occurs or fst_occurs == '*':\n                pass\n            elif not fst_occurs:\n                if st_occurs not in '?*':\n                    return False\n            elif fst_occurs == '+':\n                if st_occurs:\n                    return False\n            elif st_occurs:\n                return False\n\n            if st == fst:\n                continue\n            elif fst == 'item()':\n                continue\n            elif st == 'item()':\n                return False\n            elif fst.startswith('xs:') ^ st.startswith('xs:'):\n                return False\n            elif fst.startswith('xs:'):\n                if not issubclass(xsd11_atomic_types[st[3:]],\n                                  xsd11_atomic_types[fst[3:]]):\n                    return False\n            elif fst != 'node()':\n                return False\n\n        return True\n\n    def _partial_function(self) -> None:\n        \"\"\"Convert a named function to an anonymous partial function.\"\"\"\n        def evaluate(context: Optional[XPathContext] = None) -> Any:\n            return self\n\n        def select(context: Optional[XPathContext] = None) -> Any:\n            yield self\n\n        if self.__class__.evaluate is not XPathToken.evaluate:\n            setattr(self, '_partial_evaluate', self.evaluate)\n        if self.__class__.select is not XPathToken.select:\n            setattr(self, '_partial_select', self.select)\n\n        setattr(self, 'evaluate', evaluate)\n        setattr(self, 'select', select)\n\n        self._name = None\n        self.label = 'partial function'\n        self.nargs = len([tk for tk in self._items if tk.symbol == '?'])\n\n    def _partial_evaluate(self, context: Optional[XPathContext] = None) -> Any:\n        return [x for x in self._partial_select(context)]\n\n    def _partial_select(self, context: Optional[XPathContext] = None) -> Iterator[Any]:\n        item = self._partial_evaluate(context)\n        if item is not None:\n            if isinstance(item, list):\n                yield from item\n            else:\n                if context is not None:\n                    context.item = item\n                yield item\n", "answers": ["            elif isinstance(result, TypedElement):"], "pred": "  (self, context, index=1, tag=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=0, focus=", "length": 6293, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "ee505459c8831993d6d076ef9ee075e8cf412a45f09a9dfb"}
{"prompt": "Please complete the code given below. \npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/ExposureTransformation.java\npublic class ExposureTransformation extends TransferTransformation {\n\n    private float exposure = 1.0f;\n\n    protected float transferFunction(float f) {\n        return 1 - (float) Math.exp(-f * exposure);\n    }\n\n    /**\n     * Set the exposure level.\n     * \n     * @param exposure the exposure level\n     * @min-value 0\n     * @max-value 5+\n     * @see #getExposure\n     */\n    public void setExposure(float exposure) {\n        this.exposure = exposure;\n        initialized = false;\n    }\n\n    /**\n     * Get the exposure level.\n     * \n     * @return the exposure level\n     * @see #setExposure\n     */\n    public float getExposure() {\n        return exposure;\n    }\n\n    public String toString() {\n        return \"Colors/Exposure...\";\n    }\n\n    @Override\n    public String key() {\n        return ExposureTransformation.class.getCanonicalName() + \"-\" + exposure;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/CurvesTransformation.java\npublic class CurvesTransformation extends TransferTransformation {\n\n    private Curve[] curves = new Curve[1];\n\n    public CurvesTransformation() {\n        curves = new Curve[3];\n        curves[0] = new Curve();\n        curves[1] = new Curve();\n        curves[2] = new Curve();\n    }\n\n    protected void initialize() {\n        initialized = true;\n        if (curves.length == 1)\n            rTable = gTable = bTable = curves[0].makeTable();\n        else {\n            rTable = curves[0].makeTable();\n            gTable = curves[1].makeTable();\n            bTable = curves[2].makeTable();\n        }\n    }\n\n    public void setCurve(Curve curve) {\n        curves = new Curve[] {\n            curve\n        };\n        initialized = false;\n    }\n\n    public void setCurves(Curve[] curves) {\n        if (curves == null || (curves.length != 1 && curves.length != 3))\n            throw new IllegalArgumentException(\"Curves must be length 1 or 3\");\n        this.curves = curves;\n        initialized = false;\n    }\n\n    public Curve[] getCurves() {\n        return curves;\n    }\n\n    public String toString() {\n        return \"Colors/Curves...\";\n    }\n\n    @Override\n    public String key() {\n        return CurvesTransformation.class.getCanonicalName() + \"-\" + curves.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EdgeTransformation.java\npublic class EdgeTransformation extends WholeImageTransformation {\n\t\n\tpublic final static float R2 = (float)Math.sqrt(2);\n\n\tpublic final static float[] ROBERTS_V = {\n\t\t0,  0, -1,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] ROBERTS_H = {\n\t\t-1,  0,  0,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] PREWITT_V = {\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t};\n\tpublic final static float[] PREWITT_H = {\n\t\t-1, -1, -1,\n\t\t0,  0,  0,\n\t\t1,  1,  1,\n\t};\n\tpublic final static float[] SOBEL_V = {\n\t\t-1,  0,  1,\n\t\t-2,  0,  2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] SOBEL_H = {\n\t\t-1, -2, -1,\n\t\t0,  0,  0,\n\t\t1,  2,  1,\n\t};\n\tpublic final static float[] FREI_CHEN_V = {\n\t\t-1,  0,  1,\n\t\t-R2,  0,  R2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] FREI_CHEN_H = {\n\t\t-1, -R2, -1,\n\t\t0,  0,  0,\n\t\t1,  R2,  1,\n\t};\n\n\tprotected float[] vEdgeMatrix = SOBEL_V;\n\tprotected float[] hEdgeMatrix = SOBEL_H;\n\n\tpublic EdgeTransformation() {\n\t}\n\n\tpublic void setVEdgeMatrix(float[] vEdgeMatrix) {\n\t\tthis.vEdgeMatrix = vEdgeMatrix;\n\t}\n\n\tpublic float[] getVEdgeMatrix() {\n\t\treturn vEdgeMatrix;\n\t}\n\n\tpublic void setHEdgeMatrix(float[] hEdgeMatrix) {\n\t\tthis.hEdgeMatrix = hEdgeMatrix;\n\t}\n\n\tpublic float[] getHEdgeMatrix() {\n\t\treturn hEdgeMatrix;\n\t}\n\n\tprotected int[] filterPixels( int width, int height, int[] inPixels, Rect transformedSpace ) {\n\t\tint index = 0;\n\t\tint[] outPixels = new int[width * height];\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tint r = 0, g = 0, b = 0;\n\t\t\t\tint rh = 0, gh = 0, bh = 0;\n\t\t\t\tint rv = 0, gv = 0, bv = 0;\n\t\t\t\tint a = inPixels[y*width+x] & 0xff000000;\n\n\t\t\t\tfor (int row = -1; row <= 1; row++) {\n\t\t\t\t\tint iy = y+row;\n\t\t\t\t\tint ioffset;\n\t\t\t\t\tif (0 <= iy && iy < height)\n\t\t\t\t\t\tioffset = iy*width;\n\t\t\t\t\telse\n\t\t\t\t\t\tioffset = y*width;\n\t\t\t\t\tint moffset = 3*(row+1)+1;\n\t\t\t\t\tfor (int col = -1; col <= 1; col++) {\n\t\t\t\t\t\tint ix = x+col;\n\t\t\t\t\t\tif (!(0 <= ix && ix < width))\n\t\t\t\t\t\t\tix = x;\n\t\t\t\t\t\tint rgb = inPixels[ioffset+ix];\n\t\t\t\t\t\tfloat h = hEdgeMatrix[moffset+col];\n\t\t\t\t\t\tfloat v = vEdgeMatrix[moffset+col];\n\n\t\t\t\t\t\tr = (rgb & 0xff0000) >> 16;\n\t\t\t\t\t\tg = (rgb & 0x00ff00) >> 8;\n\t\t\t\t\t\tb = rgb & 0x0000ff;\n\t\t\t\t\t\trh += (int)(h * r);\n\t\t\t\t\t\tgh += (int)(h * g);\n\t\t\t\t\t\tbh += (int)(h * b);\n\t\t\t\t\t\trv += (int)(v * r);\n\t\t\t\t\t\tgv += (int)(v * g);\n\t\t\t\t\t\tbv += (int)(v * b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = (int)(Math.sqrt(rh*rh + rv*rv) / 1.8);\n\t\t\t\tg = (int)(Math.sqrt(gh*gh + gv*gv) / 1.8);\n\t\t\t\tb = (int)(Math.sqrt(bh*bh + bv*bv) / 1.8);\n\t\t\t\tr = PixelUtils.clamp(r);\n\t\t\t\tg = PixelUtils.clamp(g);\n\t\t\t\tb = PixelUtils.clamp(b);\n\t\t\t\toutPixels[index++] = a | (r << 16) | (g << 8) | b;\n\t\t\t}\n\n\t\t}\n\t\treturn outPixels;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Edges/Detect Edges\";\n\t}\n\n    @Override\n    public String key() {\n        return EdgeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/QuantizeTransformation.java\npublic class QuantizeTransformation extends WholeImageTransformation {\n\n    /**\n     * Floyd-Steinberg dithering matrix.\n     */\n    protected final static int[] matrix = {\n            0, 0, 0, 0, 0, 7, 3, 5, 1,\n    };\n\n    private int sum = 3 + 5 + 7 + 1;\n\n    private boolean dither;\n\n    private int numColors = 256;\n\n    private boolean serpentine = true;\n\n    /**\n     * Set the number of colors to quantize to.\n     * \n     * @param numColors the number of colors. The default is 256.\n     */\n    public void setNumColors(int numColors) {\n        this.numColors = Math.min(Math.max(numColors, 8), 256);\n    }\n\n    /**\n     * Get the number of colors to quantize to.\n     * \n     * @return the number of colors.\n     */\n    public int getNumColors() {\n        return numColors;\n    }\n\n    /**\n     * Set whether to use dithering or not. If not, the image is posterized.\n     * \n     * @param dither true to use dithering\n     */\n    public void setDither(boolean dither) {\n        this.dither = dither;\n    }\n\n    /**\n     * Return the dithering setting\n     * \n     * @return the current setting\n     */\n    public boolean getDither() {\n        return dither;\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine true to use serpentine pattern\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting\n     * \n     * @return the current setting\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    public void quantize(int[] inPixels, int[] outPixels, int width, int height, int numColors, boolean dither, boolean serpentine) {\n        int count = width * height;\n        Quantizer quantizer = new OctTreeQuantizer();\n        quantizer.setup(numColors);\n        quantizer.addPixels(inPixels, 0, count);\n        int[] table = quantizer.buildColorTable();\n\n        if (!dither) {\n            for (int i = 0; i < count; i++)\n                outPixels[i] = table[quantizer.getIndexForColor(inPixels[i])];\n        } else {\n            int index = 0;\n            for (int y = 0; y < height; y++) {\n                boolean reverse = serpentine && (y & 1) == 1;\n                int direction;\n                if (reverse) {\n                    index = y * width + width - 1;\n                    direction = -1;\n                } else {\n                    index = y * width;\n                    direction = 1;\n                }\n                for (int x = 0; x < width; x++) {\n                    int rgb1 = inPixels[index];\n                    int rgb2 = table[quantizer.getIndexForColor(rgb1)];\n\n                    outPixels[index] = rgb2;\n\n                    int r1 = (rgb1 >> 16) & 0xff;\n                    int g1 = (rgb1 >> 8) & 0xff;\n                    int b1 = rgb1 & 0xff;\n\n                    int r2 = (rgb2 >> 16) & 0xff;\n                    int g2 = (rgb2 >> 8) & 0xff;\n                    int b2 = rgb2 & 0xff;\n\n                    int er = r1 - r2;\n                    int eg = g1 - g2;\n                    int eb = b1 - b2;\n\n                    for (int i = -1; i <= 1; i++) {\n                        int iy = i + y;\n                        if (0 <= iy && iy < height) {\n                            for (int j = -1; j <= 1; j++) {\n                                int jx = j + x;\n                                if (0 <= jx && jx < width) {\n                                    int w;\n                                    if (reverse)\n                                        w = matrix[ (i + 1) * 3 - j + 1];\n                                    else\n                                        w = matrix[ (i + 1) * 3 + j + 1];\n                                    if (w != 0) {\n                                        int k = reverse ? index - j : index + j;\n                                        rgb1 = inPixels[k];\n                                        r1 = (rgb1 >> 16) & 0xff;\n                                        g1 = (rgb1 >> 8) & 0xff;\n                                        b1 = rgb1 & 0xff;\n                                        r1 += er * w / sum;\n                                        g1 += eg * w / sum;\n                                        b1 += eb * w / sum;\n                                        inPixels[k] = (PixelUtils.clamp(r1) << 16) | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    index += direction;\n                }\n            }\n        }\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        quantize(inPixels, outPixels, width, height, numColors, dither, serpentine);\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Quantize...\";\n    }\n\n    @Override\n    public String key() {\n        return QuantizeTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\" + dither + \"-\" + numColors + \"-\"\n                + serpentine;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LookupTransformation.java\npublic class LookupTransformation extends PointTransformation {\n\n    private Colormap colormap = new Gradient();\n\n    /**\n     * Construct a LookupFilter.\n     */\n    public LookupTransformation() {\n        canFilterIndexColorModel = true;\n    }\n\n    /**\n     * Construct a LookupFilter.\n     * \n     * @param colormap the color map\n     */\n    public LookupTransformation(Colormap colormap) {\n        canFilterIndexColorModel = true;\n        this.colormap = colormap;\n    }\n\n    /**\n     * Set the colormap to be used for the filter.\n     * \n     * @param colormap the colormap\n     * @see #getColormap\n     */\n    public void setColormap(Colormap colormap) {\n        this.colormap = colormap;\n    }\n\n    /**\n     * Get the colormap to be used for the filter.\n     * \n     * @return the colormap\n     * @see #setColormap\n     */\n    public Colormap getColormap() {\n        return colormap;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        // int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        rgb = (r + g + b) / 3;\n        return colormap.getColor(rgb / 255.0f);\n    }\n\n    public String toString() {\n        return \"Colors/Lookup...\";\n    }\n\n    @Override\n    public String key() {\n        return LookupTransformation.class.getCanonicalName() + \"-\" + colormap.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LevelsTransformation.java\npublic class LevelsTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    private float lowLevel = 0;\n\n    private float highLevel = 1;\n\n    private float lowOutputLevel = 0;\n\n    private float highOutputLevel = 1;\n\n    public LevelsTransformation() {\n    }\n\n    public void setLowLevel(float lowLevel) {\n        this.lowLevel = lowLevel;\n    }\n\n    public float getLowLevel() {\n        return lowLevel;\n    }\n\n    public void setHighLevel(float highLevel) {\n        this.highLevel = highLevel;\n    }\n\n    public float getHighLevel() {\n        return highLevel;\n    }\n\n    public void setLowOutputLevel(float lowOutputLevel) {\n        this.lowOutputLevel = lowOutputLevel;\n    }\n\n    public float getLowOutputLevel() {\n        return lowOutputLevel;\n    }\n\n    public void setHighOutputLevel(float highOutputLevel) {\n        this.highOutputLevel = highOutputLevel;\n    }\n\n    public float getHighOutputLevel() {\n        return highOutputLevel;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            lut = new int[3][256];\n\n            float low = lowLevel * 255;\n            float high = highLevel * 255;\n            if (low == high)\n                high++;\n            for (i = 0; i < 3; i++) {\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = PixelUtils.clamp((int) (255 * (lowOutputLevel + (highOutputLevel - lowOutputLevel) * (j - low)\n                            / (high - low))));\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][ (rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][ (rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Levels...\";\n    }\n\n    @Override\n    public String key() {\n        return LevelsTransformation.class.getCanonicalName() + \"-\" + lowLevel + \"-\" + highLevel + \"-\" + lowOutputLevel + \"-\"\n                + highOutputLevel;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/PosterizeTransformation.java\npublic class PosterizeTransformation extends PointTransformation {\n\n    private int numLevels;\n\n    private int[] levels;\n\n    private boolean initialized = false;\n\n    public PosterizeTransformation() {\n        setNumLevels(6);\n    }\n\n    /**\n     * Set the number of levels in the output image.\n     * \n     * @param numLevels the number of levels\n     * @see #getNumLevels\n     */\n    public void setNumLevels(int numLevels) {\n        this.numLevels = numLevels;\n        initialized = false;\n    }\n\n    /**\n     * Get the number of levels in the output image.\n     * \n     * @return the number of levels\n     * @see #setNumLevels\n     */\n    public int getNumLevels() {\n        return numLevels;\n    }\n\n    /**\n     * Initialize the filter.\n     */\n    protected void initialize() {\n        levels = new int[256];\n        if (numLevels != 1)\n            for (int i = 0; i < 256; i++)\n                levels[i] = 255 * (numLevels * i / 256) / (numLevels - 1);\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (!initialized) {\n            initialized = true;\n            initialize();\n        }\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        r = levels[r];\n        g = levels[g];\n        b = levels[b];\n        return a | (r << 16) | (g << 8) | b;\n    }\n\n    public String toString() {\n        return \"Colors/Posterize...\";\n    }\n\n    @Override\n    public String key() {\n        return PosterizeTransformation.class.getCanonicalName() + \"-\" + numLevels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/DiffusionTransformation.java\npublic class DiffusionTransformation extends WholeImageTransformation {\n\n    private final static int[] diffusionMatrix = { 0, 0, 0, 0, 0, 7, 3, 5, 1, };\n\n    private int[] matrix;\n    private int sum = 3 + 5 + 7 + 1;\n    private boolean serpentine = true;\n    private boolean colorDither = true;\n    private int levels = 6;\n\n    /**\n     * Construct a DiffusionFilter.\n     */\n    public DiffusionTransformation() {\n        setMatrix(diffusionMatrix);\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can\n     * reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine\n     *            true to use serpentine pattern\n     * @see #getSerpentine\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting.\n     * \n     * @return the current setting\n     * @see #setSerpentine\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    /**\n     * Set whether to use a color dither.\n     * \n     * @param colorDither\n     *            true to use a color dither\n     * @see #getColorDither\n     */\n    public void setColorDither(boolean colorDither) {\n        this.colorDither = colorDither;\n    }\n\n    /**\n     * Get whether to use a color dither.\n     * \n     * @return true to use a color dither\n     * @see #setColorDither\n     */\n    public boolean getColorDither() {\n        return colorDither;\n    }\n\n    /**\n     * Set the dither matrix.\n     * \n     * @param matrix\n     *            the dither matrix\n     * @see #getMatrix\n     */\n    public void setMatrix(int[] matrix) {\n        this.matrix = matrix;\n        sum = 0;\n        for (int i = 0; i < matrix.length; i++)\n            sum += matrix[i];\n    }\n\n    /**\n     * Get the dither matrix.\n     * \n     * @return the dither matrix\n     * @see #setMatrix\n     */\n    public int[] getMatrix() {\n        return matrix;\n    }\n\n    /**\n     * Set the number of dither levels.\n     * \n     * @param levels\n     *            the number of levels\n     * @see #getLevels\n     */\n    public void setLevels(int levels) {\n        this.levels = levels;\n    }\n\n    /**\n     * Get the number of dither levels.\n     * \n     * @return the number of levels\n     * @see #setLevels\n     */\n    public int getLevels() {\n        return levels;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        int index = 0;\n        int[] map = new int[levels];\n        for (int i = 0; i < levels; i++) {\n            int v = 255 * i / (levels - 1);\n            map[i] = v;\n        }\n        int[] div = new int[256];\n        for (int i = 0; i < 256; i++)\n            div[i] = levels * i / 256;\n\n        for (int y = 0; y < height; y++) {\n            boolean reverse = serpentine && (y & 1) == 1;\n            int direction;\n            if (reverse) {\n                index = y * width + width - 1;\n                direction = -1;\n            } else {\n                index = y * width;\n                direction = 1;\n            }\n            for (int x = 0; x < width; x++) {\n                int rgb1 = inPixels[index];\n\n                int r1 = (rgb1 >> 16) & 0xff;\n                int g1 = (rgb1 >> 8) & 0xff;\n                int b1 = rgb1 & 0xff;\n\n                if (!colorDither)\n                    r1 = g1 = b1 = (r1 + g1 + b1) / 3;\n\n                int r2 = map[div[r1]];\n                int g2 = map[div[g1]];\n                int b2 = map[div[b1]];\n\n                outPixels[index] = (rgb1 & 0xff000000) | (r2 << 16) | (g2 << 8) | b2;\n\n                int er = r1 - r2;\n                int eg = g1 - g2;\n                int eb = b1 - b2;\n\n                for (int i = -1; i <= 1; i++) {\n                    int iy = i + y;\n                    if (0 <= iy && iy < height) {\n                        for (int j = -1; j <= 1; j++) {\n                            int jx = j + x;\n                            if (0 <= jx && jx < width) {\n                                int w;\n                                if (reverse)\n                                    w = matrix[(i + 1) * 3 - j + 1];\n                                else\n                                    w = matrix[(i + 1) * 3 + j + 1];\n                                if (w != 0) {\n                                    int k = reverse ? index - j : index + j;\n                                    rgb1 = inPixels[k];\n                                    r1 = (rgb1 >> 16) & 0xff;\n                                    g1 = (rgb1 >> 8) & 0xff;\n                                    b1 = rgb1 & 0xff;\n                                    r1 += er * w / sum;\n                                    g1 += eg * w / sum;\n                                    b1 += eb * w / sum;\n                                    inPixels[k] = (inPixels[k] & 0xff000000) | (PixelUtils.clamp(r1) << 16)\n                                            | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                }\n                            }\n                        }\n                    }\n                }\n                index += direction;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Diffusion Dither...\";\n    }\n\n    @Override\n    public String key() {\n        return DiffusionTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\"\n                + serpentine + \"-\" + colorDither + \"-\" + levels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayscaleTransformation.java\npublic class GrayscaleTransformation extends PointTransformation {\n\n\tpublic GrayscaleTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n//\t\trgb = (r + g + b) / 3;\t// simple average\n\t\trgb = (r * 77 + g * 151 + b * 28) >> 8;\t// NTSC luma\n\t\treturn a | (rgb << 16) | (rgb << 8) | rgb;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Grayscale\";\n\t}\n\n    @Override\n    public String key() {\n        return GrayscaleTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/TritoneTransformation.java\npublic class TritoneTransformation extends PointTransformation {\n\n    private int shadowColor = 0xff000000;\n\n    private int midColor = 0xff888888;\n\n    private int highColor = 0xffffffff;\n\n    private int[] lut;\n\n//    public BufferedImage filter(BufferedImage src, BufferedImage dst) {\n//        lut = new int[256];\n//        for (int i = 0; i < 128; i++) {\n//            float t = i / 127.0f;\n//            lut[i] = ImageMath.mixColors(t, shadowColor, midColor);\n//        }\n//        for (int i = 128; i < 256; i++) {\n//            float t = (i - 127) / 128.0f;\n//            lut[i] = ImageMath.mixColors(t, midColor, highColor);\n//        }\n//        dst = super.filter(src, dst);\n//        lut = null;\n//        return dst;\n//    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        return lut[PixelUtils.brightness(rgb)];\n    }\n\n    /**\n     * Set the shadow color.\n     * \n     * @param shadowColor the shadow color\n     * @see #getShadowColor\n     */\n    public void setShadowColor(int shadowColor) {\n        this.shadowColor = shadowColor;\n    }\n\n    /**\n     * Get the shadow color.\n     * \n     * @return the shadow color\n     * @see #setShadowColor\n     */\n    public int getShadowColor() {\n        return shadowColor;\n    }\n\n    /**\n     * Set the mid color.\n     * \n     * @param midColor the mid color\n     * @see #getmidColor\n     */\n    public void setMidColor(int midColor) {\n        this.midColor = midColor;\n    }\n\n    /**\n     * Get the mid color.\n     * \n     * @return the mid color\n     * @see #setmidColor\n     */\n    public int getMidColor() {\n        return midColor;\n    }\n\n    /**\n     * Set the high color.\n     * \n     * @param highColor the high color\n     * @see #gethighColor\n     */\n    public void setHighColor(int highColor) {\n        this.highColor = highColor;\n    }\n\n    /**\n     * Get the high color.\n     * \n     * @return the high color\n     * @see #sethighColor\n     */\n    public int getHighColor() {\n        return highColor;\n    }\n\n    public String toString() {\n        return \"Colors/Tritone...\";\n    }\n\n    @Override\n    public String key() {\n        return TritoneTransformation.class.getCanonicalName() + \"-\" + shadowColor + \"-\" + midColor + \"-\" + highColor;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MirrorTransformation.java\npublic class MirrorTransformation implements Transformation {\n\n    private float opacity = 1.0f;\n\n    private float centreY = 0.5f;\n\n    private float distance;\n\n    private float gap;\n\n    public MirrorTransformation() {\n    }\n\n    public MirrorTransformation setDistance(float distance) {\n        this.distance = distance;\n        return this;\n    }\n\n    public float getDistance() {\n        return distance;\n    }\n\n    public MirrorTransformation setGap(float gap) {\n        this.gap = gap;\n        return this;\n    }\n\n    public float getGap() {\n        return gap;\n    }\n\n    /**\n     * Set the opacity of the reflection.\n     * \n     * @param opacity the opacity.\n     * @see #getOpacity\n     */\n    public MirrorTransformation setOpacity(float opacity) {\n        this.opacity = opacity;\n        return this;\n    }\n\n    /**\n     * Get the opacity of the reflection.\n     * \n     * @return the opacity.\n     * @see #setOpacity\n     */\n    public float getOpacity() {\n        return opacity;\n    }\n\n    public MirrorTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    public float getCentreY() {\n        return centreY;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        int width = source.getWidth();\n        int height = source.getHeight();\n\n        int h = (int) (centreY * height);\n        int d = (int) (gap * height);\n\n        Canvas canvas = new Canvas();\n        Paint paint = new Paint();\n\n        Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n        canvas.setBitmap(bitmap);\n\n        // Set background color\n        canvas.drawColor(Color.BLACK);\n\n        // Draw upper region\n        RectF clipSrcF = new RectF(0, 0, width, height);\n        RectF clipDestF = new RectF(0, 0, width, h);\n        Matrix m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        canvas.drawBitmap(source, m, paint);\n\n        // Draw mirror\n        clipSrcF = new RectF(0, 0, width, height);\n        clipDestF = new RectF(0, h + d, width, height + d);\n        m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        m.preTranslate(0, height);\n        m.preScale(1, -1);\n        canvas.drawBitmap(source, m, paint);\n\n        // Done with source image\n        source.recycle();\n\n        // Draw gradient over mirror\n        RectF clipGradientF = new RectF(0, 0, width, height);\n        m.mapRect(clipGradientF);\n        paint.setShader(new LinearGradient(0, h, 0, height, Color.argb(50, 0, 0, 0), Color.argb((int) (opacity * 255), 0, 1, 0),\n                Shader.TileMode.CLAMP));\n        canvas.drawRect(clipGradientF, paint);\n\n        return bitmap;\n    }\n\n    public String toString() {\n        return \"Effects/Mirror...\";\n    }\n\n    @Override\n    public String key() {\n        return MirrorTransformation.class.getCanonicalName() + \"-\" + opacity + \"-\" + centreY + \"-\" + distance + \"-\" + gap;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayTransformation.java\npublic class GrayTransformation extends PointTransformation {\n\n\tpublic GrayTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n\t\tr = (r+255)/2;\n\t\tg = (g+255)/2;\n\t\tb = (b+255)/2;\n\t\treturn a | (r << 16) | (g << 8) | b;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Gray Out\";\n\t}\n\n    @Override\n    public String key() {\n        return GainTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/SolarizeTransformation.java\npublic class SolarizeTransformation extends TransferTransformation {\n\n    protected float transferFunction(float v) {\n        return v > 0.5f ? 2 * (v - 0.5f) : 2 * (0.5f - v);\n    }\n\n    public String toString() {\n        return \"Colors/Solarize\";\n    }\n\n    @Override\n    public String key() {\n        return SolarizeTransformation.class.getCanonicalName();\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EqualizeTransformation.java\npublic class EqualizeTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    public EqualizeTransformation() {\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            float scale = 255.0f / histogram.getNumSamples();\n            lut = new int[3][256];\n            for (i = 0; i < 3; i++) {\n                lut[i][0] = histogram.getFrequency(i, 0);\n                for (j = 1; j < 256; j++)\n                    lut[i][j] = lut[i][j - 1] + histogram.getFrequency(i, j);\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = (int) Math.round(lut[i][j] * scale);\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    private int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][(rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][(rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Equalize\";\n    }\n\n    @Override\n    public String key() {\n        return EqualizeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/BlurTransformation.java\npublic class BlurTransformation extends ConvolveTransformation {\n \t\n \t/**\n     * A 3x3 convolution kernel for a simple blur.\n     */\n    protected static float[] blurMatrix = {\n\t\t1/14f, 2/14f, 1/14f,\n\t\t2/14f, 2/14f, 2/14f,\n\t\t1/14f, 2/14f, 1/14f\n\t};\n\n\tpublic BlurTransformation() {\n\t\tsuper(blurMatrix);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Blur/Simple Blur\";\n\t}\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MapColorsTransformation.java\npublic class MapColorsTransformation extends PointTransformation {\n\n    private int oldColor;\n\n    private int newColor;\n\n    /**\n     * Construct a MapColorsFilter.\n     */\n    public MapColorsTransformation() {\n        this(0xffffffff, 0xff000000);\n    }\n\n    /**\n     * Construct a MapColorsFilter.\n     * \n     * @param oldColor the color to replace\n     * @param newColor the color to replace it with\n     */\n    public MapColorsTransformation(int oldColor, int newColor) {\n        canFilterIndexColorModel = true;\n        this.oldColor = oldColor;\n        this.newColor = newColor;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (rgb == oldColor)\n            return newColor;\n        return rgb;\n    }\n\n    @Override\n    public String key() {\n        return MapColorsTransformation.class.getCanonicalName() + \"-\" + oldColor + \"-\" + newColor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/HSBAdjustTransformation.java\npublic class HSBAdjustTransformation extends PointTransformation {\n\n    public float hFactor, sFactor, bFactor;\n    private float[] hsb = new float[3];\n    \n    public HSBAdjustTransformation() {\n        this(0, 0, 0);\n    }\n\n    public HSBAdjustTransformation(float r, float g, float b) {\n        hFactor = r;\n        sFactor = g;\n        bFactor = b;\n        canFilterIndexColorModel = true;\n    }\n\n    public HSBAdjustTransformation setHFactor( float hFactor ) {\n        this.hFactor = hFactor;\n        return this;\n    }\n    \n    public float getHFactor() {\n        return hFactor;\n    }\n    \n    public HSBAdjustTransformation setSFactor( float sFactor ) {\n        this.sFactor = sFactor;\n        return this;\n    }\n    \n    public float getSFactor() {\n        return sFactor;\n    }\n    \n    public HSBAdjustTransformation setBFactor( float bFactor ) {\n        this.bFactor = bFactor;\n        return this;\n    }\n    \n    public float getBFactor() {\n        return bFactor;\n    }\n    \n    public int filterRGB(int x, int y, int rgb) {\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        Color.RGBtoHSB(r, g, b, hsb);\n        hsb[0] += hFactor;\n        while (hsb[0] < 0)\n            hsb[0] += Math.PI*2;\n        hsb[1] += sFactor;\n        if (hsb[1] < 0)\n            hsb[1] = 0;\n        else if (hsb[1] > 1.0)\n            hsb[1] = 1.0f;\n        hsb[2] += bFactor;\n        if (hsb[2] < 0)\n            hsb[2] = 0;\n        else if (hsb[2] > 1.0)\n            hsb[2] = 1.0f;\n        rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);\n        return a | (rgb & 0xffffff);\n    }\n\n    public String toString() {\n        return \"Colors/Adjust HSB...\";\n    }\n\n    @Override\n    public String key() {\n        return HSBAdjustTransformation.class.getCanonicalName() + \"-\" + hFactor + \"-\" + sFactor + \"-\" + bFactor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/RescaleTransformation.java\npublic class RescaleTransformation extends TransferTransformation {\n\n    private float scale = 1.0f;\n\n    public RescaleTransformation() {\n    }\n\n    public RescaleTransformation(float scale) {\n        this.scale = scale;\n    }\n\n    protected float transferFunction(float v) {\n        return v * scale;\n    }\n\n    /**\n     * Specifies the scale factor.\n     * \n     * @param scale the scale factor.\n     * @min-value 1\n     * @max-value 5+\n     * @see #getScale\n     */\n    public void setScale(float scale) {\n        this.scale = scale;\n        initialized = false;\n    }\n\n    /**\n     * Returns the scale factor.\n     * \n     * @return the scale factor.\n     * @see #setScale\n     */\n    public float getScale() {\n        return scale;\n    }\n\n    public String toString() {\n        return \"Colors/Rescale...\";\n    }\n\n    @Override\n    public String key() {\n        return RescaleTransformation.class.getCanonicalName() + \"-\" + scale;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/KaleidoscopeTransformation.java\npublic class KaleidoscopeTransformation extends TransformTransformation {\n\n    private float angle = 0;\n\n    private float angle2 = 0;\n\n    private float centreX = 0.5f;\n\n    private float centreY = 0.5f;\n\n    private int sides = 3;\n\n    private float radius = 0;\n\n    private float icentreX;\n\n    private float icentreY;\n\n    /**\n     * Construct a KaleidoscopeFilter with no distortion.\n     */\n    public KaleidoscopeTransformation() {\n        setEdgeAction(CLAMP);\n    }\n\n    /**\n     * Set the number of sides of the kaleidoscope.\n     * \n     * @param sides the number of sides\n     * @min-value 2\n     * @see #getSides\n     */\n    public KaleidoscopeTransformation setSides(int sides) {\n        this.sides = sides;\n        return this;\n    }\n\n    /**\n     * Get the number of sides of the kaleidoscope.\n     * \n     * @return the number of sides\n     * @see #setSides\n     */\n    public int getSides() {\n        return sides;\n    }\n\n    /**\n     * Set the angle of the kaleidoscope.\n     * \n     * @param angle the angle of the kaleidoscope.\n     * @angle\n     * @see #getAngle\n     */\n    public KaleidoscopeTransformation setAngle(float angle) {\n        this.angle = angle;\n        return this;\n    }\n\n    /**\n     * Get the angle of the kaleidoscope.\n     * \n     * @return the angle of the kaleidoscope.\n     * @see #setAngle\n     */\n    public float getAngle() {\n        return angle;\n    }\n\n    /**\n     * Set the secondary angle of the kaleidoscope.\n     * \n     * @param angle2 the angle\n     * @angle\n     * @see #getAngle2\n     */\n    public KaleidoscopeTransformation setAngle2(float angle2) {\n        this.angle2 = angle2;\n        return this;\n    }\n\n    /**\n     * Get the secondary angle of the kaleidoscope.\n     * \n     * @return the angle\n     * @see #setAngle2\n     */\n    public float getAngle2() {\n        return angle2;\n    }\n\n    /**\n     * Set the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @param centreX the center\n     * @see #getCentreX\n     */\n    public KaleidoscopeTransformation setCentreX(float centreX) {\n        this.centreX = centreX;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreX\n     */\n    public float getCentreX() {\n        return centreX;\n    }\n\n    /**\n     * Set the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @param centreY the center\n     * @see #getCentreY\n     */\n    public KaleidoscopeTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreY\n     */\n    public float getCentreY() {\n        return centreY;\n    }\n\n    /**\n     * Set the centre of the effect as a proportion of the image size.\n     * \n     * @param centre the center\n     * @see #getCentre\n     */\n    public KaleidoscopeTransformation setCentre(PointF centre) {\n        this.centreX = centre.x;\n        this.centreY = centre.y;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentre\n     */\n    public PointF getCentre() {\n        return new PointF(centreX, centreY);\n    }\n\n    /**\n     * Set the radius of the effect.\n     * \n     * @param radius the radius\n     * @min-value 0\n     * @see #getRadius\n     */\n    public KaleidoscopeTransformation setRadius(float radius) {\n        this.radius = radius;\n        return this;\n    }\n\n    /**\n     * Get the radius of the effect.\n     * \n     * @return the radius\n     * @see #setRadius\n     */\n    public float getRadius() {\n        return radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        icentreX = source.getWidth() * centreX;\n        icentreY = source.getHeight() * centreY;\n        return super.transform(source);\n    }\n\n    protected void transformInverse(int x, int y, float[] out) {\n        double dx = x - icentreX;\n        double dy = y - icentreY;\n        double r = Math.sqrt(dx * dx + dy * dy);\n        double theta = Math.atan2(dy, dx) - angle - angle2;\n        theta = ImageMath.triangle((float) (theta / Math.PI * sides * .5));\n        if (radius != 0) {\n            double c = Math.cos(theta);\n            double radiusc = radius / c;\n            r = radiusc * ImageMath.triangle((float) (r / radiusc));\n        }\n        theta += angle;\n\n        out[0] = (float) (icentreX + r * Math.cos(theta));\n        out[1] = (float) (icentreY + r * Math.sin(theta));\n    }\n\n    public String toString() {\n        return \"Distort/Kaleidoscope...\";\n    }\n\n    @Override\n    public String key() {\n        return KaleidoscopeTransformation.class.getCanonicalName() + \"-\" + angle + \"-\" + angle2 + \"-\" + centreX + \"-\" + centreY + \"-\"\n                + sides + \"-\" + radius + \"-\" + icentreX + \"-\" + icentreY;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EmbossTransformation.java\npublic class EmbossTransformation extends WholeImageTransformation {\n\n    private final static float pixelScale = 255.9f;\n\n    private float azimuth = 135.0f * ImageMath.PI / 180.0f, elevation = 30.0f * ImageMath.PI / 180f;\n    private boolean emboss = false;\n    private float width45 = 3.0f;\n\n    public EmbossTransformation() {\n    }\n\n    public void setAzimuth(float azimuth) {\n        this.azimuth = azimuth;\n    }\n\n    public float getAzimuth() {\n        return azimuth;\n    }\n\n    public void setElevation(float elevation) {\n        this.elevation = elevation;\n    }\n\n    public float getElevation() {\n        return elevation;\n    }\n\n    public void setBumpHeight(float bumpHeight) {\n        this.width45 = 3 * bumpHeight;\n    }\n\n    public float getBumpHeight() {\n        return width45 / 3;\n    }\n\n    public void setEmboss(boolean emboss) {\n        this.emboss = emboss;\n    }\n\n    public boolean getEmboss() {\n        return emboss;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int index = 0;\n        int[] outPixels = new int[width * height];\n\n        int[] bumpPixels;\n        int bumpMapWidth, bumpMapHeight;\n\n        bumpMapWidth = width;\n        bumpMapHeight = height;\n        bumpPixels = new int[bumpMapWidth * bumpMapHeight];\n        for (int i = 0; i < inPixels.length; i++)\n            bumpPixels[i] = PixelUtils.brightness(inPixels[i]);\n\n        int Nx, Ny, Nz, Lx, Ly, Lz, Nz2, NzLz, NdotL;\n        int shade, background;\n\n        Lx = (int) (Math.cos(azimuth) * Math.cos(elevation) * pixelScale);\n        Ly = (int) (Math.sin(azimuth) * Math.cos(elevation) * pixelScale);\n        Lz = (int) (Math.sin(elevation) * pixelScale);\n\n        Nz = (int) (6 * 255 / width45);\n        Nz2 = Nz * Nz;\n        NzLz = Nz * Lz;\n\n        background = Lz;\n\n        int bumpIndex = 0;\n\n        for (int y = 0; y < height; y++, bumpIndex += bumpMapWidth) {\n            int s1 = bumpIndex;\n            int s2 = s1 + bumpMapWidth;\n            int s3 = s2 + bumpMapWidth;\n\n            for (int x = 0; x < width; x++, s1++, s2++, s3++) {\n                if (y != 0 && y < height - 2 && x != 0 && x < width - 2) {\n                    Nx = bumpPixels[s1 - 1] + bumpPixels[s2 - 1] + bumpPixels[s3 - 1] - bumpPixels[s1 + 1]\n                            - bumpPixels[s2 + 1] - bumpPixels[s3 + 1];\n                    Ny = bumpPixels[s3 - 1] + bumpPixels[s3] + bumpPixels[s3 + 1] - bumpPixels[s1 - 1] - bumpPixels[s1]\n                            - bumpPixels[s1 + 1];\n\n                    if (Nx == 0 && Ny == 0)\n                        shade = background;\n                    else if ((NdotL = Nx * Lx + Ny * Ly + NzLz) < 0)\n                        shade = 0;\n                    else\n                        shade = (int) (NdotL / Math.sqrt(Nx * Nx + Ny * Ny + Nz2));\n                } else\n                    shade = background;\n\n                if (emboss) {\n                    int rgb = inPixels[index];\n                    int a = rgb & 0xff000000;\n                    int r = (rgb >> 16) & 0xff;\n                    int g = (rgb >> 8) & 0xff;\n                    int b = rgb & 0xff;\n                    r = (r * shade) >> 8;\n                    g = (g * shade) >> 8;\n                    b = (b * shade) >> 8;\n                    outPixels[index++] = a | (r << 16) | (g << 8) | b;\n                } else\n                    outPixels[index++] = 0xff000000 | (shade << 16) | (shade << 8) | shade;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Stylize/Emboss...\";\n    }\n\n    @Override\n    public String key() {\n        return EmbossTransformation.class.getCanonicalName() + \"-\" + pixelScale + \"-\" + azimuth + \"-\" + elevation + \"-\"\n                + emboss + \"-\" + width45;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/renderscript/RSGaussianBlurTransformation.java\npublic class RSGaussianBlurTransformation implements Transformation {\n\n    private Context mContext;\n\n    private int mRadius;\n    \n    /**\n     * Constructor.\n     * \n     * @param context The context.\n     * @param radius The blur radius: (0, 25]\n     */\n    public RSGaussianBlurTransformation(Context context, int radius) {\n        mContext = context;\n        mRadius = radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        if (Build.VERSION.SDK_INT < 17) {\n            return source;\n        }\n        \n        RenderScript rs = RenderScript.create(mContext);\n        Allocation input = Allocation.createFromBitmap(rs, source, Allocation.MipmapControl.MIPMAP_NONE, Allocation.USAGE_SCRIPT);\n        Allocation output = Allocation.createTyped(rs, input.getType());\n        ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\n        script.setRadius(mRadius);\n        script.setInput(input);\n        script.forEach(output);\n        output.copyTo(source);\n        return source;\n    }\n\n    @Override\n    public String key() {\n        return RSGaussianBlurTransformation.class.getCanonicalName() + \"-\" + mRadius;\n    }\n\n}\nimport java.util.Arrays;\nimport java.util.List;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport com.picassotransformations.StackBlurTransformation;\nimport com.picassotransformations.jhlabs.BlockTransformation;\nimport com.picassotransformations.jhlabs.BlurTransformation;\nimport com.picassotransformations.jhlabs.ChannelMixTransformation;\nimport com.picassotransformations.jhlabs.ContrastTransformation;\nimport com.picassotransformations.jhlabs.CurvesTransformation;\nimport com.picassotransformations.jhlabs.DiffusionTransformation;\nimport com.picassotransformations.jhlabs.DitherTransformation;\nimport com.picassotransformations.jhlabs.EdgeTransformation;\nimport com.picassotransformations.jhlabs.EmbossTransformation;\nimport com.picassotransformations.jhlabs.EqualizeTransformation;\nimport com.picassotransformations.jhlabs.ExposureTransformation;\nimport com.picassotransformations.jhlabs.GainTransformation;\nimport com.picassotransformations.jhlabs.GrayTransformation;\nimport com.picassotransformations.jhlabs.GrayscaleTransformation;\nimport com.picassotransformations.jhlabs.HSBAdjustTransformation;\nimport com.picassotransformations.jhlabs.InvertTransformation;\nimport com.picassotransformations.jhlabs.KaleidoscopeTransformation;\nimport com.picassotransformations.jhlabs.LevelsTransformation;\nimport com.picassotransformations.jhlabs.LookupTransformation;\nimport com.picassotransformations.jhlabs.MapColorsTransformation;\nimport com.picassotransformations.jhlabs.MarbleTransformation;\nimport com.picassotransformations.jhlabs.MaskTransformation;\nimport com.picassotransformations.jhlabs.MirrorTransformation;\nimport com.picassotransformations.jhlabs.PolarTransformation;\nimport com.picassotransformations.jhlabs.PosterizeTransformation;\nimport com.picassotransformations.jhlabs.QuantizeTransformation;\nimport com.picassotransformations.jhlabs.RGBAdjustTransformation;\nimport com.picassotransformations.jhlabs.RescaleTransformation;\nimport com.picassotransformations.jhlabs.SolarizeTransformation;\nimport com.picassotransformations.jhlabs.ThresholdTransformation;\nimport com.picassotransformations.jhlabs.TritoneTransformation;\nimport com.picassotransformations.renderscript.RSGaussianBlurTransformation;\nimport com.squareup.picasso.Transformation;\n/*\n * Copyright (C) 2014 Tanner Perrien\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.picassotransformations;\n\n\n\n\n\npublic enum TransformationCategory implements Parcelable {\n\n    COLOR_ADJUSTMENT(\"Color Adjustment\",\n            Arrays.asList(\n                    new ChannelMixTransformation(),\n                    new ContrastTransformation().setBrightness(.7f).setContrast(.5f),\n                    new CurvesTransformation(),\n                    new DiffusionTransformation(),\n                    new DitherTransformation(),\n                    new ExposureTransformation(),\n                    new GainTransformation(),\n                    new GrayTransformation(),\n                    new GrayscaleTransformation(),Next line of code:\n", "input": "import java.util.Arrays;\nimport java.util.List;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport com.picassotransformations.StackBlurTransformation;\nimport com.picassotransformations.jhlabs.BlockTransformation;\nimport com.picassotransformations.jhlabs.BlurTransformation;\nimport com.picassotransformations.jhlabs.ChannelMixTransformation;\nimport com.picassotransformations.jhlabs.ContrastTransformation;\nimport com.picassotransformations.jhlabs.CurvesTransformation;\nimport com.picassotransformations.jhlabs.DiffusionTransformation;\nimport com.picassotransformations.jhlabs.DitherTransformation;\nimport com.picassotransformations.jhlabs.EdgeTransformation;\nimport com.picassotransformations.jhlabs.EmbossTransformation;\nimport com.picassotransformations.jhlabs.EqualizeTransformation;\nimport com.picassotransformations.jhlabs.ExposureTransformation;\nimport com.picassotransformations.jhlabs.GainTransformation;\nimport com.picassotransformations.jhlabs.GrayTransformation;\nimport com.picassotransformations.jhlabs.GrayscaleTransformation;\nimport com.picassotransformations.jhlabs.HSBAdjustTransformation;\nimport com.picassotransformations.jhlabs.InvertTransformation;\nimport com.picassotransformations.jhlabs.KaleidoscopeTransformation;\nimport com.picassotransformations.jhlabs.LevelsTransformation;\nimport com.picassotransformations.jhlabs.LookupTransformation;\nimport com.picassotransformations.jhlabs.MapColorsTransformation;\nimport com.picassotransformations.jhlabs.MarbleTransformation;\nimport com.picassotransformations.jhlabs.MaskTransformation;\nimport com.picassotransformations.jhlabs.MirrorTransformation;\nimport com.picassotransformations.jhlabs.PolarTransformation;\nimport com.picassotransformations.jhlabs.PosterizeTransformation;\nimport com.picassotransformations.jhlabs.QuantizeTransformation;\nimport com.picassotransformations.jhlabs.RGBAdjustTransformation;\nimport com.picassotransformations.jhlabs.RescaleTransformation;\nimport com.picassotransformations.jhlabs.SolarizeTransformation;\nimport com.picassotransformations.jhlabs.ThresholdTransformation;\nimport com.picassotransformations.jhlabs.TritoneTransformation;\nimport com.picassotransformations.renderscript.RSGaussianBlurTransformation;\nimport com.squareup.picasso.Transformation;\n/*\n * Copyright (C) 2014 Tanner Perrien\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.picassotransformations;\n\n\n\n\n\npublic enum TransformationCategory implements Parcelable {\n\n    COLOR_ADJUSTMENT(\"Color Adjustment\",\n            Arrays.asList(\n                    new ChannelMixTransformation(),\n                    new ContrastTransformation().setBrightness(.7f).setContrast(.5f),\n                    new CurvesTransformation(),\n                    new DiffusionTransformation(),\n                    new DitherTransformation(),\n                    new ExposureTransformation(),\n                    new GainTransformation(),\n                    new GrayTransformation(),\n                    new GrayscaleTransformation(),", "context": "picasso-transformations/src/main/java/com/picassotransformations/jhlabs/ExposureTransformation.java\npublic class ExposureTransformation extends TransferTransformation {\n\n    private float exposure = 1.0f;\n\n    protected float transferFunction(float f) {\n        return 1 - (float) Math.exp(-f * exposure);\n    }\n\n    /**\n     * Set the exposure level.\n     * \n     * @param exposure the exposure level\n     * @min-value 0\n     * @max-value 5+\n     * @see #getExposure\n     */\n    public void setExposure(float exposure) {\n        this.exposure = exposure;\n        initialized = false;\n    }\n\n    /**\n     * Get the exposure level.\n     * \n     * @return the exposure level\n     * @see #setExposure\n     */\n    public float getExposure() {\n        return exposure;\n    }\n\n    public String toString() {\n        return \"Colors/Exposure...\";\n    }\n\n    @Override\n    public String key() {\n        return ExposureTransformation.class.getCanonicalName() + \"-\" + exposure;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/CurvesTransformation.java\npublic class CurvesTransformation extends TransferTransformation {\n\n    private Curve[] curves = new Curve[1];\n\n    public CurvesTransformation() {\n        curves = new Curve[3];\n        curves[0] = new Curve();\n        curves[1] = new Curve();\n        curves[2] = new Curve();\n    }\n\n    protected void initialize() {\n        initialized = true;\n        if (curves.length == 1)\n            rTable = gTable = bTable = curves[0].makeTable();\n        else {\n            rTable = curves[0].makeTable();\n            gTable = curves[1].makeTable();\n            bTable = curves[2].makeTable();\n        }\n    }\n\n    public void setCurve(Curve curve) {\n        curves = new Curve[] {\n            curve\n        };\n        initialized = false;\n    }\n\n    public void setCurves(Curve[] curves) {\n        if (curves == null || (curves.length != 1 && curves.length != 3))\n            throw new IllegalArgumentException(\"Curves must be length 1 or 3\");\n        this.curves = curves;\n        initialized = false;\n    }\n\n    public Curve[] getCurves() {\n        return curves;\n    }\n\n    public String toString() {\n        return \"Colors/Curves...\";\n    }\n\n    @Override\n    public String key() {\n        return CurvesTransformation.class.getCanonicalName() + \"-\" + curves.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EdgeTransformation.java\npublic class EdgeTransformation extends WholeImageTransformation {\n\t\n\tpublic final static float R2 = (float)Math.sqrt(2);\n\n\tpublic final static float[] ROBERTS_V = {\n\t\t0,  0, -1,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] ROBERTS_H = {\n\t\t-1,  0,  0,\n\t\t0,  1,  0,\n\t\t0,  0,  0,\n\t};\n\tpublic final static float[] PREWITT_V = {\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t\t-1,  0,  1,\n\t};\n\tpublic final static float[] PREWITT_H = {\n\t\t-1, -1, -1,\n\t\t0,  0,  0,\n\t\t1,  1,  1,\n\t};\n\tpublic final static float[] SOBEL_V = {\n\t\t-1,  0,  1,\n\t\t-2,  0,  2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] SOBEL_H = {\n\t\t-1, -2, -1,\n\t\t0,  0,  0,\n\t\t1,  2,  1,\n\t};\n\tpublic final static float[] FREI_CHEN_V = {\n\t\t-1,  0,  1,\n\t\t-R2,  0,  R2,\n\t\t-1,  0,  1,\n\t};\n\tpublic static float[] FREI_CHEN_H = {\n\t\t-1, -R2, -1,\n\t\t0,  0,  0,\n\t\t1,  R2,  1,\n\t};\n\n\tprotected float[] vEdgeMatrix = SOBEL_V;\n\tprotected float[] hEdgeMatrix = SOBEL_H;\n\n\tpublic EdgeTransformation() {\n\t}\n\n\tpublic void setVEdgeMatrix(float[] vEdgeMatrix) {\n\t\tthis.vEdgeMatrix = vEdgeMatrix;\n\t}\n\n\tpublic float[] getVEdgeMatrix() {\n\t\treturn vEdgeMatrix;\n\t}\n\n\tpublic void setHEdgeMatrix(float[] hEdgeMatrix) {\n\t\tthis.hEdgeMatrix = hEdgeMatrix;\n\t}\n\n\tpublic float[] getHEdgeMatrix() {\n\t\treturn hEdgeMatrix;\n\t}\n\n\tprotected int[] filterPixels( int width, int height, int[] inPixels, Rect transformedSpace ) {\n\t\tint index = 0;\n\t\tint[] outPixels = new int[width * height];\n\n\t\tfor (int y = 0; y < height; y++) {\n\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\tint r = 0, g = 0, b = 0;\n\t\t\t\tint rh = 0, gh = 0, bh = 0;\n\t\t\t\tint rv = 0, gv = 0, bv = 0;\n\t\t\t\tint a = inPixels[y*width+x] & 0xff000000;\n\n\t\t\t\tfor (int row = -1; row <= 1; row++) {\n\t\t\t\t\tint iy = y+row;\n\t\t\t\t\tint ioffset;\n\t\t\t\t\tif (0 <= iy && iy < height)\n\t\t\t\t\t\tioffset = iy*width;\n\t\t\t\t\telse\n\t\t\t\t\t\tioffset = y*width;\n\t\t\t\t\tint moffset = 3*(row+1)+1;\n\t\t\t\t\tfor (int col = -1; col <= 1; col++) {\n\t\t\t\t\t\tint ix = x+col;\n\t\t\t\t\t\tif (!(0 <= ix && ix < width))\n\t\t\t\t\t\t\tix = x;\n\t\t\t\t\t\tint rgb = inPixels[ioffset+ix];\n\t\t\t\t\t\tfloat h = hEdgeMatrix[moffset+col];\n\t\t\t\t\t\tfloat v = vEdgeMatrix[moffset+col];\n\n\t\t\t\t\t\tr = (rgb & 0xff0000) >> 16;\n\t\t\t\t\t\tg = (rgb & 0x00ff00) >> 8;\n\t\t\t\t\t\tb = rgb & 0x0000ff;\n\t\t\t\t\t\trh += (int)(h * r);\n\t\t\t\t\t\tgh += (int)(h * g);\n\t\t\t\t\t\tbh += (int)(h * b);\n\t\t\t\t\t\trv += (int)(v * r);\n\t\t\t\t\t\tgv += (int)(v * g);\n\t\t\t\t\t\tbv += (int)(v * b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = (int)(Math.sqrt(rh*rh + rv*rv) / 1.8);\n\t\t\t\tg = (int)(Math.sqrt(gh*gh + gv*gv) / 1.8);\n\t\t\t\tb = (int)(Math.sqrt(bh*bh + bv*bv) / 1.8);\n\t\t\t\tr = PixelUtils.clamp(r);\n\t\t\t\tg = PixelUtils.clamp(g);\n\t\t\t\tb = PixelUtils.clamp(b);\n\t\t\t\toutPixels[index++] = a | (r << 16) | (g << 8) | b;\n\t\t\t}\n\n\t\t}\n\t\treturn outPixels;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Edges/Detect Edges\";\n\t}\n\n    @Override\n    public String key() {\n        return EdgeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/QuantizeTransformation.java\npublic class QuantizeTransformation extends WholeImageTransformation {\n\n    /**\n     * Floyd-Steinberg dithering matrix.\n     */\n    protected final static int[] matrix = {\n            0, 0, 0, 0, 0, 7, 3, 5, 1,\n    };\n\n    private int sum = 3 + 5 + 7 + 1;\n\n    private boolean dither;\n\n    private int numColors = 256;\n\n    private boolean serpentine = true;\n\n    /**\n     * Set the number of colors to quantize to.\n     * \n     * @param numColors the number of colors. The default is 256.\n     */\n    public void setNumColors(int numColors) {\n        this.numColors = Math.min(Math.max(numColors, 8), 256);\n    }\n\n    /**\n     * Get the number of colors to quantize to.\n     * \n     * @return the number of colors.\n     */\n    public int getNumColors() {\n        return numColors;\n    }\n\n    /**\n     * Set whether to use dithering or not. If not, the image is posterized.\n     * \n     * @param dither true to use dithering\n     */\n    public void setDither(boolean dither) {\n        this.dither = dither;\n    }\n\n    /**\n     * Return the dithering setting\n     * \n     * @return the current setting\n     */\n    public boolean getDither() {\n        return dither;\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine true to use serpentine pattern\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting\n     * \n     * @return the current setting\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    public void quantize(int[] inPixels, int[] outPixels, int width, int height, int numColors, boolean dither, boolean serpentine) {\n        int count = width * height;\n        Quantizer quantizer = new OctTreeQuantizer();\n        quantizer.setup(numColors);\n        quantizer.addPixels(inPixels, 0, count);\n        int[] table = quantizer.buildColorTable();\n\n        if (!dither) {\n            for (int i = 0; i < count; i++)\n                outPixels[i] = table[quantizer.getIndexForColor(inPixels[i])];\n        } else {\n            int index = 0;\n            for (int y = 0; y < height; y++) {\n                boolean reverse = serpentine && (y & 1) == 1;\n                int direction;\n                if (reverse) {\n                    index = y * width + width - 1;\n                    direction = -1;\n                } else {\n                    index = y * width;\n                    direction = 1;\n                }\n                for (int x = 0; x < width; x++) {\n                    int rgb1 = inPixels[index];\n                    int rgb2 = table[quantizer.getIndexForColor(rgb1)];\n\n                    outPixels[index] = rgb2;\n\n                    int r1 = (rgb1 >> 16) & 0xff;\n                    int g1 = (rgb1 >> 8) & 0xff;\n                    int b1 = rgb1 & 0xff;\n\n                    int r2 = (rgb2 >> 16) & 0xff;\n                    int g2 = (rgb2 >> 8) & 0xff;\n                    int b2 = rgb2 & 0xff;\n\n                    int er = r1 - r2;\n                    int eg = g1 - g2;\n                    int eb = b1 - b2;\n\n                    for (int i = -1; i <= 1; i++) {\n                        int iy = i + y;\n                        if (0 <= iy && iy < height) {\n                            for (int j = -1; j <= 1; j++) {\n                                int jx = j + x;\n                                if (0 <= jx && jx < width) {\n                                    int w;\n                                    if (reverse)\n                                        w = matrix[ (i + 1) * 3 - j + 1];\n                                    else\n                                        w = matrix[ (i + 1) * 3 + j + 1];\n                                    if (w != 0) {\n                                        int k = reverse ? index - j : index + j;\n                                        rgb1 = inPixels[k];\n                                        r1 = (rgb1 >> 16) & 0xff;\n                                        g1 = (rgb1 >> 8) & 0xff;\n                                        b1 = rgb1 & 0xff;\n                                        r1 += er * w / sum;\n                                        g1 += eg * w / sum;\n                                        b1 += eb * w / sum;\n                                        inPixels[k] = (PixelUtils.clamp(r1) << 16) | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    index += direction;\n                }\n            }\n        }\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        quantize(inPixels, outPixels, width, height, numColors, dither, serpentine);\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Quantize...\";\n    }\n\n    @Override\n    public String key() {\n        return QuantizeTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\" + dither + \"-\" + numColors + \"-\"\n                + serpentine;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LookupTransformation.java\npublic class LookupTransformation extends PointTransformation {\n\n    private Colormap colormap = new Gradient();\n\n    /**\n     * Construct a LookupFilter.\n     */\n    public LookupTransformation() {\n        canFilterIndexColorModel = true;\n    }\n\n    /**\n     * Construct a LookupFilter.\n     * \n     * @param colormap the color map\n     */\n    public LookupTransformation(Colormap colormap) {\n        canFilterIndexColorModel = true;\n        this.colormap = colormap;\n    }\n\n    /**\n     * Set the colormap to be used for the filter.\n     * \n     * @param colormap the colormap\n     * @see #getColormap\n     */\n    public void setColormap(Colormap colormap) {\n        this.colormap = colormap;\n    }\n\n    /**\n     * Get the colormap to be used for the filter.\n     * \n     * @return the colormap\n     * @see #setColormap\n     */\n    public Colormap getColormap() {\n        return colormap;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        // int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        rgb = (r + g + b) / 3;\n        return colormap.getColor(rgb / 255.0f);\n    }\n\n    public String toString() {\n        return \"Colors/Lookup...\";\n    }\n\n    @Override\n    public String key() {\n        return LookupTransformation.class.getCanonicalName() + \"-\" + colormap.hashCode();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/LevelsTransformation.java\npublic class LevelsTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    private float lowLevel = 0;\n\n    private float highLevel = 1;\n\n    private float lowOutputLevel = 0;\n\n    private float highOutputLevel = 1;\n\n    public LevelsTransformation() {\n    }\n\n    public void setLowLevel(float lowLevel) {\n        this.lowLevel = lowLevel;\n    }\n\n    public float getLowLevel() {\n        return lowLevel;\n    }\n\n    public void setHighLevel(float highLevel) {\n        this.highLevel = highLevel;\n    }\n\n    public float getHighLevel() {\n        return highLevel;\n    }\n\n    public void setLowOutputLevel(float lowOutputLevel) {\n        this.lowOutputLevel = lowOutputLevel;\n    }\n\n    public float getLowOutputLevel() {\n        return lowOutputLevel;\n    }\n\n    public void setHighOutputLevel(float highOutputLevel) {\n        this.highOutputLevel = highOutputLevel;\n    }\n\n    public float getHighOutputLevel() {\n        return highOutputLevel;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            lut = new int[3][256];\n\n            float low = lowLevel * 255;\n            float high = highLevel * 255;\n            if (low == high)\n                high++;\n            for (i = 0; i < 3; i++) {\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = PixelUtils.clamp((int) (255 * (lowOutputLevel + (highOutputLevel - lowOutputLevel) * (j - low)\n                            / (high - low))));\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][ (rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][ (rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Levels...\";\n    }\n\n    @Override\n    public String key() {\n        return LevelsTransformation.class.getCanonicalName() + \"-\" + lowLevel + \"-\" + highLevel + \"-\" + lowOutputLevel + \"-\"\n                + highOutputLevel;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/PosterizeTransformation.java\npublic class PosterizeTransformation extends PointTransformation {\n\n    private int numLevels;\n\n    private int[] levels;\n\n    private boolean initialized = false;\n\n    public PosterizeTransformation() {\n        setNumLevels(6);\n    }\n\n    /**\n     * Set the number of levels in the output image.\n     * \n     * @param numLevels the number of levels\n     * @see #getNumLevels\n     */\n    public void setNumLevels(int numLevels) {\n        this.numLevels = numLevels;\n        initialized = false;\n    }\n\n    /**\n     * Get the number of levels in the output image.\n     * \n     * @return the number of levels\n     * @see #setNumLevels\n     */\n    public int getNumLevels() {\n        return numLevels;\n    }\n\n    /**\n     * Initialize the filter.\n     */\n    protected void initialize() {\n        levels = new int[256];\n        if (numLevels != 1)\n            for (int i = 0; i < 256; i++)\n                levels[i] = 255 * (numLevels * i / 256) / (numLevels - 1);\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (!initialized) {\n            initialized = true;\n            initialize();\n        }\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        r = levels[r];\n        g = levels[g];\n        b = levels[b];\n        return a | (r << 16) | (g << 8) | b;\n    }\n\n    public String toString() {\n        return \"Colors/Posterize...\";\n    }\n\n    @Override\n    public String key() {\n        return PosterizeTransformation.class.getCanonicalName() + \"-\" + numLevels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/DiffusionTransformation.java\npublic class DiffusionTransformation extends WholeImageTransformation {\n\n    private final static int[] diffusionMatrix = { 0, 0, 0, 0, 0, 7, 3, 5, 1, };\n\n    private int[] matrix;\n    private int sum = 3 + 5 + 7 + 1;\n    private boolean serpentine = true;\n    private boolean colorDither = true;\n    private int levels = 6;\n\n    /**\n     * Construct a DiffusionFilter.\n     */\n    public DiffusionTransformation() {\n        setMatrix(diffusionMatrix);\n    }\n\n    /**\n     * Set whether to use a serpentine pattern for return or not. This can\n     * reduce 'avalanche' artifacts in the output.\n     * \n     * @param serpentine\n     *            true to use serpentine pattern\n     * @see #getSerpentine\n     */\n    public void setSerpentine(boolean serpentine) {\n        this.serpentine = serpentine;\n    }\n\n    /**\n     * Return the serpentine setting.\n     * \n     * @return the current setting\n     * @see #setSerpentine\n     */\n    public boolean getSerpentine() {\n        return serpentine;\n    }\n\n    /**\n     * Set whether to use a color dither.\n     * \n     * @param colorDither\n     *            true to use a color dither\n     * @see #getColorDither\n     */\n    public void setColorDither(boolean colorDither) {\n        this.colorDither = colorDither;\n    }\n\n    /**\n     * Get whether to use a color dither.\n     * \n     * @return true to use a color dither\n     * @see #setColorDither\n     */\n    public boolean getColorDither() {\n        return colorDither;\n    }\n\n    /**\n     * Set the dither matrix.\n     * \n     * @param matrix\n     *            the dither matrix\n     * @see #getMatrix\n     */\n    public void setMatrix(int[] matrix) {\n        this.matrix = matrix;\n        sum = 0;\n        for (int i = 0; i < matrix.length; i++)\n            sum += matrix[i];\n    }\n\n    /**\n     * Get the dither matrix.\n     * \n     * @return the dither matrix\n     * @see #setMatrix\n     */\n    public int[] getMatrix() {\n        return matrix;\n    }\n\n    /**\n     * Set the number of dither levels.\n     * \n     * @param levels\n     *            the number of levels\n     * @see #getLevels\n     */\n    public void setLevels(int levels) {\n        this.levels = levels;\n    }\n\n    /**\n     * Get the number of dither levels.\n     * \n     * @return the number of levels\n     * @see #setLevels\n     */\n    public int getLevels() {\n        return levels;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int[] outPixels = new int[width * height];\n\n        int index = 0;\n        int[] map = new int[levels];\n        for (int i = 0; i < levels; i++) {\n            int v = 255 * i / (levels - 1);\n            map[i] = v;\n        }\n        int[] div = new int[256];\n        for (int i = 0; i < 256; i++)\n            div[i] = levels * i / 256;\n\n        for (int y = 0; y < height; y++) {\n            boolean reverse = serpentine && (y & 1) == 1;\n            int direction;\n            if (reverse) {\n                index = y * width + width - 1;\n                direction = -1;\n            } else {\n                index = y * width;\n                direction = 1;\n            }\n            for (int x = 0; x < width; x++) {\n                int rgb1 = inPixels[index];\n\n                int r1 = (rgb1 >> 16) & 0xff;\n                int g1 = (rgb1 >> 8) & 0xff;\n                int b1 = rgb1 & 0xff;\n\n                if (!colorDither)\n                    r1 = g1 = b1 = (r1 + g1 + b1) / 3;\n\n                int r2 = map[div[r1]];\n                int g2 = map[div[g1]];\n                int b2 = map[div[b1]];\n\n                outPixels[index] = (rgb1 & 0xff000000) | (r2 << 16) | (g2 << 8) | b2;\n\n                int er = r1 - r2;\n                int eg = g1 - g2;\n                int eb = b1 - b2;\n\n                for (int i = -1; i <= 1; i++) {\n                    int iy = i + y;\n                    if (0 <= iy && iy < height) {\n                        for (int j = -1; j <= 1; j++) {\n                            int jx = j + x;\n                            if (0 <= jx && jx < width) {\n                                int w;\n                                if (reverse)\n                                    w = matrix[(i + 1) * 3 - j + 1];\n                                else\n                                    w = matrix[(i + 1) * 3 + j + 1];\n                                if (w != 0) {\n                                    int k = reverse ? index - j : index + j;\n                                    rgb1 = inPixels[k];\n                                    r1 = (rgb1 >> 16) & 0xff;\n                                    g1 = (rgb1 >> 8) & 0xff;\n                                    b1 = rgb1 & 0xff;\n                                    r1 += er * w / sum;\n                                    g1 += eg * w / sum;\n                                    b1 += eb * w / sum;\n                                    inPixels[k] = (inPixels[k] & 0xff000000) | (PixelUtils.clamp(r1) << 16)\n                                            | (PixelUtils.clamp(g1) << 8) | PixelUtils.clamp(b1);\n                                }\n                            }\n                        }\n                    }\n                }\n                index += direction;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Colors/Diffusion Dither...\";\n    }\n\n    @Override\n    public String key() {\n        return DiffusionTransformation.class.getCanonicalName() + \"-\" + matrix.hashCode() + \"-\" + sum + \"-\"\n                + serpentine + \"-\" + colorDither + \"-\" + levels;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayscaleTransformation.java\npublic class GrayscaleTransformation extends PointTransformation {\n\n\tpublic GrayscaleTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n//\t\trgb = (r + g + b) / 3;\t// simple average\n\t\trgb = (r * 77 + g * 151 + b * 28) >> 8;\t// NTSC luma\n\t\treturn a | (rgb << 16) | (rgb << 8) | rgb;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Grayscale\";\n\t}\n\n    @Override\n    public String key() {\n        return GrayscaleTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/TritoneTransformation.java\npublic class TritoneTransformation extends PointTransformation {\n\n    private int shadowColor = 0xff000000;\n\n    private int midColor = 0xff888888;\n\n    private int highColor = 0xffffffff;\n\n    private int[] lut;\n\n//    public BufferedImage filter(BufferedImage src, BufferedImage dst) {\n//        lut = new int[256];\n//        for (int i = 0; i < 128; i++) {\n//            float t = i / 127.0f;\n//            lut[i] = ImageMath.mixColors(t, shadowColor, midColor);\n//        }\n//        for (int i = 128; i < 256; i++) {\n//            float t = (i - 127) / 128.0f;\n//            lut[i] = ImageMath.mixColors(t, midColor, highColor);\n//        }\n//        dst = super.filter(src, dst);\n//        lut = null;\n//        return dst;\n//    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        return lut[PixelUtils.brightness(rgb)];\n    }\n\n    /**\n     * Set the shadow color.\n     * \n     * @param shadowColor the shadow color\n     * @see #getShadowColor\n     */\n    public void setShadowColor(int shadowColor) {\n        this.shadowColor = shadowColor;\n    }\n\n    /**\n     * Get the shadow color.\n     * \n     * @return the shadow color\n     * @see #setShadowColor\n     */\n    public int getShadowColor() {\n        return shadowColor;\n    }\n\n    /**\n     * Set the mid color.\n     * \n     * @param midColor the mid color\n     * @see #getmidColor\n     */\n    public void setMidColor(int midColor) {\n        this.midColor = midColor;\n    }\n\n    /**\n     * Get the mid color.\n     * \n     * @return the mid color\n     * @see #setmidColor\n     */\n    public int getMidColor() {\n        return midColor;\n    }\n\n    /**\n     * Set the high color.\n     * \n     * @param highColor the high color\n     * @see #gethighColor\n     */\n    public void setHighColor(int highColor) {\n        this.highColor = highColor;\n    }\n\n    /**\n     * Get the high color.\n     * \n     * @return the high color\n     * @see #sethighColor\n     */\n    public int getHighColor() {\n        return highColor;\n    }\n\n    public String toString() {\n        return \"Colors/Tritone...\";\n    }\n\n    @Override\n    public String key() {\n        return TritoneTransformation.class.getCanonicalName() + \"-\" + shadowColor + \"-\" + midColor + \"-\" + highColor;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MirrorTransformation.java\npublic class MirrorTransformation implements Transformation {\n\n    private float opacity = 1.0f;\n\n    private float centreY = 0.5f;\n\n    private float distance;\n\n    private float gap;\n\n    public MirrorTransformation() {\n    }\n\n    public MirrorTransformation setDistance(float distance) {\n        this.distance = distance;\n        return this;\n    }\n\n    public float getDistance() {\n        return distance;\n    }\n\n    public MirrorTransformation setGap(float gap) {\n        this.gap = gap;\n        return this;\n    }\n\n    public float getGap() {\n        return gap;\n    }\n\n    /**\n     * Set the opacity of the reflection.\n     * \n     * @param opacity the opacity.\n     * @see #getOpacity\n     */\n    public MirrorTransformation setOpacity(float opacity) {\n        this.opacity = opacity;\n        return this;\n    }\n\n    /**\n     * Get the opacity of the reflection.\n     * \n     * @return the opacity.\n     * @see #setOpacity\n     */\n    public float getOpacity() {\n        return opacity;\n    }\n\n    public MirrorTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    public float getCentreY() {\n        return centreY;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        int width = source.getWidth();\n        int height = source.getHeight();\n\n        int h = (int) (centreY * height);\n        int d = (int) (gap * height);\n\n        Canvas canvas = new Canvas();\n        Paint paint = new Paint();\n\n        Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n        canvas.setBitmap(bitmap);\n\n        // Set background color\n        canvas.drawColor(Color.BLACK);\n\n        // Draw upper region\n        RectF clipSrcF = new RectF(0, 0, width, height);\n        RectF clipDestF = new RectF(0, 0, width, h);\n        Matrix m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        canvas.drawBitmap(source, m, paint);\n\n        // Draw mirror\n        clipSrcF = new RectF(0, 0, width, height);\n        clipDestF = new RectF(0, h + d, width, height + d);\n        m = new Matrix();\n        m.setRectToRect(clipSrcF, clipDestF, ScaleToFit.CENTER);\n        m.preTranslate(0, height);\n        m.preScale(1, -1);\n        canvas.drawBitmap(source, m, paint);\n\n        // Done with source image\n        source.recycle();\n\n        // Draw gradient over mirror\n        RectF clipGradientF = new RectF(0, 0, width, height);\n        m.mapRect(clipGradientF);\n        paint.setShader(new LinearGradient(0, h, 0, height, Color.argb(50, 0, 0, 0), Color.argb((int) (opacity * 255), 0, 1, 0),\n                Shader.TileMode.CLAMP));\n        canvas.drawRect(clipGradientF, paint);\n\n        return bitmap;\n    }\n\n    public String toString() {\n        return \"Effects/Mirror...\";\n    }\n\n    @Override\n    public String key() {\n        return MirrorTransformation.class.getCanonicalName() + \"-\" + opacity + \"-\" + centreY + \"-\" + distance + \"-\" + gap;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/GrayTransformation.java\npublic class GrayTransformation extends PointTransformation {\n\n\tpublic GrayTransformation() {\n\t\tcanFilterIndexColorModel = true;\n\t}\n\n\tpublic int filterRGB(int x, int y, int rgb) {\n\t\tint a = rgb & 0xff000000;\n\t\tint r = (rgb >> 16) & 0xff;\n\t\tint g = (rgb >> 8) & 0xff;\n\t\tint b = rgb & 0xff;\n\t\tr = (r+255)/2;\n\t\tg = (g+255)/2;\n\t\tb = (b+255)/2;\n\t\treturn a | (r << 16) | (g << 8) | b;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Colors/Gray Out\";\n\t}\n\n    @Override\n    public String key() {\n        return GainTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/SolarizeTransformation.java\npublic class SolarizeTransformation extends TransferTransformation {\n\n    protected float transferFunction(float v) {\n        return v > 0.5f ? 2 * (v - 0.5f) : 2 * (0.5f - v);\n    }\n\n    public String toString() {\n        return \"Colors/Solarize\";\n    }\n\n    @Override\n    public String key() {\n        return SolarizeTransformation.class.getCanonicalName();\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EqualizeTransformation.java\npublic class EqualizeTransformation extends WholeImageTransformation {\n\n    private int[][] lut;\n\n    public EqualizeTransformation() {\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        Histogram histogram = new Histogram(inPixels, width, height, 0, width);\n\n        int i, j;\n\n        if (histogram.getNumSamples() > 0) {\n            float scale = 255.0f / histogram.getNumSamples();\n            lut = new int[3][256];\n            for (i = 0; i < 3; i++) {\n                lut[i][0] = histogram.getFrequency(i, 0);\n                for (j = 1; j < 256; j++)\n                    lut[i][j] = lut[i][j - 1] + histogram.getFrequency(i, j);\n                for (j = 0; j < 256; j++)\n                    lut[i][j] = (int) Math.round(lut[i][j] * scale);\n            }\n        } else\n            lut = null;\n\n        i = 0;\n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++) {\n                inPixels[i] = filterRGB(x, y, inPixels[i]);\n                i++;\n            }\n        lut = null;\n\n        return inPixels;\n    }\n\n    private int filterRGB(int x, int y, int rgb) {\n        if (lut != null) {\n            int a = rgb & 0xff000000;\n            int r = lut[Histogram.RED][(rgb >> 16) & 0xff];\n            int g = lut[Histogram.GREEN][(rgb >> 8) & 0xff];\n            int b = lut[Histogram.BLUE][rgb & 0xff];\n\n            return a | (r << 16) | (g << 8) | b;\n        }\n        return rgb;\n    }\n\n    public String toString() {\n        return \"Colors/Equalize\";\n    }\n\n    @Override\n    public String key() {\n        return EqualizeTransformation.class.getCanonicalName();\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/BlurTransformation.java\npublic class BlurTransformation extends ConvolveTransformation {\n \t\n \t/**\n     * A 3x3 convolution kernel for a simple blur.\n     */\n    protected static float[] blurMatrix = {\n\t\t1/14f, 2/14f, 1/14f,\n\t\t2/14f, 2/14f, 2/14f,\n\t\t1/14f, 2/14f, 1/14f\n\t};\n\n\tpublic BlurTransformation() {\n\t\tsuper(blurMatrix);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"Blur/Simple Blur\";\n\t}\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/MapColorsTransformation.java\npublic class MapColorsTransformation extends PointTransformation {\n\n    private int oldColor;\n\n    private int newColor;\n\n    /**\n     * Construct a MapColorsFilter.\n     */\n    public MapColorsTransformation() {\n        this(0xffffffff, 0xff000000);\n    }\n\n    /**\n     * Construct a MapColorsFilter.\n     * \n     * @param oldColor the color to replace\n     * @param newColor the color to replace it with\n     */\n    public MapColorsTransformation(int oldColor, int newColor) {\n        canFilterIndexColorModel = true;\n        this.oldColor = oldColor;\n        this.newColor = newColor;\n    }\n\n    public int filterRGB(int x, int y, int rgb) {\n        if (rgb == oldColor)\n            return newColor;\n        return rgb;\n    }\n\n    @Override\n    public String key() {\n        return MapColorsTransformation.class.getCanonicalName() + \"-\" + oldColor + \"-\" + newColor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/HSBAdjustTransformation.java\npublic class HSBAdjustTransformation extends PointTransformation {\n\n    public float hFactor, sFactor, bFactor;\n    private float[] hsb = new float[3];\n    \n    public HSBAdjustTransformation() {\n        this(0, 0, 0);\n    }\n\n    public HSBAdjustTransformation(float r, float g, float b) {\n        hFactor = r;\n        sFactor = g;\n        bFactor = b;\n        canFilterIndexColorModel = true;\n    }\n\n    public HSBAdjustTransformation setHFactor( float hFactor ) {\n        this.hFactor = hFactor;\n        return this;\n    }\n    \n    public float getHFactor() {\n        return hFactor;\n    }\n    \n    public HSBAdjustTransformation setSFactor( float sFactor ) {\n        this.sFactor = sFactor;\n        return this;\n    }\n    \n    public float getSFactor() {\n        return sFactor;\n    }\n    \n    public HSBAdjustTransformation setBFactor( float bFactor ) {\n        this.bFactor = bFactor;\n        return this;\n    }\n    \n    public float getBFactor() {\n        return bFactor;\n    }\n    \n    public int filterRGB(int x, int y, int rgb) {\n        int a = rgb & 0xff000000;\n        int r = (rgb >> 16) & 0xff;\n        int g = (rgb >> 8) & 0xff;\n        int b = rgb & 0xff;\n        Color.RGBtoHSB(r, g, b, hsb);\n        hsb[0] += hFactor;\n        while (hsb[0] < 0)\n            hsb[0] += Math.PI*2;\n        hsb[1] += sFactor;\n        if (hsb[1] < 0)\n            hsb[1] = 0;\n        else if (hsb[1] > 1.0)\n            hsb[1] = 1.0f;\n        hsb[2] += bFactor;\n        if (hsb[2] < 0)\n            hsb[2] = 0;\n        else if (hsb[2] > 1.0)\n            hsb[2] = 1.0f;\n        rgb = Color.HSBtoRGB(hsb[0], hsb[1], hsb[2]);\n        return a | (rgb & 0xffffff);\n    }\n\n    public String toString() {\n        return \"Colors/Adjust HSB...\";\n    }\n\n    @Override\n    public String key() {\n        return HSBAdjustTransformation.class.getCanonicalName() + \"-\" + hFactor + \"-\" + sFactor + \"-\" + bFactor;\n    }\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/RescaleTransformation.java\npublic class RescaleTransformation extends TransferTransformation {\n\n    private float scale = 1.0f;\n\n    public RescaleTransformation() {\n    }\n\n    public RescaleTransformation(float scale) {\n        this.scale = scale;\n    }\n\n    protected float transferFunction(float v) {\n        return v * scale;\n    }\n\n    /**\n     * Specifies the scale factor.\n     * \n     * @param scale the scale factor.\n     * @min-value 1\n     * @max-value 5+\n     * @see #getScale\n     */\n    public void setScale(float scale) {\n        this.scale = scale;\n        initialized = false;\n    }\n\n    /**\n     * Returns the scale factor.\n     * \n     * @return the scale factor.\n     * @see #setScale\n     */\n    public float getScale() {\n        return scale;\n    }\n\n    public String toString() {\n        return \"Colors/Rescale...\";\n    }\n\n    @Override\n    public String key() {\n        return RescaleTransformation.class.getCanonicalName() + \"-\" + scale;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/KaleidoscopeTransformation.java\npublic class KaleidoscopeTransformation extends TransformTransformation {\n\n    private float angle = 0;\n\n    private float angle2 = 0;\n\n    private float centreX = 0.5f;\n\n    private float centreY = 0.5f;\n\n    private int sides = 3;\n\n    private float radius = 0;\n\n    private float icentreX;\n\n    private float icentreY;\n\n    /**\n     * Construct a KaleidoscopeFilter with no distortion.\n     */\n    public KaleidoscopeTransformation() {\n        setEdgeAction(CLAMP);\n    }\n\n    /**\n     * Set the number of sides of the kaleidoscope.\n     * \n     * @param sides the number of sides\n     * @min-value 2\n     * @see #getSides\n     */\n    public KaleidoscopeTransformation setSides(int sides) {\n        this.sides = sides;\n        return this;\n    }\n\n    /**\n     * Get the number of sides of the kaleidoscope.\n     * \n     * @return the number of sides\n     * @see #setSides\n     */\n    public int getSides() {\n        return sides;\n    }\n\n    /**\n     * Set the angle of the kaleidoscope.\n     * \n     * @param angle the angle of the kaleidoscope.\n     * @angle\n     * @see #getAngle\n     */\n    public KaleidoscopeTransformation setAngle(float angle) {\n        this.angle = angle;\n        return this;\n    }\n\n    /**\n     * Get the angle of the kaleidoscope.\n     * \n     * @return the angle of the kaleidoscope.\n     * @see #setAngle\n     */\n    public float getAngle() {\n        return angle;\n    }\n\n    /**\n     * Set the secondary angle of the kaleidoscope.\n     * \n     * @param angle2 the angle\n     * @angle\n     * @see #getAngle2\n     */\n    public KaleidoscopeTransformation setAngle2(float angle2) {\n        this.angle2 = angle2;\n        return this;\n    }\n\n    /**\n     * Get the secondary angle of the kaleidoscope.\n     * \n     * @return the angle\n     * @see #setAngle2\n     */\n    public float getAngle2() {\n        return angle2;\n    }\n\n    /**\n     * Set the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @param centreX the center\n     * @see #getCentreX\n     */\n    public KaleidoscopeTransformation setCentreX(float centreX) {\n        this.centreX = centreX;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the X direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreX\n     */\n    public float getCentreX() {\n        return centreX;\n    }\n\n    /**\n     * Set the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @param centreY the center\n     * @see #getCentreY\n     */\n    public KaleidoscopeTransformation setCentreY(float centreY) {\n        this.centreY = centreY;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect in the Y direction as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentreY\n     */\n    public float getCentreY() {\n        return centreY;\n    }\n\n    /**\n     * Set the centre of the effect as a proportion of the image size.\n     * \n     * @param centre the center\n     * @see #getCentre\n     */\n    public KaleidoscopeTransformation setCentre(PointF centre) {\n        this.centreX = centre.x;\n        this.centreY = centre.y;\n        return this;\n    }\n\n    /**\n     * Get the centre of the effect as a proportion of the image size.\n     * \n     * @return the center\n     * @see #setCentre\n     */\n    public PointF getCentre() {\n        return new PointF(centreX, centreY);\n    }\n\n    /**\n     * Set the radius of the effect.\n     * \n     * @param radius the radius\n     * @min-value 0\n     * @see #getRadius\n     */\n    public KaleidoscopeTransformation setRadius(float radius) {\n        this.radius = radius;\n        return this;\n    }\n\n    /**\n     * Get the radius of the effect.\n     * \n     * @return the radius\n     * @see #setRadius\n     */\n    public float getRadius() {\n        return radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        icentreX = source.getWidth() * centreX;\n        icentreY = source.getHeight() * centreY;\n        return super.transform(source);\n    }\n\n    protected void transformInverse(int x, int y, float[] out) {\n        double dx = x - icentreX;\n        double dy = y - icentreY;\n        double r = Math.sqrt(dx * dx + dy * dy);\n        double theta = Math.atan2(dy, dx) - angle - angle2;\n        theta = ImageMath.triangle((float) (theta / Math.PI * sides * .5));\n        if (radius != 0) {\n            double c = Math.cos(theta);\n            double radiusc = radius / c;\n            r = radiusc * ImageMath.triangle((float) (r / radiusc));\n        }\n        theta += angle;\n\n        out[0] = (float) (icentreX + r * Math.cos(theta));\n        out[1] = (float) (icentreY + r * Math.sin(theta));\n    }\n\n    public String toString() {\n        return \"Distort/Kaleidoscope...\";\n    }\n\n    @Override\n    public String key() {\n        return KaleidoscopeTransformation.class.getCanonicalName() + \"-\" + angle + \"-\" + angle2 + \"-\" + centreX + \"-\" + centreY + \"-\"\n                + sides + \"-\" + radius + \"-\" + icentreX + \"-\" + icentreY;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/jhlabs/EmbossTransformation.java\npublic class EmbossTransformation extends WholeImageTransformation {\n\n    private final static float pixelScale = 255.9f;\n\n    private float azimuth = 135.0f * ImageMath.PI / 180.0f, elevation = 30.0f * ImageMath.PI / 180f;\n    private boolean emboss = false;\n    private float width45 = 3.0f;\n\n    public EmbossTransformation() {\n    }\n\n    public void setAzimuth(float azimuth) {\n        this.azimuth = azimuth;\n    }\n\n    public float getAzimuth() {\n        return azimuth;\n    }\n\n    public void setElevation(float elevation) {\n        this.elevation = elevation;\n    }\n\n    public float getElevation() {\n        return elevation;\n    }\n\n    public void setBumpHeight(float bumpHeight) {\n        this.width45 = 3 * bumpHeight;\n    }\n\n    public float getBumpHeight() {\n        return width45 / 3;\n    }\n\n    public void setEmboss(boolean emboss) {\n        this.emboss = emboss;\n    }\n\n    public boolean getEmboss() {\n        return emboss;\n    }\n\n    @Override\n    protected int[] filterPixels(int width, int height, int[] inPixels, Rect transformedSpace) {\n        int index = 0;\n        int[] outPixels = new int[width * height];\n\n        int[] bumpPixels;\n        int bumpMapWidth, bumpMapHeight;\n\n        bumpMapWidth = width;\n        bumpMapHeight = height;\n        bumpPixels = new int[bumpMapWidth * bumpMapHeight];\n        for (int i = 0; i < inPixels.length; i++)\n            bumpPixels[i] = PixelUtils.brightness(inPixels[i]);\n\n        int Nx, Ny, Nz, Lx, Ly, Lz, Nz2, NzLz, NdotL;\n        int shade, background;\n\n        Lx = (int) (Math.cos(azimuth) * Math.cos(elevation) * pixelScale);\n        Ly = (int) (Math.sin(azimuth) * Math.cos(elevation) * pixelScale);\n        Lz = (int) (Math.sin(elevation) * pixelScale);\n\n        Nz = (int) (6 * 255 / width45);\n        Nz2 = Nz * Nz;\n        NzLz = Nz * Lz;\n\n        background = Lz;\n\n        int bumpIndex = 0;\n\n        for (int y = 0; y < height; y++, bumpIndex += bumpMapWidth) {\n            int s1 = bumpIndex;\n            int s2 = s1 + bumpMapWidth;\n            int s3 = s2 + bumpMapWidth;\n\n            for (int x = 0; x < width; x++, s1++, s2++, s3++) {\n                if (y != 0 && y < height - 2 && x != 0 && x < width - 2) {\n                    Nx = bumpPixels[s1 - 1] + bumpPixels[s2 - 1] + bumpPixels[s3 - 1] - bumpPixels[s1 + 1]\n                            - bumpPixels[s2 + 1] - bumpPixels[s3 + 1];\n                    Ny = bumpPixels[s3 - 1] + bumpPixels[s3] + bumpPixels[s3 + 1] - bumpPixels[s1 - 1] - bumpPixels[s1]\n                            - bumpPixels[s1 + 1];\n\n                    if (Nx == 0 && Ny == 0)\n                        shade = background;\n                    else if ((NdotL = Nx * Lx + Ny * Ly + NzLz) < 0)\n                        shade = 0;\n                    else\n                        shade = (int) (NdotL / Math.sqrt(Nx * Nx + Ny * Ny + Nz2));\n                } else\n                    shade = background;\n\n                if (emboss) {\n                    int rgb = inPixels[index];\n                    int a = rgb & 0xff000000;\n                    int r = (rgb >> 16) & 0xff;\n                    int g = (rgb >> 8) & 0xff;\n                    int b = rgb & 0xff;\n                    r = (r * shade) >> 8;\n                    g = (g * shade) >> 8;\n                    b = (b * shade) >> 8;\n                    outPixels[index++] = a | (r << 16) | (g << 8) | b;\n                } else\n                    outPixels[index++] = 0xff000000 | (shade << 16) | (shade << 8) | shade;\n            }\n        }\n\n        return outPixels;\n    }\n\n    public String toString() {\n        return \"Stylize/Emboss...\";\n    }\n\n    @Override\n    public String key() {\n        return EmbossTransformation.class.getCanonicalName() + \"-\" + pixelScale + \"-\" + azimuth + \"-\" + elevation + \"-\"\n                + emboss + \"-\" + width45;\n    }\n\n}\npicasso-transformations/src/main/java/com/picassotransformations/renderscript/RSGaussianBlurTransformation.java\npublic class RSGaussianBlurTransformation implements Transformation {\n\n    private Context mContext;\n\n    private int mRadius;\n    \n    /**\n     * Constructor.\n     * \n     * @param context The context.\n     * @param radius The blur radius: (0, 25]\n     */\n    public RSGaussianBlurTransformation(Context context, int radius) {\n        mContext = context;\n        mRadius = radius;\n    }\n\n    @Override\n    public Bitmap transform(Bitmap source) {\n        if (Build.VERSION.SDK_INT < 17) {\n            return source;\n        }\n        \n        RenderScript rs = RenderScript.create(mContext);\n        Allocation input = Allocation.createFromBitmap(rs, source, Allocation.MipmapControl.MIPMAP_NONE, Allocation.USAGE_SCRIPT);\n        Allocation output = Allocation.createTyped(rs, input.getType());\n        ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\n        script.setRadius(mRadius);\n        script.setInput(input);\n        script.forEach(output);\n        output.copyTo(source);\n        return source;\n    }\n\n    @Override\n    public String key() {\n        return RSGaussianBlurTransformation.class.getCanonicalName() + \"-\" + mRadius;\n    }\n\n}\n", "answers": ["                    new HSBAdjustTransformation(.5f,.5f,.5f),"], "pred": "  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **  **", "length": 5849, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "054c54050c80c29f3bbf1adf5fba865a2468928d4e19a1fe"}
{"prompt": "Please complete the code given below. \napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Movie.java\n @AutoValue public abstract class Movie implements Parcelable{\n    public static final String QUALITY_LOW = \"w342\";\n    public static final String QUALITY_MEDIUM = \"w500\";\n    public static final String QUALITY_HIGH = \"w780\";\n\n    public abstract long id();\n    @Nullable @Json(name = \"imdb_id\") public abstract String ImdbId();\n    public abstract String title();\n    @Nullable public abstract String overview();\n    public abstract long runtime();\n    @Json(name = \"vote_average\") public abstract float tmdbRating();\n    @Json(name = \"release_date\") public abstract String releaseDate();\n    @Nullable @Json(name = \"backdrop_path\") public abstract String backdropPath();\n    @Nullable @Json(name = \"poster_path\") public abstract String posterPath();\n\n\n    public static Movie create(long id, String ImdbId,String title, String overview, Long runtime,\n           float tmdbRating,String releaseDate, String backdropPath, String posterPath) {\n        return new AutoValue_Movie(id,ImdbId,title,overview,runtime,tmdbRating,releaseDate,backdropPath,posterPath);\n    }\n\n\n\n    public static JsonAdapter<Movie> jsonAdapter(Moshi moshi){\n        return new AutoValue_Movie.MoshiJsonAdapter(moshi);\n    }\n\n\n    public String getFormattedRuntime(Long runtime){\n        int hours = (int) (runtime / 60);\n        int minutes = (int) (runtime % 60);\n        return hours > 1 ? String.format(Locale.getDefault(), \"%d hrs %02d mins\", hours, minutes)\n                : String.format(Locale.getDefault(), \"%d hr %02d mins\", hours, minutes);\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/MovieDetails.java\n@AutoValue\npublic abstract class MovieDetails {\n    public abstract String imdbID ();\n    public abstract String imdbRating();\n    @Json(name = \"Ratings\") public abstract List<Rating> ratings();\n    @Json(name = \"Rated\") public abstract String rated();\n    @Json(name = \"Genre\") public abstract String genre();\n    @Json(name = \"Metascore\") public abstract String metascore();\n    @Json(name = \"BoxOffice\") public abstract String boxOffice();\n    @Json(name = \"Awards\") public abstract String awards();\n    @Json(name = \"Production\") public abstract String production();\n    @Json(name = \"Website\") public abstract String website();\n\n\n    public static JsonAdapter<MovieDetails> jsonAdapter(Moshi moshi){\n        return new AutoValue_MovieDetails.MoshiJsonAdapter(moshi);\n    }\n\n    public String getFormattedBoxOffice(){\n        return this.boxOffice().substring(0,this.boxOffice().length()-3);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/favoriteMovies/FavoriteMoviesActivity.java\npublic class FavoriteMoviesActivity extends BaseActivity {\n\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_favorite_movies);\n        navigationView.setCheckedItem(R.id.nav_favorites);\n        toolbar.setTitle(R.string.nav_favorites_title);\n        super.onCreateBaseActivity(savedInstanceState);\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Rating.java\n@AutoValue\npublic abstract class Rating {\n    public static final String ROTTEN_TOMATOES_KEY = \"Rotten Tomatoes\";\n    @Json(name = \"Source\") public abstract String source();\n    @Json(name = \"Value\") public abstract String value();\n\n    public static JsonAdapter<Rating> jsonAdapter(Moshi moshi){\n        return new AutoValue_Rating.MoshiJsonAdapter(moshi);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Trailer.java\n@AutoValue public abstract class Trailer {\n    @Inject public transient Application context;\n    @Json(name = \"key\") public abstract String youtubeUrl();\n    public abstract String name();\n    public abstract String type();\n\n    public Trailer() {\n        PopularMoviesApplication.getApplicationComponent().inject(this);\n    }\n\n    public static JsonAdapter<Trailer> jsonAdapter(Moshi moshi){\n        return new AutoValue_Trailer.MoshiJsonAdapter(moshi);\n    }\n\n    public String getTrailerThumbnail(){\n        String baseUrl = context.getString(R.string.trailer_youtube_thumbnail);\n        return String.format(baseUrl,youtubeUrl());\n    }\n    public Uri getFullYoutubeUri(){\n        String baseUrl = context.getString(R.string.trailer_youtube_video);\n        return Uri.parse(baseUrl).buildUpon()\n                .appendQueryParameter(\"v\",this.youtubeUrl()).build();\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/MovieDetailsActivity.java\npublic class MovieDetailsActivity extends AppCompatActivity implements DelegateToActivity\n        ,MovieDetailsView,ShowDetailsInActivity,AppBarLayout.OnOffsetChangedListener{\n\n    private static final String EXTRA_MOVIE = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_MOVIE\";\n    private static final String EXTRA_SHARED_ELEMENT_NAME = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_SHARED_ELEMENT_NAME\";\n    @BindView(R.id.details_coordinator_layout) CoordinatorLayout coordinatorLayout;\n    @BindView(R.id.details_sliding_tabs) TabLayout detailsTabLayout;\n    @BindView(R.id.details_view_pager) ViewPager detailsViewPager;\n    @BindView(R.id.image_backdrop) ImageView blurPoster;\n    @BindView(R.id.image_poster) ImageView posterImage;\n    @BindView(R.id.text_release) TextView release;\n    @BindView(R.id.text_movie_title) TextView textMovieTitle;\n    @BindView(R.id.toolbar_movie_title) TextView toolbarMovieTitle;\n    @BindView(R.id.collapsing_toolbar_layout) CollapsingToolbarLayout collapsingToolbar;\n    @BindView(R.id.toggle_watchlist) ToggleButton toggleWatchlist;\n    @BindView(R.id.button_play_main_trailer) ImageButton buttonPlayTrailer;\n    @BindView(R.id.appbar) AppBarLayout appBarLayout;\n    @BindView(R.id.text_runtime) TextView textRuntime;\n    @BindView(R.id.text_movie_genres) TextView textGenres;\n    @BindView(R.id.image_mpaa_rating) ImageView imageMpaaRating;\n    @BindView(R.id.appbar_constraint_layout) ConstraintLayout appbarConstraintLayout;\n    @BindView(R.id.fab_favorite) FloatingActionButton fab;\n    @Nullable @BindView(R.id.toolbar_details) Toolbar toolbar;\n    @BindColor(android.R.color.black) int blackColor;\n    private String sharedElementName;\n    private Movie movie;\n    @Inject MovieDetailsPresenter presenter;\n    private boolean isFavorite = false;\n    private ConstantState fullHeartConstantState;\n    private ConstantState emptyHeartConstantState;\n    private String sharedTrailerUrl;\n    private Uri mainTrailerUri;\n    private TransitionListenerAdapter transitionListener;\n\n    public static Intent getMovieDetailsIntent(Context context, Movie movie, String sharedElementName){\n        Intent intent = new Intent(context,MovieDetailsActivity.class);\n        intent.putExtra(EXTRA_MOVIE,movie);\n        intent.putExtra(EXTRA_SHARED_ELEMENT_NAME,sharedElementName);\n        return intent;\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ((PopularMoviesApplication)getApplication()).createMovieDetailsComponent().inject(this);\n        Intent intent = getIntent();\n        movie = intent.getParcelableExtra(EXTRA_MOVIE);\n        sharedElementName = intent.getStringExtra(EXTRA_SHARED_ELEMENT_NAME);\n        setContentView(R.layout.activity_movie_details);\n        ButterKnife.bind(this);\n        presenter.attachView(this);\n        setupShareElementTransition();\n        setupViews();\n\n\n\n//        MovieInfoFragment movieDetailsFragment = (MovieInfoFragment)\n//                fragmentManager.findFragmentByTag(TAG_MOVIE_DETAILS_FRAGMENT);\n//        if (savedInstanceState == null && movieDetailsFragment == null){\n//            movieDetailsFragment = MovieInfoFragment.newInstance(movie,sharedElementName);\n//            fragmentManager.beginTransaction()\n//                    .replace(R.id.movie_details_container,movieDetailsFragment, TAG_MOVIE_DETAILS_FRAGMENT)\n//                    .commit();\n//        }\n    }\n\n    private void setupShareElementTransition() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            transitionListener = new TransitionListenerAdapter() {\n                @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n                @Override\n                public void onTransitionEnd(Transition transition) {\n                    super.onTransitionEnd(transition);\n                    setupViewPager();\n                    getWindow().getSharedElementEnterTransition().removeListener(transitionListener);\n                }\n            };\n            posterImage.setTransitionName(sharedElementName);\n            getWindow().getSharedElementEnterTransition().addListener(transitionListener);\n        }\n    }\n\n    private void setupViewPager() {\n        MovieDetailsPagerAdapter detailsPagerAdapter = new MovieDetailsPagerAdapter(\n                getSupportFragmentManager(),movie);\n        detailsViewPager.setAdapter(detailsPagerAdapter);\n        detailsTabLayout.setupWithViewPager(detailsViewPager);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    private void enterReveal() {\n        if (!isDestroyed()) {\n            blurPoster.setVisibility(View.VISIBLE);\n            final int finalRadius = Math.max(blurPoster.getWidth(), blurPoster.getHeight()) / 2;\n            Animator circularReveal = ViewAnimationUtils.createCircularReveal(blurPoster\n                    , blurPoster.getWidth() / 2, blurPoster.getHeight() / 2\n                    , 0, finalRadius);\n            circularReveal.start();\n        }\n    }\n\n    @Override\n    public void showFavoriteMovie() {\n        if (!isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable emptyHeart = (AnimatedVectorDrawable)\n                        emptyHeartConstantState.newDrawable();\n                fab.setImageDrawable(emptyHeart);\n                emptyHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.heart_fill);\n            }\n            isFavorite = true;\n        }\n    }\n\n    @Override\n    public void showNonFavoriteMovie() {\n        if (isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable fullHeart = (AnimatedVectorDrawable)\n                        fullHeartConstantState.newDrawable();\n                fab.setImageDrawable(fullHeart);\n                fullHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.fab_heart_empty);\n            }\n            isFavorite = false;\n        }\n    }\n    @Override\n    public void showWatchlistMovie() {\n        toggleWatchlist.setChecked(true);\n    }\n\n    @Override\n    public void showNormalMovie() {\n        toggleWatchlist.setChecked(false);\n    }\n\n    @Override\n    public void showRuntime(String runtime) {\n        textRuntime.setText(runtime);\n    }\n\n    @Override\n    public void showOmdbDetails(MovieDetails movieDetails) {\n        textGenres.setText(movieDetails.genre());\n        imageMpaaRating.setImageDrawable(ContextCompat.getDrawable(this\n                ,chooseRatingImage(movieDetails.rated())));\n    }\n\n    @Override\n    public void showReviewMessage(String message) {\n        Snackbar.make(coordinatorLayout,message,Snackbar.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void showShareIcon(String trailerUrl) {\n        sharedTrailerUrl = trailerUrl;\n        supportInvalidateOptionsMenu();\n    }\n\n    @Override\n    public void showPlayMainTrailer(Uri mainTrailerUri) {\n        this.mainTrailerUri = mainTrailerUri;\n        buttonPlayTrailer.setVisibility(View.VISIBLE);\n    }\n\n    private @DrawableRes\n    int chooseRatingImage(String rating){\n        switch (rating){\n            case \"PG-13\":\n                return R.drawable.ic_rated_pg_13;\n            case \"PG\":\n                return R.drawable.ic_rated_pg;\n            case \"R\":\n                return R.drawable.ic_rated_r;\n            case \"G\":\n                return R.drawable.ic_rated_g;\n            case \"NC-17\":\n                return R.drawable.ic_rated_nc_17;\n            default:\n                return R.drawable.ic_not_applicable;\n        }\n    }\n\n    @OnClick(R.id.fab_favorite)\n    public void onFabClicked(){\n        if (isFavorite){\n            presenter.removeMovieFromFavorites(movie.id());\n        }else {\n            presenter.addMovieToFavorites(movie);\n        }\n    }\n\n    @OnClick(R.id.toggle_watchlist)\n    public void onWatchlistClicked(){\n        if (!toggleWatchlist.isChecked()){\n            presenter.removeMovieFromWatchlist(movie.id());\n        }else {\n            presenter.addMovieToWatchlist(movie);\n        }\n    }\n\n    @OnClick({R.id.image_backdrop,R.id.button_play_main_trailer})\n    public void onPlayTrailerClicked(){\n        if (mainTrailerUri != null) {\n            Intent intent = new Intent(Intent.ACTION_VIEW,mainTrailerUri);\n            startActivity(intent);\n        }\n    }\n\n    private void setupViews(){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            fullHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_fill).getConstantState();\n            emptyHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_empty).getConstantState();\n            getWindow().setStatusBarColor(ContextCompat.getColor(this,R.color.transparent_black));\n        }\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        presenter.isMovieFavorite(movie.id());\n        presenter.isMovieInWatchlist(movie.id());\n\n\n\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        toolbarMovieTitle.setAlpha(0);\n        toolbarMovieTitle.setText(movie.title());\n        appBarLayout.addOnOffsetChangedListener(this);\n        populateMovieDetilas();\n    }\n\n    private void populateMovieDetilas(){\n        textMovieTitle.setText(movie.title());\n        release.setText(Utilities.getFormattedDate(movie.releaseDate(),Utilities.MONTH_YEAR_DATE_FORMAT));\n        Picasso.with(this)\n                .load(Utilities.getFullPosterPath(this,movie.posterPath(),Utilities.QUALITY_LOW))\n                .networkPolicy(NetworkPolicy.OFFLINE)\n                .transform(new PaletteTransformation())\n                .into(posterImage, new PaletteTransformation.Callback(posterImage) {\n                    @Override\n                    public void onPalette(Palette palette) {\n                        if (palette != null) {\n                            Palette.Swatch darkVibrantSwatch = palette.getDarkVibrantSwatch();\n                            if (collapsingToolbar != null && darkVibrantSwatch != null) {\n                                int darkVibrantColor = darkVibrantSwatch.getRgb();\n                                collapsingToolbar.setContentScrimColor(darkVibrantColor);\n                                collapsingToolbar.setStatusBarScrimColor(darkVibrantColor);\n                                detailsTabLayout.setBackgroundColor(darkVibrantColor);\n                                GradientDrawable gradient = new GradientDrawable\n                                        (GradientDrawable.Orientation.TL_BR,new int[]{\n                                                blackColor,\n                                                darkVibrantColor\n                                        });\n                                gradient.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n                                appbarConstraintLayout.setBackground(gradient);\n                            }\n                        }\n                    }});\n\n        Picasso.with(this).load(Utilities.getFullBackdropPath(this,movie.backdropPath()\n                ,Movie.QUALITY_MEDIUM)).fit().centerCrop()\n                .into(blurPoster, new Callback() {\n                    @Override\n                    public void onSuccess() {\n                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                            enterReveal();\n                        }else {\n                            blurPoster.setVisibility(View.VISIBLE);\n                        }\n                    }\n                    @Override\n                    public void onError() {\n                    }\n                });\n    }\n\n\n    @Override\n    public boolean onNavigateUp() {\n        supportFinishAfterTransition();\n        return true;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_movie_details,menu);\n        if (sharedTrailerUrl != null){\n            menu.findItem(R.id.menu_share).setVisible(true);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()){\n            case android.R.id.home:\n                onNavigateUp();\n                return true;\n            case R.id.menu_share:\n                Utilities.createShareIntent(this,movie.title(), sharedTrailerUrl);\n                Timber.d(\"Share Clicked!\");\n                return true;\n        }\n        return false;\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();\n        ((PopularMoviesApplication)getApplication()).releaseMovieDetailsComponent();\n    }\n\n    @Override\n    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n        if(collapsingToolbar.getHeight() + verticalOffset > collapsingToolbar.getScrimVisibleHeightTrigger()){\n            toolbarMovieTitle.animate().alpha(0).setDuration(250);\n        }else {\n            toolbarMovieTitle.animate().alpha(1).setDuration(500);\n\n        }\n    }\n\n\n    @Override\n    public void delegateItemClicked(Object item, ImageView sharedView) {\n        //Dosen't handle master/detail views\n        Intent intent;\n        String transitionName = \"\";\n        if (item instanceof Cast){\n            Cast clickedCastItem = (Cast) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                startActivity(intent);\n            }\n        }else if (item instanceof Movie){\n            Movie clickedMovie = (Movie) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = getMovieDetailsIntent(this,clickedMovie,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = MovieDetailsActivity.getMovieDetailsIntent(this,clickedMovie,transitionName);\n                startActivity(intent);\n            }\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown item type\");\n        }\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/ShowDetailsInActivity.java\npublic interface ShowDetailsInActivity {\n    void showRuntime(String runtime);\n    void showOmdbDetails(MovieDetails movieDetails);\n    void showReviewMessage(String message);\n    void showShareIcon(String trailerUrl);\n    void showPlayMainTrailer(Uri mainTrailerUrl);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/common/utilities/DelegateToActivity.java\npublic interface DelegateToActivity<T> {\n    void delegateItemClicked(T item, ImageView sharedView);\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/PopularMoviesApplication.java\npublic class PopularMoviesApplication extends Application {\n    private static ApplicationComponent applicationComponent;\n    private BrowseMoviesComponent browseMoviesComponent;\n    private MovieDetailsComponent movieDetailsComponent;\n    private MovieInfoComponent movieInfoComponent;\n    private NearbyMoviesComponent nearbyMoviesComponent;\n    private FavoriteMoviesComponent favoriteMoviesComponent;\n    private WatchlistComponent watchlistComponent;\n    private MovieReviewsComponent movieReviewsComponent;\n    private MovieCastComponent movieCastComponent;\n    private ActorInfoComponent actorInfoComponent;\n    private ActorMoviesComponent actorMoviesComponent;\n    private ActorDetailsComponent actorDetailsComponent;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        if (LeakCanary.isInAnalyzerProcess(this)) {\n            // This process is dedicated to LeakCanary for heap analysis.\n            // You should not init your app in this process.\n            return;\n        }\n        LeakCanary.install(this);\n        applicationComponent = createAppComponent();\n\n        Timber.plant(new Timber.DebugTree() {\n            @Override\n            protected String createStackElementTag(StackTraceElement element) {\n                return super.createStackElementTag(element) + ':' + element.getLineNumber();\n            }\n        });\n\n\n    }\n\n    private ApplicationComponent createAppComponent() {\n        return DaggerApplicationComponent.builder().applicationModule(new ApplicationModule(this))\n                .castRepositoryModule(new CastRepositoryModule())\n                .moviesRepositoryModule(new MoviesRepositoryModule())\n                .build();\n    }\n\n    public BrowseMoviesComponent createBrowseMoviesComponent(){\n         browseMoviesComponent = applicationComponent.plus(new BrowseMoviesModule());\n\n        return browseMoviesComponent;\n    }\n\n    public MovieDetailsComponent createMovieDetailsComponent(){\n        movieDetailsComponent = applicationComponent.plusMovieDetailsComponent();\n        return movieDetailsComponent;\n    }\n\n    public NearbyMoviesComponent createNearbyMoviesComponent(){\n        nearbyMoviesComponent = applicationComponent.plus(new NearbyMoviesModule());\n        return nearbyMoviesComponent;\n    }\n\n    public FavoriteMoviesComponent createFavoriteMoviesComponent(){\n        favoriteMoviesComponent = applicationComponent.plus(new FavoriteMoviesModule());\n        return favoriteMoviesComponent;\n    }\n\n    public WatchlistComponent createWatchlistComponent(){\n        watchlistComponent = applicationComponent.plus(new WatchlistModule());\n        return watchlistComponent;\n    }\n    public MovieInfoComponent createMovieInfoComponent(){\n        movieInfoComponent = applicationComponent.plus(new MovieInfoModule());\n        return movieInfoComponent;\n    }\n    public MovieReviewsComponent createMovieReviewsComponent(){\n        movieReviewsComponent = applicationComponent.plus(new MovieReviewsModule());\n        return movieReviewsComponent;\n    }\n    public MovieCastComponent createMovieCastComponent(){\n        movieCastComponent = applicationComponent.plus(new MovieCastModule());\n        return movieCastComponent;\n    }\n\n    public ActorInfoComponent createActorInfoComponent(){\n        actorInfoComponent = applicationComponent.plus(new ActorInfoModule());\n        return actorInfoComponent;\n    }\n\n    public ActorMoviesComponent createActorMoviesComponent(){\n        actorMoviesComponent = applicationComponent.plus(new ActorMoviesModule());\n        return actorMoviesComponent;\n    }\n    public ActorDetailsComponent createActorDetailsComponent(){\n        actorDetailsComponent = applicationComponent.plusActorDetailsComponent();\n        return actorDetailsComponent;\n    }\n\n\n    public void releaseBrowseMoviesComponent(){\n        browseMoviesComponent = null;\n    }\n    public void releaseMovieDetailsComponent(){\n        movieDetailsComponent = null;\n    }\n    public void releaseNearbyMoviesComponent(){\n        nearbyMoviesComponent = null;\n    }\n    public void releaseFavoriteMoviesComponent(){\n        favoriteMoviesComponent = null;\n    }\n    public void releaseWatchlistMoviesComponent(){\n        watchlistComponent = null;\n    }\n    public void releaseMovieInfoComponent(){\n        movieInfoComponent = null;\n    }\n    public void releaseMovieReviewsComponent(){\n        movieReviewsComponent = null;\n    }\n    public void releaseMovieCastComponent(){\n        movieCastComponent = null;\n    }\n    public void releaseActorInfoComponent(){actorInfoComponent = null;}\n    public void releaseActorMoviesComponent(){actorMoviesComponent = null;}\n    public void releaseActorDetailsComponent(){actorDetailsComponent = null;}\n\n\n\n    public static ApplicationComponent getApplicationComponent(){\n        return applicationComponent;\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/BrowseMoviesActivity.java\npublic class BrowseMoviesActivity extends BaseActivity implements DelegateToActivity<Movie> {\n\n    @BindView(R.id.slidingTabs) TabLayout tabLayout;\n    @BindView(R.id.viewpager) ViewPager viewPager;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    private BrowseMoviesPagerAdapter browseMoviesPagerAdapter;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_browse_movies);\n        navigationView.setCheckedItem(R.id.nav_discover);\n        browseMoviesPagerAdapter = new BrowseMoviesPagerAdapter(getSupportFragmentManager());\n        viewPager.setAdapter(browseMoviesPagerAdapter);\n        tabLayout.setupWithViewPager(viewPager);\n        toolbar.setTitle(R.string.nav_discover_title);\n        super.onCreateBaseActivity(savedInstanceState);\n\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if(requestCode == NearbyMoviesFragment.REQUEST_RESOLVE_ERROR){\n            browseMoviesPagerAdapter.getItem(viewPager.getCurrentItem())\n                    .onActivityResult(requestCode,resultCode,data);\n        }else {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n}\npackage com.rashwan.reactive_popular_movies.feature.movieDetails.movieInfo;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport com.rashwan.reactive_popular_movies.PopularMoviesApplication;\nimport com.rashwan.reactive_popular_movies.R;\nimport com.rashwan.reactive_popular_movies.common.utilities.DelegateToActivity;\nimport com.rashwan.reactive_popular_movies.data.model.Movie;\nimport com.rashwan.reactive_popular_movies.data.model.MovieDetails;\nimport com.rashwan.reactive_popular_movies.data.model.Rating;\nimport com.rashwan.reactive_popular_movies.data.model.Trailer;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.BrowseMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.favoriteMovies.FavoriteMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.MovieDetailsActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.ShowDetailsInActivity;\nimport java.util.List;\nimport javax.inject.Inject;\nimport butterknife.BindColor;\nimport butterknife.BindView;\nimport butterknife.BindViews;\nimport butterknife.ButterKnife;\nimport butterknife.OnClick;\nimport butterknife.Unbinder;\nimport rx.Observable;\n\n\n\n\n\n\n/**\n * Created by rashwan on 7/3/16.\n */\n\npublic class MovieInfoFragment extends Fragment implements MovieInfoView\n        ,MovieTrailersAdapter.ClickListener,SimilarMoviesAdapter.ClickListener {\n\n    private static final String ARGUMENT_MOVIE_ID = \"ARGUMENT_MOVIE_ID\";\n    private static final String ARGUMENT_DESCRIPTION = \"ARGUMENT_DESCRIPTION\";\n    private static final String ARGUMENT_TMDB_RATING = \"ARGUMENT_TMDB_RATING\";\n    private static final ButterKnife.Action<View> SHOW = (view, index) -> view.setVisibility(View.VISIBLE);\n    private static final ButterKnife.Action<View> HIDE = (view, index) -> view.setVisibility(View.GONE);Next line of code:\n", "input": "package com.rashwan.reactive_popular_movies.feature.movieDetails.movieInfo;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport com.rashwan.reactive_popular_movies.PopularMoviesApplication;\nimport com.rashwan.reactive_popular_movies.R;\nimport com.rashwan.reactive_popular_movies.common.utilities.DelegateToActivity;\nimport com.rashwan.reactive_popular_movies.data.model.Movie;\nimport com.rashwan.reactive_popular_movies.data.model.MovieDetails;\nimport com.rashwan.reactive_popular_movies.data.model.Rating;\nimport com.rashwan.reactive_popular_movies.data.model.Trailer;\nimport com.rashwan.reactive_popular_movies.feature.discoverMovies.BrowseMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.favoriteMovies.FavoriteMoviesActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.MovieDetailsActivity;\nimport com.rashwan.reactive_popular_movies.feature.movieDetails.ShowDetailsInActivity;\nimport java.util.List;\nimport javax.inject.Inject;\nimport butterknife.BindColor;\nimport butterknife.BindView;\nimport butterknife.BindViews;\nimport butterknife.ButterKnife;\nimport butterknife.OnClick;\nimport butterknife.Unbinder;\nimport rx.Observable;\n\n\n\n\n\n\n/**\n * Created by rashwan on 7/3/16.\n */\n\npublic class MovieInfoFragment extends Fragment implements MovieInfoView\n        ,MovieTrailersAdapter.ClickListener,SimilarMoviesAdapter.ClickListener {\n\n    private static final String ARGUMENT_MOVIE_ID = \"ARGUMENT_MOVIE_ID\";\n    private static final String ARGUMENT_DESCRIPTION = \"ARGUMENT_DESCRIPTION\";\n    private static final String ARGUMENT_TMDB_RATING = \"ARGUMENT_TMDB_RATING\";\n    private static final ButterKnife.Action<View> SHOW = (view, index) -> view.setVisibility(View.VISIBLE);\n    private static final ButterKnife.Action<View> HIDE = (view, index) -> view.setVisibility(View.GONE);", "context": "app/src/main/java/com/rashwan/reactive_popular_movies/data/model/Movie.java\n @AutoValue public abstract class Movie implements Parcelable{\n    public static final String QUALITY_LOW = \"w342\";\n    public static final String QUALITY_MEDIUM = \"w500\";\n    public static final String QUALITY_HIGH = \"w780\";\n\n    public abstract long id();\n    @Nullable @Json(name = \"imdb_id\") public abstract String ImdbId();\n    public abstract String title();\n    @Nullable public abstract String overview();\n    public abstract long runtime();\n    @Json(name = \"vote_average\") public abstract float tmdbRating();\n    @Json(name = \"release_date\") public abstract String releaseDate();\n    @Nullable @Json(name = \"backdrop_path\") public abstract String backdropPath();\n    @Nullable @Json(name = \"poster_path\") public abstract String posterPath();\n\n\n    public static Movie create(long id, String ImdbId,String title, String overview, Long runtime,\n           float tmdbRating,String releaseDate, String backdropPath, String posterPath) {\n        return new AutoValue_Movie(id,ImdbId,title,overview,runtime,tmdbRating,releaseDate,backdropPath,posterPath);\n    }\n\n\n\n    public static JsonAdapter<Movie> jsonAdapter(Moshi moshi){\n        return new AutoValue_Movie.MoshiJsonAdapter(moshi);\n    }\n\n\n    public String getFormattedRuntime(Long runtime){\n        int hours = (int) (runtime / 60);\n        int minutes = (int) (runtime % 60);\n        return hours > 1 ? String.format(Locale.getDefault(), \"%d hrs %02d mins\", hours, minutes)\n                : String.format(Locale.getDefault(), \"%d hr %02d mins\", hours, minutes);\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/MovieDetails.java\n@AutoValue\npublic abstract class MovieDetails {\n    public abstract String imdbID ();\n    public abstract String imdbRating();\n    @Json(name = \"Ratings\") public abstract List<Rating> ratings();\n    @Json(name = \"Rated\") public abstract String rated();\n    @Json(name = \"Genre\") public abstract String genre();\n    @Json(name = \"Metascore\") public abstract String metascore();\n    @Json(name = \"BoxOffice\") public abstract String boxOffice();\n    @Json(name = \"Awards\") public abstract String awards();\n    @Json(name = \"Production\") public abstract String production();\n    @Json(name = \"Website\") public abstract String website();\n\n\n    public static JsonAdapter<MovieDetails> jsonAdapter(Moshi moshi){\n        return new AutoValue_MovieDetails.MoshiJsonAdapter(moshi);\n    }\n\n    public String getFormattedBoxOffice(){\n        return this.boxOffice().substring(0,this.boxOffice().length()-3);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/favoriteMovies/FavoriteMoviesActivity.java\npublic class FavoriteMoviesActivity extends BaseActivity {\n\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_favorite_movies);\n        navigationView.setCheckedItem(R.id.nav_favorites);\n        toolbar.setTitle(R.string.nav_favorites_title);\n        super.onCreateBaseActivity(savedInstanceState);\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Rating.java\n@AutoValue\npublic abstract class Rating {\n    public static final String ROTTEN_TOMATOES_KEY = \"Rotten Tomatoes\";\n    @Json(name = \"Source\") public abstract String source();\n    @Json(name = \"Value\") public abstract String value();\n\n    public static JsonAdapter<Rating> jsonAdapter(Moshi moshi){\n        return new AutoValue_Rating.MoshiJsonAdapter(moshi);\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/data/model/Trailer.java\n@AutoValue public abstract class Trailer {\n    @Inject public transient Application context;\n    @Json(name = \"key\") public abstract String youtubeUrl();\n    public abstract String name();\n    public abstract String type();\n\n    public Trailer() {\n        PopularMoviesApplication.getApplicationComponent().inject(this);\n    }\n\n    public static JsonAdapter<Trailer> jsonAdapter(Moshi moshi){\n        return new AutoValue_Trailer.MoshiJsonAdapter(moshi);\n    }\n\n    public String getTrailerThumbnail(){\n        String baseUrl = context.getString(R.string.trailer_youtube_thumbnail);\n        return String.format(baseUrl,youtubeUrl());\n    }\n    public Uri getFullYoutubeUri(){\n        String baseUrl = context.getString(R.string.trailer_youtube_video);\n        return Uri.parse(baseUrl).buildUpon()\n                .appendQueryParameter(\"v\",this.youtubeUrl()).build();\n    }\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/MovieDetailsActivity.java\npublic class MovieDetailsActivity extends AppCompatActivity implements DelegateToActivity\n        ,MovieDetailsView,ShowDetailsInActivity,AppBarLayout.OnOffsetChangedListener{\n\n    private static final String EXTRA_MOVIE = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_MOVIE\";\n    private static final String EXTRA_SHARED_ELEMENT_NAME = \"com.rashwan.reactive_popular_movies.feature.movieDetails.EXTRA_SHARED_ELEMENT_NAME\";\n    @BindView(R.id.details_coordinator_layout) CoordinatorLayout coordinatorLayout;\n    @BindView(R.id.details_sliding_tabs) TabLayout detailsTabLayout;\n    @BindView(R.id.details_view_pager) ViewPager detailsViewPager;\n    @BindView(R.id.image_backdrop) ImageView blurPoster;\n    @BindView(R.id.image_poster) ImageView posterImage;\n    @BindView(R.id.text_release) TextView release;\n    @BindView(R.id.text_movie_title) TextView textMovieTitle;\n    @BindView(R.id.toolbar_movie_title) TextView toolbarMovieTitle;\n    @BindView(R.id.collapsing_toolbar_layout) CollapsingToolbarLayout collapsingToolbar;\n    @BindView(R.id.toggle_watchlist) ToggleButton toggleWatchlist;\n    @BindView(R.id.button_play_main_trailer) ImageButton buttonPlayTrailer;\n    @BindView(R.id.appbar) AppBarLayout appBarLayout;\n    @BindView(R.id.text_runtime) TextView textRuntime;\n    @BindView(R.id.text_movie_genres) TextView textGenres;\n    @BindView(R.id.image_mpaa_rating) ImageView imageMpaaRating;\n    @BindView(R.id.appbar_constraint_layout) ConstraintLayout appbarConstraintLayout;\n    @BindView(R.id.fab_favorite) FloatingActionButton fab;\n    @Nullable @BindView(R.id.toolbar_details) Toolbar toolbar;\n    @BindColor(android.R.color.black) int blackColor;\n    private String sharedElementName;\n    private Movie movie;\n    @Inject MovieDetailsPresenter presenter;\n    private boolean isFavorite = false;\n    private ConstantState fullHeartConstantState;\n    private ConstantState emptyHeartConstantState;\n    private String sharedTrailerUrl;\n    private Uri mainTrailerUri;\n    private TransitionListenerAdapter transitionListener;\n\n    public static Intent getMovieDetailsIntent(Context context, Movie movie, String sharedElementName){\n        Intent intent = new Intent(context,MovieDetailsActivity.class);\n        intent.putExtra(EXTRA_MOVIE,movie);\n        intent.putExtra(EXTRA_SHARED_ELEMENT_NAME,sharedElementName);\n        return intent;\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ((PopularMoviesApplication)getApplication()).createMovieDetailsComponent().inject(this);\n        Intent intent = getIntent();\n        movie = intent.getParcelableExtra(EXTRA_MOVIE);\n        sharedElementName = intent.getStringExtra(EXTRA_SHARED_ELEMENT_NAME);\n        setContentView(R.layout.activity_movie_details);\n        ButterKnife.bind(this);\n        presenter.attachView(this);\n        setupShareElementTransition();\n        setupViews();\n\n\n\n//        MovieInfoFragment movieDetailsFragment = (MovieInfoFragment)\n//                fragmentManager.findFragmentByTag(TAG_MOVIE_DETAILS_FRAGMENT);\n//        if (savedInstanceState == null && movieDetailsFragment == null){\n//            movieDetailsFragment = MovieInfoFragment.newInstance(movie,sharedElementName);\n//            fragmentManager.beginTransaction()\n//                    .replace(R.id.movie_details_container,movieDetailsFragment, TAG_MOVIE_DETAILS_FRAGMENT)\n//                    .commit();\n//        }\n    }\n\n    private void setupShareElementTransition() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            transitionListener = new TransitionListenerAdapter() {\n                @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n                @Override\n                public void onTransitionEnd(Transition transition) {\n                    super.onTransitionEnd(transition);\n                    setupViewPager();\n                    getWindow().getSharedElementEnterTransition().removeListener(transitionListener);\n                }\n            };\n            posterImage.setTransitionName(sharedElementName);\n            getWindow().getSharedElementEnterTransition().addListener(transitionListener);\n        }\n    }\n\n    private void setupViewPager() {\n        MovieDetailsPagerAdapter detailsPagerAdapter = new MovieDetailsPagerAdapter(\n                getSupportFragmentManager(),movie);\n        detailsViewPager.setAdapter(detailsPagerAdapter);\n        detailsTabLayout.setupWithViewPager(detailsViewPager);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    private void enterReveal() {\n        if (!isDestroyed()) {\n            blurPoster.setVisibility(View.VISIBLE);\n            final int finalRadius = Math.max(blurPoster.getWidth(), blurPoster.getHeight()) / 2;\n            Animator circularReveal = ViewAnimationUtils.createCircularReveal(blurPoster\n                    , blurPoster.getWidth() / 2, blurPoster.getHeight() / 2\n                    , 0, finalRadius);\n            circularReveal.start();\n        }\n    }\n\n    @Override\n    public void showFavoriteMovie() {\n        if (!isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable emptyHeart = (AnimatedVectorDrawable)\n                        emptyHeartConstantState.newDrawable();\n                fab.setImageDrawable(emptyHeart);\n                emptyHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.heart_fill);\n            }\n            isFavorite = true;\n        }\n    }\n\n    @Override\n    public void showNonFavoriteMovie() {\n        if (isFavorite) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n                AnimatedVectorDrawable fullHeart = (AnimatedVectorDrawable)\n                        fullHeartConstantState.newDrawable();\n                fab.setImageDrawable(fullHeart);\n                fullHeart.start();\n\n            } else {\n                fab.setImageResource(R.drawable.fab_heart_empty);\n            }\n            isFavorite = false;\n        }\n    }\n    @Override\n    public void showWatchlistMovie() {\n        toggleWatchlist.setChecked(true);\n    }\n\n    @Override\n    public void showNormalMovie() {\n        toggleWatchlist.setChecked(false);\n    }\n\n    @Override\n    public void showRuntime(String runtime) {\n        textRuntime.setText(runtime);\n    }\n\n    @Override\n    public void showOmdbDetails(MovieDetails movieDetails) {\n        textGenres.setText(movieDetails.genre());\n        imageMpaaRating.setImageDrawable(ContextCompat.getDrawable(this\n                ,chooseRatingImage(movieDetails.rated())));\n    }\n\n    @Override\n    public void showReviewMessage(String message) {\n        Snackbar.make(coordinatorLayout,message,Snackbar.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void showShareIcon(String trailerUrl) {\n        sharedTrailerUrl = trailerUrl;\n        supportInvalidateOptionsMenu();\n    }\n\n    @Override\n    public void showPlayMainTrailer(Uri mainTrailerUri) {\n        this.mainTrailerUri = mainTrailerUri;\n        buttonPlayTrailer.setVisibility(View.VISIBLE);\n    }\n\n    private @DrawableRes\n    int chooseRatingImage(String rating){\n        switch (rating){\n            case \"PG-13\":\n                return R.drawable.ic_rated_pg_13;\n            case \"PG\":\n                return R.drawable.ic_rated_pg;\n            case \"R\":\n                return R.drawable.ic_rated_r;\n            case \"G\":\n                return R.drawable.ic_rated_g;\n            case \"NC-17\":\n                return R.drawable.ic_rated_nc_17;\n            default:\n                return R.drawable.ic_not_applicable;\n        }\n    }\n\n    @OnClick(R.id.fab_favorite)\n    public void onFabClicked(){\n        if (isFavorite){\n            presenter.removeMovieFromFavorites(movie.id());\n        }else {\n            presenter.addMovieToFavorites(movie);\n        }\n    }\n\n    @OnClick(R.id.toggle_watchlist)\n    public void onWatchlistClicked(){\n        if (!toggleWatchlist.isChecked()){\n            presenter.removeMovieFromWatchlist(movie.id());\n        }else {\n            presenter.addMovieToWatchlist(movie);\n        }\n    }\n\n    @OnClick({R.id.image_backdrop,R.id.button_play_main_trailer})\n    public void onPlayTrailerClicked(){\n        if (mainTrailerUri != null) {\n            Intent intent = new Intent(Intent.ACTION_VIEW,mainTrailerUri);\n            startActivity(intent);\n        }\n    }\n\n    private void setupViews(){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            fullHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_fill).getConstantState();\n            emptyHeartConstantState = ContextCompat.getDrawable(this,R.drawable.fab_heart_empty).getConstantState();\n            getWindow().setStatusBarColor(ContextCompat.getColor(this,R.color.transparent_black));\n        }\n        setSupportActionBar(toolbar);\n        getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        presenter.isMovieFavorite(movie.id());\n        presenter.isMovieInWatchlist(movie.id());\n\n\n\n        getSupportActionBar().setDisplayShowTitleEnabled(false);\n        toolbarMovieTitle.setAlpha(0);\n        toolbarMovieTitle.setText(movie.title());\n        appBarLayout.addOnOffsetChangedListener(this);\n        populateMovieDetilas();\n    }\n\n    private void populateMovieDetilas(){\n        textMovieTitle.setText(movie.title());\n        release.setText(Utilities.getFormattedDate(movie.releaseDate(),Utilities.MONTH_YEAR_DATE_FORMAT));\n        Picasso.with(this)\n                .load(Utilities.getFullPosterPath(this,movie.posterPath(),Utilities.QUALITY_LOW))\n                .networkPolicy(NetworkPolicy.OFFLINE)\n                .transform(new PaletteTransformation())\n                .into(posterImage, new PaletteTransformation.Callback(posterImage) {\n                    @Override\n                    public void onPalette(Palette palette) {\n                        if (palette != null) {\n                            Palette.Swatch darkVibrantSwatch = palette.getDarkVibrantSwatch();\n                            if (collapsingToolbar != null && darkVibrantSwatch != null) {\n                                int darkVibrantColor = darkVibrantSwatch.getRgb();\n                                collapsingToolbar.setContentScrimColor(darkVibrantColor);\n                                collapsingToolbar.setStatusBarScrimColor(darkVibrantColor);\n                                detailsTabLayout.setBackgroundColor(darkVibrantColor);\n                                GradientDrawable gradient = new GradientDrawable\n                                        (GradientDrawable.Orientation.TL_BR,new int[]{\n                                                blackColor,\n                                                darkVibrantColor\n                                        });\n                                gradient.setGradientType(GradientDrawable.LINEAR_GRADIENT);\n                                appbarConstraintLayout.setBackground(gradient);\n                            }\n                        }\n                    }});\n\n        Picasso.with(this).load(Utilities.getFullBackdropPath(this,movie.backdropPath()\n                ,Movie.QUALITY_MEDIUM)).fit().centerCrop()\n                .into(blurPoster, new Callback() {\n                    @Override\n                    public void onSuccess() {\n                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                            enterReveal();\n                        }else {\n                            blurPoster.setVisibility(View.VISIBLE);\n                        }\n                    }\n                    @Override\n                    public void onError() {\n                    }\n                });\n    }\n\n\n    @Override\n    public boolean onNavigateUp() {\n        supportFinishAfterTransition();\n        return true;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.activity_movie_details,menu);\n        if (sharedTrailerUrl != null){\n            menu.findItem(R.id.menu_share).setVisible(true);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()){\n            case android.R.id.home:\n                onNavigateUp();\n                return true;\n            case R.id.menu_share:\n                Utilities.createShareIntent(this,movie.title(), sharedTrailerUrl);\n                Timber.d(\"Share Clicked!\");\n                return true;\n        }\n        return false;\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();\n        ((PopularMoviesApplication)getApplication()).releaseMovieDetailsComponent();\n    }\n\n    @Override\n    public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {\n        if(collapsingToolbar.getHeight() + verticalOffset > collapsingToolbar.getScrimVisibleHeightTrigger()){\n            toolbarMovieTitle.animate().alpha(0).setDuration(250);\n        }else {\n            toolbarMovieTitle.animate().alpha(1).setDuration(500);\n\n        }\n    }\n\n\n    @Override\n    public void delegateItemClicked(Object item, ImageView sharedView) {\n        //Dosen't handle master/detail views\n        Intent intent;\n        String transitionName = \"\";\n        if (item instanceof Cast){\n            Cast clickedCastItem = (Cast) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = ActorDetailsActivity.getActorDetailsIntent(this,clickedCastItem,transitionName);\n                startActivity(intent);\n            }\n        }else if (item instanceof Movie){\n            Movie clickedMovie = (Movie) item;\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {\n                transitionName = sharedView.getTransitionName();\n                intent = getMovieDetailsIntent(this,clickedMovie,transitionName);\n                ActivityOptions activityOptions = ActivityOptions\n                        .makeSceneTransitionAnimation(this,sharedView,sharedView.getTransitionName());\n                startActivity(intent,activityOptions.toBundle());\n\n            }else {\n                intent = MovieDetailsActivity.getMovieDetailsIntent(this,clickedMovie,transitionName);\n                startActivity(intent);\n            }\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown item type\");\n        }\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/movieDetails/ShowDetailsInActivity.java\npublic interface ShowDetailsInActivity {\n    void showRuntime(String runtime);\n    void showOmdbDetails(MovieDetails movieDetails);\n    void showReviewMessage(String message);\n    void showShareIcon(String trailerUrl);\n    void showPlayMainTrailer(Uri mainTrailerUrl);\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/common/utilities/DelegateToActivity.java\npublic interface DelegateToActivity<T> {\n    void delegateItemClicked(T item, ImageView sharedView);\n\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/PopularMoviesApplication.java\npublic class PopularMoviesApplication extends Application {\n    private static ApplicationComponent applicationComponent;\n    private BrowseMoviesComponent browseMoviesComponent;\n    private MovieDetailsComponent movieDetailsComponent;\n    private MovieInfoComponent movieInfoComponent;\n    private NearbyMoviesComponent nearbyMoviesComponent;\n    private FavoriteMoviesComponent favoriteMoviesComponent;\n    private WatchlistComponent watchlistComponent;\n    private MovieReviewsComponent movieReviewsComponent;\n    private MovieCastComponent movieCastComponent;\n    private ActorInfoComponent actorInfoComponent;\n    private ActorMoviesComponent actorMoviesComponent;\n    private ActorDetailsComponent actorDetailsComponent;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        if (LeakCanary.isInAnalyzerProcess(this)) {\n            // This process is dedicated to LeakCanary for heap analysis.\n            // You should not init your app in this process.\n            return;\n        }\n        LeakCanary.install(this);\n        applicationComponent = createAppComponent();\n\n        Timber.plant(new Timber.DebugTree() {\n            @Override\n            protected String createStackElementTag(StackTraceElement element) {\n                return super.createStackElementTag(element) + ':' + element.getLineNumber();\n            }\n        });\n\n\n    }\n\n    private ApplicationComponent createAppComponent() {\n        return DaggerApplicationComponent.builder().applicationModule(new ApplicationModule(this))\n                .castRepositoryModule(new CastRepositoryModule())\n                .moviesRepositoryModule(new MoviesRepositoryModule())\n                .build();\n    }\n\n    public BrowseMoviesComponent createBrowseMoviesComponent(){\n         browseMoviesComponent = applicationComponent.plus(new BrowseMoviesModule());\n\n        return browseMoviesComponent;\n    }\n\n    public MovieDetailsComponent createMovieDetailsComponent(){\n        movieDetailsComponent = applicationComponent.plusMovieDetailsComponent();\n        return movieDetailsComponent;\n    }\n\n    public NearbyMoviesComponent createNearbyMoviesComponent(){\n        nearbyMoviesComponent = applicationComponent.plus(new NearbyMoviesModule());\n        return nearbyMoviesComponent;\n    }\n\n    public FavoriteMoviesComponent createFavoriteMoviesComponent(){\n        favoriteMoviesComponent = applicationComponent.plus(new FavoriteMoviesModule());\n        return favoriteMoviesComponent;\n    }\n\n    public WatchlistComponent createWatchlistComponent(){\n        watchlistComponent = applicationComponent.plus(new WatchlistModule());\n        return watchlistComponent;\n    }\n    public MovieInfoComponent createMovieInfoComponent(){\n        movieInfoComponent = applicationComponent.plus(new MovieInfoModule());\n        return movieInfoComponent;\n    }\n    public MovieReviewsComponent createMovieReviewsComponent(){\n        movieReviewsComponent = applicationComponent.plus(new MovieReviewsModule());\n        return movieReviewsComponent;\n    }\n    public MovieCastComponent createMovieCastComponent(){\n        movieCastComponent = applicationComponent.plus(new MovieCastModule());\n        return movieCastComponent;\n    }\n\n    public ActorInfoComponent createActorInfoComponent(){\n        actorInfoComponent = applicationComponent.plus(new ActorInfoModule());\n        return actorInfoComponent;\n    }\n\n    public ActorMoviesComponent createActorMoviesComponent(){\n        actorMoviesComponent = applicationComponent.plus(new ActorMoviesModule());\n        return actorMoviesComponent;\n    }\n    public ActorDetailsComponent createActorDetailsComponent(){\n        actorDetailsComponent = applicationComponent.plusActorDetailsComponent();\n        return actorDetailsComponent;\n    }\n\n\n    public void releaseBrowseMoviesComponent(){\n        browseMoviesComponent = null;\n    }\n    public void releaseMovieDetailsComponent(){\n        movieDetailsComponent = null;\n    }\n    public void releaseNearbyMoviesComponent(){\n        nearbyMoviesComponent = null;\n    }\n    public void releaseFavoriteMoviesComponent(){\n        favoriteMoviesComponent = null;\n    }\n    public void releaseWatchlistMoviesComponent(){\n        watchlistComponent = null;\n    }\n    public void releaseMovieInfoComponent(){\n        movieInfoComponent = null;\n    }\n    public void releaseMovieReviewsComponent(){\n        movieReviewsComponent = null;\n    }\n    public void releaseMovieCastComponent(){\n        movieCastComponent = null;\n    }\n    public void releaseActorInfoComponent(){actorInfoComponent = null;}\n    public void releaseActorMoviesComponent(){actorMoviesComponent = null;}\n    public void releaseActorDetailsComponent(){actorDetailsComponent = null;}\n\n\n\n    public static ApplicationComponent getApplicationComponent(){\n        return applicationComponent;\n    }\n}\napp/src/main/java/com/rashwan/reactive_popular_movies/feature/discoverMovies/BrowseMoviesActivity.java\npublic class BrowseMoviesActivity extends BaseActivity implements DelegateToActivity<Movie> {\n\n    @BindView(R.id.slidingTabs) TabLayout tabLayout;\n    @BindView(R.id.viewpager) ViewPager viewPager;\n    @BindView(R.id.navigation_view) NavigationView navigationView;\n    @BindView(R.id.browse_toolbar) Toolbar toolbar;\n    private BrowseMoviesPagerAdapter browseMoviesPagerAdapter;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_browse_movies);\n        navigationView.setCheckedItem(R.id.nav_discover);\n        browseMoviesPagerAdapter = new BrowseMoviesPagerAdapter(getSupportFragmentManager());\n        viewPager.setAdapter(browseMoviesPagerAdapter);\n        tabLayout.setupWithViewPager(viewPager);\n        toolbar.setTitle(R.string.nav_discover_title);\n        super.onCreateBaseActivity(savedInstanceState);\n\n    }\n\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if(requestCode == NearbyMoviesFragment.REQUEST_RESOLVE_ERROR){\n            browseMoviesPagerAdapter.getItem(viewPager.getCurrentItem())\n                    .onActivityResult(requestCode,resultCode,data);\n        }else {\n            super.onActivityResult(requestCode, resultCode, data);\n        }\n    }\n}\n", "answers": ["    private DelegateToActivity<Movie> delegateListener;"], "pred": "  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View:  View: ", "length": 1661, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "31ce3569263336194441a7715e1766ab4954b250a5082477"}
{"prompt": "Please complete the code given below. \nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte BOOLEAN = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_NAME = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTES = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_EXP = 0x07;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface Event {\n    void run() throws IOException;\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ADD_NOTIFICATION_LISTENER = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_INSTANCE = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/VersionedProxy.java\npublic interface VersionedProxy {\n\n    String getConnectionId();\n\n    void close();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION_FILTER = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_INFO = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte EXCEPTION = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte FAILURE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte CREATE_MBEAN = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte UNREGISTER_MBEAN = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_MBEANS = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_INSTANCE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING_ARRAY = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTE = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DOMAINS = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SEND_NOTIFICATION = 0x13;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DEFAULT_DOMAIN = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte MBEAN_INFO = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface ServerMessageInterceptor {\n\n    /**\n     * Called to handle the actual event, gives the Interceptor an opportunity to wrap the call.\n     *\n     * @param event - The event to run.\n     * @throws IOException - If thrown from the event.\n     */\n    void handleEvent(final Event event) throws IOException;\n\n    public interface Event {\n        void run() throws IOException;\n    }\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_NAME = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte RESPONSE_MASK = (byte) 0x80;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER_ARRAY = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SUCCESS = 0x00;\nsrc/main/java/org/jboss/remotingjmx/WrappedMBeanServerConnection.java\npublic interface WrappedMBeanServerConnection {\n\n    MBeanServerConnection getMBeanServerConnection();\n\n    void connectionOpened(final VersionedProxy proxy);\n\n    void connectionClosed(final VersionedProxy proxy);\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INSTANCE_OF = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte IS_REGISTERED = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_NAMES = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTES = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_ARRAY = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTE = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INVOKE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_COUNT = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_OBJECT_INSTANCE = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE_LIST = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte REMOVE_NOTIFICATION_LISTENER = 0x12;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ADD_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE_LIST;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.BOOLEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.CREATE_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.EXCEPTION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.FAILURE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DEFAULT_DOMAIN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DOMAINS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_COUNT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INSTANCE_OF;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INVOKE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.IS_REGISTERED;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION_FILTER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_EXP;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_MBEANS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_NAMES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.REMOVE_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.RESPONSE_MASK;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SEND_NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SUCCESS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.UNREGISTER_MBEAN;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Executor;\nimport javax.management.Attribute;\nimport javax.management.AttributeList;\nimport javax.management.AttributeNotFoundException;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.InstanceNotFoundException;\nimport javax.management.IntrospectionException;\nimport javax.management.InvalidAttributeValueException;\nimport javax.management.JMRuntimeException;\nimport javax.management.ListenerNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanInfo;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MBeanServerConnection;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.Notification;\nimport javax.management.NotificationFilter;\nimport javax.management.NotificationListener;\nimport javax.management.ObjectInstance;\nimport javax.management.ObjectName;\nimport javax.management.QueryExp;\nimport javax.management.ReflectionException;\nimport org.jboss.logging.Logger;\nimport org.jboss.marshalling.AbstractClassResolver;\nimport org.jboss.marshalling.Marshaller;\nimport org.jboss.marshalling.Unmarshaller;\nimport org.jboss.remoting3.Channel;\nimport org.jboss.remoting3.MessageInputStream;\nimport org.jboss.remotingjmx.ServerMessageInterceptor;\nimport org.jboss.remotingjmx.ServerMessageInterceptor.Event;\nimport org.jboss.remotingjmx.VersionedProxy;\nimport org.jboss.remotingjmx.WrappedMBeanServerConnection;\nimport org.xnio.IoUtils;\n                paramType = unmarshaller.readByte();\n                if (paramType != OBJECT) {\n                    throw new IOException(\"Unexpected paramType\");\n                }\n                handback = unmarshaller.readObject();\n            } catch (ClassNotFoundException cnfe) {\n                throw new IOException(cnfe);\n            }\n\n            try {\n                if (remoteNotification) {\n                    remoteNotificationManager.addNotificationListener(name, listenerId, filter, handback);\n                } else {\n                    server.getMBeanServerConnection().addNotificationListener(name, listener, filter, handback);\n                }\n\n                writeResponse(ADD_NOTIFICATION_LISTENER, correlationId);\n\n                log.tracef(\"[%d] AddNotificationListener - Success Response Sent\", correlationId);\n            } catch (InstanceNotFoundException e) {\n                writeResponse(e, ADD_NOTIFICATION_LISTENER, correlationId);\n                log.tracef(\"[%d] AddNotificationListener - Failure Response Sent\", correlationId);\n            }\n        }\n    }\n\n    private class CreateMBeanHandler implements Common.MessageHandler {\n\n        @Override\n        public void handle(DataInput input, final int correlationId) throws IOException {\n            log.trace(\"CreateMBean\");\n            byte paramType = input.readByte();\n            if (paramType != INTEGER) {\n                throw new IOException(\"Unexpected paramType\");\n            }\n            int paramCount = input.readInt();\n            String className = null;\n            ObjectName name = null;\n            ObjectName loader = null;\n            Object[] params = null;\n            String[] signature = null;\n            final ClassLoaderSwitchingClassResolver resolver = new ClassLoaderSwitchingClassResolver(\n                    ServerProxy.class.getClassLoader());\n            Unmarshaller unmarshaller = prepareForUnMarshalling(input, resolver);\n            for (int i = 0; i < paramCount; i++) {\n                byte param = unmarshaller.readByte();\n                switch (param) {\n                    case STRING:\n                        if (className == null) {\n                            className = unmarshaller.readUTF();\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n                        break;\n                    case OBJECT_NAME:\n                        try {\n                            if (name == null) {\n                                name = unmarshaller.readObject(ObjectName.class);\n                            } else if (loader == null) {\n                                loader = unmarshaller.readObject(ObjectName.class);\n                                switchClassLoaderForLoader(loader, resolver);\n                            } else {\n                                throw new IOException(\"Unexpected paramter\");\n                            }\n                        } catch (ClassNotFoundException e) {\n                            throw new IOException(e);\n                        }\n                        break;\n                    case OBJECT_ARRAY:\n                        if (params == null) {\n                            int count = unmarshaller.readInt();\n                            params = new Object[count];\n                            for (int j = 0; j < count; j++) {\n                                try {\n                                    params[j] = unmarshaller.readObject();\n                                } catch (ClassNotFoundException e) {\n                                    throw new IOException(e);\n                                }\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    case STRING_ARRAY:\n                        if (signature == null) {\n                            int count = unmarshaller.readInt();\n                            signature = new String[count];\n                            for (int j = 0; j < count; j++) {\n                                signature[j] = unmarshaller.readUTF();\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    default:\n                        throw new IOException(\"Unexpected paramter\");\n                }\n            }\n\n            try {\n                final ObjectInstance instance;\n                switch (paramCount) {\n                    case 2:\n                        instance = server.getMBeanServerConnection().createMBean(className, name);\n                        break;\n                    case 3:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader);\n                        break;\n                    case 4:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, params, signature);\n                        break;\n                    case 5:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader, params, signature);\n                        break;\n                    default:\n                        throw new IOException(\"Unable to identify correct create method to call.\");\n                }\nNext line of code:\n", "input": "import static org.jboss.remotingjmx.protocol.v1.Constants.ADD_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.ATTRIBUTE_LIST;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.BOOLEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.CREATE_MBEAN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.EXCEPTION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.FAILURE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DEFAULT_DOMAIN;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_DOMAINS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_COUNT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.GET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INSTANCE_OF;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INTEGER_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.INVOKE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.IS_REGISTERED;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.MBEAN_INFO;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.NOTIFICATION_FILTER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_EXP;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_MBEANS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.QUERY_NAMES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.REMOVE_NOTIFICATION_LISTENER;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.RESPONSE_MASK;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SEND_NOTIFICATION;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_ATTRIBUTES;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_INSTANCE;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SET_OBJECT_NAME;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.STRING_ARRAY;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.SUCCESS;\nimport static org.jboss.remotingjmx.protocol.v1.Constants.UNREGISTER_MBEAN;\nimport java.io.DataInput;\nimport java.io.DataInputStream;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.Executor;\nimport javax.management.Attribute;\nimport javax.management.AttributeList;\nimport javax.management.AttributeNotFoundException;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.InstanceNotFoundException;\nimport javax.management.IntrospectionException;\nimport javax.management.InvalidAttributeValueException;\nimport javax.management.JMRuntimeException;\nimport javax.management.ListenerNotFoundException;\nimport javax.management.MBeanException;\nimport javax.management.MBeanInfo;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MBeanServerConnection;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.Notification;\nimport javax.management.NotificationFilter;\nimport javax.management.NotificationListener;\nimport javax.management.ObjectInstance;\nimport javax.management.ObjectName;\nimport javax.management.QueryExp;\nimport javax.management.ReflectionException;\nimport org.jboss.logging.Logger;\nimport org.jboss.marshalling.AbstractClassResolver;\nimport org.jboss.marshalling.Marshaller;\nimport org.jboss.marshalling.Unmarshaller;\nimport org.jboss.remoting3.Channel;\nimport org.jboss.remoting3.MessageInputStream;\nimport org.jboss.remotingjmx.ServerMessageInterceptor;\nimport org.jboss.remotingjmx.ServerMessageInterceptor.Event;\nimport org.jboss.remotingjmx.VersionedProxy;\nimport org.jboss.remotingjmx.WrappedMBeanServerConnection;\nimport org.xnio.IoUtils;\n                paramType = unmarshaller.readByte();\n                if (paramType != OBJECT) {\n                    throw new IOException(\"Unexpected paramType\");\n                }\n                handback = unmarshaller.readObject();\n            } catch (ClassNotFoundException cnfe) {\n                throw new IOException(cnfe);\n            }\n\n            try {\n                if (remoteNotification) {\n                    remoteNotificationManager.addNotificationListener(name, listenerId, filter, handback);\n                } else {\n                    server.getMBeanServerConnection().addNotificationListener(name, listener, filter, handback);\n                }\n\n                writeResponse(ADD_NOTIFICATION_LISTENER, correlationId);\n\n                log.tracef(\"[%d] AddNotificationListener - Success Response Sent\", correlationId);\n            } catch (InstanceNotFoundException e) {\n                writeResponse(e, ADD_NOTIFICATION_LISTENER, correlationId);\n                log.tracef(\"[%d] AddNotificationListener - Failure Response Sent\", correlationId);\n            }\n        }\n    }\n\n    private class CreateMBeanHandler implements Common.MessageHandler {\n\n        @Override\n        public void handle(DataInput input, final int correlationId) throws IOException {\n            log.trace(\"CreateMBean\");\n            byte paramType = input.readByte();\n            if (paramType != INTEGER) {\n                throw new IOException(\"Unexpected paramType\");\n            }\n            int paramCount = input.readInt();\n            String className = null;\n            ObjectName name = null;\n            ObjectName loader = null;\n            Object[] params = null;\n            String[] signature = null;\n            final ClassLoaderSwitchingClassResolver resolver = new ClassLoaderSwitchingClassResolver(\n                    ServerProxy.class.getClassLoader());\n            Unmarshaller unmarshaller = prepareForUnMarshalling(input, resolver);\n            for (int i = 0; i < paramCount; i++) {\n                byte param = unmarshaller.readByte();\n                switch (param) {\n                    case STRING:\n                        if (className == null) {\n                            className = unmarshaller.readUTF();\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n                        break;\n                    case OBJECT_NAME:\n                        try {\n                            if (name == null) {\n                                name = unmarshaller.readObject(ObjectName.class);\n                            } else if (loader == null) {\n                                loader = unmarshaller.readObject(ObjectName.class);\n                                switchClassLoaderForLoader(loader, resolver);\n                            } else {\n                                throw new IOException(\"Unexpected paramter\");\n                            }\n                        } catch (ClassNotFoundException e) {\n                            throw new IOException(e);\n                        }\n                        break;\n                    case OBJECT_ARRAY:\n                        if (params == null) {\n                            int count = unmarshaller.readInt();\n                            params = new Object[count];\n                            for (int j = 0; j < count; j++) {\n                                try {\n                                    params[j] = unmarshaller.readObject();\n                                } catch (ClassNotFoundException e) {\n                                    throw new IOException(e);\n                                }\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    case STRING_ARRAY:\n                        if (signature == null) {\n                            int count = unmarshaller.readInt();\n                            signature = new String[count];\n                            for (int j = 0; j < count; j++) {\n                                signature[j] = unmarshaller.readUTF();\n                            }\n                        } else {\n                            throw new IOException(\"Unexpected paramter\");\n                        }\n\n                        break;\n                    default:\n                        throw new IOException(\"Unexpected paramter\");\n                }\n            }\n\n            try {\n                final ObjectInstance instance;\n                switch (paramCount) {\n                    case 2:\n                        instance = server.getMBeanServerConnection().createMBean(className, name);\n                        break;\n                    case 3:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader);\n                        break;\n                    case 4:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, params, signature);\n                        break;\n                    case 5:\n                        instance = server.getMBeanServerConnection().createMBean(className, name, loader, params, signature);\n                        break;\n                    default:\n                        throw new IOException(\"Unable to identify correct create method to call.\");\n                }\n", "context": "src/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte BOOLEAN = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_NAME = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTES = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_EXP = 0x07;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface Event {\n    void run() throws IOException;\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ADD_NOTIFICATION_LISTENER = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_INSTANCE = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/VersionedProxy.java\npublic interface VersionedProxy {\n\n    String getConnectionId();\n\n    void close();\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION_FILTER = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_INFO = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte EXCEPTION = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte FAILURE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte CREATE_MBEAN = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte UNREGISTER_MBEAN = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_MBEANS = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_INSTANCE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte NOTIFICATION = 0x11;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING_ARRAY = 0x09;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTE = 0x0A;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DOMAINS = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SEND_NOTIFICATION = 0x13;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_DEFAULT_DOMAIN = 0x0D;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte MBEAN_INFO = 0x0E;\nsrc/main/java/org/jboss/remotingjmx/ServerMessageInterceptor.java\npublic interface ServerMessageInterceptor {\n\n    /**\n     * Called to handle the actual event, gives the Interceptor an opportunity to wrap the call.\n     *\n     * @param event - The event to run.\n     * @throws IOException - If thrown from the event.\n     */\n    void handleEvent(final Event event) throws IOException;\n\n    public interface Event {\n        void run() throws IOException;\n    }\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_OBJECT_NAME = 0x0F;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte RESPONSE_MASK = (byte) 0x80;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE = 0x01;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER_ARRAY = 0x12;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT = 0x04;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SUCCESS = 0x00;\nsrc/main/java/org/jboss/remotingjmx/WrappedMBeanServerConnection.java\npublic interface WrappedMBeanServerConnection {\n\n    MBeanServerConnection getMBeanServerConnection();\n\n    void connectionOpened(final VersionedProxy proxy);\n\n    void connectionClosed(final VersionedProxy proxy);\n\n}\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INSTANCE_OF = 0x10;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte IS_REGISTERED = 0x06;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte QUERY_NAMES = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte SET_ATTRIBUTES = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte OBJECT_ARRAY = 0x05;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_ATTRIBUTE = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte STRING = 0x08;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INVOKE = 0x0C;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_MBEAN_COUNT = 0x07;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte GET_OBJECT_INSTANCE = 0x03;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte INTEGER = 0x0B;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte ATTRIBUTE_LIST = 0x02;\nsrc/main/java/org/jboss/remotingjmx/protocol/v1/Constants.java\nstatic final byte REMOVE_NOTIFICATION_LISTENER = 0x12;\n", "answers": ["                writeResponse(instance, OBJECT_INSTANCE, CREATE_MBEAN, correlationId);"], "pred": "  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of code:  Next line of", "length": 953, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "feeef9aaf0fc0be21c3fc0124904f5755baa327e041f60dd"}
{"prompt": "Please complete the code given below. \nclembot/core/commands.py\nclass Cog(Cog):\n\n\n    pass\nclembot/config/constants.py\nclass MyEmojis:\n\n    DESPAWNED = '\ud83d\udca8'\n    ON_MY_WAY = '\ud83c\udfce\ufe0f'\n    TRASH = '\ud83d\uddd1\ufe0f'\n\n    REMOTE = f\"{parse_emoji(None, config_template.misc_emoji.get('remote_raid'))}\"\n    INVITE = f\"{parse_emoji(None, config_template.misc_emoji.get('add_friend'))}\"\n    HERE = f\"{parse_emoji(None, config_template.misc_emoji.get('here'))}\"\n    COMING = f\"{parse_emoji(None, config_template.misc_emoji.get('coming'))}\"\n    INTERESTED = f\"{parse_emoji(None, config_template.misc_emoji.get('interested'))}\"\n    INFO = f\"{parse_emoji(None, config_template.misc_emoji.get('info'))}\"\n    ERROR = f\"{parse_emoji(None, config_template.misc_emoji.get('error'))}\"\n    POKE_BATTLER = f\"{parse_emoji(None, config_template.misc_emoji.get('pb'))}\"\nclembot/exts/profile/user_guild_profile.py\nclass UserGuildProfile:\n\n    TABLE_NAME = 'user_guild_profile'\n\n    dict_fields = ['leaderboard_status']\n    list_fields = ['badge_id']\n\n    LEADERBOARD_STATS = ['wilds', 'raids', 'quests', 'eggs', 'nest', 'rocket']\n\n    def __init__(self, bot, db_dict = dict()):\n        self.bot = bot\n        self.db_dict = {\n            'user_id' : None,\n            'guild_id' : None,\n            'badge_id' :  [],\n            'leaderboard_status' : {},\n            'status' : None\n        }\n        self.db_dict.update(Serializer.deserialize(db_dict, dict_fields=UserGuildProfile.dict_fields))\n\n\n    def __getitem__(self, item):\n        return self.db_dict.get(item) or ([] if item in UserGuildProfile.list_fields else None) or ({} if item in UserGuildProfile.dict_fields else None)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        if key in UserGuildProfile.list_fields:\n            if self.db_dict[key] is None or value is None:\n                self.db_dict[key] = []\n            if value:\n                self.db_dict[key].append(value)\n        else:\n            self.db_dict[key] = value\n\n\n    @classmethod\n    async def data(cls, bot, user_id, guild_id) -> dict():\n        report_user_query = bot.dbi.table('user_metadata').query()\n        _data = report_user_query.where(user_id=user_id, guild_id=guild_id)\n        db_record = await _data.get()\n\n        if db_record:\n            user_metadata = UserGuildProfile.from_db_dict(bot, dict(db_record[0]))\n        else:\n\n            user_metadata = UserGuildProfile(bot, user_id, guild_id)\n            await user_metadata.insert()\n\n        return user_metadata\n\n\n    @classmethod\n    async def find(cls, bot, user_id, guild_id):\n        table = bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n        user_list = await query.getjson()\n        if user_list:\n            return cls(bot, user_list[0])\n        else:\n            await UserGuildProfile.create(bot, user_id, guild_id)\n            query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n            user_list = await query.getjson()\n            if user_list:\n                return cls(bot, user_list[0])\n        return None\n\n\n    @classmethod\n    async def create(cls, bot, user_id, guild_id):\n        user_guild_profile = UserGuildProfile(bot, {'user_id': user_id, 'guild_id': guild_id})\n        await user_guild_profile.insert()\n        return user_guild_profile\n\n\n    async def update(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        update_dict=Serializer.serialize(self.db_dict)\n        update_query = table.update(**update_dict).where(user_id=self['user_id'], guild_id=self['guild_id'])\n        await update_query.commit()\n\n\n    async def insert(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        insert_dict=Serializer.serialize(self.db_dict)\n        insert_query = table.insert(**insert_dict)\n        await insert_query.commit()\n\n\n    def record_report(self, stat_type, board_type='lifetime', increase_by=1, initialize=False):\n        \"\"\"\n            record_report('eggs','lifetime') => increases by 1\n            record_report('raids','lifetime', initialize=True) => set to 1\n            record_report('wilds','lifetime', increase_by=0, initialize=True) => set to 0\n            record_report('quests','lifetime', increase_by=12, initialize=True) => set to 12\n        \"\"\"\n        if stat_type in UserGuildProfile.LEADERBOARD_STATS:\n            current_stat = 0 if initialize else _.get(self.db_dict,f'leaderboard_status.{board_type}.{stat_type}', 0)\n            self.db_dict.setdefault('leaderboard_status',{}).setdefault(board_type, {})[stat_type] = current_stat + increase_by\n\n\n    def leaderboard_stats_dict(self, board_type):\n        return _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n\n\n    def leaderboard_status(self, board_type):\n        status_dict = _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n        wilds, raids, quests, eggs, nest, rocket = ([status_dict.get(stat, 0) for stat in UserGuildProfile.LEADERBOARD_STATS])\n\n        status_text = f\"Raids: **{raids}** | Eggs: **{eggs}** | Wilds: **{wilds}** | Research: **{quests}** | Nest: **{nest}** | Grunts: **{rocket}**\"\n\n        return status_text\n\n    @property\n    def user_id(self):\n        return self['user_id']\n\n    @classmethod\n    async def find_top10_reporters(cls, bot, guild_id, leaderboard_type, stat_type):\n\n        query = top_10_leaderboard_query\n        query_args = [guild_id, f'{leaderboard_type}', f'{leaderboard_type}', None if stat_type == 'total' else stat_type , 10]\n        user_rcrd_list = await bot.dbi.execute_query_json(query, *query_args)\n\n        return user_rcrd_list\nclembot/exts/gymmanager/gym.py\nclass POILocationConverter(commands.Converter):\n    \"\"\"\n    !nest chimchar MESC\n    !nest pikachu somewhere closer\n    !nest aron some park http://google-url.com\n    \"\"\"\n\n    @staticmethod\n    async def convert_from_text(ctx, *argument) -> POILocation:\n\n        try:\n            if len(argument) == 1:\n                city = await ctx.city()\n                gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument[0], city)\n                if gym:\n                    return POILocation.from_gym(gym)\n\n            text = \" \".join(argument)\n            maps_link = TextUtil.extract_link_from_text(text)\n            if maps_link:\n                new_text = text.replace(maps_link, '')\n                return POILocation.from_url( new_text if new_text.__len__() > 0 else \"Click for directions\", maps_link)\n\n            return POILocation.from_location_city(text, \"\")\n\n        except Exception as error:\n            raise BadArgument(error)\n\n\n    @staticmethod\n    async def convert(ctx, argument) -> POILocation:\n        try:\n            city = await ctx.city()\n            if city is None:\n                city = await ctx.guild_profile(key='city')\n            gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument, city)\n\n            if gym:\n                return POILocation.from_gym(gym)\n            else:\n                return POILocation.from_location_city(argument, city)\n        except Exception as error:\n            raise BadArgument(error)\n\n    @staticmethod\n    def combine(location_list):\n\n        location_text = []\n        for rl in location_list:\n            if rl.is_gym:\n                return rl\n            location_text.append(rl.location)\n\n        return POILocation.from_location_city(\" \".join(location_text), location_list[0].city)\n\n\n\n    # @staticmethod\n    # async def auto_correct(ctx, pokemon_as_text):\n    #\n    #     not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n    #\n    #     spellcheck_suggestion = SpellHelper.correction(pokemon_as_text)\n    #\n    #     if spellcheck_suggestion and spellcheck_suggestion != pokemon_as_text:\n    #\n    #         not_acceptable_message += f\" Did you mean **{spellcheck_suggestion}**?\"\n    #         replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n    #         if replace_pokemon:\n    #             return spellcheck_suggestion\n    #\n    #     return None\nclembot/core/bot.py\ndef group(*args, **kwargs):\n    def decorator(func):\n        category = kwargs.get(\"category\")\n        func.command_category = category\n        examples = kwargs.get(\"examples\")\n        func.examples = examples\n        error_wrapped_func = wrap_error(func)\n        result = commands.group(*args, **kwargs)(error_wrapped_func)\n        return result\n    return decorator\nclembot/core/logs.py\ndef init_loggers():\nclembot/core/utils.py\nasync def notify_for(bot, guild, role_name):\n    role = discord.utils.get(guild.roles, name=role_name.lower())\n    if role:\n        notify = await bot.data_manager.guild(guild.id).guild_profile('notifications')\n        if notify == 'true':\n            return role\n    return None\nclembot/exts/wild/wild.py\nclass Wild:\n    by_id = dict()\n    by_message = dict()\n\n    def __init__(self, bot, wild_id, guild_id, reporter_id, pkmn: Pokemon, location: POILocation = None, timezone=None,\n                 caught_by=None,\n                 message_id=None, channel_id=None, reported_time=None, despawn_time=None):\n        self.bot = bot\n        self.wild_id = wild_id\n        self.guild_id = guild_id\n        self.reporter_id = reporter_id\n        self.location = location\n        self.pkmn = pkmn\n        self.reported_time = TH.current_epoch(second_precision=True) if reported_time is None else reported_time\n        self.despawn_time = self.reported_time + (config_template.development_timer or 30) * 60 if despawn_time is None else despawn_time\n        self.message_id = message_id\n        self.channel_id = channel_id\n        self.caught_by = caught_by or []\n        self.timezone = timezone\n        self.monitor_task_tuple = None\n        self.snowflake = Snowflake()\n\n    def to_db_dict(self):\n        state = {\n            'wild_id': self.wild_id,\n            'guild_id': self.guild_id,\n            'reporter_id': self.reporter_id,\n            'pokemon_id': self.pkmn.id,\n            'location': json.dumps(self.location.to_dict()),\n            'reported_time': self.reported_time,\n            'despawn_time': self.despawn_time,\n            'message_id': self.message_id,\n            'channel_id': self.channel_id,\n            'timezone': self.timezone\n        }\n        return state\n\n\n    @classmethod\n    async def from_db_dict(cls, bot, db_dict):\n\n        wild_id, guild_id, reporter_id, pokemon_id, location, reported_time, despawn_time, message_id, channel_id, timezone = [\n            db_dict.get(attr, None) for attr in\n            ['wild_id', 'guild_id', 'reporter_id', 'pokemon_id', 'location', 'reported_time', 'despawn_time',\n             'message_id',\n             'channel_id', 'timezone']]\n\n        pkmn = Pokemon.to_pokemon(pokemon_id) if pokemon_id else None\n        wild_location = await POILocation.from_dict(bot, json.loads(location))\n\n        wild = cls(bot, wild_id=wild_id, guild_id=guild_id, reporter_id=reporter_id,\n                   pkmn=pkmn, location=wild_location, timezone=timezone,\n                   message_id=message_id, channel_id=channel_id,\n                   reported_time=reported_time, despawn_time=despawn_time)\n\n        Wild.cache(wild)\n        return wild\n\n\n    def create_task_tuple(self, coro):\n        task_id = CUIDGenerator.cuid(self.snowflake.next())\n        return self.bot.loop.create_task(coro), task_id\n\n\n    @property\n    def monitor_task(self):\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[0]\n\n\n    @property\n    def monitor_task_id(self) -> str:\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[1]\n\n\n    @monitor_task.setter\n    def monitor_task(self, task_tuple: tuple):\n        \"\"\" reset hatch and expiry tasks\"\"\"\n        if self.monitor_task_tuple:\n            self.monitor_task.cancel()\n        self.monitor_task_tuple = task_tuple\n\n\n    @property\n    def reported_at(self):\n        \"\"\"as Readable time\"\"\"\n        # TODO: add guild timezone\n        return TH.as_local_readable_time(self.reported_time, self.timezone)\n\n\n    def timer_info(self):\n        timer_info = f\"Reported at: {self.reported_at}\" if self.reported_time else \"\"\n        return timer_info\n\n\n    @classmethod\n    def cache(cls, wild):\n        cls.by_message[wild.message_id] = wild\n        cls.by_id[wild.wild_id] = wild\n\n\n    @classmethod\n    def evict(cls, wild):\n        cls.by_message.pop(wild.message_id, None)\n        cls.by_id.pop(wild.wild_id, None)\n\n\n    def set_message(self, message):\n        self.message_id = message.id\n        self.channel_id = message.channel.id\n\n\n    @staticmethod\n    async def find_all(bot):\n        wild_table = bot.dbi.table('wild_report')\n        wild_table_query = wild_table.query().select()\n        record_list = await wild_table_query.getjson()\n        return record_list\n\n\n    async def insert(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_insert = wild_table.insert(**self.to_db_dict())\n        await wild_table_insert.commit()\n        Wild.cache(self)\n\n\n    async def delete(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_delete = wild_table.query().where(wild_id=self.wild_id)\n        await wild_table_delete.delete()\n        Wild.evict(self)\n\n\n    def wild_embed(self, ctx):\n        return (WildEmbed.from_wild_report(ctx, self)).embed\n\n\n    def expire_embed(self):\n        return (WildEmbed.expire_embed(self)).embed\n\n\n    async def despawn(self):\n        try:\n            channel, message = await ChannelMessage.from_id(self.bot, self.channel_id, self.message_id)\n            embed = self.expire_embed()\n            await message.edit(content=\"\", embed=embed)\n            await message.clear_reactions()\n        except Exception as error:\n            Logger.info(error)\n\n        await self.delete()\n        self.monitor_task = None\n\n\n    async def monitor_status(self):\n        Logger.info(f\"{self.pkmn.label} at {self.location}\")\n        sleep_time = self.despawn_time - TH.current_epoch()\n        if sleep_time > 0:\n            await asyncio.sleep(sleep_time)\n\n        await self.despawn()\nclembot/utilities/utils/snowflake.py\nCLEM_EPOCH = 1502123160\ndef to_timestamp(_id):\ndef create():\n    def __init__(self):\n    def next(self):\n    def dumps(self, number):\n    def loads(self, value):\n    def cuid(cls, id):\ndef main():\nclass Snowflake:\nclass Base36:\nclass CUIDGenerator:\nclembot/exts/pkmn/gm_pokemon.py\nclass Pokemon:\n\n    _cache = dict()\n\n    def __init__(self, db_dict, pokedex_num, aliases=[], pokemon_form_id=None):\n        self.db_dict = db_dict\n        self.pokedex_num = pokedex_num\n        self.aliases = aliases\n        self.pokemon_form_id = pokemon_form_id\n\n    def __getitem__(self, item):\n        \"\"\"use [] operator to access members, simpler to create entity objects\"\"\"\n        return self.db_dict.get(item)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        self.db_dict[key] = value\n\n\n    def __repr__(self):\n        return self.label\n\n    @property\n    def id(self):\n        return self.aliases[0] if self.aliases else None\n\n    @property\n    def label(self):\n        return self.id.title()\n\n    # @property\n    # def label(self):\n    #     if self.pokeform_display_text:\n    #         return self.pokeform_display_text.capitalize()\n    #     return None\n\n\n    @property\n    def form(self):\n        form = _.get(self.db_dict, 'pokemonId')\n        if '_ALOLA' in form:\n            form = form.replace('_ALOLA','_ALOLA_FORM')\n        return form\n\n    @property\n    def base_attack(self):\n        return _.get(self.db_dict, 'stats.baseAttack')\n\n    @property\n    def base_defense(self):\n        return _.get(self.db_dict, 'stats.baseDefense')\n\n    @property\n    def base_stamina(self):\n        return _.get(self.db_dict, 'stats.baseStamina')\n\n    @property\n    def fast_moves(self):\n        return list(map(lambda move: move.replace(\"_FAST\", \"\"), _.get(self.db_dict, 'quickMoves')))\n\n    @property\n    def fast_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.fast_moves))\n\n    @property\n    def charge_moves(self):\n        return list(map(lambda move: move, _.get(self.db_dict, 'cinematicMoves')))\n\n    @property\n    def charge_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.charge_moves))\n\n\n    @property\n    def type1(self):\n        type1 = _.get(self.db_dict, 'type')\n        if type1:\n            return type1.replace(\"POKEMON_TYPE_\",\"\").upper()\n        return None\n\n    @property\n    def type2(self):\n        type2 = _.get(self.db_dict, 'type2')\n        if type2:\n            return type2.replace(\"POKEMON_TYPE_\", \"\").upper()\n        return None\n\n    @property\n    def types(self):\n        if self.type2:\n            return [self.type1, self.type2]\n        return [self.type1]\n\n    @property\n    def type1_icon(self):\n        if self.type1:\n            key = self.type1.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def type2_icon(self):\n        if self.type2:\n            key = self.type2.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def shiny(self):\n        return False\n\n    def _gender_type(self):\n        return 'X'\n\n    @property\n    def gender(self):\n        return 'MALE'\n\n\n    @property\n    def extended_label(self):\n        \"\"\"returns pokemon(pokedex) type1 type2\"\"\"\n        extended_label=f\"{self.label} ({self.pokedex_num}) {self.type1_icon}\"\n        if self.type2_icon:\n            extended_label=f\"{extended_label}{self.type2_icon}\"\n        return extended_label\n\n    @property\n    def preview_url(self):\n        url = \"https://raw.githubusercontent.com/TrainingB/Clembot/v2-rewrite/images/pkmn/\"\n        if self.form:\n            url += str(self.form)\n        if self.shiny:\n            url += '_SHINY'\n        if self._gender_type() == 'DIMORPH' and self.gender:\n            url += f'_{self.gender.upper()}'\n        url += '.png'\n        # url += '?cache=5'\n        return url\n\n    # async def color(self):\n    #     url = await self.sprite_url()\n    #     color = await formatters.url_color(url)\n    #     return color\n\n    @property\n    def raid_cp_range(self):\n        low_cp = self.calculate_cp(20, 10, 10, 10)\n        high_cp = self.calculate_cp(20, 15, 15, 15)\n        return [low_cp, high_cp]\n\n\n    def calculate_cp(self, level, attiv, defiv, staiv):\n        if None in [level, attiv, defiv, staiv]:\n            return None\n        else:\n            cpm = CPCalculator().cpM[level]\n            att = (self.base_attack + attiv)*cpm\n            defense = (self.base_defense + defiv)*cpm\n            sta = (self.base_stamina + staiv)*cpm\n            cp = math.floor((att*defense**0.5*sta**0.5)/10)\n            if cp < 10:\n                cp = 10\n            return cp\n\n    @classmethod\n    def cache(cls, form):\n        Pokemon._cache[form.aliases[0]] = form\n\n    @classmethod\n    def to_pokemon(cls, search_for):\n        if len(cls._cache) < 1:\n            raise Exception(\"Error : Pokemon forms are not loaded yet.\")\n\n        if search_for:\n            return cls._cache.get(search_for.upper(), None)\n\n        return None\n\n    @classmethod\n    async def load(cls, bot):\n\n        if len(Pokemon._cache) == 0:\n            table = bot.dbi.table('PB_POKEMON_FORM')\n            forms = await table.query().select().getjson()\n\n            for form in forms:\n                pForm = Pokemon(json.loads(form.get('data')), form.get('pokedex_id'), form.get('aliases'), form.get('pokemon_form_id'))\n                Pokemon.cache(pForm)\n        GMPokemonFormSpellHelper.set_dictionary(cls._cache.keys())\n\n    @classmethod\n    async def convert(cls, ctx, argument) :\n\n        await cls.load(ctx.bot)\n\n        pokemon_form = cls.to_pokemon(argument.upper())\n        if pokemon_form:\n            return pokemon_form\n        else:\n            possible_pokemon_form = await Pokemon.auto_correct(ctx, argument.upper())\n            if possible_pokemon_form:\n                pokemon_form = cls.to_pokemon(possible_pokemon_form)\n                return pokemon_form\n\n        raise BadArgument(f\"{argument} could not be resolved to a pokemon.\")\n\n    @staticmethod\n    async def auto_correct(ctx, pokemon_as_text):\n\n        not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n\n        suggestion = GMPokemonFormSpellHelper.correction(pokemon_as_text)\n\n        if suggestion and suggestion != pokemon_as_text:\n\n            not_acceptable_message += f\" Did you mean **{suggestion}**?\"\n            replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n            if replace_pokemon:\n                return suggestion\n\n        return None\n\n\n\n\n\n    @property\n    def weaknesses(self):\n        \"\"\"\n        Given a Pokemon name, return a list of its weaknesses as defined in the type chart\n        Calculate sum of its weaknesses and resistances.\n        -2 == immune , -1 == NVE, 0 == neutral, 1 == SE, 2 == double SE\n        \"\"\"\n        type_eff = {}\n        for p_type in self.types:\n            for atk_type in _TYPE_CHART[p_type]:\n                if atk_type not in type_eff:\n                    type_eff[atk_type] = 0\n                type_eff[atk_type] += _TYPE_CHART[p_type][atk_type]\n\n        # Summarize into a list of weaknesses,\n        # sorting double weaknesses to the front and marking them with 'x2'.\n        ret = []\n        for p_type, effectiveness in sorted(type_eff.items(), key=lambda x: x[1], reverse=True):\n            if effectiveness == 1:\n                ret.append(p_type.lower())\n            elif effectiveness == 2:\n                ret.append(p_type.lower() + \"x2\")\n\n        return ret\n\n\n    @property\n    def weaknesses_icon(self):\n        \"\"\"\n        Given a list of weaknesses, return a space-separated string of their type IDs as defined in the type_id_dict\n        \"\"\"\n        ret = \"\"\n        for weakness in self.weaknesses:\n            # Handle an \"x2\" postfix defining a double weakness\n            x2 = \"\"\n            if weakness[-2:] == \"x2\":\n                weakness = weakness[:-2]\n                x2 = \"x2\"\n\n            # Append to string\n            ret += config_template.type_emoji[weakness] + x2 + \" \"\n\n        return ret\nclembot/exts/config/channel_checks.py\nasync def _is_wild_report_channel(ctx):\nasync def _is_raid_report_channel(ctx):\nasync def _is_nest_report_channel(ctx):\ndef raid_report_enabled():\ndef wild_report_enabled():\ndef nest_report_enabled():\nclembot/exts/config/guild_metadata.py\nclass GuildMetadata:\n\n\n    def __init__(self, bot, guild):\n        self.bot = bot\n        self.guild = guild\n\n    def __eq__(self, other):\n        return self.guild.id == other.guild.id\n\n    @property\n    def _data(self):\n        report_guild_query = self.bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=self.guild.id)\n        return _data\n\n\n    @classmethod\n    async def data(cls, bot, guild_id, config_name):\n\n        report_guild_query = bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=guild_id, config_name=config_name)\n        db_record = await _data.get()\n\n        if db_record:\n            guild_metadata = GuildMetadata.deserialize(dict(db_record[0]))\n            return guild_metadata\n\n        return {}\n\n    @classmethod\n    async def city(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'city')\n        return guild_dict.get('config_value')\n\n    @classmethod\n    async def bingo_card_repo(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'bingo-card-repo') or {}\n        return guild_dict.get('config_value')\n\n    @staticmethod\n    def serialize(data_dict):\n        return _.map_values(data_dict, lambda val: json.dumps(val) if isinstance(val, dict) else val)\n\n    @staticmethod\n    def deserialize(data_dict):\n        return { k :json.loads(v) if k == 'config' and v is not None else v for (k, v) in data_dict.items()}\n\n\n    @classmethod\n    async def update(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict=GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_update = guild_metadata_table.update(**update_dict).where(guild_id=guild_dict.get('guild_id'))\n        await guild_metadata_table_update.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @classmethod\n    async def insert(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict = GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_insert = guild_metadata_table.insert(**update_dict)\n        await guild_metadata_table_insert.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @staticmethod\n    def embed(ctx, guild_dict):\n        return (GuildMetadataEmbed.from_guild_metadata(ctx, guild_dict)).embed\nimport discord\nfrom discord.ext import commands\nfrom discord.ext.commands import BadArgument\nfrom clembot.config.constants import MyEmojis\nfrom clembot.core.bot import group\nfrom clembot.core.commands import Cog\nfrom clembot.core.logs import Logger\nfrom clembot.core.utils import notify_for\nfrom clembot.exts.config import channel_checks\nfrom clembot.exts.config.guild_metadata import GuildMetadata\nfrom clembot.exts.gymmanager.gym import POILocationConverter\nfrom clembot.exts.pkmn.gm_pokemon import Pokemon\nfrom clembot.exts.profile.user_guild_profile import UserGuildProfile\nfrom clembot.exts.wild.wild import Wild\nfrom clembot.utilities.utils import snowflake\n\n\n\nclass WildCog(commands.Cog):\n\n\n    wild_SYNTAX_ATTRIBUTE = ['gym', 'others']\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.bot.loop.create_task(self.load_wild_reports())\n\n\n    async def load_wild_reports(self):\n        await Pokemon.load(self.bot)\n        for rcrd in await Wild.find_all(self.bot):\n            self.bot.loop.create_task(self.load_wild_report(rcrd))\n\n\n    async def load_wild_report(self, rcrd):\n        Logger.info(f\"load_wild_report({rcrd.get('wild_id', None)})\")\n        wild = await Wild.from_db_dict(self.bot, rcrd)\n        wild.monitor_task = wild.create_task_tuple(wild.monitor_status())\n\n\n    @group(pass_context=True, category='Bot Info', aliases=[\"wild\"])\n    @channel_checks.wild_report_enabled()\n    async def cmd_wild(self, ctx, pokemon: Pokemon, *loc):\n        \"\"\"Reports a wild spawn\n        **Arguments**\n        *pokemon* The name of the wild pokemon\n        *location* The location of the spawn\n\n        If the location is a gym, directions will be accurate otherwise I will\n        just provide a link for **location** + city of the channel.\n        \"\"\"\n\n        timezone = await ctx.timezone()\n        wild_id = next(snowflake.create())\n        if len(loc) == 0:\n            raise BadArgument(\"Ohh, that's awesome, but where? I can't create a report without location.\")\n        location = await POILocationConverter.convert(ctx, ' '.join(loc))\n\n        wild = Wild(self.bot, wild_id=wild_id, guild_id=ctx.guild.id, reporter_id=ctx.message.author.id,\n                    pkmn=pokemon, location=location, timezone=timezone)\n\n        message_content = None\n        role = await notify_for(self.bot, ctx.guild, pokemon.id)\n        if role:\n            message_content=f\"A wild {role.mention} spotted by {ctx.message.author.mention}.\"\n\n        if message_content:\n            wild_report = await ctx.send(content=message_content, embed=wild.wild_embed(ctx))\n        else:\n            wild_report = await ctx.send(embed=wild.wild_embed(ctx))\n\nNext line of code:\n", "input": "import discord\nfrom discord.ext import commands\nfrom discord.ext.commands import BadArgument\nfrom clembot.config.constants import MyEmojis\nfrom clembot.core.bot import group\nfrom clembot.core.commands import Cog\nfrom clembot.core.logs import Logger\nfrom clembot.core.utils import notify_for\nfrom clembot.exts.config import channel_checks\nfrom clembot.exts.config.guild_metadata import GuildMetadata\nfrom clembot.exts.gymmanager.gym import POILocationConverter\nfrom clembot.exts.pkmn.gm_pokemon import Pokemon\nfrom clembot.exts.profile.user_guild_profile import UserGuildProfile\nfrom clembot.exts.wild.wild import Wild\nfrom clembot.utilities.utils import snowflake\n\n\n\nclass WildCog(commands.Cog):\n\n\n    wild_SYNTAX_ATTRIBUTE = ['gym', 'others']\n\n    def __init__(self, bot):\n        self.bot = bot\n        self.bot.loop.create_task(self.load_wild_reports())\n\n\n    async def load_wild_reports(self):\n        await Pokemon.load(self.bot)\n        for rcrd in await Wild.find_all(self.bot):\n            self.bot.loop.create_task(self.load_wild_report(rcrd))\n\n\n    async def load_wild_report(self, rcrd):\n        Logger.info(f\"load_wild_report({rcrd.get('wild_id', None)})\")\n        wild = await Wild.from_db_dict(self.bot, rcrd)\n        wild.monitor_task = wild.create_task_tuple(wild.monitor_status())\n\n\n    @group(pass_context=True, category='Bot Info', aliases=[\"wild\"])\n    @channel_checks.wild_report_enabled()\n    async def cmd_wild(self, ctx, pokemon: Pokemon, *loc):\n        \"\"\"Reports a wild spawn\n        **Arguments**\n        *pokemon* The name of the wild pokemon\n        *location* The location of the spawn\n\n        If the location is a gym, directions will be accurate otherwise I will\n        just provide a link for **location** + city of the channel.\n        \"\"\"\n\n        timezone = await ctx.timezone()\n        wild_id = next(snowflake.create())\n        if len(loc) == 0:\n            raise BadArgument(\"Ohh, that's awesome, but where? I can't create a report without location.\")\n        location = await POILocationConverter.convert(ctx, ' '.join(loc))\n\n        wild = Wild(self.bot, wild_id=wild_id, guild_id=ctx.guild.id, reporter_id=ctx.message.author.id,\n                    pkmn=pokemon, location=location, timezone=timezone)\n\n        message_content = None\n        role = await notify_for(self.bot, ctx.guild, pokemon.id)\n        if role:\n            message_content=f\"A wild {role.mention} spotted by {ctx.message.author.mention}.\"\n\n        if message_content:\n            wild_report = await ctx.send(content=message_content, embed=wild.wild_embed(ctx))\n        else:\n            wild_report = await ctx.send(embed=wild.wild_embed(ctx))\n\n", "context": "clembot/core/commands.py\nclass Cog(Cog):\n\n\n    pass\nclembot/config/constants.py\nclass MyEmojis:\n\n    DESPAWNED = '\ud83d\udca8'\n    ON_MY_WAY = '\ud83c\udfce\ufe0f'\n    TRASH = '\ud83d\uddd1\ufe0f'\n\n    REMOTE = f\"{parse_emoji(None, config_template.misc_emoji.get('remote_raid'))}\"\n    INVITE = f\"{parse_emoji(None, config_template.misc_emoji.get('add_friend'))}\"\n    HERE = f\"{parse_emoji(None, config_template.misc_emoji.get('here'))}\"\n    COMING = f\"{parse_emoji(None, config_template.misc_emoji.get('coming'))}\"\n    INTERESTED = f\"{parse_emoji(None, config_template.misc_emoji.get('interested'))}\"\n    INFO = f\"{parse_emoji(None, config_template.misc_emoji.get('info'))}\"\n    ERROR = f\"{parse_emoji(None, config_template.misc_emoji.get('error'))}\"\n    POKE_BATTLER = f\"{parse_emoji(None, config_template.misc_emoji.get('pb'))}\"\nclembot/exts/profile/user_guild_profile.py\nclass UserGuildProfile:\n\n    TABLE_NAME = 'user_guild_profile'\n\n    dict_fields = ['leaderboard_status']\n    list_fields = ['badge_id']\n\n    LEADERBOARD_STATS = ['wilds', 'raids', 'quests', 'eggs', 'nest', 'rocket']\n\n    def __init__(self, bot, db_dict = dict()):\n        self.bot = bot\n        self.db_dict = {\n            'user_id' : None,\n            'guild_id' : None,\n            'badge_id' :  [],\n            'leaderboard_status' : {},\n            'status' : None\n        }\n        self.db_dict.update(Serializer.deserialize(db_dict, dict_fields=UserGuildProfile.dict_fields))\n\n\n    def __getitem__(self, item):\n        return self.db_dict.get(item) or ([] if item in UserGuildProfile.list_fields else None) or ({} if item in UserGuildProfile.dict_fields else None)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        if key in UserGuildProfile.list_fields:\n            if self.db_dict[key] is None or value is None:\n                self.db_dict[key] = []\n            if value:\n                self.db_dict[key].append(value)\n        else:\n            self.db_dict[key] = value\n\n\n    @classmethod\n    async def data(cls, bot, user_id, guild_id) -> dict():\n        report_user_query = bot.dbi.table('user_metadata').query()\n        _data = report_user_query.where(user_id=user_id, guild_id=guild_id)\n        db_record = await _data.get()\n\n        if db_record:\n            user_metadata = UserGuildProfile.from_db_dict(bot, dict(db_record[0]))\n        else:\n\n            user_metadata = UserGuildProfile(bot, user_id, guild_id)\n            await user_metadata.insert()\n\n        return user_metadata\n\n\n    @classmethod\n    async def find(cls, bot, user_id, guild_id):\n        table = bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n        user_list = await query.getjson()\n        if user_list:\n            return cls(bot, user_list[0])\n        else:\n            await UserGuildProfile.create(bot, user_id, guild_id)\n            query = table.query().select().where(user_id=user_id, guild_id=guild_id)\n            user_list = await query.getjson()\n            if user_list:\n                return cls(bot, user_list[0])\n        return None\n\n\n    @classmethod\n    async def create(cls, bot, user_id, guild_id):\n        user_guild_profile = UserGuildProfile(bot, {'user_id': user_id, 'guild_id': guild_id})\n        await user_guild_profile.insert()\n        return user_guild_profile\n\n\n    async def update(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        update_dict=Serializer.serialize(self.db_dict)\n        update_query = table.update(**update_dict).where(user_id=self['user_id'], guild_id=self['guild_id'])\n        await update_query.commit()\n\n\n    async def insert(self):\n        table = self.bot.dbi.table(UserGuildProfile.TABLE_NAME)\n        insert_dict=Serializer.serialize(self.db_dict)\n        insert_query = table.insert(**insert_dict)\n        await insert_query.commit()\n\n\n    def record_report(self, stat_type, board_type='lifetime', increase_by=1, initialize=False):\n        \"\"\"\n            record_report('eggs','lifetime') => increases by 1\n            record_report('raids','lifetime', initialize=True) => set to 1\n            record_report('wilds','lifetime', increase_by=0, initialize=True) => set to 0\n            record_report('quests','lifetime', increase_by=12, initialize=True) => set to 12\n        \"\"\"\n        if stat_type in UserGuildProfile.LEADERBOARD_STATS:\n            current_stat = 0 if initialize else _.get(self.db_dict,f'leaderboard_status.{board_type}.{stat_type}', 0)\n            self.db_dict.setdefault('leaderboard_status',{}).setdefault(board_type, {})[stat_type] = current_stat + increase_by\n\n\n    def leaderboard_stats_dict(self, board_type):\n        return _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n\n\n    def leaderboard_status(self, board_type):\n        status_dict = _.get(self.db_dict, f'leaderboard_status.{board_type}')\n\n        wilds, raids, quests, eggs, nest, rocket = ([status_dict.get(stat, 0) for stat in UserGuildProfile.LEADERBOARD_STATS])\n\n        status_text = f\"Raids: **{raids}** | Eggs: **{eggs}** | Wilds: **{wilds}** | Research: **{quests}** | Nest: **{nest}** | Grunts: **{rocket}**\"\n\n        return status_text\n\n    @property\n    def user_id(self):\n        return self['user_id']\n\n    @classmethod\n    async def find_top10_reporters(cls, bot, guild_id, leaderboard_type, stat_type):\n\n        query = top_10_leaderboard_query\n        query_args = [guild_id, f'{leaderboard_type}', f'{leaderboard_type}', None if stat_type == 'total' else stat_type , 10]\n        user_rcrd_list = await bot.dbi.execute_query_json(query, *query_args)\n\n        return user_rcrd_list\nclembot/exts/gymmanager/gym.py\nclass POILocationConverter(commands.Converter):\n    \"\"\"\n    !nest chimchar MESC\n    !nest pikachu somewhere closer\n    !nest aron some park http://google-url.com\n    \"\"\"\n\n    @staticmethod\n    async def convert_from_text(ctx, *argument) -> POILocation:\n\n        try:\n            if len(argument) == 1:\n                city = await ctx.city()\n                gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument[0], city)\n                if gym:\n                    return POILocation.from_gym(gym)\n\n            text = \" \".join(argument)\n            maps_link = TextUtil.extract_link_from_text(text)\n            if maps_link:\n                new_text = text.replace(maps_link, '')\n                return POILocation.from_url( new_text if new_text.__len__() > 0 else \"Click for directions\", maps_link)\n\n            return POILocation.from_location_city(text, \"\")\n\n        except Exception as error:\n            raise BadArgument(error)\n\n\n    @staticmethod\n    async def convert(ctx, argument) -> POILocation:\n        try:\n            city = await ctx.city()\n            if city is None:\n                city = await ctx.guild_profile(key='city')\n            gym = await GymRepository(ctx.bot.dbi).to_gym_by_code_city(argument, city)\n\n            if gym:\n                return POILocation.from_gym(gym)\n            else:\n                return POILocation.from_location_city(argument, city)\n        except Exception as error:\n            raise BadArgument(error)\n\n    @staticmethod\n    def combine(location_list):\n\n        location_text = []\n        for rl in location_list:\n            if rl.is_gym:\n                return rl\n            location_text.append(rl.location)\n\n        return POILocation.from_location_city(\" \".join(location_text), location_list[0].city)\n\n\n\n    # @staticmethod\n    # async def auto_correct(ctx, pokemon_as_text):\n    #\n    #     not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n    #\n    #     spellcheck_suggestion = SpellHelper.correction(pokemon_as_text)\n    #\n    #     if spellcheck_suggestion and spellcheck_suggestion != pokemon_as_text:\n    #\n    #         not_acceptable_message += f\" Did you mean **{spellcheck_suggestion}**?\"\n    #         replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n    #         if replace_pokemon:\n    #             return spellcheck_suggestion\n    #\n    #     return None\nclembot/core/bot.py\ndef group(*args, **kwargs):\n    def decorator(func):\n        category = kwargs.get(\"category\")\n        func.command_category = category\n        examples = kwargs.get(\"examples\")\n        func.examples = examples\n        error_wrapped_func = wrap_error(func)\n        result = commands.group(*args, **kwargs)(error_wrapped_func)\n        return result\n    return decorator\nclembot/core/logs.py\ndef init_loggers():\nclembot/core/utils.py\nasync def notify_for(bot, guild, role_name):\n    role = discord.utils.get(guild.roles, name=role_name.lower())\n    if role:\n        notify = await bot.data_manager.guild(guild.id).guild_profile('notifications')\n        if notify == 'true':\n            return role\n    return None\nclembot/exts/wild/wild.py\nclass Wild:\n    by_id = dict()\n    by_message = dict()\n\n    def __init__(self, bot, wild_id, guild_id, reporter_id, pkmn: Pokemon, location: POILocation = None, timezone=None,\n                 caught_by=None,\n                 message_id=None, channel_id=None, reported_time=None, despawn_time=None):\n        self.bot = bot\n        self.wild_id = wild_id\n        self.guild_id = guild_id\n        self.reporter_id = reporter_id\n        self.location = location\n        self.pkmn = pkmn\n        self.reported_time = TH.current_epoch(second_precision=True) if reported_time is None else reported_time\n        self.despawn_time = self.reported_time + (config_template.development_timer or 30) * 60 if despawn_time is None else despawn_time\n        self.message_id = message_id\n        self.channel_id = channel_id\n        self.caught_by = caught_by or []\n        self.timezone = timezone\n        self.monitor_task_tuple = None\n        self.snowflake = Snowflake()\n\n    def to_db_dict(self):\n        state = {\n            'wild_id': self.wild_id,\n            'guild_id': self.guild_id,\n            'reporter_id': self.reporter_id,\n            'pokemon_id': self.pkmn.id,\n            'location': json.dumps(self.location.to_dict()),\n            'reported_time': self.reported_time,\n            'despawn_time': self.despawn_time,\n            'message_id': self.message_id,\n            'channel_id': self.channel_id,\n            'timezone': self.timezone\n        }\n        return state\n\n\n    @classmethod\n    async def from_db_dict(cls, bot, db_dict):\n\n        wild_id, guild_id, reporter_id, pokemon_id, location, reported_time, despawn_time, message_id, channel_id, timezone = [\n            db_dict.get(attr, None) for attr in\n            ['wild_id', 'guild_id', 'reporter_id', 'pokemon_id', 'location', 'reported_time', 'despawn_time',\n             'message_id',\n             'channel_id', 'timezone']]\n\n        pkmn = Pokemon.to_pokemon(pokemon_id) if pokemon_id else None\n        wild_location = await POILocation.from_dict(bot, json.loads(location))\n\n        wild = cls(bot, wild_id=wild_id, guild_id=guild_id, reporter_id=reporter_id,\n                   pkmn=pkmn, location=wild_location, timezone=timezone,\n                   message_id=message_id, channel_id=channel_id,\n                   reported_time=reported_time, despawn_time=despawn_time)\n\n        Wild.cache(wild)\n        return wild\n\n\n    def create_task_tuple(self, coro):\n        task_id = CUIDGenerator.cuid(self.snowflake.next())\n        return self.bot.loop.create_task(coro), task_id\n\n\n    @property\n    def monitor_task(self):\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[0]\n\n\n    @property\n    def monitor_task_id(self) -> str:\n        if self.monitor_task_tuple:\n            return self.monitor_task_tuple[1]\n\n\n    @monitor_task.setter\n    def monitor_task(self, task_tuple: tuple):\n        \"\"\" reset hatch and expiry tasks\"\"\"\n        if self.monitor_task_tuple:\n            self.monitor_task.cancel()\n        self.monitor_task_tuple = task_tuple\n\n\n    @property\n    def reported_at(self):\n        \"\"\"as Readable time\"\"\"\n        # TODO: add guild timezone\n        return TH.as_local_readable_time(self.reported_time, self.timezone)\n\n\n    def timer_info(self):\n        timer_info = f\"Reported at: {self.reported_at}\" if self.reported_time else \"\"\n        return timer_info\n\n\n    @classmethod\n    def cache(cls, wild):\n        cls.by_message[wild.message_id] = wild\n        cls.by_id[wild.wild_id] = wild\n\n\n    @classmethod\n    def evict(cls, wild):\n        cls.by_message.pop(wild.message_id, None)\n        cls.by_id.pop(wild.wild_id, None)\n\n\n    def set_message(self, message):\n        self.message_id = message.id\n        self.channel_id = message.channel.id\n\n\n    @staticmethod\n    async def find_all(bot):\n        wild_table = bot.dbi.table('wild_report')\n        wild_table_query = wild_table.query().select()\n        record_list = await wild_table_query.getjson()\n        return record_list\n\n\n    async def insert(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_insert = wild_table.insert(**self.to_db_dict())\n        await wild_table_insert.commit()\n        Wild.cache(self)\n\n\n    async def delete(self):\n        wild_table = self.bot.dbi.table('wild_report')\n        wild_table_delete = wild_table.query().where(wild_id=self.wild_id)\n        await wild_table_delete.delete()\n        Wild.evict(self)\n\n\n    def wild_embed(self, ctx):\n        return (WildEmbed.from_wild_report(ctx, self)).embed\n\n\n    def expire_embed(self):\n        return (WildEmbed.expire_embed(self)).embed\n\n\n    async def despawn(self):\n        try:\n            channel, message = await ChannelMessage.from_id(self.bot, self.channel_id, self.message_id)\n            embed = self.expire_embed()\n            await message.edit(content=\"\", embed=embed)\n            await message.clear_reactions()\n        except Exception as error:\n            Logger.info(error)\n\n        await self.delete()\n        self.monitor_task = None\n\n\n    async def monitor_status(self):\n        Logger.info(f\"{self.pkmn.label} at {self.location}\")\n        sleep_time = self.despawn_time - TH.current_epoch()\n        if sleep_time > 0:\n            await asyncio.sleep(sleep_time)\n\n        await self.despawn()\nclembot/utilities/utils/snowflake.py\nCLEM_EPOCH = 1502123160\ndef to_timestamp(_id):\ndef create():\n    def __init__(self):\n    def next(self):\n    def dumps(self, number):\n    def loads(self, value):\n    def cuid(cls, id):\ndef main():\nclass Snowflake:\nclass Base36:\nclass CUIDGenerator:\nclembot/exts/pkmn/gm_pokemon.py\nclass Pokemon:\n\n    _cache = dict()\n\n    def __init__(self, db_dict, pokedex_num, aliases=[], pokemon_form_id=None):\n        self.db_dict = db_dict\n        self.pokedex_num = pokedex_num\n        self.aliases = aliases\n        self.pokemon_form_id = pokemon_form_id\n\n    def __getitem__(self, item):\n        \"\"\"use [] operator to access members, simpler to create entity objects\"\"\"\n        return self.db_dict.get(item)\n\n\n    def __setitem__(self, key, value):\n        \"\"\"use [] operator to access members, simpler to create entity objects. Handles array kind of values.\"\"\"\n        self.db_dict[key] = value\n\n\n    def __repr__(self):\n        return self.label\n\n    @property\n    def id(self):\n        return self.aliases[0] if self.aliases else None\n\n    @property\n    def label(self):\n        return self.id.title()\n\n    # @property\n    # def label(self):\n    #     if self.pokeform_display_text:\n    #         return self.pokeform_display_text.capitalize()\n    #     return None\n\n\n    @property\n    def form(self):\n        form = _.get(self.db_dict, 'pokemonId')\n        if '_ALOLA' in form:\n            form = form.replace('_ALOLA','_ALOLA_FORM')\n        return form\n\n    @property\n    def base_attack(self):\n        return _.get(self.db_dict, 'stats.baseAttack')\n\n    @property\n    def base_defense(self):\n        return _.get(self.db_dict, 'stats.baseDefense')\n\n    @property\n    def base_stamina(self):\n        return _.get(self.db_dict, 'stats.baseStamina')\n\n    @property\n    def fast_moves(self):\n        return list(map(lambda move: move.replace(\"_FAST\", \"\"), _.get(self.db_dict, 'quickMoves')))\n\n    @property\n    def fast_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.fast_moves))\n\n    @property\n    def charge_moves(self):\n        return list(map(lambda move: move, _.get(self.db_dict, 'cinematicMoves')))\n\n    @property\n    def charge_moves_labels(self):\n        return list(map(lambda move: move.replace(\"_\",\" \").title() , self.charge_moves))\n\n\n    @property\n    def type1(self):\n        type1 = _.get(self.db_dict, 'type')\n        if type1:\n            return type1.replace(\"POKEMON_TYPE_\",\"\").upper()\n        return None\n\n    @property\n    def type2(self):\n        type2 = _.get(self.db_dict, 'type2')\n        if type2:\n            return type2.replace(\"POKEMON_TYPE_\", \"\").upper()\n        return None\n\n    @property\n    def types(self):\n        if self.type2:\n            return [self.type1, self.type2]\n        return [self.type1]\n\n    @property\n    def type1_icon(self):\n        if self.type1:\n            key = self.type1.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def type2_icon(self):\n        if self.type2:\n            key = self.type2.lower()\n            return config_template.type_emoji[key]\n        return None\n\n    @property\n    def shiny(self):\n        return False\n\n    def _gender_type(self):\n        return 'X'\n\n    @property\n    def gender(self):\n        return 'MALE'\n\n\n    @property\n    def extended_label(self):\n        \"\"\"returns pokemon(pokedex) type1 type2\"\"\"\n        extended_label=f\"{self.label} ({self.pokedex_num}) {self.type1_icon}\"\n        if self.type2_icon:\n            extended_label=f\"{extended_label}{self.type2_icon}\"\n        return extended_label\n\n    @property\n    def preview_url(self):\n        url = \"https://raw.githubusercontent.com/TrainingB/Clembot/v2-rewrite/images/pkmn/\"\n        if self.form:\n            url += str(self.form)\n        if self.shiny:\n            url += '_SHINY'\n        if self._gender_type() == 'DIMORPH' and self.gender:\n            url += f'_{self.gender.upper()}'\n        url += '.png'\n        # url += '?cache=5'\n        return url\n\n    # async def color(self):\n    #     url = await self.sprite_url()\n    #     color = await formatters.url_color(url)\n    #     return color\n\n    @property\n    def raid_cp_range(self):\n        low_cp = self.calculate_cp(20, 10, 10, 10)\n        high_cp = self.calculate_cp(20, 15, 15, 15)\n        return [low_cp, high_cp]\n\n\n    def calculate_cp(self, level, attiv, defiv, staiv):\n        if None in [level, attiv, defiv, staiv]:\n            return None\n        else:\n            cpm = CPCalculator().cpM[level]\n            att = (self.base_attack + attiv)*cpm\n            defense = (self.base_defense + defiv)*cpm\n            sta = (self.base_stamina + staiv)*cpm\n            cp = math.floor((att*defense**0.5*sta**0.5)/10)\n            if cp < 10:\n                cp = 10\n            return cp\n\n    @classmethod\n    def cache(cls, form):\n        Pokemon._cache[form.aliases[0]] = form\n\n    @classmethod\n    def to_pokemon(cls, search_for):\n        if len(cls._cache) < 1:\n            raise Exception(\"Error : Pokemon forms are not loaded yet.\")\n\n        if search_for:\n            return cls._cache.get(search_for.upper(), None)\n\n        return None\n\n    @classmethod\n    async def load(cls, bot):\n\n        if len(Pokemon._cache) == 0:\n            table = bot.dbi.table('PB_POKEMON_FORM')\n            forms = await table.query().select().getjson()\n\n            for form in forms:\n                pForm = Pokemon(json.loads(form.get('data')), form.get('pokedex_id'), form.get('aliases'), form.get('pokemon_form_id'))\n                Pokemon.cache(pForm)\n        GMPokemonFormSpellHelper.set_dictionary(cls._cache.keys())\n\n    @classmethod\n    async def convert(cls, ctx, argument) :\n\n        await cls.load(ctx.bot)\n\n        pokemon_form = cls.to_pokemon(argument.upper())\n        if pokemon_form:\n            return pokemon_form\n        else:\n            possible_pokemon_form = await Pokemon.auto_correct(ctx, argument.upper())\n            if possible_pokemon_form:\n                pokemon_form = cls.to_pokemon(possible_pokemon_form)\n                return pokemon_form\n\n        raise BadArgument(f\"{argument} could not be resolved to a pokemon.\")\n\n    @staticmethod\n    async def auto_correct(ctx, pokemon_as_text):\n\n        not_acceptable_message = f\"**{pokemon_as_text}** isn't a Pokemon!\"\n\n        suggestion = GMPokemonFormSpellHelper.correction(pokemon_as_text)\n\n        if suggestion and suggestion != pokemon_as_text:\n\n            not_acceptable_message += f\" Did you mean **{suggestion}**?\"\n            replace_pokemon = await Utilities.ask_confirmation(ctx, ctx.message, not_acceptable_message, \"Alright!\", \"That's okay!\", \"Timed Out!\")\n            if replace_pokemon:\n                return suggestion\n\n        return None\n\n\n\n\n\n    @property\n    def weaknesses(self):\n        \"\"\"\n        Given a Pokemon name, return a list of its weaknesses as defined in the type chart\n        Calculate sum of its weaknesses and resistances.\n        -2 == immune , -1 == NVE, 0 == neutral, 1 == SE, 2 == double SE\n        \"\"\"\n        type_eff = {}\n        for p_type in self.types:\n            for atk_type in _TYPE_CHART[p_type]:\n                if atk_type not in type_eff:\n                    type_eff[atk_type] = 0\n                type_eff[atk_type] += _TYPE_CHART[p_type][atk_type]\n\n        # Summarize into a list of weaknesses,\n        # sorting double weaknesses to the front and marking them with 'x2'.\n        ret = []\n        for p_type, effectiveness in sorted(type_eff.items(), key=lambda x: x[1], reverse=True):\n            if effectiveness == 1:\n                ret.append(p_type.lower())\n            elif effectiveness == 2:\n                ret.append(p_type.lower() + \"x2\")\n\n        return ret\n\n\n    @property\n    def weaknesses_icon(self):\n        \"\"\"\n        Given a list of weaknesses, return a space-separated string of their type IDs as defined in the type_id_dict\n        \"\"\"\n        ret = \"\"\n        for weakness in self.weaknesses:\n            # Handle an \"x2\" postfix defining a double weakness\n            x2 = \"\"\n            if weakness[-2:] == \"x2\":\n                weakness = weakness[:-2]\n                x2 = \"x2\"\n\n            # Append to string\n            ret += config_template.type_emoji[weakness] + x2 + \" \"\n\n        return ret\nclembot/exts/config/channel_checks.py\nasync def _is_wild_report_channel(ctx):\nasync def _is_raid_report_channel(ctx):\nasync def _is_nest_report_channel(ctx):\ndef raid_report_enabled():\ndef wild_report_enabled():\ndef nest_report_enabled():\nclembot/exts/config/guild_metadata.py\nclass GuildMetadata:\n\n\n    def __init__(self, bot, guild):\n        self.bot = bot\n        self.guild = guild\n\n    def __eq__(self, other):\n        return self.guild.id == other.guild.id\n\n    @property\n    def _data(self):\n        report_guild_query = self.bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=self.guild.id)\n        return _data\n\n\n    @classmethod\n    async def data(cls, bot, guild_id, config_name):\n\n        report_guild_query = bot.dbi.table('guild_metadata').query()\n        _data = report_guild_query.where(guild_id=guild_id, config_name=config_name)\n        db_record = await _data.get()\n\n        if db_record:\n            guild_metadata = GuildMetadata.deserialize(dict(db_record[0]))\n            return guild_metadata\n\n        return {}\n\n    @classmethod\n    async def city(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'city')\n        return guild_dict.get('config_value')\n\n    @classmethod\n    async def bingo_card_repo(cls, bot, guild_id):\n        guild_dict = await GuildMetadata.data(bot, guild_id, 'bingo-card-repo') or {}\n        return guild_dict.get('config_value')\n\n    @staticmethod\n    def serialize(data_dict):\n        return _.map_values(data_dict, lambda val: json.dumps(val) if isinstance(val, dict) else val)\n\n    @staticmethod\n    def deserialize(data_dict):\n        return { k :json.loads(v) if k == 'config' and v is not None else v for (k, v) in data_dict.items()}\n\n\n    @classmethod\n    async def update(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict=GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_update = guild_metadata_table.update(**update_dict).where(guild_id=guild_dict.get('guild_id'))\n        await guild_metadata_table_update.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @classmethod\n    async def insert(cls, bot, guild_dict):\n        guild_metadata_table = bot.dbi.table('guild_metadata')\n        update_dict = GuildMetadata.serialize(guild_dict)\n        guild_metadata_table_insert = guild_metadata_table.insert(**update_dict)\n        await guild_metadata_table_insert.commit()\n        GuildMetadata.cache(guild_dict)\n\n    @staticmethod\n    def embed(ctx, guild_dict):\n        return (GuildMetadataEmbed.from_guild_metadata(ctx, guild_dict)).embed\n", "answers": ["        await wild_report.add_reaction(MyEmojis.DESPAWNED)"], "pred": "  wild_report =  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (  wild  embed  (", "length": 2162, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "f376e7b81aae7316d4e0ecc854e42de8695616f6e8946dfa"}
{"prompt": "Please complete the code given below. \ndictlearn/retrieval.py\nclass Retrieval(object):\n\n    def __init__(self, vocab_text, dictionary,\n                 max_def_length=1000, with_too_long_defs='drop',\n                 max_def_per_word=1000000, with_too_many_defs='random',\n                 exclude_top_k=None, vocab_def=None,\n                 add_bod_eod=True, seed=777):\n        \"\"\"Retrieves the definitions.\n        vocab_text\n            The vocabulary for text\n        vocab_def\n            The vocabulary for definitions\n        dictionary\n            The dictionary of the definitions.\n        max_def_length\n            Disregard definitions that are longer than that.\n        exclude_top_k\n            Do not provide defitions for the first top k\n            words of the vocabulary (typically the most frequent ones).\n        max_def_per_word\n            Pick at most max_n_def definitions for each word\n        \"\"\"\n        self._vocab_text = vocab_text\n        self._add_bod_eod = add_bod_eod\n        self._rng = numpy.random.RandomState(seed)\n        if vocab_def is None:\n            self._vocab_def = self._vocab_text\n        else:\n            self._vocab_def = vocab_def\n        self._dictionary = dictionary\n        if exclude_top_k == -1:\n            logger.debug(\"Exclude definition of all dictionary words\")\n            exclude_top_k = vocab_text.size()\n        self._exclude_top_k = exclude_top_k\n\n        if all(numpy.array(self._vocab_text._id_to_freq) == 1) and exclude_top_k > 0:\n            # Also note that after merging doing exclude_top_k on freqs in merged def/text is perhaps\n            # confusing\n            raise Exception(\"Cannot perform exclude_top_k based on vocabulary without frequency information.\")\n\n        # TODO(kudkudak):\n        # To follow conventions - def dropping etc should also be performed in crawl_dict.py\n        # TODO (rizar):\n        # ... or maybe it's moving everything to the preprocessing that was a mistake\n\n        self._max_def_length = max_def_length\n        if with_too_long_defs not in {\"drop\", \"crop\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_long_defs)\n        self._with_too_long_defs = with_too_long_defs\n\n        self._max_def_per_word = max_def_per_word\n        if with_too_many_defs not in {\"random\", \"exclude\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_many_defs)\n        self._with_too_many_defs = with_too_many_defs\n\n        self._debug_info = {\n            \"missed_word_sample\": [],\n\n            \"N_words\": 0,\n            \"N_excluded_words\": 0,\n\n            \"N_distinct_words\": 0,\n            \"N_missed_distinct_words\": 0,\n\n            \"N_def\": 0,\n            \"N_dropped_def\": 0,\n\n            \"N_queried_words\": 0,\n            \"N_missed_words\": 0,\n        }\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        if \"_rng\" not in self.__dict__:\n            self._rng = numpy.random.RandomState(777)\n\n    def retrieve(self, batch):\n        \"\"\"Retrieves all definitions for a batch of words sequences.\n\n        TODO: definitions of phrases, phrasal verbs, etc.\n\n        Returns\n        -------\n        defs\n            A list of word definitions, each definition is a list of words.\n        def_map\n            A list of triples (batch_index, time_step, def_index). Maps\n            words to their respective definitions from `defs`.\n\n        \"\"\"\n        definitions = []\n        def_map = []\n        word_def_indices = {}\n\n        for seq_pos, sequence in enumerate(batch):\n            for word_pos, word in enumerate(sequence):\n                if isinstance(word, numpy.ndarray):\n                    word = vec2str(word)\n                if not word:\n                    continue\n                self._debug_info['N_words'] += 1\n                word_id = self._vocab_text.word_to_id(word)\n                if (self._exclude_top_k\n                        and word_id != self._vocab_text.unk\n                        and word_id < self._exclude_top_k):\n                    self._debug_info['N_excluded_words'] += 1\n                    continue\n\n                if word not in word_def_indices:\n                    word_def_indices[word] = []\n                    # The first time a word is encountered in a batch\n                    word_defs = self._dictionary.get_definitions(word)\n\n                    if self._max_def_per_word < len(word_defs):\n                        if self._with_too_many_defs == 'random':\n                            word_defs = self._rng.choice(\n                                word_defs, self._max_def_per_word, replace=False)\n                        else:\n                            # (rizar): if there's too many definition for a words,\n                            # maybe let's just accept that it's a \"semantic prime\"?\n                            word_defs = []\n\n                    # Debug info\n                    self._debug_info['N_distinct_words'] += 1\n                    self._debug_info['N_missed_distinct_words'] += (len(word_defs) == 0)\n                    # End of debug info\n\n                    for i, def_ in enumerate(word_defs):\n                        self._debug_info['N_def'] += 1\n\n                        if  self._with_too_long_defs == 'drop':\n                            if len(def_) > self._max_def_length:\n                                self._debug_info['N_dropped_def'] += 1\n                                continue\n                        elif self._with_too_long_defs == 'crop':\n                            def_ = def_[0:self._max_def_length]\n                        else:\n                            raise NotImplementedError()\n\n                        final_def_ = []\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.bod)\n                        for token in def_:\n                            final_def_.append(self._vocab_def.word_to_id(token))\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.eod)\n                        word_def_indices[word].append(len(definitions))\n                        definitions.append(final_def_)\n\n                # Debug info\n                self._debug_info['N_queried_words'] += 1\n                if len(word_def_indices[word]) == 0:\n                    self._debug_info['N_missed_words'] += 1\n                    if len(self._debug_info['missed_word_sample']) == 10000:\n                        self._debug_info['missed_word_sample'][numpy.random.randint(10000)] = word\n                    else:\n                        self._debug_info['missed_word_sample'].append(word)\n                # End of debug info\n\n                for def_index in word_def_indices[word]:\n                    def_map.append((seq_pos, word_pos, def_index))\n\n        return definitions, def_map\n\n    def retrieve_and_pad(self, batch):\n        defs, def_map = self.retrieve(batch)\n        if not defs:\n            defs.append(self.sentinel_definition())\n        # `defs` have variable length and have to be padded\n        max_def_length = max(map(len, defs))\n        def_array = numpy.zeros((len(defs), max_def_length), dtype='int64')\n        def_mask = numpy.ones_like(def_array, dtype=fuel.config.floatX)\n        for i, def_ in enumerate(defs):\n            def_array[i, :len(def_)] = def_\n            def_mask[i, len(def_):] = 0.\n        def_map = (numpy.array(def_map)\n                   if def_map\n                   else numpy.zeros((0, 3), dtype='int64'))\n        return def_array, def_mask, def_map\n\n    def sentinel_definition(self):\n        \"\"\"An empty definition.\n\n        If you ever need a definition that is syntactically correct but\n        doesn't mean a thing, call me.\n\n        \"\"\"\n        return [self._vocab_def.bod, self._vocab_def.eod]\ndictlearn/extensions.py\ndef construct_embedder(theano_fnc, vocab):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        word_vectors = theano_fnc(word_ids)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass StartFuelServer(SimpleExtension):\n\n    def __init__(self, stream, stream_path, script_path=\"start_fuel_server.py\", hwm=100, *args, **kwargs):\n        self._stream = stream\n        self._hwm = hwm\n        self._stream_path = stream_path\n        self._script_path = script_path\n        super(StartFuelServer, self).__init__(*args, **kwargs)\n\n    def do(self, *args, **kwars):\n        with open(self._stream_path, 'w') as dst:\n            cPickle.dump(self._stream, dst, 0)\n        port = get_free_port()\n        self.main_loop.data_stream.port = port\n        logger.debug(\"Starting the Fuel server on port \" + str(port))\n        ret = subprocess.Popen(\n            [self._script_path,\n                self._stream_path, str(port), str(self._hwm)])\n        time.sleep(0.1)\n        if ret.returncode is not None:\n            raise Exception()\n        atexit.register(lambda: os.kill(ret.pid, signal.SIGINT))\ndictlearn/inits.py\nclass GlorotUniform(NdarrayInitialization):\n    \"\"\"Initialize parameters from an isotropic Gaussian distribution.\n\n    Parameters\n    ----------\n    std : float, optional\n        The standard deviation of the Gaussian distribution. Defaults to 1.\n    mean : float, optional\n        The mean of the Gaussian distribution. Defaults to 0\n\n    Notes\n    -----\n    Be careful: the standard deviation goes first and the mean goes\n    second!\n\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def generate(self, rng, shape):\n        if len(shape) == 1:\n            return rng.uniform(size=shape, low=-0.00001, high=0.00001).astype(theano.config.floatX)\n\n        if not len(shape) == 2:\n            raise NotImplementedError(\"GlorotUniform doesnt work for \" + str(shape) + \" shape\")\n\n        fan_in, fan_out = shape[0], shape[1]\n        s = np.sqrt(6. / (fan_in + fan_out))\n        return rng.uniform(size=shape, low=-s, high=s).astype(theano.config.floatX)\n\n    def __repr__(self):\n        return \"GlorotUniform\"\ndictlearn/vocab.py\nclass Vocabulary(object):\n    \"\"\"Class that holds a vocabulary for the dataset.\"\"\"\n    BOS = '<bos>' # beginning-of-sequence\n    EOS = '<eos>' # end-of-sequence\n    BOD = '<bod>' # beginning-of-definition\n    EOD = '<eod>' # end-of-definition\n    UNK = '<unk>' # unknown token\n    SPECIAL_TOKEN_MAP = {\n        BOS: 'bos',\n        EOS: 'eos',\n        BOD: 'bod',\n        EOD: 'eod',\n        UNK: 'unk'\n    }\n\n    def __init__(self, path_or_data):\n        \"\"\"Initialize the vocabulary.\n\n        path_or_data\n            Either a list of words or the path to it.\n        top_k\n            If not `None`, only the first `top_k` entries will be left.\n            Note, this does not include the special tokens.\n\n        \"\"\"\n        if isinstance(path_or_data, string_types):\n            words_and_freqs = []\n            with open(path_or_data) as f:\n                for line in f:\n                    word, freq_str = line.strip().split()\n                    word = word.decode('utf-8')\n                    freq = int(freq_str)\n                    words_and_freqs.append((word, freq))\n        else:\n            words_and_freqs = path_or_data\n\n        self._id_to_word = []\n        self._id_to_freq = []\n        self._word_to_id = {}\n        self.bos = self.eos = -1\n        self.bod = self.eod = -1\n        self.unk = -1\n\n        for idx, (word_name, freq) in enumerate(words_and_freqs):\n            token_attr = self.SPECIAL_TOKEN_MAP.get(word_name)\n            if token_attr is not None:\n                setattr(self, token_attr, idx)\n\n            self._id_to_word.append(word_name)\n            self._id_to_freq.append(freq)\n            self._word_to_id[word_name] = idx\n\n        if -1 in [getattr(self, attr)\n                  for attr in self.SPECIAL_TOKEN_MAP.values()]:\n            raise ValueError(\"special token not found in the vocabulary\")\n\n    def size(self):\n        return len(self._id_to_word)\n\n    @property\n    def words(self):\n        return self._id_to_word\n\n    @property\n    def frequencies(self):\n        return self._id_to_freq\n\n    def word_to_id(self, word, top_k=None):\n        id_ = self._word_to_id.get(word)\n        if id_ is not None and not top_k or id_ < top_k:\n            return id_\n        return self.unk\n\n    def id_to_word(self, cur_id):\n        return self._id_to_word[cur_id]\n\n    def word_freq(self, word):\n        if not word in self._word_to_id:\n            return 0\n        return self._id_to_freq[self._word_to_id[word]]\n\n    def decode(self, cur_ids):\n        return ' '.join([self.id_to_word(cur_id) for cur_id in cur_ids])\n\n    def encode(self, sentence):\n        word_ids = [self.word_to_id(cur_word) for cur_word in sentence]\n        return numpy.array(word_ids, dtype=numpy.int64)\n\n    @staticmethod\n    def build(text, top_k=None, sort_by='frequency'):\n        \"\"\"\n        sort_by is either 'frequency' or 'lexicographical'\n        \"\"\"\n        # For now let's use a very stupid tokenization\n        if isinstance(text, str):\n            with open(text) as file_:\n                def data():\n                    for line in file_:\n                        for word in line.strip().split():\n                            yield word\n                counter = Counter(data())\n            logger.info(\"Data is read\")\n        else:\n            counter = Counter(text)\n            for word in list(counter.keys()):\n                if ' ' in word:\n                    logger.error(\"can't have tokens with spaces, skip {}\".format(word))\n                    del counter[word]\n        # It was not immediately clear to me\n        # if counter.most_common() selects consistenly among\n        # the words with the same counts. Hence, let's just sort.\n        if sort_by == 'frequency':\n            sortf = lambda x: (-x[1], x[0])\n        elif sort_by == 'lexicographical':\n            sortf = lambda x: (x[0], x[1])\n        else:\n            raise Exception(\"sort not understood:\", sort_by)\n        words_and_freqs = sorted(counter.items(), key=sortf)\n        logger.info(\"Words are sorted\")\n        if top_k:\n            words_and_freqs  = words_and_freqs[:top_k]\n        words_and_freqs = (\n            [(Vocabulary.BOS, 0),\n             (Vocabulary.EOS, 0),\n             (Vocabulary.BOD, 0),\n             (Vocabulary.EOD, 0),\n             (Vocabulary.UNK, 0)]\n            + words_and_freqs)\n\n        return Vocabulary(words_and_freqs)\n\n    def save(self, filename):\n        with open(filename, 'w') as f:\n            for word, freq in zip(self._id_to_word, self._id_to_freq):\n\n                # Note: if this fails for you make sure that words read\n                # and used by Vocabulary were utf-8 encoded prior to that\n                if not isinstance(word, text_type):\n                    word = text_type(word, \"utf-8\")\n\n                print(word.encode('utf-8'), freq, file=f)\ndictlearn/data.py\nclass SNLIData(Data):\n    def __init__(self, *args, **kwargs):\n        super(SNLIData, self).__init__(*args, **kwargs)\n        self._retrieval = None\n\n    def set_retrieval(self, retrieval):\n        self._retrieval = retrieval\n\n    def get_stream(self, part, batch_size, seed=None, raw_text=False):\n        d = self.get_dataset(part)\n        print(\"Dataset with {} examples\".format(d.num_examples))\n        it = ShuffledExampleScheme(d.num_examples, rng=numpy.random.RandomState(seed))\n        stream = DataStream(d, iteration_scheme=it)\n        stream = Batch(stream, iteration_scheme=ConstantScheme(batch_size))\n\n        if self._retrieval:\n            stream = FixedMapping(\n                stream,\n                functools.partial(retrieve_and_pad_snli, self._retrieval),\n                add_sources=(\"defs\", \"def_mask\", \"sentence1_def_map\", \"sentence2_def_map\")) # This is because there is bug in Fuel :( Cannot concatenate tuple and list\n\n        if not raw_text:\n            stream = SourcewiseMapping(stream, functools.partial(digitize, self.vocab),\n                which_sources=('sentence1', 'sentence2'))\n\n        stream = Padding(stream, mask_sources=('sentence1', 'sentence2'))  # Increases amount of outputs by x2\n\n        return stream\ndictlearn/retrieval.py\nclass Dictionary(object):\n    \"\"\"The dictionary of definitions.\n\n    The native representation of the dictionary is a mapping from a word\n    to a list of definitions, each of which is a sequence of words. All\n    the words are stored as strings.\n\n    \"\"\"\n    def __init__(self, path=None):\n\n        if not path.endswith(\"json\"):\n            raise Exception(\"Please pass path ending in .json\")\n\n        self._data = defaultdict(list)\n        self._meta_data = {}\n        self._path = path\n        self._meta_path = path.replace(\".json\", \"_meta.json\")\n        #self._tmp_path = os.path.join(os.path.dirname(path),\n        #                              self._path + '.tmp')\n        #self._meta_tmp_path = os.path.join(os.path.dirname(path),\n        #    self._meta_path + '.tmp')\n        self._tmp_path = self._path + \".tmp\"\n        self._meta_tmp_path = self._meta_path + \".tmp\"\n        if self._path:\n            if os.path.exists(self._path):\n                self.load()\n            else:\n                logger.warning(\"No dict was loaded; ignore if you are\"\n                               \" creating new one\")\n\n    def load(self):\n        with open(self._path, 'r') as src:\n            # can't just assign because self._data should keep being a\n            # defaultdict\n            self._data.update(json.load(src))\n        if os.path.exists(self._meta_path):\n            with open(self._meta_path, 'r') as src:\n                self._meta_data = json.load(src)\n\n    def save(self):\n        logger.debug(\"saving...\")\n        with open(self._tmp_path, 'w') as dst:\n            json.dump(self._data, dst, indent=2)\n        shutil.move(self._tmp_path, self._path)\n        logger.debug(\"saving meta...\")\n        with open(self._meta_tmp_path, 'w') as dst:\n            json.dump(self._meta_data, dst, indent=2)\n        shutil.move(self._meta_tmp_path, self._meta_path)\n        logger.debug(\"saved\")\n\n    def _wait_until_quota_reset(self):\n        while True:\n            status = self._account_api.getApiTokenStatus()\n            logger.debug(\"{} remaining calls\".format(status.remainingCalls))\n            if status.remainingCalls >= _MIN_REMAINING_CALLS:\n                logger.debug(\"Wordnik quota was resetted\")\n                self._remaining_calls = status.remainingCalls\n                return\n            logger.debug(\"sleep until quota reset\")\n            time.sleep(60.)\n\n    def add_identity_mapping(self, vocab):\n        for word in vocab.words:\n            self._data[word].append([word])\n            self._meta_data[word] = {\"sourceDictionary\": \"identity\"}\n        self.save()\n\n    def remove_out_of_vocabulary(self, vocab):\n        \"\"\"\n        remove definitions that are outside of a vocabulary vocab\n        \"\"\"\n        # TODO: remove from meta too\n        # can't just zip because if meta is empty then nothing happens\n        print(\"vocab size : {}\".format(vocab.size()))\n        print(\"dict len : {}\".format(len(self._data)))\n        count_del = 0\n        for word in self._data.keys():\n            word_id = vocab.word_to_id(word)\n            if word_id == vocab.unk:\n                del self._data[word]\n                count_del += 1\n                # del self._meta_data[word] # TODO:\n        print(\"have deleted {} definitions\".format(count_del))\n        self.save()\n\n\n    def add_spelling(self, vocab, only_if_no_def=True):\n        for word in vocab.words:\n            # only add spelling to the words without defs\n            if only_if_no_def and self._data[word]:\n                continue\n            def_ = word\n            if len(def_) > 10:\n                def_ = u\"{}-{}\".format(def_[:5], def_[-5:])\n            # to avoid overlapping of the vocabularies, let's add a #\n            # before each character\n            self._data[word].append(map(lambda char: u'#' + char, def_))\n            self._meta_data[word] = {\"sourceDictionary\": \"spelling\"}\n        self.save()\n\n\n    def add_from_lowercase_definitions(self, vocab):\n        \"\"\"Add definitions of lowercase word to each word (concat)\n        \"\"\"\n        added = 0\n        no_def = 0\n        for word in vocab.words:\n            word_lower = word.lower()\n            if word != word_lower:\n                lower_defs = self._data.get(word_lower)\n                # This can be quite slow. But this code will not be used\n                # very often.\n                if not lower_defs:\n                    if lower_defs is None:\n                        # This can happen when API just dies (then vocab has, dict doesnt)\n                        logger.error(\"None def for \" + word)\n                        continue\n                    no_def += 1\n                    logger.warning(\"No defs for \" + str(word_lower) + \",\" + str(word))\n                else:\n                    # Note: often empty, like Zeus -> zeus\n                    for def_ in lower_defs:\n                        if not def_ in self._data[word]:\n                            added += 1\n                            self._data[word].append(def_)\n\n        logger.info(\"No def for {}\".format(no_def))\n        logger.info(\"Added {} new defs in add_from_lowercase_definitions\".format(added))\n        self.save()\n\n\n    def add_from_lemma_definitions(self, vocab, try_lower=False):\n        \"\"\"Add lemma definitions for non-lemmas.\n\n        This code covers the following scenario: supposed a dictionary is crawled,\n        but only for word lemmas.\n\n        \"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        added = 0\n        for word in vocab.words:\n            word_list = [word, word.lower()] if try_lower else [word]\n\n            for word_to_lemma in word_list:\n                try:\n                    for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                        lemma = lemmatizer.lemmatize(word_to_lemma, part_of_speech)\n                        lemma_defs = self._data.get(lemma)\n                        if lemma != word and lemma_defs:\n                            # This can be quite slow. But this code will not be used\n                            # very often.\n                            for def_ in lemma_defs:\n                                if not def_ in self._data[word]:\n                                    added += 1\n                                    self._data[word].append(def_)\n                except:\n                    logger.error(\"lemmatizer crashed on {}\".format(word))\n                    logger.error(traceback.format_exc())\n        logger.info(\"Added {} new defs in add_from_lemma_definitions\".format(added))\n        self.save()\n\n    def add_dictname_to_defs(self, vocab):\n        \"\"\"Add dict name in front of each def\"\"\"\n        # TODO(kudkudak): I will implement it after we have attention on defs +\n        # we do shortlisting based on dict defs\n        raise NotImplementedError()\n\n    def crawl_lemmas(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        for word in vocab.words:\n            definitions = []\n            try:\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(word, part_of_speech)\n                    if lemma != word and not [lemma] in definitions:\n                        definitions.append([lemma])\n            except:\n                logger.error(\"lemmatizer crashed on {}\".format(word))\n            if definitions:\n                self._data[word] = definitions\n        self.save()\n\n    def crawl_lowercase(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        for word in vocab.words:\n            self._data[word] = [[word.lower()]]\n            self._meta_data[word.lower()] = {\"sourceDictionary\": \"lowercase\"}\n        self.save()\n\n    def crawl_wordnet(self, corenlp_url):\n        corenlp = StanfordCoreNLP(corenlp_url)\n        for i, word in enumerate(wordnet.words()):\n            if word in self._data:\n                logger.info('skip a known word {}'.format(word))\n                continue\n            self._data[word] = []\n            for synset in wordnet.synsets(word):\n                def_ = corenlp.tokenize(synset.definition())[0]\n                self._data[word].append(def_)\n            if i % 10000 == 0:\n                self.save()\n        self.save()\n\n    def crawl_wordnik(self, vocab, api_key, corenlp_url,\n                      call_quota=15000, crawl_also_lowercase=False, crawl_also_lemma=False):\n\n        \"\"\"Download and preprocess definitions from Wordnik.\n\n        vocab\n            Vocabulary for which the definitions should be found.\n        api_key\n            The API key to use in communications with Wordnik.\n        call_quota\n            Maximum number of calls per hour.\n        crawl_also_lowercase\n            If true will add lowercase version of each word to crawl list\n        crawl_also_lemma\n            If true will also crawl lemma versions of words\n            WARNING: Lemma of Cat is Cat! So if you want to have definition of \"cat\"\n            you have to also pass crawl_also_lowercase!\n\n        \"\"\"\n        corenlp = StanfordCoreNLP(corenlp_url)\n\n        self._remaining_calls = call_quota\n        self._last_saved = 0\n\n        client = swagger.ApiClient(\n            api_key, 'https://api.wordnik.com/v4')\n        self._word_api = WordApi.WordApi(client)\n        self._account_api = AccountApi.AccountApi(client)\n\n        words = list(vocab.words)\n\n        # Note(kudkudak): for SNLI it adds 3k words\n        if crawl_also_lowercase:\n            words_set = set(words)  # For efficiency\n\n            logger.info(\"Adding lowercase words to crawl\")\n            lowercased = []\n            for w in words:\n                if w.lower() not in words_set:\n                    lowercased.append(w.lower())\n            logger.info(\"Crawling additional {} words\".format(len(lowercased)))\n            words.extend(sorted(lowercased))\n\n        # Note(kudkudak): for SNLI it adds 2k words, so we can expect\n        # like sabotage,sabotaging\n        # Note that lemma crawling is *after* lowercasing\n        if crawl_also_lemma:\n            words_set = set(words) # For efficiency\n\n            logger.info(\"Adding lemmatized vrsions to crawl\")\n            lemmas = []\n            original = []\n            lemmatizer = nltk.WordNetLemmatizer()\n            for w in words:\n                if isinstance(w, str):\n                    w = w.decode('utf-8')\n\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(w, part_of_speech)\n                    if lemma not in words_set:\n                        lemmas.append(lemma)\n                        original.append(w)\n            logger.info(\"Crawling additional {} words\".format(len(lemmas)))\n            for id in numpy.random.choice(len(lemmas), 100):\n                logger.info(\"Example:\" + lemmas[id] + \",\" + original[id])\n                words.extend(sorted(lemmas))\n\n        # Here, for now, we don't do any stemming or lemmatization.\n        # Stemming is useless because the dictionary is not indexed with\n        # lemmas, not stems. Lemmatizers, on the other hand, can not be\n        # fully trusted when it comes to unknown words.\n        for word in words:\n            if isinstance(word, str):\n                word = word.decode('utf-8')\n\n            if word in self._data:\n                logger.debug(u\"a known word {}, skip\".format(word))\n                continue\n\n            if self._last_saved >= _SAVE_EVERY_CALLS:\n                self.save()\n                self._last_saved = 0\n\n            # 100 is a safery margin, I don't want to DDoS Wordnik :)\n            if self._remaining_calls < _MIN_REMAINING_CALLS:\n                self._wait_until_quota_reset()\n            try:\n                if isinstance(word, str):\n                    word = word.decode('utf-8')\n                # NOTE(kudkudak): We fetch all dictionaries, but retrieval can filter them based on meta info\n                definitions = self._word_api.getDefinitions(word)\n            except Exception:\n                logger.error(u\"error during fetching '{}'\".format(word))\n                logger.error(traceback.format_exc())\n                continue\n            self._remaining_calls -= 1\n            self._last_saved += 1\n\n            if not definitions:\n                definitions = []\n            self._data[word] = []\n            for def_ in definitions:\n                try:\n                    # seems like definition text can be both str and unicode\n                    text = def_.text\n                    if def_.text is None:\n                        continue\n                    if isinstance(text, str):\n                        text = text.decode('utf-8')\n                    tokenized_def = corenlp.tokenize(text)[0]\n                    self._data[word].append(tokenized_def)\n                    # Note(kudkudak): I don't think there is much more useful meta data for us\n                    # Note(kudkudak): This might seem strange, but I am afraid this is most robust (least bug prone)\n                    # way of storing meta data that doens't require rewriting dict storage format\n                    self._meta_data[\" \".join(tokenized_def)] = {\"sourceDictionary\": def_.sourceDictionary}\n                except Exception:\n                    logger.error(\"error during tokenizing '{}'\".format(text))\n                    logger.error(traceback.format_exc())\n            logger.debug(u\"definitions for '{}' fetched {} remaining\".format(word, self._remaining_calls))\n        self.save()\n        self._last_saved = 0\n\n    def num_entries(self):\n        return len(self._data)\n\n    def get_definitions(self, key):\n        return self._data.get(key, [])\ndictlearn/util.py\ndef configure_logger(name = __name__,\n                     console_logging_level = logging.INFO,\n                     file_logging_level = logging.INFO,\n                     log_file = None,\n                     redirect_stdout=False,\n                     redirect_stderr=False):\n    \"\"\"\n    Configures logger\n    :param name: logger name (default=module name, __name__)\n    :param console_logging_level: level of logging to console (stdout), None = no logging\n    :param file_logging_level: level of logging to log file, None = no logging\n    :param log_file: path to log file (required if file_logging_level not None)\n    :return instance of Logger class\n    \"\"\"\n    if console_logging_level is None and file_logging_level is None:\n        return # no logging\n\n    if isinstance(console_logging_level, (str, unicode)):\n        console_logging_level = parse_logging_level(console_logging_level)\n\n    if isinstance(file_logging_level, (str, unicode)):\n        file_logging_level = parse_logging_level(file_logging_level)\n\n    if not os.path.exists(os.path.dirname(log_file)):\n        os.makedirs(os.path.dirname(log_file))\n\n    logger = logging.getLogger(name)\n    logger.handlers = []\n    logger.setLevel(logging.DEBUG)\n    format = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\n    if console_logging_level is not None:\n        ch = logging.StreamHandler(sys.stdout)\n        ch.setFormatter(format)\n        ch.setLevel(console_logging_level)\n        logger.addHandler(ch)\n\n    if file_logging_level is not None:\n        if log_file is None:\n            raise ValueError(\"If file logging enabled, log_file path is required\")\n        fh = handlers.RotatingFileHandler(log_file, maxBytes=(1048576*5), backupCount=7)\n        fh.setFormatter(format)\n        logger.addHandler(fh)\n\n    logger.info(\"Logging configured!\")\n\n    if redirect_stderr:\n        sys.stderr = LoggerWriter(logger.warning)\n    if redirect_stdout:\n        sys.stdout = LoggerWriter(logger.info)\n\n    return logger\ndictlearn/extensions.py\nclass DumpCSVSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n\n        if not os.path.exists(os.path.join(self._save_path, \"logs.csv\")):\n            self._current_log = defaultdict(list)\n        else:\n            self._current_log = pd.read_csv(os.path.join(self._save_path, \"logs.csv\"))\n            self._current_log = {col: list(self._current_log[col].values) for col in self._current_log.columns}\n            logging.warning(\"Loaded {} columns and {} rows from logs.csv\".format(len(self._current_log), len(self._current_log.values()[0])))\n\n        super(DumpCSVSummaries, self).__init__(**kwargs)\n\n    def do(self, *args, **kwargs):\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n            except:\n                continue\n\n            if not key.startswith(\"val\") and not key.startswith(\"train\") and not key.startswith(\"test\"):\n                key = \"train_\" + key\n\n            if key not in self._current_log:\n                self._current_log[key] = []\n\n            self._current_log[key].append(float_value)\n\n        # Make sure all logs have same length (for csv serialization)\n        max_len = max([len(v) for v in self._current_log.values()])\n        for k in self._current_log:\n            if len(self._current_log[k]) != max_len:\n                self._current_log[k] += [self._current_log[k][-1] for _ in range(max_len - len(self._current_log[k]))]\n\n        pd.DataFrame(self._current_log).to_csv(os.path.join(self._save_path, \"logs.csv\"))\ndictlearn/extensions.py\ndef construct_dict_embedder(theano_fnc, vocab, retrieval):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        def_array, def_mask, def_map = retrieval.retrieve_and_pad(np.array(word_list).reshape(-1, 1))\n        word_vectors = theano_fnc(word_ids, def_array, def_mask, def_map)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass LoadNoUnpickling(Load):\n    \"\"\"Like `Load` but without unpickling.\n\n    Avoids unpiclkling the main loop by assuming that the log\n    and the iteration state were saved separately.\n\n    \"\"\"\n\n    def load_to(self, main_loop):\n        with open(self.path, \"rb\") as source:\n            main_loop.model.set_parameter_values(load_parameters(source))\n            if self.load_iteration_state:\n                main_loop.iteration_state = load(source, name='iteration_state')\n            if self.load_log:\n                main_loop.log = load(source, name='log')\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n    def get_embeddings_lookups(self):\n    def get_def_embeddings_lookups(self):\n    def set_def_embeddings(self, embeddings):\n    def set_embeddings(self, embeddings):\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\ndictlearn/extensions.py\nclass SimilarityWordEmbeddingEval(SimpleExtension):\n    \"\"\"\n    Parameters\n    ----------\n\n    embedder: function: word -> vector\n    \"\"\"\n\n    def __init__(self, embedder, prefix=\"\", **kwargs):\n        try:\n            from web.datasets.similarity import fetch_MEN, fetch_WS353, fetch_SimLex999, fetch_RW\n        except ImportError:\n            raise RuntimeError(\"Please install web (https://github.com/kudkudak/word-embeddings-benchmarks)\")\n\n        self._embedder = embedder\n        self._prefix = prefix\n\n        # Define tasks\n        logger.info(\"Downloading benchmark data\")\n        tasks = { # TODO: Pick a bit better tasks\n            \"MEN\": fetch_MEN(),\n            \"WS353\": fetch_WS353(),\n            \"SIMLEX999\": fetch_SimLex999(),\n            \"RW\": fetch_RW()\n        }\n\n        # Print sample data\n        for name, data in iteritems(tasks):\n            logger.info(\n            \"Sample data from {}: pair \\\"{}\\\" and \\\"{}\\\" is assigned score {}\".format(name, data.X[0][0], data.X[0][1],\n                data.y[0]))\n\n        logger.info(\"Checking embedder for \" + prefix)\n        logger.info(embedder([\"love\"])[0, 0:5]) # Test embedder\n\n        self._tasks = tasks\n\n        super(SimilarityWordEmbeddingEval, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_embedder' in dict_:\n            del dict_['_embedder']\n        if '_tasks' in dict_:\n            del dict_['_tasks']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        # Embedd\n        all_words = []\n        all_words_vectors = []\n\n        # TODO: Do it at once?\n        for task in self._tasks:\n            for row in self._tasks[task].X:\n                for w in row:\n                    all_words.append(w)\n                    all_words_vectors.append(self._embedder([w]))\n        W = dict(zip(np.array(all_words).reshape((-1,)), all_words_vectors))\n\n        # Calculate results using helper function\n        record_items = []\n        for name, data in iteritems(self._tasks):\n            eval = evaluate_similarity(W, data.X, data.y)\n            record_items.append((self._prefix + \"_\" + name, eval))\n\n        self.add_records(self.main_loop.log, record_items)\ndictlearn/extensions.py\nclass PrintMessage(SimpleExtension):\n    \"\"\"Prints log messages to the screen.\"\"\"\n    def __init__(self, msg, **kwargs):\n        self._msg = msg\n        kwargs.setdefault(\"before_first_epoch\", True)\n        kwargs.setdefault(\"on_resumption\", True)\n        kwargs.setdefault(\"after_training\", True)\n        kwargs.setdefault(\"after_epoch\", True)\n        kwargs.setdefault(\"on_interrupt\", True)\n        super(PrintMessage, self).__init__(**kwargs)\n\n    def do(self, which_callback, *args):\n        print(self._msg)\ndictlearn/extensions.py\nclass RetrievalPrintStats(SimpleExtension):\n    \"\"\"\n    Prints statistics about Retrieval object\n    \"\"\"\n\n    def __init__(self, retrieval, **kwargs):\n        self._retrieval = retrieval\n        super(RetrievalPrintStats, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_retrieval' in dict_:\n            del dict_['_retrieval']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        if self._retrieval is not None:\n            d = self._retrieval._debug_info\n            record_tuples = []\n            record_tuples.append(\n                (\"retrieval_distinct_mis_ratio\",\n                 d['N_missed_distinct_words'] / max(1, float(d['N_distinct_words']))))\n            record_tuples.append((\"retrieval_N_words\", d['N_words']))\n            record_tuples.append((\"retrieval_N_excluded_words\", d['N_excluded_words']))\n            record_tuples.append((\"retrieval_N_distinct_words\", d['N_distinct_words']))\n            record_tuples.append((\"retrieval_N_queried_words\", d['N_queried_words']))\n            record_tuples.append((\"retrieval_mis_ratio\",\n                                  d['N_missed_words']\n                                  /  max(1, float(d['N_queried_words']))))\n            record_tuples.append((\"retrieval_drop_def_ratio\",\n                                  d['N_dropped_def'] /  max(1, float(d['N_def']))))\n            if len(d['missed_word_sample']) >= 20:\n                record_tuples.append((\"retrieval_missed_word_sample\",\n                    numpy.random.choice(d['missed_word_sample'], 20, replace=False)))\n            self.add_records(self.main_loop.log, record_tuples)\ndictlearn/extensions.py\nclass DumpTensorflowSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n        super(DumpTensorflowSummaries, self).__init__(**kwargs)\n\n    @property\n    def file_writer(self):\n        if not hasattr(self, '_file_writer'):\n            self._file_writer = tensorflow.summary.FileWriter(\n                self._save_path, flush_secs=10.)\n        return self._file_writer\n\n    def __getstate__(self):\n        # FileWriter from TensorFlow is not picklable\n        dict_ = self.__dict__\n        if '_file_writer' in dict_:\n            del dict_['_file_writer']\n        return dict_\n\n    def do(self, *args, **kwargs):\n        summary = tensorflow.Summary()\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n                value = summary.value.add()\n                value.tag = key\n                value.simple_value = float_value\n            except:\n                pass\n        self.file_writer.add_summary(\n            summary, self.main_loop.log.status['iterations_done'])\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    \"\"\"\n    Simple model based on https://github.com/Smerity/keras_snl\n    \"\"\"\n\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n\n        if def_emb_dim <= 0:\n            logger.info(\"Assuming def_emb_dim=emb_dim\")\n            def_emb_dim = emb_dim\n\n        def_emb_translate_dim = def_emb_translate_dim if def_emb_translate_dim > 0 else def_emb_dim\n\n        self._vocab = vocab\n        self._bn = bn\n        self._encoder = encoder\n        self._dropout = dropout\n        self._retrieval = retrieval\n        self._only_def = disregard_word_embeddings\n        self._num_input_def_words = num_input_def_words\n        self._translate_after_emb = translate_after_emb\n\n        if reader_type not in {\"rnn\", \"mean\"}:\n            raise NotImplementedError(\"Not implemented \" + reader_type)\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            logger.info(\"Vocab set to \" + str(vocab.size()))\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if not disregard_word_embeddings:\n            self._lookup = LookupTable(self._num_input_words, emb_dim)\n            children.append(self._lookup)\n\n        if retrieval:\n            if share_def_lookup:\n                if emb_dim != def_emb_dim:\n                    self._translate_pre_def2 = Linear(input_dim=emb_dim, output_dim=def_emb_dim)\n                    children.append(self._translate_pre_def2)\n                    def_lookup = Sequence([self._lookup, self._translate_pre_def2])\n                else:\n                    def_lookup = self._lookup\n            else:\n                def_lookup = None\n\n            if reader_type== \"rnn\":\n                self._def_reader = LSTMReadDefinitions(num_input_words=self._num_input_def_words,\n                    dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab, lookup=def_lookup)\n            elif reader_type == \"mean\":\n                if combiner_reader_translate:\n                    logger.warning(\"Translate in MeanPoolReadDefinitions is redundant\")\n                self._def_reader = MeanPoolReadDefinitions(num_input_words=self._num_input_def_words,\n                    translate=combiner_reader_translate,\n                    lookup=def_lookup, dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab)\n\n            self._combiner = MeanPoolCombiner(dim=def_dim, emb_dim=def_emb_translate_dim,\n                dropout=combiner_dropout, dropout_type=combiner_dropout_type,\n                def_word_gating=combiner_gating,\n                shortcut_unk_and_excluded=combiner_shortcut, num_input_words=num_input_words,\n                exclude_top_k=exclude_top_k, vocab=vocab,\n                compose_type=compose_type)\n            children.extend([self._def_reader, self._combiner])\n\n            if self._encoder == \"rnn\":\n                self._rnn_fork = Linear(input_dim=def_emb_dim, output_dim=4 * translate_dim)\n                # TODO(kudkudak): Better LSTM weight init\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_fork)\n                children.append(self._rnn_encoder)\n            elif self._encoder == \"sum\":\n                pass\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n            if def_emb_translate_dim != emb_dim:\n                self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n                children.append(self._translate_pre_def)\n            else:\n                self._translate_pre_def = None\n\n            if self._translate_after_emb:\n                self._translation = Linear(input_dim=def_dim, output_dim=translate_dim)\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n        else:\n            if self._encoder == \"rnn\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=4 * translate_dim)\n                self._rnn_fork = self._translation\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_encoder)\n                children.append(self._translation)\n            elif self._encoder == \"sum\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=translate_dim,\n                    weights_init=GlorotUniform(), biases_init=Constant(0))\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n\n\n        if self._bn:\n            self._hyp_bn = BatchNormalization(input_dim=translate_dim, name=\"hyp_bn\", conserve_memory=False)\n            self._prem_bn = BatchNormalization(input_dim=translate_dim, name=\"prem_bn\", conserve_memory=False)\n            children += [self._hyp_bn, self._prem_bn]\n\n        self._mlp = []\n        current_dim = 2 * translate_dim  # Joint\n        for i in range(n_layers):\n            rect = Rectifier()\n            dense = Linear(input_dim=current_dim, output_dim=mlp_dim,\n                name=\"MLP_layer_\" + str(i), \\\n                weights_init=GlorotUniform(), \\\n                biases_init=Constant(0))\n            current_dim = mlp_dim\n            if self._bn:\n                bn = BatchNormalization(input_dim=current_dim, name=\"BN_\" + str(i), conserve_memory=False)\n                children.append(bn)\n            else:\n                bn = None\n\n            children += [dense, rect] #TODO: Strange place to put ReLU\n            self._mlp.append([dense, rect, bn])\n\n        self._pred = MLP([Softmax()], [current_dim, 3])\n        children.append(self._pred)\n\n        super(NLISimple, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        # Embeddings\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._retrieval is not None:\n            assert defs is not None\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            s1_transl = self._combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_transl = self._combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n\n            if self._translate_after_emb:\n                # Note: for some reader/combiner it can be redundant, but let's keep it\n                # often it will not be redundant (ex: LSTMDefReader)\n                s1_transl = s1_transl.reshape((s1_transl.shape[0] * s1_transl.shape[1], s1_transl.shape[2]))\n                s2_transl = s2_transl.reshape((s2_transl.shape[0] * s2_transl.shape[1], s2_transl.shape[2]))\n                s1_transl = self._translation.apply(s1_transl)\n                s2_transl = self._translation.apply(s2_transl)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n        else:\n            # Translate. Crucial for recovering useful information from embeddings\n            s1_emb_flatten = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n            s2_emb_flatten = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n\n            if self._translate_after_emb:\n                # Note: redundant for trainable (from scratch) embeddings\n                s1_transl = self._translation.apply(s1_emb_flatten)\n                s2_transl = self._translation.apply(s2_emb_flatten)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n                application_call.add_auxiliary_variable(\n                    1*s1_transl,\n                    name='s1_translated_word_embeddings')\n                assert s1_transl.ndim == 3\n            else:\n                s1_transl = s1_emb_flatten\n                s2_transl = s2_emb_flatten\n\n        if self._encoder == \"rnn\":\n            s1_transl = self._rnn_fork.apply(s1_transl)\n            s2_transl = self._rnn_fork.apply(s2_transl)\n\n        assert s1_transl.ndim == s2_transl.ndim == 3\n\n        # Construct entailment embedding\n        if self._encoder == \"sum\":\n            s1_emb_mask = s1_mask.dimshuffle((0, 1, \"x\"))\n            s2_emb_mask = s2_mask.dimshuffle((0, 1, \"x\"))\n\n            # TODO: This should be mean, might make learning harder otherwise\n            prem = (s1_emb_mask * s1_transl).sum(axis=1)\n            hyp = (s2_emb_mask * s2_transl).sum(axis=1)\n        else:\n            prem = self._rnn_encoder.apply(s1_transl.transpose(1, 0, 2), mask=s1_mask.transpose(1, 0))[0][-1]\n            hyp = self._rnn_encoder.apply(s2_transl.transpose(1, 0, 2), mask=s2_mask.transpose(1, 0))[0][-1]\n\n        if self._bn:\n            prem = self._prem_bn.apply(prem)\n            hyp = self._hyp_bn.apply(hyp)\n\n        joint = T.concatenate([prem, hyp], axis=1)\n        joint.name = \"MLP_input\"\n\n        if train_phase:\n            joint = apply_dropout(joint, drop_prob=self._dropout)\n\n        # MLP\n        for block in self._mlp:\n            dense, relu, bn = block\n            joint = dense.apply(joint)\n            joint = relu.apply(joint)\n\n            if train_phase:\n                joint = apply_dropout(joint, drop_prob=self._dropout)\n\n            if self._bn:\n                joint = bn.apply(joint)\n\n        return self._pred.apply(joint)\ndictlearn/nli_esim_model.py\nclass ESIM(Initializable):\n    \"\"\"\n    ESIM model based on https://github.com/NYU-MLL/multiNLI/blob/master/python/models/esim.py\n    \"\"\"\n\n    # seq_length, emb_dim, hidden_dim\n    def __init__(self, dim, emb_dim, vocab, def_emb_translate_dim=-1, def_dim=-1, encoder='bilstm', bn=True,\n            def_reader=None, def_combiner=None, dropout=0.5, num_input_words=-1,\n            # Others\n            **kwargs):\n\n        self._dropout = dropout\n        self._vocab = vocab\n        self._emb_dim = emb_dim\n        self._def_reader = def_reader\n        self._def_combiner = def_combiner\n\n        if encoder != 'bilstm':\n            raise NotImplementedError()\n\n        if def_emb_translate_dim < 0:\n            self.def_emb_translate_dim = emb_dim\n        else:\n            self.def_emb_translate_dim = def_emb_translate_dim\n\n        if def_dim < 0:\n            self._def_dim = emb_dim\n        else:\n            self._def_dim = def_dim\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if self.def_emb_translate_dim != self._emb_dim:\n            self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n            children.append(self._translate_pre_def)\n        else:\n            self._translate_pre_def = None\n\n        ## Embedding\n        self._lookup = LookupTable(self._num_input_words, emb_dim, weights_init=GlorotUniform())\n        children.append(self._lookup)\n\n        if def_reader:\n            self._final_emb_dim = self._def_dim\n            self._def_reader = def_reader\n            self._def_combiner = def_combiner\n            children.extend([self._def_reader, self._def_combiner])\n        else:\n            self._final_emb_dim = self._emb_dim\n\n        ## BiLSTM\n        self._hyp_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='hyp_bidir_fork')\n        self._hyp_bidir = Bidirectional(LSTM(dim), name='hyp_bidir')\n        self._prem_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='prem_bidir_fork')\n        self._prem_bidir = Bidirectional(LSTM(dim), name='prem_bidir')\n        children.extend([self._hyp_bidir_fork, self._hyp_bidir])\n        children.extend([self._prem_bidir, self._prem_bidir_fork])\n\n        ## BiLSTM no. 2 (encoded attentioned embeddings)\n        self._hyp_bidir_fork2 = Linear(8 * dim, 4 * dim, name='hyp_bidir_fork2')\n        self._hyp_bidir2 = Bidirectional(LSTM(dim), name='hyp_bidir2')\n        self._prem_bidir_fork2 = Linear(8 * dim, 4 * dim, name='prem_bidir_fork2')\n        self._prem_bidir2 = Bidirectional(LSTM(dim), name='prem_bidir2')\n        children.extend([self._hyp_bidir_fork2, self._hyp_bidir2])\n        children.extend([self._prem_bidir2, self._prem_bidir_fork2])\n\n        self._rnns = [self._prem_bidir2, self._hyp_bidir2, self._prem_bidir, self._hyp_bidir]\n\n        ## MLP\n        if bn:\n            self._mlp = BatchNormalizedMLP([Tanh()], [8 * dim, dim], conserve_memory=False, name=\"mlp\")\n            self._pred = BatchNormalizedMLP([Softmax()], [dim, 3],  conserve_memory=False, name=\"pred_mlp\")\n        else:\n            self._mlp = MLP([Tanh()], [8 * dim, dim], name=\"mlp\")\n            self._pred = MLP([Softmax()], [dim, 3], name=\"pred_mlp\")\n\n        children.append(self._mlp)\n        children.append(self._pred)\n\n        ## Softmax\n        self._ndim_softmax = NDimensionalSoftmax()\n        children.append(self._ndim_softmax)\n\n        super(ESIM, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None,\n            defs=None, s1_def_map=None, s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        ### Embed ###\n\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._def_reader:\n            assert defs is not None\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            s1_emb = self._def_combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_emb = self._def_combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n        else:\n            if train_phase and self._dropout > 0:\n                s1_emb = apply_dropout(s1_emb, drop_prob=self._dropout)\n                s2_emb = apply_dropout(s2_emb, drop_prob=self._dropout)\n\n        ### Encode ###\n\n        # TODO: Share this bilstm?\n        s1_bilstm, _ = self._prem_bidir.apply(flip01(self._prem_bidir_fork.apply(s1_emb)),\n            mask=s1_mask.T) # (batch_size, n_seq, 2 * dim)\n        s2_bilstm, _ = self._hyp_bidir.apply(flip01(self._hyp_bidir_fork.apply(s2_emb)),\n            mask=s2_mask.T) # (batch_size, n_seq, 2 * dim)\n        s1_bilstm = flip01(s1_bilstm)\n        s2_bilstm = flip01(s2_bilstm)\n        ### Attention ###\n\n        # Compute E matrix (eq. 11)\n        # E_ij = <s1[i], s2[j]>\n        # each call computes E[i, :]\n        def compute_e_row(s2_i, s1_bilstm, s1_mask):\n            b_size = s1_bilstm.shape[0]\n            # s2_i is (batch_size, emb_dim)\n            # s1_bilstm is (batch_size, seq_len, emb_dim)\n            # s1_mask is (batch_size, seq_len)\n            # s2_i = s2_i.reshape((s2_i.shape[0], s2_i.shape[1], 1))\n            s2_i = s2_i.reshape((b_size, s2_i.shape[1], 1))\n            s2_i = T.repeat(s2_i, 2, axis=2)\n            # s2_i is (batch_size, emb_dim, 2)\n            assert s1_bilstm.ndim == 3\n            assert s2_i.ndim == 3\n            score = T.batched_dot(s1_bilstm, s2_i) # (batch_size, seq_len, 1)\n            score = score[:, :, 0].reshape((b_size, -1)) # (batch_size, seq_len)\n            return score # E[i, :]\n\n        # NOTE: No point in masking here\n        E, _ = theano.scan(compute_e_row, sequences=[s1_bilstm.transpose(1, 0, 2)],\n            non_sequences=[s2_bilstm, s2_mask])\n        # (seq_len, batch_size, seq_len)\n        E = E.dimshuffle(1, 0, 2)\n        assert E.ndim == 3\n\n        s2s_att_weights = self._ndim_softmax.apply(E, extra_ndim=1)\n        application_call.add_auxiliary_variable(\n            s2s_att_weights.copy(), name='s2s_att_weights')\n\n        # (batch_size, seq_len, seq_len)\n\n        ### Compute tilde vectors (eq. 12 and 13) ###\n\n        def compute_tilde_vector(e_i, s, s_mask):\n            # e_i is (batch_size, seq_len)\n            # s_mask is (batch_size, seq_len)\n            # s_tilde_i = \\sum e_ij b_j, (batch_size, seq_len)\n            score = masked_softmax(e_i, s_mask, axis=1)\n            score = score.dimshuffle(0, 1, \"x\")\n\n            s_tilde_i = (score * (s * s_mask.dimshuffle(0, 1, \"x\"))).sum(axis=1)\n            return s_tilde_i\n\n        # (batch_size, seq_len, def_dim)\n        s1_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(1, 0, 2)], non_sequences=[s2_bilstm, s2_mask])\n        s1_tilde = s1_tilde.dimshuffle(1, 0, 2)\n        s2_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(2, 0, 1)], non_sequences=[s1_bilstm, s1_mask])\n        s2_tilde = s2_tilde.dimshuffle(1, 0, 2)\n\n        ### Compose (eq. 14 and 15) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        s1_comp = T.concatenate([s1_bilstm, s1_tilde, s1_bilstm - s1_tilde, s1_bilstm * s1_tilde], axis=2)\n        s2_comp = T.concatenate([s2_bilstm, s2_tilde, s2_bilstm - s2_tilde, s2_bilstm * s2_tilde], axis=2)\n        ### Encode (eq. 16 and 17) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        # TODO: Share this bilstm?\n        s1_comp_bilstm, _ = self._prem_bidir2.apply(self._prem_bidir_fork2.apply(flip01(s1_comp)), mask=s1_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s2_comp_bilstm, _ = self._hyp_bidir2.apply(self._hyp_bidir_fork2.apply(flip01(s2_comp)), mask=s2_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s1_comp_bilstm = flip01(s1_comp_bilstm)\n        s2_comp_bilstm = flip01(s2_comp_bilstm)\n        ### Pooling Layer ###\n\n        s1_comp_bilstm_ave = (s1_mask.dimshuffle(0, 1, \"x\") * s1_comp_bilstm).sum(axis=1) \\\n                            / s1_mask.sum(axis=1).dimshuffle(0, \"x\")\n\n        s1_comp_bilstm_max = T.max( ((1 - s1_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                    (s1_mask.dimshuffle(0, 1, \"x\")) * s1_comp_bilstm, axis=1)\n\n        s2_comp_bilstm_ave = (s2_mask.dimshuffle(0, 1, \"x\") * s2_comp_bilstm).sum(axis=1) \\\n                             / s2_mask.sum(axis=1).dimshuffle(0, \"x\")\n        # (batch_size, dim)\n        s2_comp_bilstm_max = T.max(((1 - s2_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                   (s2_mask.dimshuffle(0, 1, \"x\")) * s2_comp_bilstm, axis=1)\n\n        ### Final classifier ###\n\n        # MLP layer\n        # (batch_size, 8 * dim)\n        m = T.concatenate([s1_comp_bilstm_ave, s1_comp_bilstm_max, s2_comp_bilstm_ave, s2_comp_bilstm_max], axis=1)\n        pre_logits = self._mlp.apply(m)\n\n        if train_phase:\n            pre_logits = apply_dropout(pre_logits, drop_prob=self._dropout)\n\n        # Get prediction\n        self.logits = self._pred.apply(pre_logits)\n\n        return self.logits\nimport sys\nimport numpy as np\nimport matplotlib.pylab as plt\nimport os\nimport time\nimport atexit\nimport fuel\nimport signal\nimport pprint\nimport pandas as pd\nimport subprocess\nimport tqdm\nimport cPickle as pickle\nimport json\nimport numpy\nimport theano\nimport logging\nfrom theano import tensor\nfrom blocks.bricks.cost import MisclassificationRate\nfrom blocks.bricks.bn import BatchNormalization\nfrom blocks.filter import get_brick\nfrom blocks.bricks import Linear, Sequence\nfrom blocks.bricks.lookup import LookupTable\nfrom blocks.bricks.cost import CategoricalCrossEntropy\nfrom blocks.extensions import ProgressBar, Timestamp\nfrom blocks.extensions.training import TrackTheBest\nfrom dictlearn.extensions import (\n    DumpTensorflowSummaries)\nfrom blocks.extensions.predicates import OnLogRecord\nfrom blocks.serialization import load_parameters\nfrom blocks.initialization import Constant, Uniform\nfrom dictlearn.vocab import Vocabulary\nfrom dictlearn.inits import GlorotUniform\nfrom dictlearn.extensions import LoadNoUnpickling\nfrom theano import tensor as T\nfrom blocks.algorithms import (\n    GradientDescent, Adam)\nfrom blocks.graph import ComputationGraph, apply_batch_normalization, get_batch_normalization_updates\nfrom blocks.model import Model\nfrom blocks.graph.bn import (\n    apply_batch_normalization, get_batch_normalization_updates,\n    batch_normalization)\nfrom blocks.extensions import FinishAfter, Timing, Printing\nfrom blocks.extensions.saveload import Load, Checkpoint\nfrom blocks.extensions.monitoring import (DataStreamMonitoring,\n                                          TrainingDataMonitoring)\nfrom blocks.main_loop import MainLoop\nfrom blocks.roles import WEIGHT\nfrom blocks.filter import VariableFilter\nfrom fuel.streams import ServerDataStream\nfrom dictlearn.util import configure_logger\nfrom dictlearn.extensions import StartFuelServer, DumpCSVSummaries, SimilarityWordEmbeddingEval, construct_embedder, \\\n    construct_dict_embedder, RetrievalPrintStats, PrintMessage\nfrom dictlearn.data import SNLIData\nfrom dictlearn.nli_simple_model import NLISimple\nfrom dictlearn.nli_esim_model import ESIM\nfrom dictlearn.retrieval import Retrieval, Dictionary\nfrom dictlearn.nli_simple_model import LSTMReadDefinitions, MeanPoolReadDefinitions, MeanPoolCombiner\nfrom blocks.serialization import secure_dump, dump_and_add_to_dump\nfrom blocks.extensions import SimpleExtension\n    from six import string_types\n\"\"\"\nTraining loop for simple SNLI model that can use dict enchanced embeddings\n\"\"\"\n\n\n\nsys.path.append(\"..\")\n\n\n\n\n\n\n\n\n\nclass OnLogStatusExceed(object):\n    \"\"\"Trigger a callback when a certain log record is found.\n\n    Parameters\n    ----------\n    record_name : str\n        The record name to check.\n\n    \"\"\"\n    def __init__(self, record_name, max_val):\n        self.record_name = record_name\n        self.max_val = max_val\n\n    def __call__(self, log):\n        return bool(log.status.get(self.record_name, -numpy.inf) >= self.max_val)\n\n    def __eq__(self, other):\n        return (type(other) == type(self) and\n                other.record_name == self.record_name)\n\n\n# vocab defaults to data.vocab\n# vocab_text defaults to vocab\n# Vocab def defaults to vocab\ndef _initialize_simple_model_and_data(c):\n\n    if c['vocab']:\n        vocab = Vocabulary(c['vocab'])\n    else:\n        vocab = None\n    # Load data\nNext line of code:\n", "input": "import sys\nimport numpy as np\nimport matplotlib.pylab as plt\nimport os\nimport time\nimport atexit\nimport fuel\nimport signal\nimport pprint\nimport pandas as pd\nimport subprocess\nimport tqdm\nimport cPickle as pickle\nimport json\nimport numpy\nimport theano\nimport logging\nfrom theano import tensor\nfrom blocks.bricks.cost import MisclassificationRate\nfrom blocks.bricks.bn import BatchNormalization\nfrom blocks.filter import get_brick\nfrom blocks.bricks import Linear, Sequence\nfrom blocks.bricks.lookup import LookupTable\nfrom blocks.bricks.cost import CategoricalCrossEntropy\nfrom blocks.extensions import ProgressBar, Timestamp\nfrom blocks.extensions.training import TrackTheBest\nfrom dictlearn.extensions import (\n    DumpTensorflowSummaries)\nfrom blocks.extensions.predicates import OnLogRecord\nfrom blocks.serialization import load_parameters\nfrom blocks.initialization import Constant, Uniform\nfrom dictlearn.vocab import Vocabulary\nfrom dictlearn.inits import GlorotUniform\nfrom dictlearn.extensions import LoadNoUnpickling\nfrom theano import tensor as T\nfrom blocks.algorithms import (\n    GradientDescent, Adam)\nfrom blocks.graph import ComputationGraph, apply_batch_normalization, get_batch_normalization_updates\nfrom blocks.model import Model\nfrom blocks.graph.bn import (\n    apply_batch_normalization, get_batch_normalization_updates,\n    batch_normalization)\nfrom blocks.extensions import FinishAfter, Timing, Printing\nfrom blocks.extensions.saveload import Load, Checkpoint\nfrom blocks.extensions.monitoring import (DataStreamMonitoring,\n                                          TrainingDataMonitoring)\nfrom blocks.main_loop import MainLoop\nfrom blocks.roles import WEIGHT\nfrom blocks.filter import VariableFilter\nfrom fuel.streams import ServerDataStream\nfrom dictlearn.util import configure_logger\nfrom dictlearn.extensions import StartFuelServer, DumpCSVSummaries, SimilarityWordEmbeddingEval, construct_embedder, \\\n    construct_dict_embedder, RetrievalPrintStats, PrintMessage\nfrom dictlearn.data import SNLIData\nfrom dictlearn.nli_simple_model import NLISimple\nfrom dictlearn.nli_esim_model import ESIM\nfrom dictlearn.retrieval import Retrieval, Dictionary\nfrom dictlearn.nli_simple_model import LSTMReadDefinitions, MeanPoolReadDefinitions, MeanPoolCombiner\nfrom blocks.serialization import secure_dump, dump_and_add_to_dump\nfrom blocks.extensions import SimpleExtension\n    from six import string_types\n\"\"\"\nTraining loop for simple SNLI model that can use dict enchanced embeddings\n\"\"\"\n\n\n\nsys.path.append(\"..\")\n\n\n\n\n\n\n\n\n\nclass OnLogStatusExceed(object):\n    \"\"\"Trigger a callback when a certain log record is found.\n\n    Parameters\n    ----------\n    record_name : str\n        The record name to check.\n\n    \"\"\"\n    def __init__(self, record_name, max_val):\n        self.record_name = record_name\n        self.max_val = max_val\n\n    def __call__(self, log):\n        return bool(log.status.get(self.record_name, -numpy.inf) >= self.max_val)\n\n    def __eq__(self, other):\n        return (type(other) == type(self) and\n                other.record_name == self.record_name)\n\n\n# vocab defaults to data.vocab\n# vocab_text defaults to vocab\n# Vocab def defaults to vocab\ndef _initialize_simple_model_and_data(c):\n\n    if c['vocab']:\n        vocab = Vocabulary(c['vocab'])\n    else:\n        vocab = None\n    # Load data\n", "context": "dictlearn/retrieval.py\nclass Retrieval(object):\n\n    def __init__(self, vocab_text, dictionary,\n                 max_def_length=1000, with_too_long_defs='drop',\n                 max_def_per_word=1000000, with_too_many_defs='random',\n                 exclude_top_k=None, vocab_def=None,\n                 add_bod_eod=True, seed=777):\n        \"\"\"Retrieves the definitions.\n        vocab_text\n            The vocabulary for text\n        vocab_def\n            The vocabulary for definitions\n        dictionary\n            The dictionary of the definitions.\n        max_def_length\n            Disregard definitions that are longer than that.\n        exclude_top_k\n            Do not provide defitions for the first top k\n            words of the vocabulary (typically the most frequent ones).\n        max_def_per_word\n            Pick at most max_n_def definitions for each word\n        \"\"\"\n        self._vocab_text = vocab_text\n        self._add_bod_eod = add_bod_eod\n        self._rng = numpy.random.RandomState(seed)\n        if vocab_def is None:\n            self._vocab_def = self._vocab_text\n        else:\n            self._vocab_def = vocab_def\n        self._dictionary = dictionary\n        if exclude_top_k == -1:\n            logger.debug(\"Exclude definition of all dictionary words\")\n            exclude_top_k = vocab_text.size()\n        self._exclude_top_k = exclude_top_k\n\n        if all(numpy.array(self._vocab_text._id_to_freq) == 1) and exclude_top_k > 0:\n            # Also note that after merging doing exclude_top_k on freqs in merged def/text is perhaps\n            # confusing\n            raise Exception(\"Cannot perform exclude_top_k based on vocabulary without frequency information.\")\n\n        # TODO(kudkudak):\n        # To follow conventions - def dropping etc should also be performed in crawl_dict.py\n        # TODO (rizar):\n        # ... or maybe it's moving everything to the preprocessing that was a mistake\n\n        self._max_def_length = max_def_length\n        if with_too_long_defs not in {\"drop\", \"crop\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_long_defs)\n        self._with_too_long_defs = with_too_long_defs\n\n        self._max_def_per_word = max_def_per_word\n        if with_too_many_defs not in {\"random\", \"exclude\"}:\n            raise NotImplementedError(\"Not implemented \" + with_too_many_defs)\n        self._with_too_many_defs = with_too_many_defs\n\n        self._debug_info = {\n            \"missed_word_sample\": [],\n\n            \"N_words\": 0,\n            \"N_excluded_words\": 0,\n\n            \"N_distinct_words\": 0,\n            \"N_missed_distinct_words\": 0,\n\n            \"N_def\": 0,\n            \"N_dropped_def\": 0,\n\n            \"N_queried_words\": 0,\n            \"N_missed_words\": 0,\n        }\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        if \"_rng\" not in self.__dict__:\n            self._rng = numpy.random.RandomState(777)\n\n    def retrieve(self, batch):\n        \"\"\"Retrieves all definitions for a batch of words sequences.\n\n        TODO: definitions of phrases, phrasal verbs, etc.\n\n        Returns\n        -------\n        defs\n            A list of word definitions, each definition is a list of words.\n        def_map\n            A list of triples (batch_index, time_step, def_index). Maps\n            words to their respective definitions from `defs`.\n\n        \"\"\"\n        definitions = []\n        def_map = []\n        word_def_indices = {}\n\n        for seq_pos, sequence in enumerate(batch):\n            for word_pos, word in enumerate(sequence):\n                if isinstance(word, numpy.ndarray):\n                    word = vec2str(word)\n                if not word:\n                    continue\n                self._debug_info['N_words'] += 1\n                word_id = self._vocab_text.word_to_id(word)\n                if (self._exclude_top_k\n                        and word_id != self._vocab_text.unk\n                        and word_id < self._exclude_top_k):\n                    self._debug_info['N_excluded_words'] += 1\n                    continue\n\n                if word not in word_def_indices:\n                    word_def_indices[word] = []\n                    # The first time a word is encountered in a batch\n                    word_defs = self._dictionary.get_definitions(word)\n\n                    if self._max_def_per_word < len(word_defs):\n                        if self._with_too_many_defs == 'random':\n                            word_defs = self._rng.choice(\n                                word_defs, self._max_def_per_word, replace=False)\n                        else:\n                            # (rizar): if there's too many definition for a words,\n                            # maybe let's just accept that it's a \"semantic prime\"?\n                            word_defs = []\n\n                    # Debug info\n                    self._debug_info['N_distinct_words'] += 1\n                    self._debug_info['N_missed_distinct_words'] += (len(word_defs) == 0)\n                    # End of debug info\n\n                    for i, def_ in enumerate(word_defs):\n                        self._debug_info['N_def'] += 1\n\n                        if  self._with_too_long_defs == 'drop':\n                            if len(def_) > self._max_def_length:\n                                self._debug_info['N_dropped_def'] += 1\n                                continue\n                        elif self._with_too_long_defs == 'crop':\n                            def_ = def_[0:self._max_def_length]\n                        else:\n                            raise NotImplementedError()\n\n                        final_def_ = []\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.bod)\n                        for token in def_:\n                            final_def_.append(self._vocab_def.word_to_id(token))\n                        if self._add_bod_eod:\n                            final_def_.append(self._vocab_def.eod)\n                        word_def_indices[word].append(len(definitions))\n                        definitions.append(final_def_)\n\n                # Debug info\n                self._debug_info['N_queried_words'] += 1\n                if len(word_def_indices[word]) == 0:\n                    self._debug_info['N_missed_words'] += 1\n                    if len(self._debug_info['missed_word_sample']) == 10000:\n                        self._debug_info['missed_word_sample'][numpy.random.randint(10000)] = word\n                    else:\n                        self._debug_info['missed_word_sample'].append(word)\n                # End of debug info\n\n                for def_index in word_def_indices[word]:\n                    def_map.append((seq_pos, word_pos, def_index))\n\n        return definitions, def_map\n\n    def retrieve_and_pad(self, batch):\n        defs, def_map = self.retrieve(batch)\n        if not defs:\n            defs.append(self.sentinel_definition())\n        # `defs` have variable length and have to be padded\n        max_def_length = max(map(len, defs))\n        def_array = numpy.zeros((len(defs), max_def_length), dtype='int64')\n        def_mask = numpy.ones_like(def_array, dtype=fuel.config.floatX)\n        for i, def_ in enumerate(defs):\n            def_array[i, :len(def_)] = def_\n            def_mask[i, len(def_):] = 0.\n        def_map = (numpy.array(def_map)\n                   if def_map\n                   else numpy.zeros((0, 3), dtype='int64'))\n        return def_array, def_mask, def_map\n\n    def sentinel_definition(self):\n        \"\"\"An empty definition.\n\n        If you ever need a definition that is syntactically correct but\n        doesn't mean a thing, call me.\n\n        \"\"\"\n        return [self._vocab_def.bod, self._vocab_def.eod]\ndictlearn/extensions.py\ndef construct_embedder(theano_fnc, vocab):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        word_vectors = theano_fnc(word_ids)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass StartFuelServer(SimpleExtension):\n\n    def __init__(self, stream, stream_path, script_path=\"start_fuel_server.py\", hwm=100, *args, **kwargs):\n        self._stream = stream\n        self._hwm = hwm\n        self._stream_path = stream_path\n        self._script_path = script_path\n        super(StartFuelServer, self).__init__(*args, **kwargs)\n\n    def do(self, *args, **kwars):\n        with open(self._stream_path, 'w') as dst:\n            cPickle.dump(self._stream, dst, 0)\n        port = get_free_port()\n        self.main_loop.data_stream.port = port\n        logger.debug(\"Starting the Fuel server on port \" + str(port))\n        ret = subprocess.Popen(\n            [self._script_path,\n                self._stream_path, str(port), str(self._hwm)])\n        time.sleep(0.1)\n        if ret.returncode is not None:\n            raise Exception()\n        atexit.register(lambda: os.kill(ret.pid, signal.SIGINT))\ndictlearn/inits.py\nclass GlorotUniform(NdarrayInitialization):\n    \"\"\"Initialize parameters from an isotropic Gaussian distribution.\n\n    Parameters\n    ----------\n    std : float, optional\n        The standard deviation of the Gaussian distribution. Defaults to 1.\n    mean : float, optional\n        The mean of the Gaussian distribution. Defaults to 0\n\n    Notes\n    -----\n    Be careful: the standard deviation goes first and the mean goes\n    second!\n\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def generate(self, rng, shape):\n        if len(shape) == 1:\n            return rng.uniform(size=shape, low=-0.00001, high=0.00001).astype(theano.config.floatX)\n\n        if not len(shape) == 2:\n            raise NotImplementedError(\"GlorotUniform doesnt work for \" + str(shape) + \" shape\")\n\n        fan_in, fan_out = shape[0], shape[1]\n        s = np.sqrt(6. / (fan_in + fan_out))\n        return rng.uniform(size=shape, low=-s, high=s).astype(theano.config.floatX)\n\n    def __repr__(self):\n        return \"GlorotUniform\"\ndictlearn/vocab.py\nclass Vocabulary(object):\n    \"\"\"Class that holds a vocabulary for the dataset.\"\"\"\n    BOS = '<bos>' # beginning-of-sequence\n    EOS = '<eos>' # end-of-sequence\n    BOD = '<bod>' # beginning-of-definition\n    EOD = '<eod>' # end-of-definition\n    UNK = '<unk>' # unknown token\n    SPECIAL_TOKEN_MAP = {\n        BOS: 'bos',\n        EOS: 'eos',\n        BOD: 'bod',\n        EOD: 'eod',\n        UNK: 'unk'\n    }\n\n    def __init__(self, path_or_data):\n        \"\"\"Initialize the vocabulary.\n\n        path_or_data\n            Either a list of words or the path to it.\n        top_k\n            If not `None`, only the first `top_k` entries will be left.\n            Note, this does not include the special tokens.\n\n        \"\"\"\n        if isinstance(path_or_data, string_types):\n            words_and_freqs = []\n            with open(path_or_data) as f:\n                for line in f:\n                    word, freq_str = line.strip().split()\n                    word = word.decode('utf-8')\n                    freq = int(freq_str)\n                    words_and_freqs.append((word, freq))\n        else:\n            words_and_freqs = path_or_data\n\n        self._id_to_word = []\n        self._id_to_freq = []\n        self._word_to_id = {}\n        self.bos = self.eos = -1\n        self.bod = self.eod = -1\n        self.unk = -1\n\n        for idx, (word_name, freq) in enumerate(words_and_freqs):\n            token_attr = self.SPECIAL_TOKEN_MAP.get(word_name)\n            if token_attr is not None:\n                setattr(self, token_attr, idx)\n\n            self._id_to_word.append(word_name)\n            self._id_to_freq.append(freq)\n            self._word_to_id[word_name] = idx\n\n        if -1 in [getattr(self, attr)\n                  for attr in self.SPECIAL_TOKEN_MAP.values()]:\n            raise ValueError(\"special token not found in the vocabulary\")\n\n    def size(self):\n        return len(self._id_to_word)\n\n    @property\n    def words(self):\n        return self._id_to_word\n\n    @property\n    def frequencies(self):\n        return self._id_to_freq\n\n    def word_to_id(self, word, top_k=None):\n        id_ = self._word_to_id.get(word)\n        if id_ is not None and not top_k or id_ < top_k:\n            return id_\n        return self.unk\n\n    def id_to_word(self, cur_id):\n        return self._id_to_word[cur_id]\n\n    def word_freq(self, word):\n        if not word in self._word_to_id:\n            return 0\n        return self._id_to_freq[self._word_to_id[word]]\n\n    def decode(self, cur_ids):\n        return ' '.join([self.id_to_word(cur_id) for cur_id in cur_ids])\n\n    def encode(self, sentence):\n        word_ids = [self.word_to_id(cur_word) for cur_word in sentence]\n        return numpy.array(word_ids, dtype=numpy.int64)\n\n    @staticmethod\n    def build(text, top_k=None, sort_by='frequency'):\n        \"\"\"\n        sort_by is either 'frequency' or 'lexicographical'\n        \"\"\"\n        # For now let's use a very stupid tokenization\n        if isinstance(text, str):\n            with open(text) as file_:\n                def data():\n                    for line in file_:\n                        for word in line.strip().split():\n                            yield word\n                counter = Counter(data())\n            logger.info(\"Data is read\")\n        else:\n            counter = Counter(text)\n            for word in list(counter.keys()):\n                if ' ' in word:\n                    logger.error(\"can't have tokens with spaces, skip {}\".format(word))\n                    del counter[word]\n        # It was not immediately clear to me\n        # if counter.most_common() selects consistenly among\n        # the words with the same counts. Hence, let's just sort.\n        if sort_by == 'frequency':\n            sortf = lambda x: (-x[1], x[0])\n        elif sort_by == 'lexicographical':\n            sortf = lambda x: (x[0], x[1])\n        else:\n            raise Exception(\"sort not understood:\", sort_by)\n        words_and_freqs = sorted(counter.items(), key=sortf)\n        logger.info(\"Words are sorted\")\n        if top_k:\n            words_and_freqs  = words_and_freqs[:top_k]\n        words_and_freqs = (\n            [(Vocabulary.BOS, 0),\n             (Vocabulary.EOS, 0),\n             (Vocabulary.BOD, 0),\n             (Vocabulary.EOD, 0),\n             (Vocabulary.UNK, 0)]\n            + words_and_freqs)\n\n        return Vocabulary(words_and_freqs)\n\n    def save(self, filename):\n        with open(filename, 'w') as f:\n            for word, freq in zip(self._id_to_word, self._id_to_freq):\n\n                # Note: if this fails for you make sure that words read\n                # and used by Vocabulary were utf-8 encoded prior to that\n                if not isinstance(word, text_type):\n                    word = text_type(word, \"utf-8\")\n\n                print(word.encode('utf-8'), freq, file=f)\ndictlearn/data.py\nclass SNLIData(Data):\n    def __init__(self, *args, **kwargs):\n        super(SNLIData, self).__init__(*args, **kwargs)\n        self._retrieval = None\n\n    def set_retrieval(self, retrieval):\n        self._retrieval = retrieval\n\n    def get_stream(self, part, batch_size, seed=None, raw_text=False):\n        d = self.get_dataset(part)\n        print(\"Dataset with {} examples\".format(d.num_examples))\n        it = ShuffledExampleScheme(d.num_examples, rng=numpy.random.RandomState(seed))\n        stream = DataStream(d, iteration_scheme=it)\n        stream = Batch(stream, iteration_scheme=ConstantScheme(batch_size))\n\n        if self._retrieval:\n            stream = FixedMapping(\n                stream,\n                functools.partial(retrieve_and_pad_snli, self._retrieval),\n                add_sources=(\"defs\", \"def_mask\", \"sentence1_def_map\", \"sentence2_def_map\")) # This is because there is bug in Fuel :( Cannot concatenate tuple and list\n\n        if not raw_text:\n            stream = SourcewiseMapping(stream, functools.partial(digitize, self.vocab),\n                which_sources=('sentence1', 'sentence2'))\n\n        stream = Padding(stream, mask_sources=('sentence1', 'sentence2'))  # Increases amount of outputs by x2\n\n        return stream\ndictlearn/retrieval.py\nclass Dictionary(object):\n    \"\"\"The dictionary of definitions.\n\n    The native representation of the dictionary is a mapping from a word\n    to a list of definitions, each of which is a sequence of words. All\n    the words are stored as strings.\n\n    \"\"\"\n    def __init__(self, path=None):\n\n        if not path.endswith(\"json\"):\n            raise Exception(\"Please pass path ending in .json\")\n\n        self._data = defaultdict(list)\n        self._meta_data = {}\n        self._path = path\n        self._meta_path = path.replace(\".json\", \"_meta.json\")\n        #self._tmp_path = os.path.join(os.path.dirname(path),\n        #                              self._path + '.tmp')\n        #self._meta_tmp_path = os.path.join(os.path.dirname(path),\n        #    self._meta_path + '.tmp')\n        self._tmp_path = self._path + \".tmp\"\n        self._meta_tmp_path = self._meta_path + \".tmp\"\n        if self._path:\n            if os.path.exists(self._path):\n                self.load()\n            else:\n                logger.warning(\"No dict was loaded; ignore if you are\"\n                               \" creating new one\")\n\n    def load(self):\n        with open(self._path, 'r') as src:\n            # can't just assign because self._data should keep being a\n            # defaultdict\n            self._data.update(json.load(src))\n        if os.path.exists(self._meta_path):\n            with open(self._meta_path, 'r') as src:\n                self._meta_data = json.load(src)\n\n    def save(self):\n        logger.debug(\"saving...\")\n        with open(self._tmp_path, 'w') as dst:\n            json.dump(self._data, dst, indent=2)\n        shutil.move(self._tmp_path, self._path)\n        logger.debug(\"saving meta...\")\n        with open(self._meta_tmp_path, 'w') as dst:\n            json.dump(self._meta_data, dst, indent=2)\n        shutil.move(self._meta_tmp_path, self._meta_path)\n        logger.debug(\"saved\")\n\n    def _wait_until_quota_reset(self):\n        while True:\n            status = self._account_api.getApiTokenStatus()\n            logger.debug(\"{} remaining calls\".format(status.remainingCalls))\n            if status.remainingCalls >= _MIN_REMAINING_CALLS:\n                logger.debug(\"Wordnik quota was resetted\")\n                self._remaining_calls = status.remainingCalls\n                return\n            logger.debug(\"sleep until quota reset\")\n            time.sleep(60.)\n\n    def add_identity_mapping(self, vocab):\n        for word in vocab.words:\n            self._data[word].append([word])\n            self._meta_data[word] = {\"sourceDictionary\": \"identity\"}\n        self.save()\n\n    def remove_out_of_vocabulary(self, vocab):\n        \"\"\"\n        remove definitions that are outside of a vocabulary vocab\n        \"\"\"\n        # TODO: remove from meta too\n        # can't just zip because if meta is empty then nothing happens\n        print(\"vocab size : {}\".format(vocab.size()))\n        print(\"dict len : {}\".format(len(self._data)))\n        count_del = 0\n        for word in self._data.keys():\n            word_id = vocab.word_to_id(word)\n            if word_id == vocab.unk:\n                del self._data[word]\n                count_del += 1\n                # del self._meta_data[word] # TODO:\n        print(\"have deleted {} definitions\".format(count_del))\n        self.save()\n\n\n    def add_spelling(self, vocab, only_if_no_def=True):\n        for word in vocab.words:\n            # only add spelling to the words without defs\n            if only_if_no_def and self._data[word]:\n                continue\n            def_ = word\n            if len(def_) > 10:\n                def_ = u\"{}-{}\".format(def_[:5], def_[-5:])\n            # to avoid overlapping of the vocabularies, let's add a #\n            # before each character\n            self._data[word].append(map(lambda char: u'#' + char, def_))\n            self._meta_data[word] = {\"sourceDictionary\": \"spelling\"}\n        self.save()\n\n\n    def add_from_lowercase_definitions(self, vocab):\n        \"\"\"Add definitions of lowercase word to each word (concat)\n        \"\"\"\n        added = 0\n        no_def = 0\n        for word in vocab.words:\n            word_lower = word.lower()\n            if word != word_lower:\n                lower_defs = self._data.get(word_lower)\n                # This can be quite slow. But this code will not be used\n                # very often.\n                if not lower_defs:\n                    if lower_defs is None:\n                        # This can happen when API just dies (then vocab has, dict doesnt)\n                        logger.error(\"None def for \" + word)\n                        continue\n                    no_def += 1\n                    logger.warning(\"No defs for \" + str(word_lower) + \",\" + str(word))\n                else:\n                    # Note: often empty, like Zeus -> zeus\n                    for def_ in lower_defs:\n                        if not def_ in self._data[word]:\n                            added += 1\n                            self._data[word].append(def_)\n\n        logger.info(\"No def for {}\".format(no_def))\n        logger.info(\"Added {} new defs in add_from_lowercase_definitions\".format(added))\n        self.save()\n\n\n    def add_from_lemma_definitions(self, vocab, try_lower=False):\n        \"\"\"Add lemma definitions for non-lemmas.\n\n        This code covers the following scenario: supposed a dictionary is crawled,\n        but only for word lemmas.\n\n        \"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        added = 0\n        for word in vocab.words:\n            word_list = [word, word.lower()] if try_lower else [word]\n\n            for word_to_lemma in word_list:\n                try:\n                    for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                        lemma = lemmatizer.lemmatize(word_to_lemma, part_of_speech)\n                        lemma_defs = self._data.get(lemma)\n                        if lemma != word and lemma_defs:\n                            # This can be quite slow. But this code will not be used\n                            # very often.\n                            for def_ in lemma_defs:\n                                if not def_ in self._data[word]:\n                                    added += 1\n                                    self._data[word].append(def_)\n                except:\n                    logger.error(\"lemmatizer crashed on {}\".format(word))\n                    logger.error(traceback.format_exc())\n        logger.info(\"Added {} new defs in add_from_lemma_definitions\".format(added))\n        self.save()\n\n    def add_dictname_to_defs(self, vocab):\n        \"\"\"Add dict name in front of each def\"\"\"\n        # TODO(kudkudak): I will implement it after we have attention on defs +\n        # we do shortlisting based on dict defs\n        raise NotImplementedError()\n\n    def crawl_lemmas(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        lemmatizer = nltk.WordNetLemmatizer()\n        for word in vocab.words:\n            definitions = []\n            try:\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(word, part_of_speech)\n                    if lemma != word and not [lemma] in definitions:\n                        definitions.append([lemma])\n            except:\n                logger.error(\"lemmatizer crashed on {}\".format(word))\n            if definitions:\n                self._data[word] = definitions\n        self.save()\n\n    def crawl_lowercase(self, vocab):\n        \"\"\"Add Wordnet lemmas as definitions.\"\"\"\n        for word in vocab.words:\n            self._data[word] = [[word.lower()]]\n            self._meta_data[word.lower()] = {\"sourceDictionary\": \"lowercase\"}\n        self.save()\n\n    def crawl_wordnet(self, corenlp_url):\n        corenlp = StanfordCoreNLP(corenlp_url)\n        for i, word in enumerate(wordnet.words()):\n            if word in self._data:\n                logger.info('skip a known word {}'.format(word))\n                continue\n            self._data[word] = []\n            for synset in wordnet.synsets(word):\n                def_ = corenlp.tokenize(synset.definition())[0]\n                self._data[word].append(def_)\n            if i % 10000 == 0:\n                self.save()\n        self.save()\n\n    def crawl_wordnik(self, vocab, api_key, corenlp_url,\n                      call_quota=15000, crawl_also_lowercase=False, crawl_also_lemma=False):\n\n        \"\"\"Download and preprocess definitions from Wordnik.\n\n        vocab\n            Vocabulary for which the definitions should be found.\n        api_key\n            The API key to use in communications with Wordnik.\n        call_quota\n            Maximum number of calls per hour.\n        crawl_also_lowercase\n            If true will add lowercase version of each word to crawl list\n        crawl_also_lemma\n            If true will also crawl lemma versions of words\n            WARNING: Lemma of Cat is Cat! So if you want to have definition of \"cat\"\n            you have to also pass crawl_also_lowercase!\n\n        \"\"\"\n        corenlp = StanfordCoreNLP(corenlp_url)\n\n        self._remaining_calls = call_quota\n        self._last_saved = 0\n\n        client = swagger.ApiClient(\n            api_key, 'https://api.wordnik.com/v4')\n        self._word_api = WordApi.WordApi(client)\n        self._account_api = AccountApi.AccountApi(client)\n\n        words = list(vocab.words)\n\n        # Note(kudkudak): for SNLI it adds 3k words\n        if crawl_also_lowercase:\n            words_set = set(words)  # For efficiency\n\n            logger.info(\"Adding lowercase words to crawl\")\n            lowercased = []\n            for w in words:\n                if w.lower() not in words_set:\n                    lowercased.append(w.lower())\n            logger.info(\"Crawling additional {} words\".format(len(lowercased)))\n            words.extend(sorted(lowercased))\n\n        # Note(kudkudak): for SNLI it adds 2k words, so we can expect\n        # like sabotage,sabotaging\n        # Note that lemma crawling is *after* lowercasing\n        if crawl_also_lemma:\n            words_set = set(words) # For efficiency\n\n            logger.info(\"Adding lemmatized vrsions to crawl\")\n            lemmas = []\n            original = []\n            lemmatizer = nltk.WordNetLemmatizer()\n            for w in words:\n                if isinstance(w, str):\n                    w = w.decode('utf-8')\n\n                for part_of_speech in ['a', 's', 'r', 'n', 'v']:\n                    lemma = lemmatizer.lemmatize(w, part_of_speech)\n                    if lemma not in words_set:\n                        lemmas.append(lemma)\n                        original.append(w)\n            logger.info(\"Crawling additional {} words\".format(len(lemmas)))\n            for id in numpy.random.choice(len(lemmas), 100):\n                logger.info(\"Example:\" + lemmas[id] + \",\" + original[id])\n                words.extend(sorted(lemmas))\n\n        # Here, for now, we don't do any stemming or lemmatization.\n        # Stemming is useless because the dictionary is not indexed with\n        # lemmas, not stems. Lemmatizers, on the other hand, can not be\n        # fully trusted when it comes to unknown words.\n        for word in words:\n            if isinstance(word, str):\n                word = word.decode('utf-8')\n\n            if word in self._data:\n                logger.debug(u\"a known word {}, skip\".format(word))\n                continue\n\n            if self._last_saved >= _SAVE_EVERY_CALLS:\n                self.save()\n                self._last_saved = 0\n\n            # 100 is a safery margin, I don't want to DDoS Wordnik :)\n            if self._remaining_calls < _MIN_REMAINING_CALLS:\n                self._wait_until_quota_reset()\n            try:\n                if isinstance(word, str):\n                    word = word.decode('utf-8')\n                # NOTE(kudkudak): We fetch all dictionaries, but retrieval can filter them based on meta info\n                definitions = self._word_api.getDefinitions(word)\n            except Exception:\n                logger.error(u\"error during fetching '{}'\".format(word))\n                logger.error(traceback.format_exc())\n                continue\n            self._remaining_calls -= 1\n            self._last_saved += 1\n\n            if not definitions:\n                definitions = []\n            self._data[word] = []\n            for def_ in definitions:\n                try:\n                    # seems like definition text can be both str and unicode\n                    text = def_.text\n                    if def_.text is None:\n                        continue\n                    if isinstance(text, str):\n                        text = text.decode('utf-8')\n                    tokenized_def = corenlp.tokenize(text)[0]\n                    self._data[word].append(tokenized_def)\n                    # Note(kudkudak): I don't think there is much more useful meta data for us\n                    # Note(kudkudak): This might seem strange, but I am afraid this is most robust (least bug prone)\n                    # way of storing meta data that doens't require rewriting dict storage format\n                    self._meta_data[\" \".join(tokenized_def)] = {\"sourceDictionary\": def_.sourceDictionary}\n                except Exception:\n                    logger.error(\"error during tokenizing '{}'\".format(text))\n                    logger.error(traceback.format_exc())\n            logger.debug(u\"definitions for '{}' fetched {} remaining\".format(word, self._remaining_calls))\n        self.save()\n        self._last_saved = 0\n\n    def num_entries(self):\n        return len(self._data)\n\n    def get_definitions(self, key):\n        return self._data.get(key, [])\ndictlearn/util.py\ndef configure_logger(name = __name__,\n                     console_logging_level = logging.INFO,\n                     file_logging_level = logging.INFO,\n                     log_file = None,\n                     redirect_stdout=False,\n                     redirect_stderr=False):\n    \"\"\"\n    Configures logger\n    :param name: logger name (default=module name, __name__)\n    :param console_logging_level: level of logging to console (stdout), None = no logging\n    :param file_logging_level: level of logging to log file, None = no logging\n    :param log_file: path to log file (required if file_logging_level not None)\n    :return instance of Logger class\n    \"\"\"\n    if console_logging_level is None and file_logging_level is None:\n        return # no logging\n\n    if isinstance(console_logging_level, (str, unicode)):\n        console_logging_level = parse_logging_level(console_logging_level)\n\n    if isinstance(file_logging_level, (str, unicode)):\n        file_logging_level = parse_logging_level(file_logging_level)\n\n    if not os.path.exists(os.path.dirname(log_file)):\n        os.makedirs(os.path.dirname(log_file))\n\n    logger = logging.getLogger(name)\n    logger.handlers = []\n    logger.setLevel(logging.DEBUG)\n    format = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\n    if console_logging_level is not None:\n        ch = logging.StreamHandler(sys.stdout)\n        ch.setFormatter(format)\n        ch.setLevel(console_logging_level)\n        logger.addHandler(ch)\n\n    if file_logging_level is not None:\n        if log_file is None:\n            raise ValueError(\"If file logging enabled, log_file path is required\")\n        fh = handlers.RotatingFileHandler(log_file, maxBytes=(1048576*5), backupCount=7)\n        fh.setFormatter(format)\n        logger.addHandler(fh)\n\n    logger.info(\"Logging configured!\")\n\n    if redirect_stderr:\n        sys.stderr = LoggerWriter(logger.warning)\n    if redirect_stdout:\n        sys.stdout = LoggerWriter(logger.info)\n\n    return logger\ndictlearn/extensions.py\nclass DumpCSVSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n\n        if not os.path.exists(os.path.join(self._save_path, \"logs.csv\")):\n            self._current_log = defaultdict(list)\n        else:\n            self._current_log = pd.read_csv(os.path.join(self._save_path, \"logs.csv\"))\n            self._current_log = {col: list(self._current_log[col].values) for col in self._current_log.columns}\n            logging.warning(\"Loaded {} columns and {} rows from logs.csv\".format(len(self._current_log), len(self._current_log.values()[0])))\n\n        super(DumpCSVSummaries, self).__init__(**kwargs)\n\n    def do(self, *args, **kwargs):\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n            except:\n                continue\n\n            if not key.startswith(\"val\") and not key.startswith(\"train\") and not key.startswith(\"test\"):\n                key = \"train_\" + key\n\n            if key not in self._current_log:\n                self._current_log[key] = []\n\n            self._current_log[key].append(float_value)\n\n        # Make sure all logs have same length (for csv serialization)\n        max_len = max([len(v) for v in self._current_log.values()])\n        for k in self._current_log:\n            if len(self._current_log[k]) != max_len:\n                self._current_log[k] += [self._current_log[k][-1] for _ in range(max_len - len(self._current_log[k]))]\n\n        pd.DataFrame(self._current_log).to_csv(os.path.join(self._save_path, \"logs.csv\"))\ndictlearn/extensions.py\ndef construct_dict_embedder(theano_fnc, vocab, retrieval):\n    \"\"\"\n    Parameters\n    ----------\n    theano_fnc: theano.Function\n        (batch_size, seq_len) -> (batch_size, seq_len, word_dim)\n\n    vocab: Vocabulary\n        Vocabulary instance\n\n    Returns\n    -------\n        Python function: (batch_size, ) -> (batch_size, word_dim)\n    \"\"\"\n\n    def _embedder(word_list):\n        word_ids = vocab.encode(word_list)\n        word_ids = np.array(word_ids)\n        word_ids = word_ids.reshape((-1, 1)) # Just to adhere to theano.Function, whatever\n        def_array, def_mask, def_map = retrieval.retrieve_and_pad(np.array(word_list).reshape(-1, 1))\n        word_vectors = theano_fnc(word_ids, def_array, def_mask, def_map)\n        word_vectors = word_vectors.reshape((len(word_list), -1))\n        return word_vectors\n\n    return _embedder\ndictlearn/extensions.py\nclass LoadNoUnpickling(Load):\n    \"\"\"Like `Load` but without unpickling.\n\n    Avoids unpiclkling the main loop by assuming that the log\n    and the iteration state were saved separately.\n\n    \"\"\"\n\n    def load_to(self, main_loop):\n        with open(self.path, \"rb\") as source:\n            main_loop.model.set_parameter_values(load_parameters(source))\n            if self.load_iteration_state:\n                main_loop.iteration_state = load(source, name='iteration_state')\n            if self.load_log:\n                main_loop.log = load(source, name='log')\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n    def get_embeddings_lookups(self):\n    def get_def_embeddings_lookups(self):\n    def set_def_embeddings(self, embeddings):\n    def set_embeddings(self, embeddings):\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\ndictlearn/extensions.py\nclass SimilarityWordEmbeddingEval(SimpleExtension):\n    \"\"\"\n    Parameters\n    ----------\n\n    embedder: function: word -> vector\n    \"\"\"\n\n    def __init__(self, embedder, prefix=\"\", **kwargs):\n        try:\n            from web.datasets.similarity import fetch_MEN, fetch_WS353, fetch_SimLex999, fetch_RW\n        except ImportError:\n            raise RuntimeError(\"Please install web (https://github.com/kudkudak/word-embeddings-benchmarks)\")\n\n        self._embedder = embedder\n        self._prefix = prefix\n\n        # Define tasks\n        logger.info(\"Downloading benchmark data\")\n        tasks = { # TODO: Pick a bit better tasks\n            \"MEN\": fetch_MEN(),\n            \"WS353\": fetch_WS353(),\n            \"SIMLEX999\": fetch_SimLex999(),\n            \"RW\": fetch_RW()\n        }\n\n        # Print sample data\n        for name, data in iteritems(tasks):\n            logger.info(\n            \"Sample data from {}: pair \\\"{}\\\" and \\\"{}\\\" is assigned score {}\".format(name, data.X[0][0], data.X[0][1],\n                data.y[0]))\n\n        logger.info(\"Checking embedder for \" + prefix)\n        logger.info(embedder([\"love\"])[0, 0:5]) # Test embedder\n\n        self._tasks = tasks\n\n        super(SimilarityWordEmbeddingEval, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_embedder' in dict_:\n            del dict_['_embedder']\n        if '_tasks' in dict_:\n            del dict_['_tasks']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        # Embedd\n        all_words = []\n        all_words_vectors = []\n\n        # TODO: Do it at once?\n        for task in self._tasks:\n            for row in self._tasks[task].X:\n                for w in row:\n                    all_words.append(w)\n                    all_words_vectors.append(self._embedder([w]))\n        W = dict(zip(np.array(all_words).reshape((-1,)), all_words_vectors))\n\n        # Calculate results using helper function\n        record_items = []\n        for name, data in iteritems(self._tasks):\n            eval = evaluate_similarity(W, data.X, data.y)\n            record_items.append((self._prefix + \"_\" + name, eval))\n\n        self.add_records(self.main_loop.log, record_items)\ndictlearn/extensions.py\nclass PrintMessage(SimpleExtension):\n    \"\"\"Prints log messages to the screen.\"\"\"\n    def __init__(self, msg, **kwargs):\n        self._msg = msg\n        kwargs.setdefault(\"before_first_epoch\", True)\n        kwargs.setdefault(\"on_resumption\", True)\n        kwargs.setdefault(\"after_training\", True)\n        kwargs.setdefault(\"after_epoch\", True)\n        kwargs.setdefault(\"on_interrupt\", True)\n        super(PrintMessage, self).__init__(**kwargs)\n\n    def do(self, which_callback, *args):\n        print(self._msg)\ndictlearn/extensions.py\nclass RetrievalPrintStats(SimpleExtension):\n    \"\"\"\n    Prints statistics about Retrieval object\n    \"\"\"\n\n    def __init__(self, retrieval, **kwargs):\n        self._retrieval = retrieval\n        super(RetrievalPrintStats, self).__init__(**kwargs)\n\n    def __getstate__(self):\n        dict_ = dict(self.__dict__)\n        if '_retrieval' in dict_:\n            del dict_['_retrieval']\n        return dict_\n\n    def add_records(self, log, record_tuples):\n        \"\"\"Helper function to add monitoring records to the log.\"\"\"\n        for name, value in record_tuples:\n            if not name:\n                raise ValueError(\"monitor variable without name\")\n            log.current_row[name] = value\n\n    def do(self, *args, **kwargs):\n        if self._retrieval is not None:\n            d = self._retrieval._debug_info\n            record_tuples = []\n            record_tuples.append(\n                (\"retrieval_distinct_mis_ratio\",\n                 d['N_missed_distinct_words'] / max(1, float(d['N_distinct_words']))))\n            record_tuples.append((\"retrieval_N_words\", d['N_words']))\n            record_tuples.append((\"retrieval_N_excluded_words\", d['N_excluded_words']))\n            record_tuples.append((\"retrieval_N_distinct_words\", d['N_distinct_words']))\n            record_tuples.append((\"retrieval_N_queried_words\", d['N_queried_words']))\n            record_tuples.append((\"retrieval_mis_ratio\",\n                                  d['N_missed_words']\n                                  /  max(1, float(d['N_queried_words']))))\n            record_tuples.append((\"retrieval_drop_def_ratio\",\n                                  d['N_dropped_def'] /  max(1, float(d['N_def']))))\n            if len(d['missed_word_sample']) >= 20:\n                record_tuples.append((\"retrieval_missed_word_sample\",\n                    numpy.random.choice(d['missed_word_sample'], 20, replace=False)))\n            self.add_records(self.main_loop.log, record_tuples)\ndictlearn/extensions.py\nclass DumpTensorflowSummaries(SimpleExtension):\n    def __init__(self, save_path, **kwargs):\n        self._save_path = save_path\n        super(DumpTensorflowSummaries, self).__init__(**kwargs)\n\n    @property\n    def file_writer(self):\n        if not hasattr(self, '_file_writer'):\n            self._file_writer = tensorflow.summary.FileWriter(\n                self._save_path, flush_secs=10.)\n        return self._file_writer\n\n    def __getstate__(self):\n        # FileWriter from TensorFlow is not picklable\n        dict_ = self.__dict__\n        if '_file_writer' in dict_:\n            del dict_['_file_writer']\n        return dict_\n\n    def do(self, *args, **kwargs):\n        summary = tensorflow.Summary()\n        for key, value in self.main_loop.log.current_row.items():\n            try:\n                float_value = float(value)\n                value = summary.value.add()\n                value.tag = key\n                value.simple_value = float_value\n            except:\n                pass\n        self.file_writer.add_summary(\n            summary, self.main_loop.log.status['iterations_done'])\ndictlearn/nli_simple_model.py\nclass NLISimple(Initializable):\n    \"\"\"\n    Simple model based on https://github.com/Smerity/keras_snl\n    \"\"\"\n\n    def __init__(self, mlp_dim, translate_dim, emb_dim, vocab, num_input_words=-1,\n            num_input_def_words=-1, dropout=0.2, encoder=\"sum\",\n            n_layers=3, translate_after_emb=True, bn=True,\n\n            # Dict lookup kwargs\n            retrieval=None, reader_type=\"rnn\", compose_type=\"sum\", def_dim=300,\n            disregard_word_embeddings=False, combiner_dropout=1.0, combiner_bn=False,\n            combiner_dropout_type=\"regular\", share_def_lookup=False, exclude_top_k=-1,\n            combiner_reader_translate=True, def_vocab=None, def_emb_dim=-1,\n            combiner_gating=\"none\", def_emb_translate_dim=-1,\n            combiner_shortcut=False,\n            # Others\n            **kwargs):\n\n        if def_emb_dim <= 0:\n            logger.info(\"Assuming def_emb_dim=emb_dim\")\n            def_emb_dim = emb_dim\n\n        def_emb_translate_dim = def_emb_translate_dim if def_emb_translate_dim > 0 else def_emb_dim\n\n        self._vocab = vocab\n        self._bn = bn\n        self._encoder = encoder\n        self._dropout = dropout\n        self._retrieval = retrieval\n        self._only_def = disregard_word_embeddings\n        self._num_input_def_words = num_input_def_words\n        self._translate_after_emb = translate_after_emb\n\n        if reader_type not in {\"rnn\", \"mean\"}:\n            raise NotImplementedError(\"Not implemented \" + reader_type)\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            logger.info(\"Vocab set to \" + str(vocab.size()))\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if not disregard_word_embeddings:\n            self._lookup = LookupTable(self._num_input_words, emb_dim)\n            children.append(self._lookup)\n\n        if retrieval:\n            if share_def_lookup:\n                if emb_dim != def_emb_dim:\n                    self._translate_pre_def2 = Linear(input_dim=emb_dim, output_dim=def_emb_dim)\n                    children.append(self._translate_pre_def2)\n                    def_lookup = Sequence([self._lookup, self._translate_pre_def2])\n                else:\n                    def_lookup = self._lookup\n            else:\n                def_lookup = None\n\n            if reader_type== \"rnn\":\n                self._def_reader = LSTMReadDefinitions(num_input_words=self._num_input_def_words,\n                    dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab, lookup=def_lookup)\n            elif reader_type == \"mean\":\n                if combiner_reader_translate:\n                    logger.warning(\"Translate in MeanPoolReadDefinitions is redundant\")\n                self._def_reader = MeanPoolReadDefinitions(num_input_words=self._num_input_def_words,\n                    translate=combiner_reader_translate,\n                    lookup=def_lookup, dim=def_emb_translate_dim,\n                    emb_dim=def_emb_dim, vocab=def_vocab)\n\n            self._combiner = MeanPoolCombiner(dim=def_dim, emb_dim=def_emb_translate_dim,\n                dropout=combiner_dropout, dropout_type=combiner_dropout_type,\n                def_word_gating=combiner_gating,\n                shortcut_unk_and_excluded=combiner_shortcut, num_input_words=num_input_words,\n                exclude_top_k=exclude_top_k, vocab=vocab,\n                compose_type=compose_type)\n            children.extend([self._def_reader, self._combiner])\n\n            if self._encoder == \"rnn\":\n                self._rnn_fork = Linear(input_dim=def_emb_dim, output_dim=4 * translate_dim)\n                # TODO(kudkudak): Better LSTM weight init\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_fork)\n                children.append(self._rnn_encoder)\n            elif self._encoder == \"sum\":\n                pass\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n            if def_emb_translate_dim != emb_dim:\n                self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n                children.append(self._translate_pre_def)\n            else:\n                self._translate_pre_def = None\n\n            if self._translate_after_emb:\n                self._translation = Linear(input_dim=def_dim, output_dim=translate_dim)\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n        else:\n            if self._encoder == \"rnn\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=4 * translate_dim)\n                self._rnn_fork = self._translation\n                self._rnn_encoder = LSTM(dim=translate_dim, name='LSTM_encoder')\n                children.append(self._rnn_encoder)\n                children.append(self._translation)\n            elif self._encoder == \"sum\":\n                self._translation = Linear(input_dim=emb_dim, output_dim=translate_dim,\n                    weights_init=GlorotUniform(), biases_init=Constant(0))\n                self._translation_act = Rectifier()\n                children.append(self._translation)\n                children.append(self._translation_act)\n            else:\n                raise NotImplementedError(\"Not implemented encoder\")\n\n\n\n        if self._bn:\n            self._hyp_bn = BatchNormalization(input_dim=translate_dim, name=\"hyp_bn\", conserve_memory=False)\n            self._prem_bn = BatchNormalization(input_dim=translate_dim, name=\"prem_bn\", conserve_memory=False)\n            children += [self._hyp_bn, self._prem_bn]\n\n        self._mlp = []\n        current_dim = 2 * translate_dim  # Joint\n        for i in range(n_layers):\n            rect = Rectifier()\n            dense = Linear(input_dim=current_dim, output_dim=mlp_dim,\n                name=\"MLP_layer_\" + str(i), \\\n                weights_init=GlorotUniform(), \\\n                biases_init=Constant(0))\n            current_dim = mlp_dim\n            if self._bn:\n                bn = BatchNormalization(input_dim=current_dim, name=\"BN_\" + str(i), conserve_memory=False)\n                children.append(bn)\n            else:\n                bn = None\n\n            children += [dense, rect] #TODO: Strange place to put ReLU\n            self._mlp.append([dense, rect, bn])\n\n        self._pred = MLP([Softmax()], [current_dim, 3])\n        children.append(self._pred)\n\n        super(NLISimple, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None, defs=None, s1_def_map=None,\n            s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        # Embeddings\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._retrieval is not None:\n            assert defs is not None\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            s1_transl = self._combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_transl = self._combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n\n            if self._translate_after_emb:\n                # Note: for some reader/combiner it can be redundant, but let's keep it\n                # often it will not be redundant (ex: LSTMDefReader)\n                s1_transl = s1_transl.reshape((s1_transl.shape[0] * s1_transl.shape[1], s1_transl.shape[2]))\n                s2_transl = s2_transl.reshape((s2_transl.shape[0] * s2_transl.shape[1], s2_transl.shape[2]))\n                s1_transl = self._translation.apply(s1_transl)\n                s2_transl = self._translation.apply(s2_transl)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n        else:\n            # Translate. Crucial for recovering useful information from embeddings\n            s1_emb_flatten = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n            s2_emb_flatten = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n\n            if self._translate_after_emb:\n                # Note: redundant for trainable (from scratch) embeddings\n                s1_transl = self._translation.apply(s1_emb_flatten)\n                s2_transl = self._translation.apply(s2_emb_flatten)\n                s1_transl = self._translation_act.apply(s1_transl)\n                s2_transl = self._translation_act.apply(s2_transl)\n                s1_transl = s1_transl.reshape((s1_emb.shape[0], s1_emb.shape[1], -1))\n                s2_transl = s2_transl.reshape((s2_emb.shape[0], s2_emb.shape[1], -1))\n                application_call.add_auxiliary_variable(\n                    1*s1_transl,\n                    name='s1_translated_word_embeddings')\n                assert s1_transl.ndim == 3\n            else:\n                s1_transl = s1_emb_flatten\n                s2_transl = s2_emb_flatten\n\n        if self._encoder == \"rnn\":\n            s1_transl = self._rnn_fork.apply(s1_transl)\n            s2_transl = self._rnn_fork.apply(s2_transl)\n\n        assert s1_transl.ndim == s2_transl.ndim == 3\n\n        # Construct entailment embedding\n        if self._encoder == \"sum\":\n            s1_emb_mask = s1_mask.dimshuffle((0, 1, \"x\"))\n            s2_emb_mask = s2_mask.dimshuffle((0, 1, \"x\"))\n\n            # TODO: This should be mean, might make learning harder otherwise\n            prem = (s1_emb_mask * s1_transl).sum(axis=1)\n            hyp = (s2_emb_mask * s2_transl).sum(axis=1)\n        else:\n            prem = self._rnn_encoder.apply(s1_transl.transpose(1, 0, 2), mask=s1_mask.transpose(1, 0))[0][-1]\n            hyp = self._rnn_encoder.apply(s2_transl.transpose(1, 0, 2), mask=s2_mask.transpose(1, 0))[0][-1]\n\n        if self._bn:\n            prem = self._prem_bn.apply(prem)\n            hyp = self._hyp_bn.apply(hyp)\n\n        joint = T.concatenate([prem, hyp], axis=1)\n        joint.name = \"MLP_input\"\n\n        if train_phase:\n            joint = apply_dropout(joint, drop_prob=self._dropout)\n\n        # MLP\n        for block in self._mlp:\n            dense, relu, bn = block\n            joint = dense.apply(joint)\n            joint = relu.apply(joint)\n\n            if train_phase:\n                joint = apply_dropout(joint, drop_prob=self._dropout)\n\n            if self._bn:\n                joint = bn.apply(joint)\n\n        return self._pred.apply(joint)\ndictlearn/nli_esim_model.py\nclass ESIM(Initializable):\n    \"\"\"\n    ESIM model based on https://github.com/NYU-MLL/multiNLI/blob/master/python/models/esim.py\n    \"\"\"\n\n    # seq_length, emb_dim, hidden_dim\n    def __init__(self, dim, emb_dim, vocab, def_emb_translate_dim=-1, def_dim=-1, encoder='bilstm', bn=True,\n            def_reader=None, def_combiner=None, dropout=0.5, num_input_words=-1,\n            # Others\n            **kwargs):\n\n        self._dropout = dropout\n        self._vocab = vocab\n        self._emb_dim = emb_dim\n        self._def_reader = def_reader\n        self._def_combiner = def_combiner\n\n        if encoder != 'bilstm':\n            raise NotImplementedError()\n\n        if def_emb_translate_dim < 0:\n            self.def_emb_translate_dim = emb_dim\n        else:\n            self.def_emb_translate_dim = def_emb_translate_dim\n\n        if def_dim < 0:\n            self._def_dim = emb_dim\n        else:\n            self._def_dim = def_dim\n\n        if num_input_words > 0:\n            logger.info(\"Restricting vocab to \" + str(num_input_words))\n            self._num_input_words = num_input_words\n        else:\n            self._num_input_words = vocab.size()\n\n        children = []\n\n        if self.def_emb_translate_dim != self._emb_dim:\n            self._translate_pre_def = Linear(input_dim=emb_dim, output_dim=def_emb_translate_dim)\n            children.append(self._translate_pre_def)\n        else:\n            self._translate_pre_def = None\n\n        ## Embedding\n        self._lookup = LookupTable(self._num_input_words, emb_dim, weights_init=GlorotUniform())\n        children.append(self._lookup)\n\n        if def_reader:\n            self._final_emb_dim = self._def_dim\n            self._def_reader = def_reader\n            self._def_combiner = def_combiner\n            children.extend([self._def_reader, self._def_combiner])\n        else:\n            self._final_emb_dim = self._emb_dim\n\n        ## BiLSTM\n        self._hyp_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='hyp_bidir_fork')\n        self._hyp_bidir = Bidirectional(LSTM(dim), name='hyp_bidir')\n        self._prem_bidir_fork = Linear(self._def_dim if def_reader else self._emb_dim, 4 * dim, name='prem_bidir_fork')\n        self._prem_bidir = Bidirectional(LSTM(dim), name='prem_bidir')\n        children.extend([self._hyp_bidir_fork, self._hyp_bidir])\n        children.extend([self._prem_bidir, self._prem_bidir_fork])\n\n        ## BiLSTM no. 2 (encoded attentioned embeddings)\n        self._hyp_bidir_fork2 = Linear(8 * dim, 4 * dim, name='hyp_bidir_fork2')\n        self._hyp_bidir2 = Bidirectional(LSTM(dim), name='hyp_bidir2')\n        self._prem_bidir_fork2 = Linear(8 * dim, 4 * dim, name='prem_bidir_fork2')\n        self._prem_bidir2 = Bidirectional(LSTM(dim), name='prem_bidir2')\n        children.extend([self._hyp_bidir_fork2, self._hyp_bidir2])\n        children.extend([self._prem_bidir2, self._prem_bidir_fork2])\n\n        self._rnns = [self._prem_bidir2, self._hyp_bidir2, self._prem_bidir, self._hyp_bidir]\n\n        ## MLP\n        if bn:\n            self._mlp = BatchNormalizedMLP([Tanh()], [8 * dim, dim], conserve_memory=False, name=\"mlp\")\n            self._pred = BatchNormalizedMLP([Softmax()], [dim, 3],  conserve_memory=False, name=\"pred_mlp\")\n        else:\n            self._mlp = MLP([Tanh()], [8 * dim, dim], name=\"mlp\")\n            self._pred = MLP([Softmax()], [dim, 3], name=\"pred_mlp\")\n\n        children.append(self._mlp)\n        children.append(self._pred)\n\n        ## Softmax\n        self._ndim_softmax = NDimensionalSoftmax()\n        children.append(self._ndim_softmax)\n\n        super(ESIM, self).__init__(children=children, **kwargs)\n\n    def get_embeddings_lookups(self):\n        return [self._lookup]\n\n    def set_embeddings(self, embeddings):\n        self._lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    def get_def_embeddings_lookups(self):\n        return [self._def_reader._def_lookup]\n\n    def set_def_embeddings(self, embeddings):\n        self._def_reader._def_lookup.parameters[0].set_value(embeddings.astype(theano.config.floatX))\n\n    @application\n    def apply(self, application_call,\n            s1_preunk, s1_mask, s2_preunk, s2_mask, def_mask=None,\n            defs=None, s1_def_map=None, s2_def_map=None, train_phase=True):\n        # Shortlist words (sometimes we want smaller vocab, especially when dict is small)\n        s1 = (tensor.lt(s1_preunk, self._num_input_words) * s1_preunk\n              + tensor.ge(s1_preunk, self._num_input_words) * self._vocab.unk)\n        s2 = (tensor.lt(s2_preunk, self._num_input_words) * s2_preunk\n              + tensor.ge(s2_preunk, self._num_input_words) * self._vocab.unk)\n\n        ### Embed ###\n\n        s1_emb = self._lookup.apply(s1)\n        s2_emb = self._lookup.apply(s2)\n\n        application_call.add_auxiliary_variable(\n            1 * s1_emb,\n            name='s1_word_embeddings')\n\n        if self._def_reader:\n            assert defs is not None\n\n            def_embs = self._def_reader.apply(defs, def_mask)\n\n            if self._translate_pre_def:\n                logger.info(\"Translate pre def\")\n                s1_emb = s1_emb.reshape((s1_emb.shape[0] * s1_emb.shape[1], s1_emb.shape[2]))\n                s2_emb = s2_emb.reshape((s2_emb.shape[0] * s2_emb.shape[1], s2_emb.shape[2]))\n                s1_emb = self._translate_pre_def.apply(s1_emb)\n                s2_emb = self._translate_pre_def.apply(s2_emb)\n                s1_emb = s1_emb.reshape((s1_preunk.shape[0], s1_preunk.shape[1], -1))\n                s2_emb = s2_emb.reshape((s2_preunk.shape[0], s2_preunk.shape[1], -1))\n\n            s1_emb = self._def_combiner.apply(\n                s1_emb, s1_mask,\n                def_embs, s1_def_map, word_ids=s1, train_phase=train_phase, call_name=\"s1\")\n\n            s2_emb = self._def_combiner.apply(\n                s2_emb, s2_mask,\n                def_embs, s2_def_map, word_ids=s2, train_phase=train_phase, call_name=\"s2\")\n        else:\n            if train_phase and self._dropout > 0:\n                s1_emb = apply_dropout(s1_emb, drop_prob=self._dropout)\n                s2_emb = apply_dropout(s2_emb, drop_prob=self._dropout)\n\n        ### Encode ###\n\n        # TODO: Share this bilstm?\n        s1_bilstm, _ = self._prem_bidir.apply(flip01(self._prem_bidir_fork.apply(s1_emb)),\n            mask=s1_mask.T) # (batch_size, n_seq, 2 * dim)\n        s2_bilstm, _ = self._hyp_bidir.apply(flip01(self._hyp_bidir_fork.apply(s2_emb)),\n            mask=s2_mask.T) # (batch_size, n_seq, 2 * dim)\n        s1_bilstm = flip01(s1_bilstm)\n        s2_bilstm = flip01(s2_bilstm)\n        ### Attention ###\n\n        # Compute E matrix (eq. 11)\n        # E_ij = <s1[i], s2[j]>\n        # each call computes E[i, :]\n        def compute_e_row(s2_i, s1_bilstm, s1_mask):\n            b_size = s1_bilstm.shape[0]\n            # s2_i is (batch_size, emb_dim)\n            # s1_bilstm is (batch_size, seq_len, emb_dim)\n            # s1_mask is (batch_size, seq_len)\n            # s2_i = s2_i.reshape((s2_i.shape[0], s2_i.shape[1], 1))\n            s2_i = s2_i.reshape((b_size, s2_i.shape[1], 1))\n            s2_i = T.repeat(s2_i, 2, axis=2)\n            # s2_i is (batch_size, emb_dim, 2)\n            assert s1_bilstm.ndim == 3\n            assert s2_i.ndim == 3\n            score = T.batched_dot(s1_bilstm, s2_i) # (batch_size, seq_len, 1)\n            score = score[:, :, 0].reshape((b_size, -1)) # (batch_size, seq_len)\n            return score # E[i, :]\n\n        # NOTE: No point in masking here\n        E, _ = theano.scan(compute_e_row, sequences=[s1_bilstm.transpose(1, 0, 2)],\n            non_sequences=[s2_bilstm, s2_mask])\n        # (seq_len, batch_size, seq_len)\n        E = E.dimshuffle(1, 0, 2)\n        assert E.ndim == 3\n\n        s2s_att_weights = self._ndim_softmax.apply(E, extra_ndim=1)\n        application_call.add_auxiliary_variable(\n            s2s_att_weights.copy(), name='s2s_att_weights')\n\n        # (batch_size, seq_len, seq_len)\n\n        ### Compute tilde vectors (eq. 12 and 13) ###\n\n        def compute_tilde_vector(e_i, s, s_mask):\n            # e_i is (batch_size, seq_len)\n            # s_mask is (batch_size, seq_len)\n            # s_tilde_i = \\sum e_ij b_j, (batch_size, seq_len)\n            score = masked_softmax(e_i, s_mask, axis=1)\n            score = score.dimshuffle(0, 1, \"x\")\n\n            s_tilde_i = (score * (s * s_mask.dimshuffle(0, 1, \"x\"))).sum(axis=1)\n            return s_tilde_i\n\n        # (batch_size, seq_len, def_dim)\n        s1_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(1, 0, 2)], non_sequences=[s2_bilstm, s2_mask])\n        s1_tilde = s1_tilde.dimshuffle(1, 0, 2)\n        s2_tilde, _ = theano.scan(compute_tilde_vector,\n            sequences=[E.dimshuffle(2, 0, 1)], non_sequences=[s1_bilstm, s1_mask])\n        s2_tilde = s2_tilde.dimshuffle(1, 0, 2)\n\n        ### Compose (eq. 14 and 15) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        s1_comp = T.concatenate([s1_bilstm, s1_tilde, s1_bilstm - s1_tilde, s1_bilstm * s1_tilde], axis=2)\n        s2_comp = T.concatenate([s2_bilstm, s2_tilde, s2_bilstm - s2_tilde, s2_bilstm * s2_tilde], axis=2)\n        ### Encode (eq. 16 and 17) ###\n\n        # (batch_size, seq_len, 8 * dim)\n        # TODO: Share this bilstm?\n        s1_comp_bilstm, _ = self._prem_bidir2.apply(self._prem_bidir_fork2.apply(flip01(s1_comp)), mask=s1_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s2_comp_bilstm, _ = self._hyp_bidir2.apply(self._hyp_bidir_fork2.apply(flip01(s2_comp)), mask=s2_mask.T)  # (batch_size, n_seq, 2 * dim)\n        s1_comp_bilstm = flip01(s1_comp_bilstm)\n        s2_comp_bilstm = flip01(s2_comp_bilstm)\n        ### Pooling Layer ###\n\n        s1_comp_bilstm_ave = (s1_mask.dimshuffle(0, 1, \"x\") * s1_comp_bilstm).sum(axis=1) \\\n                            / s1_mask.sum(axis=1).dimshuffle(0, \"x\")\n\n        s1_comp_bilstm_max = T.max( ((1 - s1_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                    (s1_mask.dimshuffle(0, 1, \"x\")) * s1_comp_bilstm, axis=1)\n\n        s2_comp_bilstm_ave = (s2_mask.dimshuffle(0, 1, \"x\") * s2_comp_bilstm).sum(axis=1) \\\n                             / s2_mask.sum(axis=1).dimshuffle(0, \"x\")\n        # (batch_size, dim)\n        s2_comp_bilstm_max = T.max(((1 - s2_mask.dimshuffle(0, 1, \"x\")) * -10000) + \\\n                                   (s2_mask.dimshuffle(0, 1, \"x\")) * s2_comp_bilstm, axis=1)\n\n        ### Final classifier ###\n\n        # MLP layer\n        # (batch_size, 8 * dim)\n        m = T.concatenate([s1_comp_bilstm_ave, s1_comp_bilstm_max, s2_comp_bilstm_ave, s2_comp_bilstm_max], axis=1)\n        pre_logits = self._mlp.apply(m)\n\n        if train_phase:\n            pre_logits = apply_dropout(pre_logits, drop_prob=self._dropout)\n\n        # Get prediction\n        self.logits = self._pred.apply(pre_logits)\n\n        return self.logits\n", "answers": ["    data = SNLIData(path=c['data_path'], layout=c['layout'], vocab=vocab)"], "pred": "  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #  #", "length": 5411, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "6348b3e17f0fb021c8e9112c4c5f056d8462afedf6a6aa41"}
{"prompt": "Please complete the code given below. \nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/doppler_poly.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has constant acceleration. Such signal has\n  constant doppler value with a possible sign invert.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2\n\n  def __init__(self, distance0_m, tec_epm2, coeffs):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    coeffs : array-like\n      Phase shift coefficients. Phase chift will be computed as:\n      C_n*t^n + C_(n-1)^(n-1) + ... + C_2*t^2 + C_1*t + C_0\n      C_n..C_0 - values for speed of light\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.coeffs = tuple([x for x in coeffs])\n    self.n_coeffs = len(coeffs)\n    self.speedPoly = None\n    self.distancePoly = None\n    if self.n_coeffs > 0:\n      new_coeffs = []\n      self.n_coeffs += 1\n      for idx, c in enumerate(coeffs):\n        order = self.n_coeffs - idx - 1\n        new_coeffs.append(c / order)\n      new_coeffs.append(0.)\n      self.distancePoly = numpy.poly1d(new_coeffs)\n      self.distanceCoeffs = new_coeffs\n      if self.n_coeffs > 1:\n        self.speedPoly = numpy.poly1d(coeffs)\n    else:\n      self.distanceCoeffs = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"DopplerPoly(coeffs={}, distance0_m={},\" \\\n           \" tec_epm2={} codeDopplerIgnored={})\". \\\n           format(self.coeffs, self.distance0_m,\n                  self.tec_epm2, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    poly = self.distancePoly\n    if poly is not None:\n      return poly(svTime_s)  # self.coeffs[cnt - 1]\n    else:\n      return 0.\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    poly = self.speedPoly\n    if poly is not None:\n      return poly(svTime_s)\n    else:\n      return 0.\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    distancePoly = self.distancePoly\n    if distancePoly is not None:\n      # Slower, but simple\n      doppler_m = distancePoly(userTimeAll_s)\n    else:\n      # No phase shift\n      doppler_m = numpy.zeros_like(userTimeAll_s)\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    speedPoly = self.speedPoly\n    if speedPoly is not None:\n      # Slower, but simple\n      c0 = -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n      doppler_hz = speedPoly(userTimeAll_s) * c0\n    else:\n      # No phase shift\n      doppler_hz = numpy.zeros_like(userTimeAll_s)\n    return doppler_hz\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass CustomRateConfig(object):\n  '''\n  Output control configuration for comparison tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  '''\n  NAME = \"Custom configuration for fast tests\"\n  SAMPLE_RATE_HZ = freq_profile_peregrine['sampling_freq']\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 562500l) for b in range(7)] + \\\n          [float(6000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 437500l) for b in range(7)] + \\\n          [float(6000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2TwoBitsEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                    outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_poly.py\nclass TCXOPoly(TCXOBase):\n  '''\n  Polynomial TCXO control class.\n  '''\n\n  def __init__(self, coeffs):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    coeffs : array-like\n      Coefficients for TCXO polynome. These coeffificens define a TCXO drift\n      over time in ppm.\n    '''\n    super(TCXOPoly, self).__init__()\n    self.coeffs = tuple([x for x in coeffs])\n    if coeffs:\n      # Recompute drift coefficients from speed of drift into distance of drift\n      new_coeffs = []\n      power_c = len(coeffs)\n      for idx, val in enumerate(coeffs):\n        power = power_c - idx\n        new_coeffs.append(val * 1e-6 / power)\n      new_coeffs.append(0)\n      self.poly = numpy.poly1d(new_coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOPoly: coeffs=%s\" % str(self.coeffs)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    poly = self.poly\n\n    if poly:\n      time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n      timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n      timeAll_s = numpy.linspace(time0_s,\n                                 timeX_s,\n                                 toSample - fromSample,\n                                 endpoint=False,\n                                 dtype=numpy.float)\n      result = poly(timeAll_s)\n    else:\n      result = None\n\n    return result\nperegrine/iqgen/bits/amplitude_poly.py\nclass AmplitudePoly(AmplitudeBase):\n  '''\n  Amplitude control with polynomial dependency over time.\n  '''\n\n  def __init__(self, units, coeffs):\n    '''\n    Constructs polynomial amplitude control object.\n\n    Parameters\n    coeffs : array-like\n      Polynomial coefficients\n    '''\n    super(AmplitudePoly, self).__init__(units)\n\n    self.coeffs = tuple([x for x in coeffs])\n    if len(coeffs) > 0:\n      self.poly = numpy.poly1d(coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudePoly(units={}, c={})\".format(self.units, self.coeffs)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    This method applies polynomial modulation.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    poly = self.poly\n    if poly is not None:\n      amplitudeVector = poly(userTimeAll_s)\n      amplitudeVector = AmplitudeBase.convertUnits2Amp(amplitudeVector,\n                                                       self.units,\n                                                       noiseParams)\n      signal *= amplitudeVector\n    else:\n      amplitude = AmplitudeBase.convertUnits2Amp(1.,\n                                                 self.units,\n                                                 noiseParams)\n      signal *= amplitude\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    poly = self.poly\n    if poly is not None:\n      value = poly(0.)\n    else:\n      value = 1.\n\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/message_lnav.py\nclass Message(object):\n  '''\n  GPS LNAV message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to pre-generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTow = tow0\n    self.nextMsgId = 0\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    words = (n_prefixBits + 29) / 30\n    if words:\n      tmp = numpy.zeros(words * 30, dtype=numpy.uint8)\n      tmp[1::2] = 1\n      if words > 1:\n        self.updateParity(tmp[0:30])\n        for i in range(1, words - 1):\n          self.updateParity(tmp[i * 30 - 2: i * 30 + 30])\n        self.updateParity(tmp[words * 30 - 32: words * 30], True)\n      else:\n        self.updateParity(tmp[0: 30], True)\n      self.messageBits[:] = tmp[-n_prefixBits:]\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.a32 = numpy.ndarray(1, dtype=numpy.dtype('>u4'))\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS LNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 300\n      if delta % 300:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional LNAV messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    if newMsgCount == 0:\n      return\n\n    newMessageLen = newMsgCount * 300 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 300):\n      logger.info(\"Generating LNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, self.nextMsgId))\n      lnav_msg = self.generateLNavMessage()\n      newMessageData[i:i + 300] = lnav_msg\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n    return\n\n  def generateLNavMessage(self):\n    '''\n    Produces additional GPS LNAV message.\n\n    Returns\n    -------\n    numpy.ndarray(shape=300, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(300, dtype=numpy.uint8)\n    msgData[1::2] = 1  # Zero + one everywhere\n\n    # TLM word\n    self.fillTlmWord(msgData[0:30], self.nextMsgId)\n    self.nextMsgId += 1\n    self.updateParity(msgData[0:30])\n    # logger.debug(\"TLM: %s\" % msgData[0:30])\n\n    # TOW word\n    self.fillTowWord(msgData[30:60], self.nextTow)\n    self.nextTow += 1\n    if self.nextTow == 7 * 24 * 60 * 10:\n      self.nextTow = 0\n    self.updateParity(msgData[28:60], True)\n    # logger.debug(\"TOW: %s\" % msgData[30:60])\n\n    self.updateParity(msgData[58:90])\n    self.updateParity(msgData[88:120])\n    self.updateParity(msgData[118:150])\n    self.updateParity(msgData[148:180])\n    self.updateParity(msgData[178:210])\n    self.updateParity(msgData[208:240])\n    self.updateParity(msgData[238:270])\n    self.updateParity(msgData[268:300], True)\n\n    return msgData\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:\n      self.a32[0] = value\n      result = numpy.unpackbits(self.a32.view(dtype=numpy.uint8))\n    return result[-nBits:]\n\n  def fillTlmWord(self, wordBits, msgId=0):\n    '''\n    Fills in TLM word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:8] = self.getBits(0b10001011, 8)  # Preamble\n    wordBits[8:22] = self.getBits(msgId, 14)  # TML message\n    wordBits[22] = 0  # Reserved\n    wordBits[23] = 0  # Integrity\n    return\n\n  def fillTowWord(self, wordBits, tow):\n    '''\n    Fills in TOW word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:17] = self.getBits(tow, 17)  # TOW count in 6 second units\n    wordBits[17] = 0  # Alert Flag\n    wordBits[18] = 0  # Anti-Spoof flag\n    wordBits[19:22] = self.getBits(0, 3)  # Sub-frame ID\n    return\n\n  def updateParity(self, dataBits, resolve=False):\n    '''\n    Updates data bits and computes parity.\n\n    When 32 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      30 or 32 element array\n    resolve: bool, optional\n      When specified, bits d23 and d24 of the GPS word are updated to ensure\n      that parity bits d29 and d30 are zeros.\n    '''\n    packed = numpy.packbits(dataBits)\n    acc = (packed[0] << 24) | (packed[1] << 16) | \\\n          (packed[2] << 8) | packed[3]\n    if len(dataBits) == 30:\n      acc >>= 2\n    elif acc & 0x40000000:\n      acc ^= 0x3FFFFFC0\n      dataBits[-30:-6] ^= 1\n\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    d29 = parity(acc & 0b01101011101100011111001101000000)\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    d30 = parity(acc & 0b10001011011110101000100111000000)\n\n    if resolve:\n      if d29:\n        acc ^= 0x80\n        d29 = False\n        d30 = not d30\n        dataBits[-8] ^= 1\n      if d30:\n        acc ^= 0x40\n        d30 = False\n        dataBits[-7] ^= 1\n\n    # D25 = D29*^d1^d2^d3^d5^d6^d10^d11^d12^d13^d14^d17^d18^d20^d23\n    dataBits[-6] = parity(acc & 0b10111011000111110011010010000000)\n    # D26 = D30*^d2^d3^d4^d6^d7^d11^d12^d13^d14^d15^d18^d19^d21^d24\n    dataBits[-5] = parity(acc & 0b01011101100011111001101001000000)\n    # D27 = D29*^d1^d3^d4^d5^d7^d8^d12^d13^d14^d15^d16^d19^d20^d22\n    dataBits[-4] = parity(acc & 0b10101110110001111100111000000000)\n    # D28 = D30*^d2^d4^d5^d6^d8^d9^d13^d14^d15^d16^d17^d20^d21^d23\n    dataBits[-3] = parity(acc & 0b01010111011000111110011010000000)\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    dataBits[-2] = d29\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    dataBits[-1] = d30\n\n    return\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                            outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/satellite_gps.py\nclass GPSSatellite(Satellite):\n  '''\n  GPS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GPSSatellite, self).__init__(\"GPS{}\".format(prnNo))\n    self.prn = prnNo\n    self.l2clCodeType = '01'\n    self.l1caCode = GPS_L1CA_Code(prnNo)\n    self.l2cCode = GPS_L2C_Code(prnNo, self.l2clCodeType)\n    self.l1caEnabled = False\n    self.l2cEnabled = False\n    self.l1caMessage = DEFAULT_MESSAGE\n    self.l2cMessage = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1CAEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1caEnabled = enableFlag\n\n  def isL1CAEnabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1caEnabled\n\n  def setL2CEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2cEnabled = enableFlag\n\n  def isL2CEnabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2cEnabled\n\n  def setL2CLCodeType(self, clCodeType):\n    '''\n    Change L1 CL code type if needed\n\n    Parameters\n    ----------\n    clCodeType : string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    if self.l2clCodeType != clCodeType:\n      self.l2cCode = GPS_L2C_Code(self.prn, clCodeType)\n      self.l2clCodeType = clCodeType\n\n  def getL2CLCodeType(self):\n    '''\n    Get L2 CL code type\n\n    Returns\n    -------\n    string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    return self.l2clCodeType\n\n  def setL1CAMessage(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1caMessage = message\n\n  def setL2CMessage(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    self.l2cMessage = message\n\n  def getL1CAMessage(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1caMessage\n\n  def getL2CMessage(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l2cMessage\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1caEnabled and band == outputConfig.GPS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L1CA,\n                                         intermediateFrequency_hz,\n                                         self.l1caMessage,\n                                         self.l1caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2cEnabled and band == outputConfig.GPS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L2C,\n                                         intermediateFrequency_hz,\n                                         self.l2cMessage,\n                                         self.l2cCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GPS.L1:\n      result = self.isL1CAEnabled()\n    elif band == outputConfig.GPS.L2:\n      result = self.isL2CEnabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/message_zeroone.py\nclass Message(object):\n  '''\n  Message that contains zeros and ones\n  '''\n\n  def __init__(self):\n    '''\n    Constructs object.\n    '''\n    super(Message, self).__init__()\n    self.bits = numpy.asarray([0, 1], dtype=numpy.uint8)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"ZeroOne\"\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.bits, dataAll_idx , mode='wrap')\n    return self.bits[dataAll_idx & 1]\nperegrine/iqgen/bits/doppler_sine.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has peridic acceleration.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2.\n\n  def __init__(self, distance0_m,  tec_epm2, speed0_mps, amplutude_mps, period_s):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    speed0_mps : float\n      Speed of satellite at time 0 in meters per second.\n    amplutude_mps : float\n      Amplitude of change\n    period_s : float\n      Period of change\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.speed0_mps = speed0_mps\n    self.amplutude_mps = amplutude_mps\n    self.period_s = period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"SineDoppler(distance0_m={}, tec_epm2={},\" \\\n           \" speed0_mps={}, amplitude_mps={}, period_s={},\" \\\n           \" codeDopplerIgnored={})\".\\\n        format(self.distance0_m, self.tec_epm2, self.speed0_mps,\n               self.amplutude_mps, self.period_s, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    return self.distance0_m + self.speed0_mps * svTime_s + \\\n        self.amplutude_mps * \\\n        (1 - numpy.cos(Doppler.TWO_PI * svTime_s / self.period_s))\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    return self.speed0_mps + self.amplutude_mps * \\\n        numpy.sin(Doppler.TWO_PI * svTime_s / self.period_s)\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps * self.period_s / self.twoPi\n    D_2 = self.twoPi / self.period_s\n\n    doppler_m = numpy.cos(D_2 * userTimeAll_s)\n    doppler_m -= 1.\n    doppler_m *= -D_1\n    if D_0:\n      doppler_m += D_0 * userTimeAll_s\n\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps\n    D_2 = self.twoPi / self.period_s\n\n    doppler_hz = numpy.sin(D_2 * userTimeAll_s) * D_1\n    if D_0:\n      doppler_hz += D_0\n    doppler_hz *= -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n    return doppler_hz\nperegrine/iqgen/if_iface.py\nclass LowRateConfig(object):\n  '''\n  Output control configuration for quick tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Low rate configuration for fast tests\"\n  SAMPLE_RATE_HZ = 24.84375e5\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = 4\n  GROUP_DELAYS = (0., 0., 0., 0.)\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1200000 + b * 562500) for b in range(7)] + \\\n          [float(1200000 + b * 562500) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1100000 + b * 437500) for b in range(7)] + \\\n          [float(1100000 + b * 437500) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e5\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e5\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e5\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e5\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/if_iface.py\nclass NormalRateConfig(object):\n  '''\n  Output control configuration for normal tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Normal rate configuration equivalent to decimated data output\"\n  SAMPLE_RATE_HZ = 24.84375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = LowRateConfig.N_GROUPS\n  GROUP_DELAYS = LowRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(12000000l + b * 562500l) for b in range(7)] + \\\n          [float(12000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(11000000l + b * 437500l) for b in range(7)] + \\\n          [float(11000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e6\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e6\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e6\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e6\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2BitEncoder, self).__init__(outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLPNASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass HighRateConfig(object):\n  '''\n  Output control configuration for high data rate tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"High rate configuration equivalent to full rate data output\"\n  SAMPLE_RATE_HZ = 99.375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  GLONASS = NormalRateConfig.GLONASS\n  Galileo = NormalRateConfig.Galileo\n  Beidou = NormalRateConfig.Beidou\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2BitEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_sine.py\nclass TCXOSine(TCXOBase):\n  '''\n  Sine TCXO control class.\n  '''\n\n  def __init__(self, initial_ppm, amplitude_ppm, period_s):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    initial_ppm : float\n      Initial drift in ppm\n    amplitude_ppm : float\n      Drift amplitude in ppm\n    period_s : float\n      Drift period in seconds\n    '''\n    super(TCXOSine, self).__init__()\n\n    self.initial_ppm = initial_ppm\n    self.amplitude_ppm = amplitude_ppm\n    self.period_s = period_s\n    self.c0 = -amplitude_ppm * 1e-6 * self.period_s / (2. * scipy.constants.pi)\n    self.c1 = 2. * scipy.constants.pi / period_s\n    self.c2 = initial_ppm * 1e-6\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOSine: initial_ppm=%f amplitude_ppm=%f period_s=%f\" % \\\n           (self.initial_ppm, self.amplitude_ppm, self.period_s)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    c0 = self.c0\n    c1 = self.c1\n    c2 = self.c2\n    time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n    timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n\n    timeAll_s = numpy.linspace(time0_s,\n                               timeX_s,\n                               toSample - fromSample,\n                               endpoint=False,\n                               dtype=numpy.float)\n\n    result = numpy.cos(timeAll_s * c1)\n    result += -1.\n    result *= c0\n    if c2:\n      result += timeAll_s * c2\n\n    return result\nperegrine/iqgen/bits/message_const.py\nclass Message(object):\n  '''\n  Message consisting of same bits\n  '''\n\n  def __init__(self, bitValue):\n    '''\n    Initializes object.\n\n    Parameters\n    ----------\n    bitValue : int\n      Value for the bits. 1 for 0 bits, -1 for 1 bits.\n    '''\n    super(Message, self).__init__()\n    self.bitValue = bitValue\n    self.binValue = 1 if bitValue < 0 else 0\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"Const: bit value=%d\" % self.binValue\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    result = numpy.ndarray(len(dataAll_idx), dtype=numpy.uint8)\n    result.fill(self.binValue)\n    return result\nperegrine/iqgen/bits/message_glo.py\nclass Message(object):\n  '''\n  GLONASS message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTk_h = tow0 / (60 * 60) % (60 * 60 * 24)\n    self.nextTk_m = tow0 / 60 % 60\n    self.nextTk_30s = 1 if tow0 / 30 % 2 else 0\n\n    self.nextMsgId = 1\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    self.messageBits[1::2] = 1\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GLONASSS: prn=%d pref=%d tod=%02d:%02d:%02d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTk_h, self.nextTk_m,\n            30 if self.nextTk_30s else 0)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 200\n      if delta % 200:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional GLONASS messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 200 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 200):\n      if self.nextMsgId == 1:\n        logger.info(\"Starting new GLONASS frame: prn=%d frame tod=%02d:%02d:%02d\" %\n                    (self.prn,\n                     self.nextTk_h, self.nextTk_m,\n                     30 if self.nextTk_30s == 1 else 0))\n      logger.debug(\"Generating GLONASS string: prn=%d msg=%d\" %\n                   (self.prn, self.nextMsgId))\n      glo_msg = self.generateGloMessage()\n      # First 170 symbols are 85 bits of message\n      # Meander sequence: as per ICD, each data bit is added to 1/0 sequence\n      newMessageData[i:i + 85 * 2:2] = glo_msg ^ 1\n      newMessageData[i + 1:i + 85 * 2:2] = glo_msg\n      # Last 30 symbols is the time mark\n      newMessageData[i + 170:i + 200] = _TIME_MARK\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n  def generateGloMessage(self):\n    '''\n    Produces additional GLONASS message.\n    Currently the method generates only type 1 GLONASS strings with ToD.\n\n    Returns\n    -------\n    numpy.ndarray(shape=85, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(85, dtype=numpy.uint8)\n\n    if self.nextMsgId == 1:\n      self.fillString1(msgData)\n    else:\n      self.fillString2_15(msgData)\n\n    self.nextMsgId += 1\n    if self.nextMsgId == 16:\n      self.nextMsgId = 1\n\n      # Frame has changed - the frame length is 30 seconds\n      self.nextTk_30s += 1\n      while self.nextTk_30s >= 2:\n        self.nextTk_30s -= 2\n        self.nextTk_m += 1\n      while self.nextTk_m >= 60:\n        self.nextTk_m -= 60\n        self.nextTk_h += 1\n      while self.nextTk_h >= 24:\n        self.nextTk_h -= 24\n\n    self.updateParity(msgData)\n\n    return msgData\n\n  def fillString1(self, msgData):\n    msgData[0] = 0                                     # idle chip\n    msgData[1:5] = self.getBits(0b0001, 4)             # m[4]\n    # [2] - Reserved\n    msgData[7:9] = self.getBits(0b00, 2)               # P1[2]\n\n    msgData[9:14] = self.getBits(self.nextTk_h, 5)     # Tk[12]\n    msgData[14:20] = self.getBits(self.nextTk_m, 6)    # Tk[12]\n    msgData[26:27] = self.getBits(self.nextTk_30s, 1)  # Tk[12]\n    msgData[28::2] = 1  # Zero + one everywhere\n\n  def fillString2_15(self, msgData):\n    msgData[1::2] = 1  # Zero + one everywhere\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:  # pragma: no cover\n      assert False\n    return result[-nBits:]\n\n  def updateParity(self, dataBits):\n    '''\n    Updates data bits and computes parity.\n\n    When 85 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      85 element array\n    '''\n    packed = numpy.packbits(dataBits)\n    assert len(packed) == 11\n\n    hc = _HAMMING_COEFFS\n    for bIdx in range(8):\n      p = 0\n      for i in range(11):\n        p ^= parity(packed[i] & hc[bIdx][i])\n      dataBits[-(bIdx + 1)] = p\n      packed[10] |= p << bIdx\nperegrine/iqgen/bits/satellite_glo.py\nclass GLOSatellite(Satellite):\n  '''\n  GLONASS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GLOSatellite, self).__init__(\"GLONASS{}\".format(prnNo))\n    self.prn = prnNo\n    self.caCode = GLO_CA_Code(prnNo)\n    self.l1Enabled = False\n    self.l2Enabled = False\n    self.l1Message = DEFAULT_MESSAGE\n    self.l2Message = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1Enabled = enableFlag\n\n  def isL1Enabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1Enabled\n\n  def setL2Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2Enabled = enableFlag\n\n  def isL2Enabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2Enabled\n\n  def setL1Message(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1Message = message\n    self.l2Message = message\n\n  def setL2Message(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    pass\n\n  def getL1Message(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1Message\n\n  def getL2Message(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l1Message\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1Enabled and band == outputConfig.GLONASS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L1S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l1Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2Enabled and band == outputConfig.GLONASS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L2S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l2Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GLONASS.L1:\n      result = self.isL1Enabled()\n    elif band == outputConfig.GLONASS.L2:\n      result = self.isL2Enabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                                outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2TwoBitsEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/message_cnav.py\nclass Message(object):\n  '''\n  GPS LNAV message block.\n\n  The object provides proper-formatted CNAV messages with random contents.\n  '''\n\n  def __init__(self, prn, tow0=2, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n\n    if tow0 & 1:\n      logger.error(\"Initial ToW is not multiple of 2\")\n\n    self.prn = prn\n    self.tow0 = tow0\n    self.n_msg0 = n_msg\n    self.n_prefixBits = n_prefixBits\n\n    self.encoder = ConvEncoder27()\n    self.messageCount = 0\n    self.messageLen = n_prefixBits * 2\n    self.symbolData = numpy.zeros(self.messageLen, dtype=numpy.uint8)\n\n    prefixBits = numpy.zeros(self.n_prefixBits, dtype=numpy.uint8)\n    prefixBits[0::2] = 1\n    self.symbolData[:] = self.encoder.encode(prefixBits)\n    self.nextTow = tow0\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS CNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 600\n      if delta % 600:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.symbolData[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional CNAV messages\n\n    This method generates and encodes additional CNAV messages. The message\n    contents is encoded using 2-7 convolution encoder and added to the internal\n    buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 600 + self.messageLen\n    newSymbolData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newSymbolData[:self.messageLen] = self.symbolData\n    for i in range(self.messageLen, newMessageLen, 600):\n      logger.info(\"Generating CNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, 0))\n      cnav_msg = CNavRawMsg.generate(self.prn, 0, self.nextTow)\n      self.nextTow += 2\n      if self.nextTow == 7 * 24 * 60 * 10:\n        self.nextTow = 0\n      encoded = self.encoder.encode(cnav_msg)\n      newSymbolData[i:i + 600] = encoded\n    self.messageLen = newMessageLen\n    self.symbolData = newSymbolData\n    self.messageCount += newMsgCount\nperegrine/iqgen/bits/amplitude_sine.py\nclass AmplitudeSine(AmplitudeBase):\n  '''\n  Amplitude control with sine modulation over time.\n  '''\n\n  def __init__(self, units, initial, amplitude, period_s):\n    '''\n    Constructs sine amplitude control object.\n\n    Parameters\n    initial : float\n      Initial amplitude value (median)\n    amplitude : float\n      Amplitude of change\n    period_s : float\n      Period of change in seconds\n    '''\n    super(AmplitudeSine, self).__init__(units)\n    self.initial = initial\n    self.amplitude = amplitude\n    self.period_s = period_s\n    self.c = 2. * scipy.constants.pi / period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudeSine(units={}, base={}, amp={}, p={} s)\".\\\n        format(self.units, self.initial, self.amplitude, self.period_s)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    ampAll = numpy.sin(userTimeAll_s * self.c) * self.amplitude + self.initial\n\n    ampAll = AmplitudeBase.convertUnits2Amp(ampAll,\n                                            self.units,\n                                            noiseParams)\n    signal *= ampAll\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    value = self.initial\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L2.INDEX)\nimport sys\nimport argparse\nfrom peregrine.iqgen.bits.satellite_gps import GPSSatellite\nfrom peregrine.iqgen.bits.satellite_glo import GLOSatellite\nfrom peregrine.iqgen.if_iface import LowRateConfig\nfrom peregrine.iqgen.if_iface import NormalRateConfig\nfrom peregrine.iqgen.if_iface import HighRateConfig\nfrom peregrine.iqgen.if_iface import CustomRateConfig\nfrom peregrine.iqgen.iqgen_main import computeDistanceDelay\nfrom peregrine.iqgen.iqgen_main import prepareArgsParser\nfrom peregrine.iqgen.iqgen_main import selectOutputConfig\nfrom peregrine.iqgen.iqgen_main import printOutputConfig\nfrom peregrine.iqgen.iqgen_main import computeEnabledBands\nfrom peregrine.iqgen.iqgen_main import selectEncoder\nfrom peregrine.iqgen.iqgen_main import makeProgressBar\nfrom peregrine.iqgen.bits.doppler_poly import Doppler as DopplerPoly\nfrom peregrine.iqgen.bits.doppler_sine import Doppler as DopplerSine\nfrom peregrine.iqgen.bits.signals import GPS\nfrom peregrine.iqgen.bits.message_const import Message as ConstMessage\nfrom peregrine.iqgen.bits.message_zeroone import Message as ZeroOneMessage\nfrom peregrine.iqgen.bits.message_cnav import Message as CNavMessage\nfrom peregrine.iqgen.bits.message_lnav import Message as LNavMessage\nfrom peregrine.iqgen.bits.message_glo import Message as GLOMessage\nfrom peregrine.iqgen.bits.amplitude_poly import AmplitudePoly\nfrom peregrine.iqgen.bits.amplitude_sine import AmplitudeSine\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSBitEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSTwoBitsEncoder\nfrom peregrine.iqgen.bits.tcxo_sine import TCXOSine\nfrom peregrine.iqgen.bits.tcxo_poly import TCXOPoly\nfrom scipy.constants import c as C\n  '''\n  GLONASS L1 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == False\n\n\ndef test_params_band_l2():\n  '''\n  GLONASS L2 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == False\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_band_l1_l2():\n  '''\n  GLONASS dual band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1+l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_doppler_zero():\n  '''\n  Zero doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'zero',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == ()\n\n\ndef test_params_doppler_const():\n  '''\n  Constant doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'const',\n      '--doppler-value', '100'\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  assert doppler.coeffs == (speed_mps, )\n\n\ndef test_params_doppler_linear():\n  '''\n  Linear doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'linear',\n      '--doppler-value', '100',\n      '--doppler-speed', '50',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  accel_mps2 = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 50.\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == (accel_mps2, speed_mps)\n\n\ndef test_params_doppler_sine():\n  '''\n  Sine doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'sine',\n      '--doppler-value', '100',\n      '--doppler-amplitude', '50',\n      '--doppler-period', '3',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\nNext line of code:\n", "input": "import sys\nimport argparse\nfrom peregrine.iqgen.bits.satellite_gps import GPSSatellite\nfrom peregrine.iqgen.bits.satellite_glo import GLOSatellite\nfrom peregrine.iqgen.if_iface import LowRateConfig\nfrom peregrine.iqgen.if_iface import NormalRateConfig\nfrom peregrine.iqgen.if_iface import HighRateConfig\nfrom peregrine.iqgen.if_iface import CustomRateConfig\nfrom peregrine.iqgen.iqgen_main import computeDistanceDelay\nfrom peregrine.iqgen.iqgen_main import prepareArgsParser\nfrom peregrine.iqgen.iqgen_main import selectOutputConfig\nfrom peregrine.iqgen.iqgen_main import printOutputConfig\nfrom peregrine.iqgen.iqgen_main import computeEnabledBands\nfrom peregrine.iqgen.iqgen_main import selectEncoder\nfrom peregrine.iqgen.iqgen_main import makeProgressBar\nfrom peregrine.iqgen.bits.doppler_poly import Doppler as DopplerPoly\nfrom peregrine.iqgen.bits.doppler_sine import Doppler as DopplerSine\nfrom peregrine.iqgen.bits.signals import GPS\nfrom peregrine.iqgen.bits.message_const import Message as ConstMessage\nfrom peregrine.iqgen.bits.message_zeroone import Message as ZeroOneMessage\nfrom peregrine.iqgen.bits.message_cnav import Message as CNavMessage\nfrom peregrine.iqgen.bits.message_lnav import Message as LNavMessage\nfrom peregrine.iqgen.bits.message_glo import Message as GLOMessage\nfrom peregrine.iqgen.bits.amplitude_poly import AmplitudePoly\nfrom peregrine.iqgen.bits.amplitude_sine import AmplitudeSine\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_gps import GPSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2BitEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_glo import GLONASSL1L2TwoBitsEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSBitEncoder\nfrom peregrine.iqgen.bits.encoder_other import GPSGLONASSTwoBitsEncoder\nfrom peregrine.iqgen.bits.tcxo_sine import TCXOSine\nfrom peregrine.iqgen.bits.tcxo_poly import TCXOPoly\nfrom scipy.constants import c as C\n  '''\n  GLONASS L1 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == False\n\n\ndef test_params_band_l2():\n  '''\n  GLONASS L2 band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == False\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_band_l1_l2():\n  '''\n  GLONASS dual band parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--glo-sv', '1',\n      '--bands', 'l1+l2',\n  ]\n  args = parser.parse_args(params)\n  # GLONASS and GPS satellites are all added to the same parameter list: gps_sv\n  assert args.gps_sv[0].isL1Enabled() == True\n  assert args.gps_sv[0].isL2Enabled() == True\n\n\ndef test_params_doppler_zero():\n  '''\n  Zero doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'zero',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == ()\n\n\ndef test_params_doppler_const():\n  '''\n  Constant doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'const',\n      '--doppler-value', '100'\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  assert doppler.coeffs == (speed_mps, )\n\n\ndef test_params_doppler_linear():\n  '''\n  Linear doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'linear',\n      '--doppler-value', '100',\n      '--doppler-speed', '50',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n  speed_mps = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 100.\n  accel_mps2 = -C / float(GPS.L1CA.CENTER_FREQUENCY_HZ) * 50.\n  assert isinstance(doppler, DopplerPoly)\n  assert doppler.distance0_m == 0.\n  assert doppler.tec_epm2 == 50.\n  assert doppler.coeffs == (accel_mps2, speed_mps)\n\n\ndef test_params_doppler_sine():\n  '''\n  Sine doppler parameters test\n  '''\n  parser = prepareArgsParser()\n  params = [\n      '--gps-sv', '1',\n      '--bands', 'l1ca',\n      '--doppler-type', 'sine',\n      '--doppler-value', '100',\n      '--doppler-amplitude', '50',\n      '--doppler-period', '3',\n  ]\n  args = parser.parse_args(params)\n  doppler = args.gps_sv[0].getDoppler()\n", "context": "peregrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/doppler_poly.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has constant acceleration. Such signal has\n  constant doppler value with a possible sign invert.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2\n\n  def __init__(self, distance0_m, tec_epm2, coeffs):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    coeffs : array-like\n      Phase shift coefficients. Phase chift will be computed as:\n      C_n*t^n + C_(n-1)^(n-1) + ... + C_2*t^2 + C_1*t + C_0\n      C_n..C_0 - values for speed of light\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.coeffs = tuple([x for x in coeffs])\n    self.n_coeffs = len(coeffs)\n    self.speedPoly = None\n    self.distancePoly = None\n    if self.n_coeffs > 0:\n      new_coeffs = []\n      self.n_coeffs += 1\n      for idx, c in enumerate(coeffs):\n        order = self.n_coeffs - idx - 1\n        new_coeffs.append(c / order)\n      new_coeffs.append(0.)\n      self.distancePoly = numpy.poly1d(new_coeffs)\n      self.distanceCoeffs = new_coeffs\n      if self.n_coeffs > 1:\n        self.speedPoly = numpy.poly1d(coeffs)\n    else:\n      self.distanceCoeffs = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"DopplerPoly(coeffs={}, distance0_m={},\" \\\n           \" tec_epm2={} codeDopplerIgnored={})\". \\\n           format(self.coeffs, self.distance0_m,\n                  self.tec_epm2, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    poly = self.distancePoly\n    if poly is not None:\n      return poly(svTime_s)  # self.coeffs[cnt - 1]\n    else:\n      return 0.\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    poly = self.speedPoly\n    if poly is not None:\n      return poly(svTime_s)\n    else:\n      return 0.\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    distancePoly = self.distancePoly\n    if distancePoly is not None:\n      # Slower, but simple\n      doppler_m = distancePoly(userTimeAll_s)\n    else:\n      # No phase shift\n      doppler_m = numpy.zeros_like(userTimeAll_s)\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    speedPoly = self.speedPoly\n    if speedPoly is not None:\n      # Slower, but simple\n      c0 = -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n      doppler_hz = speedPoly(userTimeAll_s) * c0\n    else:\n      # No phase shift\n      doppler_hz = numpy.zeros_like(userTimeAll_s)\n    return doppler_hz\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass CustomRateConfig(object):\n  '''\n  Output control configuration for comparison tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  '''\n  NAME = \"Custom configuration for fast tests\"\n  SAMPLE_RATE_HZ = freq_profile_peregrine['sampling_freq']\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_peregrine['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 562500l) for b in range(7)] + \\\n          [float(6000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(6000000l + b * 437500l) for b in range(7)] + \\\n          [float(6000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L1 and L2 signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 and L2 dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1L2TwoBitsEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX,\n                                                    outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_poly.py\nclass TCXOPoly(TCXOBase):\n  '''\n  Polynomial TCXO control class.\n  '''\n\n  def __init__(self, coeffs):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    coeffs : array-like\n      Coefficients for TCXO polynome. These coeffificens define a TCXO drift\n      over time in ppm.\n    '''\n    super(TCXOPoly, self).__init__()\n    self.coeffs = tuple([x for x in coeffs])\n    if coeffs:\n      # Recompute drift coefficients from speed of drift into distance of drift\n      new_coeffs = []\n      power_c = len(coeffs)\n      for idx, val in enumerate(coeffs):\n        power = power_c - idx\n        new_coeffs.append(val * 1e-6 / power)\n      new_coeffs.append(0)\n      self.poly = numpy.poly1d(new_coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOPoly: coeffs=%s\" % str(self.coeffs)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    poly = self.poly\n\n    if poly:\n      time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n      timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n      timeAll_s = numpy.linspace(time0_s,\n                                 timeX_s,\n                                 toSample - fromSample,\n                                 endpoint=False,\n                                 dtype=numpy.float)\n      result = poly(timeAll_s)\n    else:\n      result = None\n\n    return result\nperegrine/iqgen/bits/amplitude_poly.py\nclass AmplitudePoly(AmplitudeBase):\n  '''\n  Amplitude control with polynomial dependency over time.\n  '''\n\n  def __init__(self, units, coeffs):\n    '''\n    Constructs polynomial amplitude control object.\n\n    Parameters\n    coeffs : array-like\n      Polynomial coefficients\n    '''\n    super(AmplitudePoly, self).__init__(units)\n\n    self.coeffs = tuple([x for x in coeffs])\n    if len(coeffs) > 0:\n      self.poly = numpy.poly1d(coeffs)\n    else:\n      self.poly = None\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudePoly(units={}, c={})\".format(self.units, self.coeffs)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    This method applies polynomial modulation.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    poly = self.poly\n    if poly is not None:\n      amplitudeVector = poly(userTimeAll_s)\n      amplitudeVector = AmplitudeBase.convertUnits2Amp(amplitudeVector,\n                                                       self.units,\n                                                       noiseParams)\n      signal *= amplitudeVector\n    else:\n      amplitude = AmplitudeBase.convertUnits2Amp(1.,\n                                                 self.units,\n                                                 noiseParams)\n      signal *= amplitude\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    poly = self.poly\n    if poly is not None:\n      value = poly(0.)\n    else:\n      value = 1.\n\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/message_lnav.py\nclass Message(object):\n  '''\n  GPS LNAV message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to pre-generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTow = tow0\n    self.nextMsgId = 0\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    words = (n_prefixBits + 29) / 30\n    if words:\n      tmp = numpy.zeros(words * 30, dtype=numpy.uint8)\n      tmp[1::2] = 1\n      if words > 1:\n        self.updateParity(tmp[0:30])\n        for i in range(1, words - 1):\n          self.updateParity(tmp[i * 30 - 2: i * 30 + 30])\n        self.updateParity(tmp[words * 30 - 32: words * 30], True)\n      else:\n        self.updateParity(tmp[0: 30], True)\n      self.messageBits[:] = tmp[-n_prefixBits:]\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.a32 = numpy.ndarray(1, dtype=numpy.dtype('>u4'))\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS LNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 300\n      if delta % 300:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional LNAV messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    if newMsgCount == 0:\n      return\n\n    newMessageLen = newMsgCount * 300 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 300):\n      logger.info(\"Generating LNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, self.nextMsgId))\n      lnav_msg = self.generateLNavMessage()\n      newMessageData[i:i + 300] = lnav_msg\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n    return\n\n  def generateLNavMessage(self):\n    '''\n    Produces additional GPS LNAV message.\n\n    Returns\n    -------\n    numpy.ndarray(shape=300, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(300, dtype=numpy.uint8)\n    msgData[1::2] = 1  # Zero + one everywhere\n\n    # TLM word\n    self.fillTlmWord(msgData[0:30], self.nextMsgId)\n    self.nextMsgId += 1\n    self.updateParity(msgData[0:30])\n    # logger.debug(\"TLM: %s\" % msgData[0:30])\n\n    # TOW word\n    self.fillTowWord(msgData[30:60], self.nextTow)\n    self.nextTow += 1\n    if self.nextTow == 7 * 24 * 60 * 10:\n      self.nextTow = 0\n    self.updateParity(msgData[28:60], True)\n    # logger.debug(\"TOW: %s\" % msgData[30:60])\n\n    self.updateParity(msgData[58:90])\n    self.updateParity(msgData[88:120])\n    self.updateParity(msgData[118:150])\n    self.updateParity(msgData[148:180])\n    self.updateParity(msgData[178:210])\n    self.updateParity(msgData[208:240])\n    self.updateParity(msgData[238:270])\n    self.updateParity(msgData[268:300], True)\n\n    return msgData\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:\n      self.a32[0] = value\n      result = numpy.unpackbits(self.a32.view(dtype=numpy.uint8))\n    return result[-nBits:]\n\n  def fillTlmWord(self, wordBits, msgId=0):\n    '''\n    Fills in TLM word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:8] = self.getBits(0b10001011, 8)  # Preamble\n    wordBits[8:22] = self.getBits(msgId, 14)  # TML message\n    wordBits[22] = 0  # Reserved\n    wordBits[23] = 0  # Integrity\n    return\n\n  def fillTowWord(self, wordBits, tow):\n    '''\n    Fills in TOW word contents.\n\n    Parameters\n    ----------\n    wordBits : numpy.ndarray(shape=30, type=numpy.uint8)\n      Destination array\n    '''\n    wordBits[0:17] = self.getBits(tow, 17)  # TOW count in 6 second units\n    wordBits[17] = 0  # Alert Flag\n    wordBits[18] = 0  # Anti-Spoof flag\n    wordBits[19:22] = self.getBits(0, 3)  # Sub-frame ID\n    return\n\n  def updateParity(self, dataBits, resolve=False):\n    '''\n    Updates data bits and computes parity.\n\n    When 32 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      30 or 32 element array\n    resolve: bool, optional\n      When specified, bits d23 and d24 of the GPS word are updated to ensure\n      that parity bits d29 and d30 are zeros.\n    '''\n    packed = numpy.packbits(dataBits)\n    acc = (packed[0] << 24) | (packed[1] << 16) | \\\n          (packed[2] << 8) | packed[3]\n    if len(dataBits) == 30:\n      acc >>= 2\n    elif acc & 0x40000000:\n      acc ^= 0x3FFFFFC0\n      dataBits[-30:-6] ^= 1\n\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    d29 = parity(acc & 0b01101011101100011111001101000000)\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    d30 = parity(acc & 0b10001011011110101000100111000000)\n\n    if resolve:\n      if d29:\n        acc ^= 0x80\n        d29 = False\n        d30 = not d30\n        dataBits[-8] ^= 1\n      if d30:\n        acc ^= 0x40\n        d30 = False\n        dataBits[-7] ^= 1\n\n    # D25 = D29*^d1^d2^d3^d5^d6^d10^d11^d12^d13^d14^d17^d18^d20^d23\n    dataBits[-6] = parity(acc & 0b10111011000111110011010010000000)\n    # D26 = D30*^d2^d3^d4^d6^d7^d11^d12^d13^d14^d15^d18^d19^d21^d24\n    dataBits[-5] = parity(acc & 0b01011101100011111001101001000000)\n    # D27 = D29*^d1^d3^d4^d5^d7^d8^d12^d13^d14^d15^d16^d19^d20^d22\n    dataBits[-4] = parity(acc & 0b10101110110001111100111000000000)\n    # D28 = D30*^d2^d4^d5^d6^d8^d9^d13^d14^d15^d16^d17^d20^d21^d23\n    dataBits[-3] = parity(acc & 0b01010111011000111110011010000000)\n    # D29 = D30*^d1^d3^d5^d6^d7^d9^d10^d14^d15^d16^d17^d18^d21^d22^d24\n    dataBits[-2] = d29\n    # D30 = D29*^d3^d5^d6^d8^d9^d10^d11^d13^d15^d19^d22^d23^d24\n    dataBits[-1] = d30\n\n    return\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2BitEncoder(TwoBandsBitEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2BitEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                            outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/satellite_gps.py\nclass GPSSatellite(Satellite):\n  '''\n  GPS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GPSSatellite, self).__init__(\"GPS{}\".format(prnNo))\n    self.prn = prnNo\n    self.l2clCodeType = '01'\n    self.l1caCode = GPS_L1CA_Code(prnNo)\n    self.l2cCode = GPS_L2C_Code(prnNo, self.l2clCodeType)\n    self.l1caEnabled = False\n    self.l2cEnabled = False\n    self.l1caMessage = DEFAULT_MESSAGE\n    self.l2cMessage = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1CAEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1caEnabled = enableFlag\n\n  def isL1CAEnabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1caEnabled\n\n  def setL2CEnabled(self, enableFlag):\n    '''\n    Enables or disable GPS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2cEnabled = enableFlag\n\n  def isL2CEnabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2cEnabled\n\n  def setL2CLCodeType(self, clCodeType):\n    '''\n    Change L1 CL code type if needed\n\n    Parameters\n    ----------\n    clCodeType : string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    if self.l2clCodeType != clCodeType:\n      self.l2cCode = GPS_L2C_Code(self.prn, clCodeType)\n      self.l2clCodeType = clCodeType\n\n  def getL2CLCodeType(self):\n    '''\n    Get L2 CL code type\n\n    Returns\n    -------\n    string\n      L2 CL code type: '00', '01' or '11'\n    '''\n    return self.l2clCodeType\n\n  def setL1CAMessage(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1caMessage = message\n\n  def setL2CMessage(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    self.l2cMessage = message\n\n  def getL1CAMessage(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1caMessage\n\n  def getL2CMessage(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l2cMessage\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1caEnabled and band == outputConfig.GPS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L1CA,\n                                         intermediateFrequency_hz,\n                                         self.l1caMessage,\n                                         self.l1caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2cEnabled and band == outputConfig.GPS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCY_HZ\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GPS.L2C,\n                                         intermediateFrequency_hz,\n                                         self.l2cMessage,\n                                         self.l2cCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GPSL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GPS.L1:\n      result = self.isL1CAEnabled()\n    elif band == outputConfig.GPS.L2:\n      result = self.isL2CEnabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/message_zeroone.py\nclass Message(object):\n  '''\n  Message that contains zeros and ones\n  '''\n\n  def __init__(self):\n    '''\n    Constructs object.\n    '''\n    super(Message, self).__init__()\n    self.bits = numpy.asarray([0, 1], dtype=numpy.uint8)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"ZeroOne\"\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.bits, dataAll_idx , mode='wrap')\n    return self.bits[dataAll_idx & 1]\nperegrine/iqgen/bits/doppler_sine.py\nclass Doppler(DopplerBase):\n  '''\n  Doppler control for an object that has peridic acceleration.\n  '''\n\n  TWO_PI = scipy.constants.pi * 2.\n\n  def __init__(self, distance0_m,  tec_epm2, speed0_mps, amplutude_mps, period_s):\n    '''\n    Constructs doppler control object for linear acceleration.\n\n    Parameters\n    ----------\n    distance0_m : float\n      Distance to object in meters at time 0.\n    tec_epm2 : float\n      Total free electron content integrated along line of sight to the object\n      in electrons per m^2.\n    speed0_mps : float\n      Speed of satellite at time 0 in meters per second.\n    amplutude_mps : float\n      Amplitude of change\n    period_s : float\n      Period of change\n    '''\n    super(Doppler, self).__init__(distance0_m=distance0_m,\n                                  tec_epm2=tec_epm2)\n    self.speed0_mps = speed0_mps\n    self.amplutude_mps = amplutude_mps\n    self.period_s = period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"SineDoppler(distance0_m={}, tec_epm2={},\" \\\n           \" speed0_mps={}, amplitude_mps={}, period_s={},\" \\\n           \" codeDopplerIgnored={})\".\\\n        format(self.distance0_m, self.tec_epm2, self.speed0_mps,\n               self.amplutude_mps, self.period_s, self.codeDopplerIgnored)\n\n  def computeDistanceM(self, svTime_s):\n    '''\n    Computes doppler shift in meters.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which distance is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Distance to satellite in meters.\n    '''\n    return self.distance0_m + self.speed0_mps * svTime_s + \\\n        self.amplutude_mps * \\\n        (1 - numpy.cos(Doppler.TWO_PI * svTime_s / self.period_s))\n\n  def computeSpeedMps(self, svTime_s):\n    '''\n    Computes speed along the vector to satellite in meters per second.\n\n    Parameters\n    ----------\n    svTime_s : float\n      Time in seconds at which speed is computed. Please note that  is not\n      a time of the observer.\n\n    Returns\n    -------\n    float\n      Speed of satellite in meters per second.\n    '''\n    return self.speed0_mps + self.amplutude_mps * \\\n        numpy.sin(Doppler.TWO_PI * svTime_s / self.period_s)\n\n  def computeDopplerShiftM(self, userTimeAll_s):\n    '''\n    Method to compute metric doppler shift\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler shift in meters\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps * self.period_s / self.twoPi\n    D_2 = self.twoPi / self.period_s\n\n    doppler_m = numpy.cos(D_2 * userTimeAll_s)\n    doppler_m -= 1.\n    doppler_m *= -D_1\n    if D_0:\n      doppler_m += D_0 * userTimeAll_s\n\n    return doppler_m\n\n  def computeDopplerShiftHz(self, userTimeAll_s, carrierSignal):\n    '''\n    Method to compute doppler shift in Hz.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Time vector for sample timestamps in seconds\n    carrierSignal : object\n      Carrier signal parameters\n\n    Returns\n    -------\n    numpy.ndarray(shape=(1, nSamples), dtype=numpy.float)\n      Computed doppler frquency shift in hertz\n    '''\n    D_0 = self.speed0_mps\n    D_1 = self.amplutude_mps\n    D_2 = self.twoPi / self.period_s\n\n    doppler_hz = numpy.sin(D_2 * userTimeAll_s) * D_1\n    if D_0:\n      doppler_hz += D_0\n    doppler_hz *= -float(carrierSignal.CENTER_FREQUENCY_HZ) / scipy.constants.c\n    return doppler_hz\nperegrine/iqgen/if_iface.py\nclass LowRateConfig(object):\n  '''\n  Output control configuration for quick tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Low rate configuration for fast tests\"\n  SAMPLE_RATE_HZ = 24.84375e5\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = 4\n  GROUP_DELAYS = (0., 0., 0., 0.)\n\n  class GPS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_low_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1200000 + b * 562500) for b in range(7)] + \\\n          [float(1200000 + b * 562500) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(1100000 + b * 437500) for b in range(7)] + \\\n          [float(1100000 + b * 437500) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e5\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e5\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e5\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e5\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e5\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/if_iface.py\nclass NormalRateConfig(object):\n  '''\n  Output control configuration for normal tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"Normal rate configuration equivalent to decimated data output\"\n  SAMPLE_RATE_HZ = 24.84375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = LowRateConfig.N_GROUPS\n  GROUP_DELAYS = LowRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_normal_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  class GLONASS(object):\n\n    class L1(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(12000000l + b * 562500l) for b in range(7)] + \\\n          [float(12000000l + b * 562500l) for b in range(-7, 0)]\n      INDEX = 2\n      NAME = GLONASS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCIES_HZ = \\\n          [float(11000000l + b * 437500l) for b in range(7)] + \\\n          [float(11000000l + b * 437500l) for b in range(-7, 0)]\n      INDEX = 3\n      NAME = GLONASS_L2_NAME\n\n  class Galileo(object):\n\n    class E1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 14.58e6\n      INDEX = 0\n      NAME = GALILEO_E1_NAME\n\n    class E6(object):\n      INTERMEDIATE_FREQUENCY_HZ = 43.75e6\n      INDEX = 2\n      NAME = GALILEO_E6_NAME\n\n    class E5b(object):\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = GALILEO_E5B_NAME\n\n  class Beidou(object):\n\n    class B1(object):\n      INTERMEDIATE_FREQUENCY_HZ = 28.902e6\n      INDEX = 0\n      NAME = BEIDOU_B1_NAME\n\n    class B2:\n      INTERMEDIATE_FREQUENCY_HZ = 27.86e6\n      INDEX = 3\n      NAME = BEIDOU_B2_NAME\n\n    class B3(object):\n      INTERMEDIATE_FREQUENCY_HZ = 33.52e6\n      INDEX = 2\n      NAME = BEIDOU_B3_NAME\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2BitEncoder, self).__init__(outputConfig.GLONASS.L2.INDEX)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL1BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GLPNASS L1 signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L1 band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL1BitEncoder, self).__init__(outputConfig.GLONASS.L1.INDEX)\nperegrine/iqgen/if_iface.py\nclass HighRateConfig(object):\n  '''\n  Output control configuration for high data rate tests.\n\n  Attributes\n  ----------\n  NAME : string\n    Configuration name\n  SAMPLE_RATE_HZ : float\n    Sample rate in hertz for data generation.\n  SAMPLE_BATCH_SIZE : int\n    Size of the sample batch in samples.\n  N_GROUPS : int\n    Number of groups in the configuration\n  GROUP_DELAYS: tuple(float * 4)\n    Group delays for the configuration\n  GPS : object\n    GPS band information\n  Galileo : object\n    Galileo band information\n  Beidou : object\n    Beidou band information\n  GLONASS : object\n    Glonass band information\n  '''\n  NAME = \"High rate configuration equivalent to full rate data output\"\n  SAMPLE_RATE_HZ = 99.375e6\n  SAMPLE_BATCH_SIZE = 100000\n  N_GROUPS = NormalRateConfig.N_GROUPS\n  GROUP_DELAYS = NormalRateConfig.GROUP_DELAYS\n\n  class GPS(object):\n    '''\n    Parameters for GPS bands data generation.\n    '''\n    class L1(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L1_IF']\n      INDEX = 0\n      NAME = GPS_L1_NAME\n\n    class L2(object):\n      INTERMEDIATE_FREQUENCY_HZ = freq_profile_high_rate['GPS_L2_IF']\n      INDEX = 1\n      NAME = GPS_L2_NAME\n\n  GLONASS = NormalRateConfig.GLONASS\n  Galileo = NormalRateConfig.Galileo\n  Beidou = NormalRateConfig.Beidou\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2BitEncoder(BandBitEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2BitEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/tcxo_sine.py\nclass TCXOSine(TCXOBase):\n  '''\n  Sine TCXO control class.\n  '''\n\n  def __init__(self, initial_ppm, amplitude_ppm, period_s):\n    '''\n    Constructs TCXO control object.\n\n    Parameters\n    ----------\n    initial_ppm : float\n      Initial drift in ppm\n    amplitude_ppm : float\n      Drift amplitude in ppm\n    period_s : float\n      Drift period in seconds\n    '''\n    super(TCXOSine, self).__init__()\n\n    self.initial_ppm = initial_ppm\n    self.amplitude_ppm = amplitude_ppm\n    self.period_s = period_s\n    self.c0 = -amplitude_ppm * 1e-6 * self.period_s / (2. * scipy.constants.pi)\n    self.c1 = 2. * scipy.constants.pi / period_s\n    self.c2 = initial_ppm * 1e-6\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Provides string representation of the object\n    '''\n    return \"TCXOSine: initial_ppm=%f amplitude_ppm=%f period_s=%f\" % \\\n           (self.initial_ppm, self.amplitude_ppm, self.period_s)\n\n  def computeTcxoTime(self, fromSample, toSample, outputConfig):\n    '''\n    Method generates time vector for the given sample index range depending on\n    TCXO behaviour.\n\n    Parameters\n    ----------\n    fromSample : int\n      Index of the first sample.\n    toSample: int\n      Index of the last sample plus 1.\n    outputConfig : object\n      Output configuration\n\n    Returns\n    -------\n    numpy.ndarray(shape=(toSample - fromSample), dtype=numpy.float)\n      Vector of the shifted time stamps for the given TCXO controller.\n    '''\n    c0 = self.c0\n    c1 = self.c1\n    c2 = self.c2\n    time0_s = fromSample / outputConfig.SAMPLE_RATE_HZ\n    timeX_s = toSample / outputConfig.SAMPLE_RATE_HZ\n\n    timeAll_s = numpy.linspace(time0_s,\n                               timeX_s,\n                               toSample - fromSample,\n                               endpoint=False,\n                               dtype=numpy.float)\n\n    result = numpy.cos(timeAll_s * c1)\n    result += -1.\n    result *= c0\n    if c2:\n      result += timeAll_s * c2\n\n    return result\nperegrine/iqgen/bits/message_const.py\nclass Message(object):\n  '''\n  Message consisting of same bits\n  '''\n\n  def __init__(self, bitValue):\n    '''\n    Initializes object.\n\n    Parameters\n    ----------\n    bitValue : int\n      Value for the bits. 1 for 0 bits, -1 for 1 bits.\n    '''\n    super(Message, self).__init__()\n    self.bitValue = bitValue\n    self.binValue = 1 if bitValue < 0 else 0\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"Const: bit value=%d\" % self.binValue\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n    result = numpy.ndarray(len(dataAll_idx), dtype=numpy.uint8)\n    result.fill(self.binValue)\n    return result\nperegrine/iqgen/bits/message_glo.py\nclass Message(object):\n  '''\n  GLONASS message generator\n  '''\n\n  def __init__(self, prn, tow0=1, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n    self.prn = prn\n    self.n_prefixBits = n_prefixBits\n    self.n_msg0 = n_msg\n    self.tow0 = tow0\n    self.messageCount = 0\n    self.messageLen = n_prefixBits\n    self.nextTk_h = tow0 / (60 * 60) % (60 * 60 * 24)\n    self.nextTk_m = tow0 / 60 % 60\n    self.nextTk_30s = 1 if tow0 / 30 % 2 else 0\n\n    self.nextMsgId = 1\n    self.messageBits = numpy.zeros(n_prefixBits, dtype=numpy.uint8)\n    self.messageBits[1::2] = 1\n    self.a8 = numpy.ndarray(1, dtype=numpy.uint8)\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GLONASSS: prn=%d pref=%d tod=%02d:%02d:%02d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTk_h, self.nextTk_m,\n            30 if self.nextTk_30s else 0)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 200\n      if delta % 200:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.messageBits[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional GLONASS messages\n\n    This method generates and encodes additional LNAV messages. The message\n    contents is added to the internal buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 200 + self.messageLen\n    newMessageData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newMessageData[:self.messageLen] = self.messageBits\n    for i in range(self.messageLen, newMessageLen, 200):\n      if self.nextMsgId == 1:\n        logger.info(\"Starting new GLONASS frame: prn=%d frame tod=%02d:%02d:%02d\" %\n                    (self.prn,\n                     self.nextTk_h, self.nextTk_m,\n                     30 if self.nextTk_30s == 1 else 0))\n      logger.debug(\"Generating GLONASS string: prn=%d msg=%d\" %\n                   (self.prn, self.nextMsgId))\n      glo_msg = self.generateGloMessage()\n      # First 170 symbols are 85 bits of message\n      # Meander sequence: as per ICD, each data bit is added to 1/0 sequence\n      newMessageData[i:i + 85 * 2:2] = glo_msg ^ 1\n      newMessageData[i + 1:i + 85 * 2:2] = glo_msg\n      # Last 30 symbols is the time mark\n      newMessageData[i + 170:i + 200] = _TIME_MARK\n    self.messageLen = newMessageLen\n    self.messageBits = newMessageData\n    self.messageCount += newMsgCount\n\n  def generateGloMessage(self):\n    '''\n    Produces additional GLONASS message.\n    Currently the method generates only type 1 GLONASS strings with ToD.\n\n    Returns\n    -------\n    numpy.ndarray(shape=85, dtype=numpy.uint8)\n      Message bits.\n    '''\n    msgData = numpy.zeros(85, dtype=numpy.uint8)\n\n    if self.nextMsgId == 1:\n      self.fillString1(msgData)\n    else:\n      self.fillString2_15(msgData)\n\n    self.nextMsgId += 1\n    if self.nextMsgId == 16:\n      self.nextMsgId = 1\n\n      # Frame has changed - the frame length is 30 seconds\n      self.nextTk_30s += 1\n      while self.nextTk_30s >= 2:\n        self.nextTk_30s -= 2\n        self.nextTk_m += 1\n      while self.nextTk_m >= 60:\n        self.nextTk_m -= 60\n        self.nextTk_h += 1\n      while self.nextTk_h >= 24:\n        self.nextTk_h -= 24\n\n    self.updateParity(msgData)\n\n    return msgData\n\n  def fillString1(self, msgData):\n    msgData[0] = 0                                     # idle chip\n    msgData[1:5] = self.getBits(0b0001, 4)             # m[4]\n    # [2] - Reserved\n    msgData[7:9] = self.getBits(0b00, 2)               # P1[2]\n\n    msgData[9:14] = self.getBits(self.nextTk_h, 5)     # Tk[12]\n    msgData[14:20] = self.getBits(self.nextTk_m, 6)    # Tk[12]\n    msgData[26:27] = self.getBits(self.nextTk_30s, 1)  # Tk[12]\n    msgData[28::2] = 1  # Zero + one everywhere\n\n  def fillString2_15(self, msgData):\n    msgData[1::2] = 1  # Zero + one everywhere\n\n  def getBits(self, value, nBits):\n    '''\n    Converts integer into bit array\n\n    Parameters\n    ----------\n    value : int\n      Integer value\n    nBits : number of bits to produce\n\n    Returns\n    -------\n    numpy.ndarray(shape=(`nBits`), dtype=numpy.uint8)\n      Parameter `value` represented as a bit array\n    '''\n    if nBits <= 8:\n      self.a8[0] = value\n      result = numpy.unpackbits(self.a8)\n    else:  # pragma: no cover\n      assert False\n    return result[-nBits:]\n\n  def updateParity(self, dataBits):\n    '''\n    Updates data bits and computes parity.\n\n    When 85 bits are provided, they are used for parity computation and for\n    bit inversion.\n\n    Parameters\n    ----------\n    dataBits : numpy.ndarray(dtype=numpy.uint8)\n      85 element array\n    '''\n    packed = numpy.packbits(dataBits)\n    assert len(packed) == 11\n\n    hc = _HAMMING_COEFFS\n    for bIdx in range(8):\n      p = 0\n      for i in range(11):\n        p ^= parity(packed[i] & hc[bIdx][i])\n      dataBits[-(bIdx + 1)] = p\n      packed[10] |= p << bIdx\nperegrine/iqgen/bits/satellite_glo.py\nclass GLOSatellite(Satellite):\n  '''\n  GLONASS satellite object.\n  '''\n\n  def __init__(self, prnNo):\n    '''\n    Constructs satellite object\n\n    Parameters\n    ----------\n    prnNo : int\n      GPS satellite number for selecting PRN.\n    '''\n    super(GLOSatellite, self).__init__(\"GLONASS{}\".format(prnNo))\n    self.prn = prnNo\n    self.caCode = GLO_CA_Code(prnNo)\n    self.l1Enabled = False\n    self.l2Enabled = False\n    self.l1Message = DEFAULT_MESSAGE\n    self.l2Message = DEFAULT_MESSAGE\n    self.time0S = 0.\n    self.pr0M = 0.\n    self.phaseShift = 0.\n\n  def setL1Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L1 C/A sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L1 C/A samples\n    '''\n    self.l1Enabled = enableFlag\n\n  def isL1Enabled(self):\n    '''\n    Tests if L1 C/A signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L1 C/A signal generation is enabled, False otherwise\n    '''\n    return self.l1Enabled\n\n  def setL2Enabled(self, enableFlag):\n    '''\n    Enables or disable GLONASS L2 C sample generation\n\n    Parameters\n    ----------\n    enableFlag : boolean\n      Flag to enable (True) or disable (False) GPS L2 C samples\n    '''\n    self.l2Enabled = enableFlag\n\n  def isL2Enabled(self):\n    '''\n    Tests if L2 C signal generation is enabled\n\n    Returns\n    -------\n    bool\n      True, when L2 C signal generation is enabled, False otherwise\n    '''\n    return self.l2Enabled\n\n  def setL1Message(self, message):\n    '''\n    Configures data source for L1 C/A signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L1 C/A signal.\n    '''\n    self.l1Message = message\n    self.l2Message = message\n\n  def setL2Message(self, message):\n    '''\n    Configures data source for L2 C signal.\n\n    Parameters\n    ----------\n    message : object\n      Message object that will provide symbols for L2 C signal.\n    '''\n    pass\n\n  def getL1Message(self):\n    '''\n    Returns configured message object for GPS L1 C/A band\n\n    Returns\n    -------\n    object\n      L1 C/A message object\n    '''\n    return self.l1Message\n\n  def getL2Message(self):\n    '''\n    Returns configured message object for GPS L2 C band\n\n    Returns\n    -------\n    object\n      L2 C message object\n    '''\n    return self.l1Message\n\n  def getBatchSignals(self,\n                      userTimeAll_s,\n                      samples,\n                      outputConfig,\n                      noiseParams,\n                      band,\n                      debug):\n    '''\n    Generates signal samples.\n\n    Parameters\n    ----------\n    userTimeAll_s : numpy.ndarray(n_samples, dtype=numpy.float64)\n      Vector of observer's timestamps in seconds for the interval start.\n    samples : numpy.ndarray((4, n_samples))\n      Array to which samples are added.\n    outputConfig : object\n      Output configuration object.\n    noiseParams : NoiseParameters\n      Noise parameters object\n    band : Band\n      Band description object.\n    debug : bool\n      Debug flag\n\n    Returns\n    -------\n    list\n      Debug information\n    '''\n    result = []\n    if (self.l1Enabled and band == outputConfig.GLONASS.L1):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L1S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l1Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL1\", 'doppler': values[1]}\n      result.append(debugData)\n    if (self.l2Enabled and band == outputConfig.GLONASS.L2):\n      intermediateFrequency_hz = band.INTERMEDIATE_FREQUENCIES_HZ[self.prn]\n      values = self.doppler.computeBatch(userTimeAll_s,\n                                         self.amplitude,\n                                         noiseParams,\n                                         signals.GLONASS.L2S[self.prn],\n                                         intermediateFrequency_hz,\n                                         self.l2Message,\n                                         self.caCode,\n                                         outputConfig,\n                                         debug)\n      numpy.add(samples[band.INDEX],\n                values[0],\n                out=samples[band.INDEX])\n      debugData = {'type': \"GLOL2\", 'doppler': values[1]}\n      result.append(debugData)\n    return result\n\n  def isBandEnabled(self, band, outputConfig):\n    '''\n    Checks if particular band is supported and enabled.\n\n    Parameters\n    ----------\n    band : Band\n      Band description object.\n    outputConfig : object\n      Output configuration\n\n    Returns:\n    bool\n      True, if the band is supported and enabled; False otherwise.\n    '''\n    result = None\n    if band == outputConfig.GLONASS.L1:\n      result = self.isL1Enabled()\n    elif band == outputConfig.GLONASS.L2:\n      result = self.isL2Enabled()\n    else:\n      result = False\n    return result\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL1L2TwoBitsEncoder(TwoBandsTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L1 C/A and L2 Civil signals\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L1 C/A and L2 C dual band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL1L2TwoBitsEncoder, self).__init__(outputConfig.GPS.L1.INDEX,\n                                                outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/encoder_gps.py\nclass GPSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GPS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GPS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GPSL2TwoBitsEncoder, self).__init__(outputConfig.GPS.L2.INDEX)\nperegrine/iqgen/bits/message_cnav.py\nclass Message(object):\n  '''\n  GPS LNAV message block.\n\n  The object provides proper-formatted CNAV messages with random contents.\n  '''\n\n  def __init__(self, prn, tow0=2, n_msg=0, n_prefixBits=50):\n    '''\n    Constructs message object.\n\n    Parameters\n    ----------\n    prn : int\n      Satellite PRN\n    tow0 : int\n      Time of week in 6-second units for the first message\n    n_msg : int, optional\n      Number of messages to generate for output\n    n_prefixBits : int, optional\n      Number of bits to issue before the first message\n    '''\n    super(Message, self).__init__()\n\n    if tow0 & 1:\n      logger.error(\"Initial ToW is not multiple of 2\")\n\n    self.prn = prn\n    self.tow0 = tow0\n    self.n_msg0 = n_msg\n    self.n_prefixBits = n_prefixBits\n\n    self.encoder = ConvEncoder27()\n    self.messageCount = 0\n    self.messageLen = n_prefixBits * 2\n    self.symbolData = numpy.zeros(self.messageLen, dtype=numpy.uint8)\n\n    prefixBits = numpy.zeros(self.n_prefixBits, dtype=numpy.uint8)\n    prefixBits[0::2] = 1\n    self.symbolData[:] = self.encoder.encode(prefixBits)\n    self.nextTow = tow0\n    self.addMessages(n_msg)\n\n  def __str__(self, *args, **kwargs):\n    '''\n    Formats object as string literal\n\n    Returns\n    -------\n    string\n      String representation of the object\n    '''\n    return \"GPS CNAV: prn=%d pref=%d tow=%d\" % \\\n           (self.prn, self.n_prefixBits, self.nextTow)\n\n  def getDataBits(self, dataAll_idx):\n    '''\n    Generates vector of data bits corresponding to input index\n\n    Parameters\n    ----------\n    dataAll_idx : numpy.ndarray(dtype=numpy.int64)\n      Vector of bit indexes\n\n    Returns\n    -------\n    numpy.ndarray(dtype=numpy.uint8)\n      Vector of data bits\n    '''\n\n    lastIdx = dataAll_idx[-1]\n    if lastIdx >= self.messageLen:\n      # Grow data bits\n      delta = lastIdx - self.messageLen + 1\n      newMsgCount = delta / 600\n      if delta % 600:\n        newMsgCount += 1\n      self.addMessages(newMsgCount)\n\n    # numpy.take degrades performance a lot over time.\n    # return numpy.take(self.symbolData, dataAll_idx , mode='wrap')\n    return self.symbolData[dataAll_idx]\n\n  def addMessages(self, newMsgCount):\n    '''\n    Generate additional CNAV messages\n\n    This method generates and encodes additional CNAV messages. The message\n    contents is encoded using 2-7 convolution encoder and added to the internal\n    buffer.\n\n    Parameters\n    ----------\n    newMsgCount : int\n      Number of messages to generate\n    '''\n    newMessageLen = newMsgCount * 600 + self.messageLen\n    newSymbolData = numpy.ndarray(newMessageLen, dtype=numpy.uint8)\n    newSymbolData[:self.messageLen] = self.symbolData\n    for i in range(self.messageLen, newMessageLen, 600):\n      logger.info(\"Generating CNAV message: prn=%d tow=%d msg_id=%d\" %\n                  (self.prn, self.nextTow, 0))\n      cnav_msg = CNavRawMsg.generate(self.prn, 0, self.nextTow)\n      self.nextTow += 2\n      if self.nextTow == 7 * 24 * 60 * 10:\n        self.nextTow = 0\n      encoded = self.encoder.encode(cnav_msg)\n      newSymbolData[i:i + 600] = encoded\n    self.messageLen = newMessageLen\n    self.symbolData = newSymbolData\n    self.messageCount += newMsgCount\nperegrine/iqgen/bits/amplitude_sine.py\nclass AmplitudeSine(AmplitudeBase):\n  '''\n  Amplitude control with sine modulation over time.\n  '''\n\n  def __init__(self, units, initial, amplitude, period_s):\n    '''\n    Constructs sine amplitude control object.\n\n    Parameters\n    initial : float\n      Initial amplitude value (median)\n    amplitude : float\n      Amplitude of change\n    period_s : float\n      Period of change in seconds\n    '''\n    super(AmplitudeSine, self).__init__(units)\n    self.initial = initial\n    self.amplitude = amplitude\n    self.period_s = period_s\n    self.c = 2. * scipy.constants.pi / period_s\n\n  def __str__(self):\n    '''\n    Constructs literal presentation of object.\n\n    Returns\n    -------\n    string\n      Literal presentation of object\n    '''\n    return \"AmplitudeSine(units={}, base={}, amp={}, p={} s)\".\\\n        format(self.units, self.initial, self.amplitude, self.period_s)\n\n  def applyAmplitude(self, signal, userTimeAll_s, noiseParams):\n    '''\n    Applies amplitude modulation to signal.\n\n    Parameters\n    ----------\n    signal : numpy.ndarray\n      Signal sample vector. Each element defines signal amplitude in range\n      [-1; +1]. This vector is modified in place.\n    userTimeAll_s : numpy.ndarray\n      Sample time vector. Each element defines sample time in seconds.\n    noiseParams : NoiseParameters\n      Noise parameters to adjust signal amplitude level.\n\n    Returns\n    -------\n    numpy.ndarray\n      Array with output samples\n    '''\n\n    ampAll = numpy.sin(userTimeAll_s * self.c) * self.amplitude + self.initial\n\n    ampAll = AmplitudeBase.convertUnits2Amp(ampAll,\n                                            self.units,\n                                            noiseParams)\n    signal *= ampAll\n\n    return signal\n\n  def computeSNR(self, noiseParams):\n    '''\n    Computes signal to noise ratio in dB.\n\n    noiseParams : NoiseParameters\n      Noise parameter container\n\n    Returns\n    -------\n    float\n      SNR in dB\n    '''\n    value = self.initial\n    return AmplitudeBase.convertUnits2SNR(value, self.units, noiseParams)\nperegrine/iqgen/bits/encoder_glo.py\nclass GLONASSL2TwoBitsEncoder(BandTwoBitsEncoder):\n  '''\n  Generic single bit encoder for GLONASS L2 Civil signal\n  '''\n\n  def __init__(self, outputConfig):\n    '''\n    Constructs GLONASS L2 C band single bit encoder object.\n\n    Parameters\n    ----------\n    outputConfig : object\n      Output parameters object.\n    '''\n    super(GLONASSL2TwoBitsEncoder, self).__init__(\n        outputConfig.GLONASS.L2.INDEX)\n", "answers": ["  assert isinstance(doppler, DopplerSine)"], "pred": "  [0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler[0].getDoppler", "length": 6517, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "c78bbf3695db2bc16d0daf4cf8bfd6d1c7c13a32ff1383dd"}
{"prompt": "Please complete the code given below. \napp/src/main/java/br/com/javace/javou/ui/activity/MainActivity.java\npublic class MainActivity extends BaseActivity{\n\n    private ActionMode mAcitonMode;\n    private ParticipantFragment mParticipantFragment;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        setupInit(savedInstanceState);\n    }\n\n    private void setupInit(Bundle savedInstanceState){\n        //setupFragment(savedInstanceState);\n        Preference preference = new Preference(this);\n        if (preference.getString(Constant.FIRST_RUN) == null){\n            startActivityForResult(new Intent(this, SynchronizationActivity.class), 0);\n            preference.setString(Constant.FIRST_RUN, Constant.TAG);\n        }else{\n            setupFragment(savedInstanceState);\n        }\n    }\n\n    private void setupFragment(Bundle savedInstanceState){\n        if (savedInstanceState == null) {\n            mParticipantFragment = ParticipantFragment.newInstance();\n            getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n        }else{\n            if (mParticipantFragment == null) {\n                mParticipantFragment = (ParticipantFragment) getFragmentManager().findFragmentByTag(Constant.PARTICIPANT);\n            }\n        }\n    }\n\n    public void showActionMode(String name){\n        mAcitonMode = startSupportActionMode(mParticipantFragment.actionModeCallback);\n        actionModeSetTitle(name);\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.action_mode_primary_dark));\n        }\n    }\n\n    public void actionModeSetTitle(String name){\n        mAcitonMode.setTitle(name);\n    }\n\n    public void hideActionMode(){\n        if (mAcitonMode != null){\n            mAcitonMode.finish();\n            mAcitonMode = null;\n        }\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.primary_dark));\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (mAcitonMode != null) {\n            hideActionMode();\n        }else{\n            super.onBackPressed();\n        }\n    }\n\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        switch (requestCode){\n            case 0:\n                mParticipantFragment = ParticipantFragment.newInstance();\n                getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n                break;\n\n            default:\n                if (data != null) {\n                    if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n                        mParticipantFragment.onActivityResult(requestCode, resultCode, data);\n                    }\n                }\n                break;\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (mParticipantFragment != null){\n            mParticipantFragment.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemLongClickListener.java\npublic interface OnItemLongClickListener {\n    void onItemLongClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantFortunateActivity.java\npublic class ParticipantFortunateActivity extends BaseActivity{\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_name) TextView txtName;\n    @BindView(R.id.txt_email) TextView txtEmail;\n    @BindView(R.id.txt_phone) TextView txtPhone;\n    @BindView(R.id.img_photo) ImageView imgPhoto;\n    @BindView(R.id.layout_phone) LinearLayout mLayoutPhone;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_fortunate);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.participant_fortunate));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        Participant participant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n\n        if (participant != null) {\n            txtName.setText(participant.getName());\n            txtEmail.setText(participant.getEmail());\n\n            mLayoutPhone.setVisibility(View.GONE);\n            if (!TextUtils.isEmpty(participant.getPhone())){\n                txtPhone.setText(participant.getPhone());\n                mLayoutPhone.setVisibility(View.VISIBLE);\n            }\n\n            if (participant.getSex()) {\n                imgPhoto.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_suricate_girl));\n            }\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseFragment.java\npublic class BaseFragment extends Fragment {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final BaseActivity.ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(getActivity(), animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final BaseActivity.ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(getActivity(), animation);\n    }\n\n\n    private static void putAnimation(final Activity source, final BaseActivity.ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final BaseActivity.ActivityAnimation animation) {\n\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ResumeActivity.java\npublic class ResumeActivity extends BaseActivity {\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_shape_total_raffled) TextView mTxtShapeTotalReffled;\n    @BindView(R.id.txt_shape_total_attendence) TextView mTxtShapeTotalAttendence;\n    @BindView(R.id.txt_shape_total_registrations) TextView mTxtShapeTotalRegistrations;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_resume);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.resume_event));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        generateResume();\n    }\n\n    private void generateResume() {\n        ParticipantDao dao = new ParticipantDao(this);\n        Resume resume = dao.generateResume();\n        mTxtShapeTotalRegistrations.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRegistrations()));\n        mTxtShapeTotalAttendence.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalAttendance()));\n        mTxtShapeTotalReffled.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRaffled()));\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n}\napp/src/main/java/br/com/javace/javou/dao/ParticipantDao.java\npublic class ParticipantDao {\n\n    private Context mContext;\n    private ClasseDB classeDB;\n    private SQLiteDatabase db = null;\n    private static ParticipantDao instance;\n\n    public ParticipantDao(Context context) {\n        super();\n        this.mContext = context;\n\n    }\n\n    public static ParticipantDao getInstance(Context context) {\n        if (instance == null) {\n            synchronized (ParticipantDao.class) {\n                if (instance == null) {\n                    instance = new ParticipantDao(context);\n                }\n            }\n        }\n        return instance;\n    }\n\n    private void openConnection() {\n\n        try {\n            this.classeDB = ClasseDB.getInstance(this.mContext);\n            db = classeDB.getWritableDatabase();\n        } catch (Exception e) {\n\n            Log.e(Constant.TAG, \"Erro ao abrir conex?es ParticipantDao\");\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            if (null != db) {\n                db.close();\n                db = null;\n                classeDB.close();\n            }\n\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ao fechar conex?es ParticipantDao\");\n        }\n    }\n\n    public void synchronizeParticipant(List<String[]> participants) {\n\n        if (participants != null) {\n            try {\n                openConnection();\n                for (String[] participant : participants) {\n                    try {\n\n                        if (!participant[0].equals(\"NOME\")) {\n\n                            ContentValues campos = new ContentValues();\n\n                            campos.put(Constant.PARTICIPANT_name, participant[0]);\n                            campos.put(Constant.PARTICIPANT_email, participant[1].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_code, participant[5]);\n\n                            //campos.put(Constant.PARTICIPANT_phone, \"\");\n                            campos.put(Constant.PARTICIPANT_phone, Util.replacePhone(participant[13]));\n\n                            campos.put(Constant.PARTICIPANT_attend, 0);\n                            campos.put(Constant.PARTICIPANT_nameEvent, \"JAVOU! #09 - Casos de Sucesso\");\n\n                            String birthDate = participant[16];\n                            campos.put(Constant.PARTICIPANT_birthDate, birthDate);\n\n                            String company = WordUtils.capitalizeFully(participant[17].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_company, company);\n\n                            campos.put(Constant.PARTICIPANT_sex, !participant[20].equals(\"Masculino\"));\n\n                            int shirtSize = 5;\n                            if (!participant[3].contains(\"SEM Blusa\")) {\n                                shirtSize = Util.replaceShirtSize(participant[21]);\n                            }\n                            campos.put(Constant.PARTICIPANT_shirtSize, shirtSize);\n\n                            try {\n                                Long row = db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos);\n                                Log.d(\"ParticipantDao\", row.toString());\n                            } catch (Exception e) {\n                                e.getMessage();\n                                Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                            }\n                        }\n\n                    } catch (Exception e) {\n                        e.getStackTrace();\n                    }\n                }\n\n                closeConnection();\n            }catch (Exception e){\n                e.getStackTrace();\n            }\n        }\n    }\n\n    public boolean insert(Participant participant) {\n\n        if (participant != null) {\n\n            try {\n                openConnection();\n\n                ContentValues campos = new ContentValues();\n\n                campos.put(Constant.PARTICIPANT_name, participant.getName());\n                campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n                campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n                campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n                campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n                campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n                campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n                campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n                try {\n                    return ( db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos) != -1);\n                } catch (Exception e) {\n                    e.getMessage();\n                    Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                }\n\n            } finally {\n                closeConnection();\n            }\n        }\n\n        return false;\n    }\n\n    public boolean update(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues campos = new ContentValues();\n\n            campos.put(Constant.PARTICIPANT_name, participant.getName());\n            campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n            campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n            campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n            campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n            campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n            campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n            campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, campos, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao update: \", e);\n            Log.e(Constant.TAG, \"update: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean updatePresence(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 0 : 1);\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updatePresence: \", e);\n            Log.e(Constant.TAG, \"updatePresence: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean delete(int id) {\n\n        try {\n            openConnection();\n\n            String args[] = new String[]{String.valueOf(id)};\n            return (db.delete(Constant.TABLE_PARTICIPANT, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao delete: \", e);\n            Log.e(Constant.TAG, \"delete: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public ArrayList<Participant> getAll() {\n\n        Participant participant;\n        ArrayList<Participant> lParticipant = new ArrayList<>();\n\n        Cursor cursor;\n        try {\n\n            openConnection();\n            cursor = db.query(Constant.TABLE_PARTICIPANT, Constant.PARTICIPANT_COLS, null, null, null,\n                    null, Constant.PARTICIPANT_name + \" ASC\");\n\n            while (cursor.moveToNext()) {\n                participant = new Participant();\n\n                participant.setId(cursor.getInt(0));\n                participant.setName(cursor.getString(1));\n                participant.setPhone(cursor.getString(2));\n                participant.setEmail(cursor.getString(3));\n                participant.setPhoto(cursor.getString(4));\n\n                //identifying who will be the type of group\n                int shirtSize = cursor.getInt(5);\n                participant.setGroup(true);\n                participant.setShirtSize(shirtSize);\n\n                participant.setAttend(cursor.getInt(6) == 1);\n                participant.setNameEvent(cursor.getString(7));\n\n                participant.setBirthDate(cursor.getString(8));\n                participant.setSex(cursor.getInt(9) == 1);\n                participant.setRaffled(cursor.getInt(10) == 1);\n                participant.setCompany(cursor.getString(11));\n                participant.setCode(cursor.getInt(12));\n\n                lParticipant.add(participant);\n            }\n            cursor.close();\n            return lParticipant;\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ParticipantDao getAll: \", e);\n        } finally {\n            closeConnection();\n        }\n\n        return null;\n    }\n\n    public boolean updateAsRaffled(Participant participantFortunate) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_raffled, 1);\n\n            String args[] = new String[]{String.valueOf(participantFortunate.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updateAsRaffled: \", e);\n            Log.e(Constant.TAG, \"updateAsRaffled: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n\n    }\n\n    public int getTotalRegistrations(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT, null);\n        mCount.moveToFirst();\n        int totalRegistrations= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRegistrations;\n    }\n\n    public int getTotalAttendance(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1\", null);\n        mCount.moveToFirst();\n        int totalAttendance= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalAttendance;\n    }\n\n    public int getTotalRaffled(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1 and raffled=1\", null);\n        mCount.moveToFirst();\n        int totalRaffled= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRaffled;\n    }\n\n    public Resume generateResume() {\n        Resume resume = new Resume();\n        resume.setTotalRegistrations(getTotalRegistrations());\n        resume.setTotalAttendance(getTotalAttendance());\n        resume.setTotalRaffled(getTotalRaffled());\n        return resume;\n    }\n\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnScrollListener.java\npublic abstract class OnScrollListener extends RecyclerView.OnScrollListener {\n\n    private int currentPage = 1;\n    private int totalItemCount;\n    private int visibleItemCount;\n    private int firstVisibleItem;\n\n    private int lastVisibleItem = 0;\n    private boolean checkScroll = true;\n\n    private boolean loading = false;\n    private int currentTotalItems = 0;\n\n    private LinearLayoutManager mLinearLayoutManager;\n    private FloatingActionButton mFloatingActionButton;\n    public OnScrollListener(LinearLayoutManager linearLayoutManager, FloatingActionButton floatingActionButton) {\n        this.mLinearLayoutManager = linearLayoutManager;\n        this.mFloatingActionButton = floatingActionButton;\n    }\n\n    public OnScrollListener(LinearLayoutManager linearLayoutManager) {\n        this.mLinearLayoutManager = linearLayoutManager;\n    }\n\n    @Override\n    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n        super.onScrolled(recyclerView, dx, dy);\n\n        visibleItemCount = recyclerView.getChildCount();\n        totalItemCount = mLinearLayoutManager.getItemCount();\n        firstVisibleItem = mLinearLayoutManager.findFirstVisibleItemPosition();\n\n        if (totalItemCount < currentTotalItems) {\n            this.currentPage = 1;\n            this.currentTotalItems = totalItemCount;\n\n            if (totalItemCount == 0) {\n                this.loading = true;\n            }\n        }\n\n        if (loading && (totalItemCount > currentTotalItems)) {\n            loading = false;\n            currentTotalItems = totalItemCount;\n        }\n\n        if (!loading && (totalItemCount - visibleItemCount)<=(firstVisibleItem + 5)) {\n            onLoadMore(currentPage++);\n            loading = true;\n        }\n\n        if (lastVisibleItem != firstVisibleItem) {\n            if (lastVisibleItem < firstVisibleItem) {\n                if (checkScroll) {\n                    checkScroll = false;\n                    showHideFloatButton(true);\n                    onScroll(recyclerView, dx, dy, true);\n                }\n            } else {\n                if (!checkScroll) {\n                    checkScroll = true;\n                    showHideFloatButton(false);\n                    onScroll(recyclerView, dx, dy, false);\n                }\n            }\n        }\n\n        lastVisibleItem = firstVisibleItem;\n    }\n\n    public void resetEndlessRecyclerView(){\n        this.currentTotalItems = 0;\n        this.loading = false;\n    }\n\n    public abstract void onScroll(RecyclerView recyclerView, int dx, int dy, boolean onScroll);\n    public abstract void onLoadMore(int currentPage);\n\n    //Hide or show the FloatingActionButton based on the list scroll\n    private void showHideFloatButton(boolean status) {\n        if (status) {\n            mFloatingActionButton.setAlpha(1f);\n            mFloatingActionButton.setTranslationY(0f);\n            mFloatingActionButton.animate().alpha(0f)\n                    .translationY(mFloatingActionButton.getHeight())\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.GONE);\n                        }\n                    }).start();\n        } else {\n            mFloatingActionButton.setVisibility(View.VISIBLE);\n            mFloatingActionButton.setAlpha(0f);\n            mFloatingActionButton.setTranslationY(mFloatingActionButton.getHeight());\n            mFloatingActionButton.animate()\n                    .alpha(1f)\n                    .translationY(0f)\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.VISIBLE);\n                        }\n                    })\n                    .start();\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemClickListener.java\npublic interface OnItemClickListener {\n    void onItemClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/model/participant/Participant.java\npublic class Participant implements Parcelable {\n\n    private int id;\n    private int code;\n    private boolean sex;\n    private String name;\n    private String phone;\n    private String email;\n    private String photo;\n    private int shirtSize;\n    private boolean group;\n    private boolean attend;\n    private String company;\n    private String nameEvent;\n    private String birthDate;\n    private boolean raffled;\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(this.getId());\n        dest.writeInt(this.getCode());\n        dest.writeByte(isSex() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getName());\n        dest.writeString(this.getPhone());\n        dest.writeString(this.getEmail());\n        dest.writeString(this.getPhoto());\n        dest.writeInt(this.getShirtSize());\n        dest.writeByte(isGroup() ? (byte) 1 : (byte) 0);\n        dest.writeByte(isAttend() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getCompany());\n        dest.writeString(this.getNameEvent());\n        dest.writeString(this.getBirthDate());\n        dest.writeByte(isRaffled() ? (byte) 1 : (byte) 0);\n    }\n\n    public Participant() {\n    }\n\n    protected Participant(Parcel in) {\n        this.setId(in.readInt());\n        this.setCode(in.readInt());\n        this.setSex(in.readByte() != 0);\n        this.setName(in.readString());\n        this.setPhone(in.readString());\n        this.setEmail(in.readString());\n        this.setPhoto(in.readString());\n        this.setShirtSize(in.readInt());\n        this.setGroup(in.readByte() != 0);\n        this.setAttend(in.readByte() != 0);\n        this.setCompany(in.readString());\n        this.setNameEvent(in.readString());\n        this.setBirthDate(in.readString());\n        this.setRaffled(in.readByte() != 0);\n    }\n\n    public static final Parcelable.Creator<Participant> CREATOR = new Parcelable.Creator<Participant>() {\n        public Participant createFromParcel(Parcel source) {\n            return new Participant(source);\n        }\n\n        public Participant[] newArray(int size) {\n            return new Participant[size];\n        }\n    };\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public boolean isSex() {\n        return sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getPhoto() {\n        return photo;\n    }\n\n    public void setPhoto(String photo) {\n        this.photo = photo;\n    }\n\n    public int getShirtSize() {\n        return shirtSize;\n    }\n\n    public void setShirtSize(int shirtSize) {\n        this.shirtSize = shirtSize;\n    }\n\n    public boolean isGroup() {\n        return group;\n    }\n\n    public void setGroup(boolean group) {\n        this.group = group;\n    }\n\n    public boolean isAttend() {\n        return attend;\n    }\n\n    public void setAttend(boolean attend) {\n        this.attend = attend;\n    }\n\n    public String getCompany() {\n        return company;\n    }\n\n    public void setCompany(String company) {\n        this.company = company;\n    }\n\n    public String getNameEvent() {\n        return nameEvent;\n    }\n\n    public void setNameEvent(String nameEvent) {\n        this.nameEvent = nameEvent;\n    }\n\n    public String getBirthDate() {\n        return birthDate;\n    }\n\n    public void setBirthDate(String birthDate) {\n        this.birthDate = birthDate;\n    }\n\n    public boolean isRaffled() {\n        return raffled;\n    }\n\n    public void setRaffled(boolean raffled) {\n        this.raffled = raffled;\n    }\n\n    public boolean getSex() {\n        return sex;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantSendTask.java\npublic class ParticipantSendTask extends AsyncTask<Void, Void, Boolean> {\n\n    private ArrayList<Participant> mParticipant;\n\n    protected ParticipantSendTask(ArrayList<Participant> participant){\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n\n        CSVWriter writer;\n        boolean isAttend = false;\n\n        try {\n            writer = new CSVWriter(new FileWriter(Constant.PATH_FILE_JAVOU));\n            List<String[]> data = new ArrayList<>();\n\n            data.add(Constant.FILE_COLS);\n\n            for (Participant participant : mParticipant) {\n                if (participant.isAttend()) {\n                    isAttend = true;\n                    String sex = (participant.isSex() ? \"F\" : \"M\");\n                    data.add(new String[]{String.valueOf(participant.getCode()), participant.getName(), participant.getEmail(), participant.getPhone(), sex, participant.getCompany()});\n                }\n            }\n\n            writer.writeAll(data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return isAttend;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantDeleteTask.java\npublic class ParticipantDeleteTask extends AsyncTask<Void, Void, Boolean> {\n\n    private int mId;\n    private Context mContext;\n    public ParticipantDeleteTask(Context context, int id){\n        this.mId = id;\n        this.mContext = context;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.delete(mId);\n    }\n}\napp/src/main/java/br/com/javace/javou/util/Constant.java\npublic class Constant {\n    public static String TAG = \"Javou\";\n    public static final String NAME_EVENT = \"Setic - AppJavou\";\n\n    public static final int DATABASE_VERSION = 1;\n    public static final String DATABASE = \"javou.db\";\n    private static final String NAME_FILE = \"/javou.csv\";\n\n    public static String POSITION = \"POSITION\";\n    public static String FIRST_RUN = \"FIRST_RUN\";\n    static String PREFERENCES_APP = \"JAVOU\";\n    public static String ACTION_MODE = \"ACTION_MODE\";\n    public static String PARTICIPANT = \"Participant\";\n\n    public static String INSERT = \"INSERT\";\n\n    //Tablet participant\n    public static final String TABLE_PARTICIPANT = \"participant\";\n    private static final String PARTICIPANT_id = \"id\";\n    public static final String PARTICIPANT_name = \"name\";\n    public static final String PARTICIPANT_phone = \"phone\";\n    public static final String PARTICIPANT_email = \"email\";\n    public static final String PARTICIPANT_photo = \"photo\";\n    public static final String PARTICIPANT_shirtSize = \"shirtSize\";\n    public static final String PARTICIPANT_attend = \"attend\";\n    public static final String PARTICIPANT_nameEvent = \"nameEvent\";\n    public static final String PARTICIPANT_birthDate = \"birthDate\";\n    public static final String PARTICIPANT_sex = \"sex\";\n    public static final String PARTICIPANT_raffled = \"raffled\";\n    public static final String PARTICIPANT_company = \"company\";\n    public static final String PARTICIPANT_code = \"code\";\n\n    public static String[] CREATE_TABLE() {\n        String CREATE_PARTICIPANT = \" CREATE TABLE participant ( \"\n                + \" id INTEGER CONSTRAINT 'PK_PARTICIPANT' PRIMARY KEY AUTOINCREMENT, \"\n                + \" code INT NULL DEFAULT 0, \"\n                + \" name VARCHAR(100) NOT NULL, \"\n                + \" phone VARCHAR(100) NOT NULL, \"\n                + \" email VARCHAR(250) NULL, \"\n                + \" photo TEXT NULL, \"\n                + \" shirtSize INT NULL DEFAULT 0, \"\n                + \" attend INT NULL DEFAULT 0, \"\n                + \" nameEvent VARCHAR(100) NULL, \"\n                + \" birthDate VARCHAR(10) NULL, \"\n                + \" sex CHAR(1) NULL, \"\n                + \" raffled INT NULL DEFAULT 0, \"\n                + \" company VARCHAR(250) NULL ); \";\n        return new String[] {CREATE_PARTICIPANT};\n    }\n\n    public static final String PATH_FILE_JAVOU = android.os.Environment.getExternalStorageDirectory().getAbsolutePath() + NAME_FILE;\n\n    public static final String PARTICIPANT_COLS[] = {\n            PARTICIPANT_id,\n            PARTICIPANT_name,\n            PARTICIPANT_phone,\n            PARTICIPANT_email,\n            PARTICIPANT_photo,\n            PARTICIPANT_shirtSize,\n            PARTICIPANT_attend,\n            PARTICIPANT_nameEvent,\n            PARTICIPANT_birthDate,\n            PARTICIPANT_sex,\n            PARTICIPANT_raffled,\n            PARTICIPANT_company,\n            PARTICIPANT_code\n    };\n\n    public static final String FILE_COLS[] = {\n            \"CODIGO\", \"NOME\", \"EMAIL\", \"CELULAR\", \"SEXO\", \"EMPRESA\"\n    };\n\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseActivity.java\npublic class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(this, animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(this, animation);\n    }\n\n    public void finish(final ActivityAnimation animation) {\n        finish();\n        putAnimation(this, animation);\n    }\n\n    private static void putAnimation(final Activity source,\n                                     final ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final ActivityAnimation animation) {\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/interfaces/OnSearchListener.java\npublic interface OnSearchListener {\n    void changedSearch(CharSequence text);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantDetailActivity.java\npublic class ParticipantDetailActivity extends BaseActivity {\n\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_email) TextView mTxtEmail;\n    @BindView(R.id.txt_phone) TextView mTxtPhone;\n    @BindView(R.id.txt_attend) TextView mTxtAttend;\n    @BindView(R.id.img_photo) ImageView mImgPhoto;\n    @BindView(R.id.txt_shirt_size) TextView mTxtShirtSize;\n    @BindView(R.id.float_edit) FloatingActionButton mFloatEdit;\n    @BindView(R.id.collapsing_toolbar) CollapsingToolbarLayout mCollapsingToolbar;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_detail);\n\n        ButterKnife.bind(this);\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        mFloatEdit.setOnClickListener(onClickEdit);\n        mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mCollapsingToolbar.setTitle(mParticipant != null ? mParticipant.getName() : getString(R.string.app_name));\n\n        if (mParticipant != null){\n            mTxtEmail.setText(mParticipant.getEmail());\n            mTxtPhone.setText(mParticipant.getPhone());\n\n            GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(this, Util.shirtSizeColor[mParticipant.getShirtSize()]));\n            mTxtShirtSize.setText(getString(Util.shirtSize[mParticipant.getShirtSize()]));\n\n            if (mParticipant.isAttend()) {\n                mTxtAttend.setText(getString(R.string.attended_event));\n                mTxtAttend.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_check_green_18dp, 0, 0, 0);\n            }\n\n            if (mParticipant.getPhoto() != null && !mParticipant.getPhoto().equals(\"\")) {\n                Glide.with(this).load(mParticipant.getPhoto()).centerCrop().into(mImgPhoto);\n            }else{\n                Glide.with(this).load(R.drawable.ic_suricate).centerCrop().into(mImgPhoto);\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n\n            case R.id.menu_delete:\n                confirmDelete();\n                break;\n        }\n        return true;\n    }\n\n    private View.OnClickListener onClickEdit  = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(getApplicationContext(), NewParticipantActivity.class);\n            intent.putExtra(Constant.PARTICIPANT, mParticipant);\n            startActivityForResult(intent, 1, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n        }\n    };\n\n\n//    private void deleteParticipant(){\n//        showDialog();\n//        ParseObject gameScore = new ParseObject(Constant.PARTICIPANT);\n//        gameScore.setObjectId(mParticipant.getObjectId());\n//        gameScore.deleteInBackground(new DeleteCallback() {\n//            @Override\n//            public void done(ParseException error) {\n//                if (error == null) {\n//                    Intent intent = new Intent();\n//                    intent.putExtra(Constant.PARTICIPANT, true);\n//                    setResult(0, intent);\n//                    finish();\n//                    Toast.makeText(getApplicationContext(), R.string.warning_delete_participante, Toast.LENGTH_SHORT).show();\n//                } else {\n//                    Toast.makeText(getApplicationContext(), R.string.error_delete_participante, Toast.LENGTH_SHORT).show();\n//                }\n//\n//                hideDialog();\n//            }\n//        });\n//    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_delete_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    private void confirmDelete(){\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(getString(R.string.warning_participant_excluded));\n        builder.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                //deleteParticipant();\n                dialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                dialog.dismiss();\n            }\n        });\n        AlertDialog dialog = builder.create();\n        dialog.show();\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/model/raffle/Raffle.java\npublic class Raffle{\n\n    private Random randomGenerator;\n    private ArrayList<Participant> participants;\n\n    public Raffle(ArrayList<Participant> participants) {\n        this.randomGenerator = new Random();\n        this.participants = participants;\n    }\n\n    private List<Participant> getParticipantsAttend(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    private List<Participant> getParticipantsAttendSex(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    public boolean isValid(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled())\n                return true;\n        }\n        return false;\n    }\n\n    public boolean isValidSex(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex())\n                return true;\n        }\n        return false;\n    }\n\n    public Participant getFortunate() {\n        List<Participant> participantsAttend = getParticipantsAttend();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n\n    public Participant getFortunateSex() {\n        List<Participant> participantsAttend = getParticipantsAttendSex();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantPresenceTask.java\npublic class ParticipantPresenceTask extends AsyncTask<Void, Void, Boolean> {\n\n    private Context mContext;\n    private Participant mParticipant;\n\n    public ParticipantPresenceTask(Context context, Participant participant){\n        this.mContext = context;\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.updatePresence(mParticipant);\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/SearchLiveo.java\npublic class SearchLiveo extends FrameLayout {\n\n    private Activity mContext;\n\n    private EditText mEdtSearch;\n\n    private ImageView mImgArrowSearch;\n    private ImageView mImgVoiceSearch;\n    private ImageView mImgCloseSearch;\n\n    private RecyclerView mRecyclerView;\n    private RelativeLayout mViewSearch;\n\n    private int mColorPrimaryDark;\n\n    private boolean active = false;\n    private boolean isVoice = true;\n\n    private int mColorIcon = -1;\n    private int mColorIconArrow = -1;\n    private int mColorIconVoice = -1;\n    private int mColorIconClose = -1;\n\n    private int mStatusBarHideColor = -1;\n    private int mStatusBarShowColor = -1;\n    private OnSearchListener mSearchListener;\n\n    private static String SEARCH_TEXT = \"SEARCH_TEXT\";\n    public static int REQUEST_CODE_SPEECH_INPUT = 7777;\n    private static String STATE_TO_SAVE = \"STATE_TO_SAVE\";\n    private static String INSTANCE_STATE = \"INSTANCE_STATE\";\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Activity\n     *\n     * @param context - Context Activity\n     */\n    public SearchLiveo with(Context context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = (Activity) context;\n                this.mSearchListener = (OnSearchListener) context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Fragment\n     *\n     * @param getActivity - Context Fragment\n     * @param context - Listener\n     */\n    public SearchLiveo with(Activity getActivity, OnSearchListener context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = getActivity;\n                this.mSearchListener = context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_fragment_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    public void build(){\n\n        if (this.mSearchListener == null){\n            throw new ClassCastException(mContext.getString(R.string.warning_listener));\n        }\n\n        try {\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                Resources.Theme theme = this.mContext.getTheme();\n                TypedArray typedArray = theme.obtainStyledAttributes(new int[]{android.R.attr.colorPrimaryDark});\n                setColorPrimaryDark(typedArray.getResourceId(0, 0));\n            }\n        }catch (Exception e){\n            e.getStackTrace();\n        }\n    }\n\n    public SearchLiveo(Context context) {\n        this(context, null);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        if(!isInEditMode()) {\n            init(context);\n            initAttribute(context, attrs, defStyleAttr);\n        }\n    }\n\n    private void init(Context context){\n        View view = LayoutInflater.from(context).inflate(R.layout.search_liveo, this, true);\n\n        mEdtSearch = (EditText) view.findViewById(R.id.edt_search);\n\n        mImgArrowSearch = (ImageView) view.findViewById(R.id.img_arrow_search);\n        mImgVoiceSearch = (ImageView) view.findViewById(R.id.img_voice_search);\n\n        mImgCloseSearch = (ImageView) view.findViewById(R.id.img_close_search);\n        mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n\n        mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_search_view);\n\n        View toolbarShadow = view.findViewById(R.id.toolbar_shadow);\n        toolbarShadow.setVisibility(GONE);\n\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n            toolbarShadow.setVisibility(View.VISIBLE);\n        }\n\n        mViewSearch = (RelativeLayout) view.findViewById(R.id.view_search);\n        mViewSearch.setVisibility(View.INVISIBLE);\n\n        mEdtSearch.setOnKeyListener(onKeyListener);\n\n        mImgArrowSearch.setOnClickListener(onClickSearchArrow);\n        mRecyclerView.setOnClickListener(onClickRecyclerView);\n        mImgVoiceSearch.setOnClickListener(onClickVoiceSearch);\n        mImgCloseSearch.setOnClickListener(onClickCloseSearch);\n\n        mEdtSearch.setOnEditorActionListener(onEditorActionListener);\n        mEdtSearch.addTextChangedListener(new OnTextWatcherEdtSearch());\n    }\n\n    private void initAttribute(Context context, AttributeSet attributeSet, int defStyleAttr) {\n        TypedArray attr = context.obtainStyledAttributes(attributeSet, R.styleable.search_liveo, defStyleAttr, 0);\n        if (attr != null) {\n            try {\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint)) {\n                    hint(attr.getString(R.styleable.search_liveo_search_liveo_hint));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_text_color)) {\n                    mEdtSearch.setTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_text_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint_color)) {\n                    mEdtSearch.setHintTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_hint_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_icon)) {\n                    setColorIcon(attr.getColor(R.styleable.search_liveo_search_liveo_color_icon, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_arrow)) {\n                    setColorIconArrow(attr.getColor(R.styleable.search_liveo_search_liveo_color_arrow, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_voice)) {\n                    setColorIconVoice(attr.getColor(R.styleable.search_liveo_search_liveo_color_voice, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_close)) {\n                    setColorIconClose(attr.getColor(R.styleable.search_liveo_search_liveo_color_close, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_background)) {\n                    mViewSearch.setBackgroundColor(attr.getColor(R.styleable.search_liveo_search_liveo_background, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_show_color)) {\n                    setStatusBarShowColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_show_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_hide_color)) {\n                    setStatusBarHideColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_hide_color, -1));\n                }\n            } finally {\n                attr.recycle();\n            }\n        }\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     *\n     * @param resId color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundResource(int resId){\n        mViewSearch.setBackgroundResource(resId);\n        return this;\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundColor(int color){\n        mViewSearch.setBackgroundColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new text color.\n     * In his layout.xml you can use the \"app:searchLiveoTextColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo textColor(int color){\n        mEdtSearch.setTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new hint color.\n     * In his layout.xml you can use the \"app:searchLiveoHintColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo hintColor(int color){\n        mEdtSearch.setHintTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text \"valeu\"\n     */\n    public SearchLiveo text(String text){\n        mEdtSearch.setText(text);\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"value\"\" attribute\n     * @param text \"valeu\"\n     */\n    public SearchLiveo hint(String text){\n        mEdtSearch.setHint(text);\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo text(int text){\n        mEdtSearch.setText(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"@string/...\"\" attribute\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo hint(int text){\n        mEdtSearch.setHint(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new color for all icons (arrow, voice and close).\n     * In his layout.xml you can use the \"app:searchLiveoColorIcon=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIcon(int color){\n        this.setColorIcon(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for back arrow\n     * In his layout.xml you can use the \"app:searchLiveoColorArrow=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconArrow(int color){\n        this.setColorIconArrow(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for voice\n     * In his layout.xml you can use the \"app:searchLiveoColorVoice=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconVoice(int color){\n        this.setColorIconVoice(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for close\n     * In his layout.xml you can use the \"app:searchLiveoColorClose=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconClose(int color){\n        this.setColorIconClose(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo is closed\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarHideColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarHideColor(int color){\n        setStatusBarHideColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo for visible\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarShowColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarShowColor(int color){\n        setStatusBarShowColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Hide voice icon\n     */\n    public SearchLiveo hideVoice(){\n        setIsVoice(false);\n        mImgVoiceSearch.setVisibility(View.GONE);\n        return this;\n    }\n\n    /**\n     * Show voice icon\n     */\n    public SearchLiveo showVoice(){\n        setIsVoice(true);\n        mImgVoiceSearch.setVisibility(View.VISIBLE);\n        return this;\n    }\n\n    private void colorIcon(){\n        if (getColorIcon() != -1 && getColorIconArrow() == -1)  {\n            mImgArrowSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconVoice() == -1)  {\n            mImgVoiceSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconClose() == -1)  {\n            mImgCloseSearch.setColorFilter(this.getColorIcon());\n        }\n    };\n\n    private void colorIconArrow(){\n        if (getColorIconArrow() != -1) {\n            mImgArrowSearch.setColorFilter(this.getColorIconArrow());\n        }\n    };\n\n    private void colorIconVoice(){\n        if (this.getColorIconVoice() != -1) {\n            mImgVoiceSearch.setColorFilter(this.getColorIconVoice());\n        }else{\n            mImgVoiceSearch.clearColorFilter();\n        }\n    };\n\n    private void colorIconClose(){\n        if (this.getColorIconClose() != -1) {\n            mImgCloseSearch.setColorFilter(this.getColorIconClose());\n        }else{\n            mImgCloseSearch.clearColorFilter();\n        }\n    };\n\n    private OnKeyListener onKeyListener = new OnKeyListener() {\n        @Override\n        public boolean onKey(View v, int keyCode, KeyEvent event) {\n            if (event.getAction() == KeyEvent.ACTION_DOWN) {\n                if (keyCode == KeyEvent.KEYCODE_BACK) {\n                    hide();\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    private TextView.OnEditorActionListener onEditorActionListener = new TextView.OnEditorActionListener() {\n        @Override\n        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n            if (actionId == EditorInfo.IME_ACTION_SEARCH) {\n                hide();\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                    }\n                });\n                return true;\n            }\n            return false;\n        }\n    };\n\n    private OnClickListener onClickVoiceSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            startVoice(mEdtSearch);\n        }\n    };\n\n    private OnClickListener onClickCloseSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (mEdtSearch.getText().toString().length() != 0) {\n                mEdtSearch.setText(\"\");\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                    }\n                });\n            }\n        }\n    };\n\n    private OnClickListener onClickSearchArrow = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    private OnClickListener onClickRecyclerView = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    /**\n     * If SearchView is active(show), this method returns the value true\n     */\n    public boolean isActive() {\n        return active;\n    }\n\n    private void setActive(boolean active) {\n        this.active = active;\n    }\n\n    public boolean isVoice() {\n        return isVoice;\n    }\n\n    public void setIsVoice(boolean isVoice) {\n        this.isVoice = isVoice;\n    }\n\n    public int getStatusBarHideColor() {\n        return mStatusBarHideColor;\n    }\n\n    public void setStatusBarHideColor(int mStatusBarHideColor) {\n        this.mStatusBarHideColor = mStatusBarHideColor;\n    }\n\n    public int getStatusBarShowColor() {\n        return mStatusBarShowColor;\n    }\n\n    public void setStatusBarShowColor(int mStatusBarShowColor) {\n        this.mStatusBarShowColor = mStatusBarShowColor;\n    }\n\n    private int getColorIcon() {\n        return mColorIcon;\n    }\n\n    private void setColorIcon(int colorIcon) {\n        this.mColorIcon = colorIcon;\n        this.colorIcon();\n    }\n\n    public int getColorIconArrow() {\n        return mColorIconArrow;\n    }\n\n    public void setColorIconArrow(int color) {\n        this.mColorIconArrow = color;\n        this.colorIconArrow();\n    }\n\n    public int getColorIconVoice() {\n        return mColorIconVoice;\n    }\n\n    public void setColorIconVoice(int color) {\n        this.mColorIconVoice = color;\n        this.colorIconVoice();\n    }\n\n    public int getColorIconClose() {\n        return mColorIconClose;\n    }\n\n    public void setColorIconClose(int color) {\n        this.mColorIconClose = color;\n        this.colorIconClose();\n    }\n\n    private class OnTextWatcherEdtSearch implements TextWatcher {\n\n        @Override\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n        }\n\n        @Override\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\n            try {\n                if (mEdtSearch.getText().toString().length() == 0) {\n                    mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n                    mImgVoiceSearch.setVisibility(isVoice() ? View.VISIBLE : View.GONE);\n                    mImgVoiceSearch.setImageResource(R.drawable.ic_keyboard_voice_color_24dp);\n                    colorIconVoice();\n                } else {\n                    mImgVoiceSearch.setVisibility(View.GONE);\n                    mImgCloseSearch.setVisibility(View.VISIBLE);\n                    mImgCloseSearch.setImageResource(R.drawable.ic_close_color_24dp);\n                    colorIconClose();\n                }\n\n                colorIcon();\n                colorIconArrow();\n                mSearchListener.changedSearch(mEdtSearch.getText().toString());\n            } catch (Exception e) {\n                e.getStackTrace();\n            }\n        }\n\n        @Override\n        public void afterTextChanged(Editable s) {\n\n        }\n    }\n\n    /**\n     * Hide SearchLiveo\n     */\n    public void hide() {\n        try {\n            hideAnimation();\n            setActive(false);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    /**\n     * Show SearchLiveo\n     */\n    public SearchLiveo show() {\n        setActive(true);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            try {\n                showAnimation();\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_with));\n            }\n\n        } else {\n\n            Animation mFadeIn = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_in);\n            mViewSearch.setEnabled(true);\n            mViewSearch.setVisibility(View.VISIBLE);\n            mViewSearch.setAnimation(mFadeIn);\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mEdtSearch.requestFocus();\n        return this;\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private void showAnimation(){\n        try {\n\n            if (getStatusBarShowColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarShowColor());\n            }else {\n                mContext.getWindow().setStatusBarColor(ContextCompat.getColor(mContext, R.color.search_liveo_primary_dark));\n            }\n\n            final Animator animator = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, this.mContext),\n                    (int) dpToPixel(23, this.mContext), 0,\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()));\n            animator.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n\n            animator.setDuration(300);\n            animator.start();\n        }catch (Exception e){\n            e.getStackTrace();\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mViewSearch.setVisibility(View.VISIBLE);\n    }\n\n    private SearchLiveo hideAnimation() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            if (getStatusBarHideColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarHideColor());\n            } else {\n                mContext.getWindow().setStatusBarColor(getColorPrimaryDark());\n            }\n\n            final Animator animatorHide = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, mContext),\n                    (int) dpToPixel(23, mContext),\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()), 0);\n            animatorHide.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mViewSearch.setVisibility(View.GONE);\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n            animatorHide.setDuration(200);\n            animatorHide.start();\n\n        } else {\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                }\n            });\n\n            Animation mFadeOut = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_out);\n            mViewSearch.setAnimation(mFadeOut);\n            mViewSearch.setVisibility(View.INVISIBLE);\n        }\n\n        mEdtSearch.setText(\"\");\n        mViewSearch.setEnabled(false);\n        return this;\n    }\n\n    private int getColorPrimaryDark() {\n        return mColorPrimaryDark;\n    }\n\n    private void setColorPrimaryDark(int mColorPrimaryDark) {\n        this.mColorPrimaryDark = ContextCompat.getColor(mContext, mColorPrimaryDark);\n    }\n\n    private float dpToPixel(float dp, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        return dp * (metrics.densityDpi / 160f);\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Bundle bundle = new Bundle();\n        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());\n        bundle.putBoolean(STATE_TO_SAVE, this.isActive());\n\n        if (!mEdtSearch.getText().toString().trim().equals(\"\")){\n            bundle.putString(SEARCH_TEXT, mEdtSearch.getText().toString());\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n\n        if (state instanceof Bundle) {\n            Bundle bundle = (Bundle) state;\n            this.setActive(bundle.getBoolean(STATE_TO_SAVE));\n\n            String text = bundle.getString(SEARCH_TEXT, \"\");\n            if (!text.trim().equals(\"\")){\n                mEdtSearch.setText(text);\n            }\n\n            if (this.isActive()){\n                show();\n            }\n\n            state = bundle.getParcelable(INSTANCE_STATE);\n        }\n\n        super.onRestoreInstanceState(state);\n    }\n\n    private void startVoice(EditText editText) {\n        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                hideSoftInputFromWindow(editText.getWindowToken(), 0);\n\n        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault());\n        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, mContext.getString(R.string.searchview_voice));\n        try {\n            mContext.startActivityForResult(intent, REQUEST_CODE_SPEECH_INPUT);\n        } catch (ActivityNotFoundException a) {\n            Toast.makeText(mContext.getApplicationContext(), R.string.not_supported, Toast.LENGTH_SHORT).show();\n        }\n    }\n\n    public void resultVoice(int requestCode, int resultCode, Intent data){\n        if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n            if (resultCode == Activity.RESULT_OK && null != data) {\n                ArrayList<String> result = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                mEdtSearch.setText(result.get(0));\n            }\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/adapter/ParticipantAdapter.java\npublic class ParticipantAdapter extends RecyclerView.Adapter<ParticipantAdapter.ViewHolder> {\n\n    private int mBackground;\n    private Context mContext;\n    private HashSet<Integer> checkedItems;\n    private ArrayList<Participant> mParticipants;\n    private ArrayList<Participant> mSearchParticipants;\n\n    private static final int ITEM_VIEW_TYPE_ITEM = 1;\n    private static final int ITEM_VIEW_TYPE_HEADER = 0;\n\n    private static OnItemClickListener mOnClickListener;\n    private static OnItemClickListener mOnItemClickListener;\n    private static OnItemLongClickListener mOnItemLongClickListener;\n\n    public ParticipantAdapter(Context context, ArrayList<Participant> participants) {\n        this.mContext = context;\n        this.mParticipants = participants;\n        this.checkedItems = new HashSet<>();\n        this.mSearchParticipants = new ArrayList<>();\n        this.mSearchParticipants.addAll(this.mParticipants);\n\n        if (context != null) {\n            TypedValue mTypedValue = new TypedValue();\n            context.getTheme().resolveAttribute(android.R.attr.selectableItemBackground, mTypedValue, true);\n            this.mBackground = mTypedValue.resourceId;\n        }\n    }\n\n    class ViewHolder extends RecyclerView.ViewHolder {\n        View mContainer;\n\n        TextView mTitle;\n        TextView mName;\n        TextView mEmail;\n        TextView mShirtSize;\n\n        ViewHolder(View view) {\n            super(view);\n\n            mContainer = view;\n\n            mTitle = (TextView) view.findViewById(R.id.txt_title);\n            mName = (TextView) view.findViewById(R.id.txt_name);\n            mEmail = (TextView) view.findViewById(R.id.txt_email);\n            mShirtSize = (TextView) view.findViewById(R.id.txt_shirt_size);\n\n            if (mShirtSize != null) {\n                mShirtSize.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        // -1 Refers to the header\n                        int position = getAdapterPosition() - 1;\n                        if (mOnClickListener != null && position >= 0) {\n                            mOnClickListener.onItemClick(v, position);\n                        }\n                    }\n                });\n            }\n\n            mContainer.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    // -1 Refers to the header\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemClickListener != null && position >= 0) {\n                        mOnItemClickListener.onItemClick(v, position);\n                    }\n                }\n            });\n\n            mContainer.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemLongClickListener != null && position >= 0) {\n                        mOnItemLongClickListener.onItemLongClick(v, position);\n                    }\n                    return true;\n                }\n            });\n        }\n    }\n\n    @Override\n    public ParticipantAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view;\n\n        if (viewType == ITEM_VIEW_TYPE_HEADER) {\n            view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_header, parent, false);\n            return new ViewHolder(view);\n        }\n\n        view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_item, parent, false);\n        view.setBackgroundResource(this.mBackground);\n        return new ViewHolder(view);\n    }\n\n    private boolean isHeader(int position) {\n        return position == 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        return isHeader(position) ? ITEM_VIEW_TYPE_HEADER : ITEM_VIEW_TYPE_ITEM;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n\n        if (mParticipants == null || mParticipants.size() == 0){\n            return;\n        }\n\n        if (isHeader(position)) {\n            holder.mTitle.setText(mParticipants.get(position).getNameEvent());\n            return;\n        }\n\n        // -1 Refers to the header\n        Participant participant = mParticipants.get(position - 1);\n\n        holder.mName.setText(participant.getName());\n        holder.mName.setCompoundDrawablesWithIntrinsicBounds(participant.isAttend() ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n\n        holder.mEmail.setText(participant.getEmail());\n\n        if (participant.isGroup()) {\n            int shirtSize = participant.getShirtSize();\n            holder.mShirtSize.setVisibility(View.VISIBLE);\n            GradientDrawable gradientDrawable = (GradientDrawable) holder.mShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(mContext, Util.shirtSizeColor[shirtSize]));\n            holder.mShirtSize.setText(this.mContext.getString(Util.shirtSize[shirtSize]));\n        }else{\n            holder.mShirtSize.setVisibility(View.INVISIBLE);\n        }\n\n        if (checkedItems.contains(position)) {\n            holder.mContainer.setBackgroundResource(R.drawable.seletor_long_click_item);\n        } else {\n            holder.mContainer.setBackgroundResource(this.mBackground);\n        }\n    }\n\n    public void readAttendParticipant(int position, boolean attend){\n        mParticipants.get(position).setAttend(attend);\n        notifyDataSetChanged();\n    }\n\n    public void remove(int position){\n        mParticipants.remove(position);\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public int getItemCount() {\n        // +1 Refers to the header\n        return (mParticipants == null ? 0 : mParticipants.size()+1);\n    }\n\n    public void setOnClickListener(OnItemClickListener onClickListener) {\n        mOnClickListener = onClickListener;\n    }\n\n    public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n        mOnItemClickListener = onItemClickListener;\n    }\n\n    public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) {\n        mOnItemLongClickListener = onItemLongClickListener;\n    }\n\n    public void resetarCheck() {\n        this.checkedItems.clear();\n        this.notifyDataSetChanged();\n    }\n\n    public void setChecked(int position, boolean checked) {\n        resetarCheck();\n\n        if (checked) {\n            this.checkedItems.add(position);\n        } else {\n            this.checkedItems.remove(position);\n        }\n\n        this.notifyDataSetChanged();\n    }\n\n    public void searchParticipantes(CharSequence charText) {\n\n        charText = Util.removeAccent((String) charText).toLowerCase(Locale.getDefault());\n\n        mParticipants.clear();\n        if (charText.length() == 0) {\n            mParticipants.addAll(mSearchParticipants);\n        } else {\n            for (Participant participant: mSearchParticipants) {\n                String name = Util.removeAccent(participant.getName());\n                if (name.toLowerCase(Locale.getDefault()).contains(charText)) {\n                    mParticipants.add(participant);\n                }\n            }\n        }\n\n        notifyDataSetChanged();\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/NewParticipantActivity.java\npublic class NewParticipantActivity extends BaseActivity{\n\n    private int mShirtSize = 0;\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.img_sex) ImageView mImgSex;\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.sw_sex) SwitchCompat mSwSex;\n\n    @BindView(R.id.edt_code) EditText mEdtCode;\n    @BindView(R.id.edt_name) EditText mEdtName;\n    @BindView(R.id.edt_email) EditText mEdtEmail;\n    @BindView(R.id.edt_phone) EditText mEdtPhone;\n    @BindView(R.id.edt_company) EditText mEdtCompany;\n    @BindView(R.id.sw_attend) SwitchCompat mSwAttend;\n\n    @BindView(R.id.txt_shirt_size_p) TextView mTxtShirtSizeP;\n    @BindView(R.id.txt_shirt_size_m) TextView mTxtShirtSizeM;\n    @BindView(R.id.txt_shirt_size_g) TextView mTxtShirtSizeG;\n    @BindView(R.id.txt_shirt_size_gg) TextView mTxtShirtSizeGG;\n    @BindView(R.id.txt_shirt_size_eg) TextView mTxtShirtSizeEG;\n\n    @BindView(R.id.layout_code) LinearLayout mLayoutCode;\n    @BindView(R.id.layout_name) LinearLayout mLayoutName;\n    @BindView(R.id.layout_email) LinearLayout mLayoutEmail;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_new_participant);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.new_participant));\n        mToolbar.setNavigationIcon(R.drawable.ic_done_white_24dp);\n        this.setSupportActionBar(mToolbar);\n\n        setupOnClickListener();\n        if (savedInstanceState != null){\n            mShirtSize = savedInstanceState.getInt(Constant.PARTICIPANT_shirtSize, 0);\n        }\n\n        boolean isInsert = getIntent().getExtras().getBoolean(Constant.INSERT, false);\n        if (!isInsert){\n            mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n            setupUpdate(mParticipant);\n        }\n\n        colorDefaultShirtSize(mShirtSize);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n\t}\n\n    private void setupUpdate(Participant participant){\n        mEdtCode.setEnabled(false);\n        mEdtCode.setText(String.valueOf(participant.getCode()));\n        mEdtName.setText(participant.getName());\n        mEdtPhone.setText(participant.getPhone());\n        mEdtEmail.setText(participant.getEmail());\n        mShirtSize = participant.getShirtSize();\n        mSwAttend.setChecked(participant.isAttend());\n        mSwSex.setChecked(participant.isSex());\n        mEdtCompany.setText(participant.getCompany());\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_resume).setVisible(false);\n        return true;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(Constant.PARTICIPANT_shirtSize, mShirtSize);\n    }\n\n    private CompoundButton.OnCheckedChangeListener onCheckedAttend = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwAttend.setCompoundDrawablesWithIntrinsicBounds(isChecked ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n        }\n    };\n\n    private CompoundButton.OnCheckedChangeListener onCheckedSex = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwSex.setText(isChecked ? R.string.female : R.string.male);\n            mImgSex.setColorFilter(ContextCompat.getColor(NewParticipantActivity.this, isChecked ? R.color.shirt_size_g : R.color.shirt_size_m));\n            mImgSex.setImageDrawable(ContextCompat.getDrawable(NewParticipantActivity.this, isChecked ? R.drawable.ic_favorite_grey600_24dp : R.drawable.ic_android_grey600_24dp));\n\n            if (isChecked){\n                YoYo.with(Techniques.Landing).playOn(mImgSex);\n            }\n        }\n    };\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        switch (item.getItemId()){\n            case android.R.id.home:\n                    if (validation()){\n                        if (mParticipant == null) {\n                            saveParticipant();\n                        }else{\n                            updateParticipant();\n                        }\n                    }\n                break;\n\n            case R.id.menu_discart:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n        }\n\n        return true;\n    }\n\n    private void setupOnClickListener(){\n        mSwAttend.setOnCheckedChangeListener(onCheckedAttend);\n        mSwAttend.setChecked(true);\n\n        mSwSex.setOnCheckedChangeListener(onCheckedSex);\n        mSwSex.setChecked(false);\n\n        mTxtShirtSizeP.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeM.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeGG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeEG.setOnClickListener(onClickShirtSize);\n    }\n\n    private boolean validation(){\n\t\tboolean result = true;\n\n        if (mEdtCode.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtCode.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutCode);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_code, Toast.LENGTH_SHORT).show();\n        }else if (mEdtName.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtName.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutName);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_name, Toast.LENGTH_SHORT).show();\n        }else if (mEdtEmail.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtEmail.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutEmail);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_email, Toast.LENGTH_SHORT).show();\n        }\n\n\t\treturn result;\n\t}\n\n    private void saveParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(Constant.NAME_EVENT);\n        participant.setBirthDate(\"\");\n        participant.setRaffled(false);\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantInsertTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private void updateParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setId(mParticipant.getId());\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(mParticipant.getNameEvent());\n        participant.setBirthDate(mParticipant.getBirthDate());\n        participant.setRaffled(mParticipant.isRaffled());\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantUpdateTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private View.OnClickListener onClickShirtSize = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            resetColorShirtSize();\n\n            switch (v.getId()){\n\n                case R.id.txt_shirt_size_p:\n                    mShirtSize = 0;\n                    break;\n\n                case R.id.txt_shirt_size_m:\n                    mShirtSize = 1;\n                    break;\n\n                case R.id.txt_shirt_size_g:\n                    mShirtSize = 2;\n                    break;\n\n                case R.id.txt_shirt_size_gg:\n                    mShirtSize = 3;\n                    break;\n\n                case R.id.txt_shirt_size_eg:\n                    mShirtSize = 4;\n                    break;\n\n            }\n\n            colorDefaultShirtSize(mShirtSize);\n        }\n    };\n\n    private void resetColorShirtSize(){\n        GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n    }\n\n    private void colorDefaultShirtSize(int shirtSize){\n        resetColorShirtSize();\n        GradientDrawable gradientDrawable;\n\n        switch (shirtSize) {\n            case 0:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeP);\n                break;\n\n            case 1:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeM);\n                break;\n\n            case 2:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeG);\n                break;\n\n            case 3:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeGG);\n                break;\n\n            case 4:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeEG);\n                break;\n        }\n    }\n\n    private class AnimatorShirtSize implements Animator.AnimatorListener{\n\n        private int mPosition;\n        private GradientDrawable mGradientDrawable;\n\n        public AnimatorShirtSize(GradientDrawable gradientDrawable, int position){\n            this.mPosition = position;\n            this.mGradientDrawable = gradientDrawable;\n        }\n\n        @Override\n        public void onAnimationStart(Animator animation) {\n            if (mGradientDrawable != null) {\n                mGradientDrawable.setColor(ContextCompat.getColor(NewParticipantActivity.this, Util.shirtSizeColor[mPosition]));\n            }\n        }\n\n        @Override\n        public void onAnimationEnd(Animator animation) {\n        }\n\n        @Override\n        public void onAnimationCancel(Animator animation) {\n\n        }\n\n        @Override\n        public void onAnimationRepeat(Animator animation) {\n\n        }\n    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_save_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/RaffleActivity.java\npublic class RaffleActivity extends BaseActivity {\n\n    private boolean isFinishOk = false;\n    private Participant mParticipantFortunate;\n    @BindView(R.id.animated_load) AnimatedCircleLoadingView mAnimatedLoad;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_raffle_main);\n        ButterKnife.bind(this);\n\n        mParticipantFortunate =  getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mAnimatedLoad.setOnClickListener(onClickAnimLoad);\n        startPercentMockThread();\n    }\n\n    private View.OnClickListener onClickAnimLoad = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (isFinishOk) {\n                isFinishOk = false;\n                Toast.makeText(getApplicationContext(), \"Terminou\", Toast.LENGTH_SHORT).show();\n            }\n        }\n    };\n\n    private void startLoading() {\n        mAnimatedLoad.startDeterminate();\n    }\n\n    private void startPercentMockThread() {\n        startLoading();\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1500);\n                    for (int i = 0; i <= 100; i++) {\n                        Thread.sleep(10);\n                        changePercent(i);\n                    }\n                    Thread.sleep(3000);\n                    ParticipantDao participantDao = new ParticipantDao(getApplicationContext());\n                    participantDao.updateAsRaffled(mParticipantFortunate);\n                    Intent intent = new Intent(getBaseContext(), ParticipantFortunateActivity.class);\n                    intent.putExtra(Constant.PARTICIPANT, mParticipantFortunate);\n                    startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n                    finish();\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        new Thread(runnable).start();\n    }\n\n    private void changePercent(final int percent) {\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (mAnimatedLoad != null) {\n                    mAnimatedLoad.setPercent(percent);\n\n                    if (percent == 100){\n                        isFinishOk = true;\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantTask.java\npublic class ParticipantTask extends AsyncTask<Void, Void, ArrayList<Participant>> {\n\n    private Context mContext;\n    public ParticipantTask(Context context){\n        this.mContext = context;\n    }\n\n    @Override\n    protected ArrayList<Participant> doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.getAll();\n    }\n}\nimport android.Manifest;\nimport android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.view.ActionMode;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport com.daimajia.androidanimations.library.Techniques;\nimport com.daimajia.androidanimations.library.YoYo;\nimport com.nineoldandroids.animation.Animator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport br.com.javace.javou.R;\nimport br.com.javace.javou.adapter.ParticipantAdapter;\nimport br.com.javace.javou.dao.ParticipantDao;\nimport br.com.javace.javou.interfaces.OnItemClickListener;\nimport br.com.javace.javou.interfaces.OnItemLongClickListener;\nimport br.com.javace.javou.interfaces.OnScrollListener;\nimport br.com.javace.javou.model.participant.Participant;\nimport br.com.javace.javou.model.raffle.Raffle;\nimport br.com.javace.javou.task.ParticipantDeleteTask;\nimport br.com.javace.javou.task.ParticipantPresenceTask;\nimport br.com.javace.javou.task.ParticipantSendTask;\nimport br.com.javace.javou.task.ParticipantTask;\nimport br.com.javace.javou.ui.activity.MainActivity;\nimport br.com.javace.javou.ui.activity.NewParticipantActivity;\nimport br.com.javace.javou.ui.activity.ParticipantDetailActivity;\nimport br.com.javace.javou.ui.activity.ParticipantFortunateActivity;\nimport br.com.javace.javou.ui.activity.RaffleActivity;\nimport br.com.javace.javou.ui.activity.ResumeActivity;\nimport br.com.javace.javou.ui.base.BaseActivity;\nimport br.com.javace.javou.ui.base.BaseFragment;\nimport br.com.javace.javou.util.Constant;\nimport br.liveo.searchliveo.SearchLiveo;\nimport br.liveo.searchliveo.interfaces.OnSearchListener;\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n        if (savedInstanceState == null){\n            loadParticipant();\n        }else{\n            isActionMode = savedInstanceState.getBoolean(Constant.ACTION_MODE);\n            mParticipants = savedInstanceState.getParcelableArrayList(Constant.PARTICIPANT);\n\n            if (getParticipants() != null){\n                resultAdapter(getParticipants());\n            }\n\n            if (isActionMode){\n                mPositionActionMode = savedInstanceState.getInt(Constant.POSITION);\n                showActionMode(mPositionActionMode);\n            }\n        }\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putBoolean(Constant.ACTION_MODE, isActionMode);\n        outState.putInt(Constant.POSITION, mPositionActionMode);\n        outState.putParcelableArrayList(Constant.PARTICIPANT, getParticipants());\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        // TODO Auto-generated method stub\n        super.onCreateOptionsMenu(menu, inflater);\n        inflater.inflate(R.menu.menu, menu);\n\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        isSearchView = false;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // TODO Auto-generated method stub\n        switch (item.getItemId()) {\n            case R.id.menu_search:\n                isSearchView = true;\n                mSearchLiveo.show();\n                break;\n            case R.id.menu_raffle:\n                raffleParticipant(true);\n                break;\n\n            case R.id.menu_woman:\n                raffleParticipant(false);\n                break;\n            case R.id.menu_send:\n                if (checkPermission()) {\n                    generateSendingFile();\n                }\n                break;\n            case R.id.menu_resume:\n                generateResume();\n                break;\n        }\n        return true;\n    }\n\n    private void generateResume() {\n        Intent intent = new Intent(getActivity(), ResumeActivity.class);\n        startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n    }\n\n    private void loadParticipant(){\n        mEndlessListener.resetEndlessRecyclerView();\n        new ParticipantTask(getActivity()){\n\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                mSwipeRefreshLayout.setRefreshing(true);\n            }\n\n            @Override\n            protected void onPostExecute(ArrayList<Participant> participants) {\n                super.onPostExecute(participants);\n\n                if (participants != null && participants.size() > 0){\n                    mParticipants = new ArrayList<>();\n                    mParticipants = participants;\n\n                    resultAdapter(mParticipants);\n                }\n\n                mSwipeRefreshLayout.setRefreshing(false);\n            }\n        }.execute();\n\n    }\n\n    private SwipeRefreshLayout.OnRefreshListener onRefresh = new SwipeRefreshLayout.OnRefreshListener() {\n        @Override\n        public void onRefresh() {\n            loadParticipant();\n        }\n    };\n\n    private void resultAdapter(ArrayList<Participant> participants){\n        mParticipantAdapter = new ParticipantAdapter(getActivity(), participants);\n        getParticipantAdapter().setOnClickListener(onClickListener);\n        getParticipantAdapter().setOnItemClickListener(onItemClickListener);\n        getParticipantAdapter().setOnItemLongClickListener(onItemLongClickListener);\n        mRecyclerView.setAdapter(getParticipantAdapter());\n    }\n\n    private void raffleParticipant(boolean isMan) {\n        if (mParticipants != null && mParticipants.size() > 0) {\n            Raffle raffle = new Raffle(mParticipants);\n\n            if (raffle.isValid() && isMan) {\n\n                Participant participant = raffle.getFortunate();\n                ParticipantDao participantDao = new ParticipantDao(getActivity());\n                participantDao.updateAsRaffled(participant);\nNext line of code:\n", "input": "import android.Manifest;\nimport android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.view.ActionMode;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport com.daimajia.androidanimations.library.Techniques;\nimport com.daimajia.androidanimations.library.YoYo;\nimport com.nineoldandroids.animation.Animator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport br.com.javace.javou.R;\nimport br.com.javace.javou.adapter.ParticipantAdapter;\nimport br.com.javace.javou.dao.ParticipantDao;\nimport br.com.javace.javou.interfaces.OnItemClickListener;\nimport br.com.javace.javou.interfaces.OnItemLongClickListener;\nimport br.com.javace.javou.interfaces.OnScrollListener;\nimport br.com.javace.javou.model.participant.Participant;\nimport br.com.javace.javou.model.raffle.Raffle;\nimport br.com.javace.javou.task.ParticipantDeleteTask;\nimport br.com.javace.javou.task.ParticipantPresenceTask;\nimport br.com.javace.javou.task.ParticipantSendTask;\nimport br.com.javace.javou.task.ParticipantTask;\nimport br.com.javace.javou.ui.activity.MainActivity;\nimport br.com.javace.javou.ui.activity.NewParticipantActivity;\nimport br.com.javace.javou.ui.activity.ParticipantDetailActivity;\nimport br.com.javace.javou.ui.activity.ParticipantFortunateActivity;\nimport br.com.javace.javou.ui.activity.RaffleActivity;\nimport br.com.javace.javou.ui.activity.ResumeActivity;\nimport br.com.javace.javou.ui.base.BaseActivity;\nimport br.com.javace.javou.ui.base.BaseFragment;\nimport br.com.javace.javou.util.Constant;\nimport br.liveo.searchliveo.SearchLiveo;\nimport br.liveo.searchliveo.interfaces.OnSearchListener;\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n        if (savedInstanceState == null){\n            loadParticipant();\n        }else{\n            isActionMode = savedInstanceState.getBoolean(Constant.ACTION_MODE);\n            mParticipants = savedInstanceState.getParcelableArrayList(Constant.PARTICIPANT);\n\n            if (getParticipants() != null){\n                resultAdapter(getParticipants());\n            }\n\n            if (isActionMode){\n                mPositionActionMode = savedInstanceState.getInt(Constant.POSITION);\n                showActionMode(mPositionActionMode);\n            }\n        }\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putBoolean(Constant.ACTION_MODE, isActionMode);\n        outState.putInt(Constant.POSITION, mPositionActionMode);\n        outState.putParcelableArrayList(Constant.PARTICIPANT, getParticipants());\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        // TODO Auto-generated method stub\n        super.onCreateOptionsMenu(menu, inflater);\n        inflater.inflate(R.menu.menu, menu);\n\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        isSearchView = false;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // TODO Auto-generated method stub\n        switch (item.getItemId()) {\n            case R.id.menu_search:\n                isSearchView = true;\n                mSearchLiveo.show();\n                break;\n            case R.id.menu_raffle:\n                raffleParticipant(true);\n                break;\n\n            case R.id.menu_woman:\n                raffleParticipant(false);\n                break;\n            case R.id.menu_send:\n                if (checkPermission()) {\n                    generateSendingFile();\n                }\n                break;\n            case R.id.menu_resume:\n                generateResume();\n                break;\n        }\n        return true;\n    }\n\n    private void generateResume() {\n        Intent intent = new Intent(getActivity(), ResumeActivity.class);\n        startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n    }\n\n    private void loadParticipant(){\n        mEndlessListener.resetEndlessRecyclerView();\n        new ParticipantTask(getActivity()){\n\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                mSwipeRefreshLayout.setRefreshing(true);\n            }\n\n            @Override\n            protected void onPostExecute(ArrayList<Participant> participants) {\n                super.onPostExecute(participants);\n\n                if (participants != null && participants.size() > 0){\n                    mParticipants = new ArrayList<>();\n                    mParticipants = participants;\n\n                    resultAdapter(mParticipants);\n                }\n\n                mSwipeRefreshLayout.setRefreshing(false);\n            }\n        }.execute();\n\n    }\n\n    private SwipeRefreshLayout.OnRefreshListener onRefresh = new SwipeRefreshLayout.OnRefreshListener() {\n        @Override\n        public void onRefresh() {\n            loadParticipant();\n        }\n    };\n\n    private void resultAdapter(ArrayList<Participant> participants){\n        mParticipantAdapter = new ParticipantAdapter(getActivity(), participants);\n        getParticipantAdapter().setOnClickListener(onClickListener);\n        getParticipantAdapter().setOnItemClickListener(onItemClickListener);\n        getParticipantAdapter().setOnItemLongClickListener(onItemLongClickListener);\n        mRecyclerView.setAdapter(getParticipantAdapter());\n    }\n\n    private void raffleParticipant(boolean isMan) {\n        if (mParticipants != null && mParticipants.size() > 0) {\n            Raffle raffle = new Raffle(mParticipants);\n\n            if (raffle.isValid() && isMan) {\n\n                Participant participant = raffle.getFortunate();\n                ParticipantDao participantDao = new ParticipantDao(getActivity());\n                participantDao.updateAsRaffled(participant);\n", "context": "app/src/main/java/br/com/javace/javou/ui/activity/MainActivity.java\npublic class MainActivity extends BaseActivity{\n\n    private ActionMode mAcitonMode;\n    private ParticipantFragment mParticipantFragment;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        setupInit(savedInstanceState);\n    }\n\n    private void setupInit(Bundle savedInstanceState){\n        //setupFragment(savedInstanceState);\n        Preference preference = new Preference(this);\n        if (preference.getString(Constant.FIRST_RUN) == null){\n            startActivityForResult(new Intent(this, SynchronizationActivity.class), 0);\n            preference.setString(Constant.FIRST_RUN, Constant.TAG);\n        }else{\n            setupFragment(savedInstanceState);\n        }\n    }\n\n    private void setupFragment(Bundle savedInstanceState){\n        if (savedInstanceState == null) {\n            mParticipantFragment = ParticipantFragment.newInstance();\n            getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n        }else{\n            if (mParticipantFragment == null) {\n                mParticipantFragment = (ParticipantFragment) getFragmentManager().findFragmentByTag(Constant.PARTICIPANT);\n            }\n        }\n    }\n\n    public void showActionMode(String name){\n        mAcitonMode = startSupportActionMode(mParticipantFragment.actionModeCallback);\n        actionModeSetTitle(name);\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.action_mode_primary_dark));\n        }\n    }\n\n    public void actionModeSetTitle(String name){\n        mAcitonMode.setTitle(name);\n    }\n\n    public void hideActionMode(){\n        if (mAcitonMode != null){\n            mAcitonMode.finish();\n            mAcitonMode = null;\n        }\n\n        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            getWindow().setStatusBarColor(ContextCompat.getColor(this, R.color.primary_dark));\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (mAcitonMode != null) {\n            hideActionMode();\n        }else{\n            super.onBackPressed();\n        }\n    }\n\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        switch (requestCode){\n            case 0:\n                mParticipantFragment = ParticipantFragment.newInstance();\n                getFragmentManager().beginTransaction().add(R.id.container, mParticipantFragment, Constant.PARTICIPANT).commit();\n                break;\n\n            default:\n                if (data != null) {\n                    if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n                        mParticipantFragment.onActivityResult(requestCode, resultCode, data);\n                    }\n                }\n                break;\n        }\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (mParticipantFragment != null){\n            mParticipantFragment.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemLongClickListener.java\npublic interface OnItemLongClickListener {\n    void onItemLongClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantFortunateActivity.java\npublic class ParticipantFortunateActivity extends BaseActivity{\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_name) TextView txtName;\n    @BindView(R.id.txt_email) TextView txtEmail;\n    @BindView(R.id.txt_phone) TextView txtPhone;\n    @BindView(R.id.img_photo) ImageView imgPhoto;\n    @BindView(R.id.layout_phone) LinearLayout mLayoutPhone;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_fortunate);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.participant_fortunate));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        Participant participant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n\n        if (participant != null) {\n            txtName.setText(participant.getName());\n            txtEmail.setText(participant.getEmail());\n\n            mLayoutPhone.setVisibility(View.GONE);\n            if (!TextUtils.isEmpty(participant.getPhone())){\n                txtPhone.setText(participant.getPhone());\n                mLayoutPhone.setVisibility(View.VISIBLE);\n            }\n\n            if (participant.getSex()) {\n                imgPhoto.setImageDrawable(ContextCompat.getDrawable(this, R.drawable.ic_suricate_girl));\n            }\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseFragment.java\npublic class BaseFragment extends Fragment {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final BaseActivity.ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(getActivity(), animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final BaseActivity.ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(getActivity(), animation);\n    }\n\n\n    private static void putAnimation(final Activity source, final BaseActivity.ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final BaseActivity.ActivityAnimation animation) {\n\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ResumeActivity.java\npublic class ResumeActivity extends BaseActivity {\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_shape_total_raffled) TextView mTxtShapeTotalReffled;\n    @BindView(R.id.txt_shape_total_attendence) TextView mTxtShapeTotalAttendence;\n    @BindView(R.id.txt_shape_total_registrations) TextView mTxtShapeTotalRegistrations;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_resume);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.resume_event));\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        generateResume();\n    }\n\n    private void generateResume() {\n        ParticipantDao dao = new ParticipantDao(this);\n        Resume resume = dao.generateResume();\n        mTxtShapeTotalRegistrations.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRegistrations()));\n        mTxtShapeTotalAttendence.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalAttendance()));\n        mTxtShapeTotalReffled.setText(String.format(Locale.getDefault(), \"%d\", resume.getTotalRaffled()));\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish(ActivityAnimation.SLIDE_RIGHT);\n        return super.onOptionsItemSelected(item);\n    }\n}\napp/src/main/java/br/com/javace/javou/dao/ParticipantDao.java\npublic class ParticipantDao {\n\n    private Context mContext;\n    private ClasseDB classeDB;\n    private SQLiteDatabase db = null;\n    private static ParticipantDao instance;\n\n    public ParticipantDao(Context context) {\n        super();\n        this.mContext = context;\n\n    }\n\n    public static ParticipantDao getInstance(Context context) {\n        if (instance == null) {\n            synchronized (ParticipantDao.class) {\n                if (instance == null) {\n                    instance = new ParticipantDao(context);\n                }\n            }\n        }\n        return instance;\n    }\n\n    private void openConnection() {\n\n        try {\n            this.classeDB = ClasseDB.getInstance(this.mContext);\n            db = classeDB.getWritableDatabase();\n        } catch (Exception e) {\n\n            Log.e(Constant.TAG, \"Erro ao abrir conex?es ParticipantDao\");\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            if (null != db) {\n                db.close();\n                db = null;\n                classeDB.close();\n            }\n\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ao fechar conex?es ParticipantDao\");\n        }\n    }\n\n    public void synchronizeParticipant(List<String[]> participants) {\n\n        if (participants != null) {\n            try {\n                openConnection();\n                for (String[] participant : participants) {\n                    try {\n\n                        if (!participant[0].equals(\"NOME\")) {\n\n                            ContentValues campos = new ContentValues();\n\n                            campos.put(Constant.PARTICIPANT_name, participant[0]);\n                            campos.put(Constant.PARTICIPANT_email, participant[1].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_code, participant[5]);\n\n                            //campos.put(Constant.PARTICIPANT_phone, \"\");\n                            campos.put(Constant.PARTICIPANT_phone, Util.replacePhone(participant[13]));\n\n                            campos.put(Constant.PARTICIPANT_attend, 0);\n                            campos.put(Constant.PARTICIPANT_nameEvent, \"JAVOU! #09 - Casos de Sucesso\");\n\n                            String birthDate = participant[16];\n                            campos.put(Constant.PARTICIPANT_birthDate, birthDate);\n\n                            String company = WordUtils.capitalizeFully(participant[17].toLowerCase());\n                            campos.put(Constant.PARTICIPANT_company, company);\n\n                            campos.put(Constant.PARTICIPANT_sex, !participant[20].equals(\"Masculino\"));\n\n                            int shirtSize = 5;\n                            if (!participant[3].contains(\"SEM Blusa\")) {\n                                shirtSize = Util.replaceShirtSize(participant[21]);\n                            }\n                            campos.put(Constant.PARTICIPANT_shirtSize, shirtSize);\n\n                            try {\n                                Long row = db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos);\n                                Log.d(\"ParticipantDao\", row.toString());\n                            } catch (Exception e) {\n                                e.getMessage();\n                                Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                            }\n                        }\n\n                    } catch (Exception e) {\n                        e.getStackTrace();\n                    }\n                }\n\n                closeConnection();\n            }catch (Exception e){\n                e.getStackTrace();\n            }\n        }\n    }\n\n    public boolean insert(Participant participant) {\n\n        if (participant != null) {\n\n            try {\n                openConnection();\n\n                ContentValues campos = new ContentValues();\n\n                campos.put(Constant.PARTICIPANT_name, participant.getName());\n                campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n                campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n                campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n                campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n                campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n                campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n                campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n                campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n                try {\n                    return ( db.insertOrThrow(Constant.TABLE_PARTICIPANT, Constant.DATABASE, campos) != -1);\n                } catch (Exception e) {\n                    e.getMessage();\n                    Log.e(Constant.TAG, \"insert: \" + mContext.getString(R.string.app_name));\n                }\n\n            } finally {\n                closeConnection();\n            }\n        }\n\n        return false;\n    }\n\n    public boolean update(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues campos = new ContentValues();\n\n            campos.put(Constant.PARTICIPANT_name, participant.getName());\n            campos.put(Constant.PARTICIPANT_phone, participant.getPhone());\n            campos.put(Constant.PARTICIPANT_email, participant.getEmail());\n            campos.put(Constant.PARTICIPANT_photo, participant.getPhoto());\n            campos.put(Constant.PARTICIPANT_shirtSize, participant.getShirtSize());\n            campos.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_nameEvent, participant.getNameEvent());\n            campos.put(Constant.PARTICIPANT_birthDate, participant.getBirthDate());\n            campos.put(Constant.PARTICIPANT_sex, participant.isSex() ? 1 : 0);\n            campos.put(Constant.PARTICIPANT_company, participant.getCompany());\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, campos, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao update: \", e);\n            Log.e(Constant.TAG, \"update: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean updatePresence(Participant participant) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_attend, participant.isAttend() ? 0 : 1);\n\n            String args[] = new String[]{String.valueOf(participant.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updatePresence: \", e);\n            Log.e(Constant.TAG, \"updatePresence: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public boolean delete(int id) {\n\n        try {\n            openConnection();\n\n            String args[] = new String[]{String.valueOf(id)};\n            return (db.delete(Constant.TABLE_PARTICIPANT, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao delete: \", e);\n            Log.e(Constant.TAG, \"delete: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n    }\n\n    public ArrayList<Participant> getAll() {\n\n        Participant participant;\n        ArrayList<Participant> lParticipant = new ArrayList<>();\n\n        Cursor cursor;\n        try {\n\n            openConnection();\n            cursor = db.query(Constant.TABLE_PARTICIPANT, Constant.PARTICIPANT_COLS, null, null, null,\n                    null, Constant.PARTICIPANT_name + \" ASC\");\n\n            while (cursor.moveToNext()) {\n                participant = new Participant();\n\n                participant.setId(cursor.getInt(0));\n                participant.setName(cursor.getString(1));\n                participant.setPhone(cursor.getString(2));\n                participant.setEmail(cursor.getString(3));\n                participant.setPhoto(cursor.getString(4));\n\n                //identifying who will be the type of group\n                int shirtSize = cursor.getInt(5);\n                participant.setGroup(true);\n                participant.setShirtSize(shirtSize);\n\n                participant.setAttend(cursor.getInt(6) == 1);\n                participant.setNameEvent(cursor.getString(7));\n\n                participant.setBirthDate(cursor.getString(8));\n                participant.setSex(cursor.getInt(9) == 1);\n                participant.setRaffled(cursor.getInt(10) == 1);\n                participant.setCompany(cursor.getString(11));\n                participant.setCode(cursor.getInt(12));\n\n                lParticipant.add(participant);\n            }\n            cursor.close();\n            return lParticipant;\n        } catch (Exception e) {\n            Log.e(Constant.TAG, \"Erro ParticipantDao getAll: \", e);\n        } finally {\n            closeConnection();\n        }\n\n        return null;\n    }\n\n    public boolean updateAsRaffled(Participant participantFortunate) {\n\n        try {\n            openConnection();\n\n            ContentValues contentValues = new ContentValues();\n            contentValues.put(Constant.PARTICIPANT_raffled, 1);\n\n            String args[] = new String[]{String.valueOf(participantFortunate.getId())};\n            return (db.update(Constant.TABLE_PARTICIPANT, contentValues, \"id = ?\", args) != -1);\n\n        } catch (Exception e) {\n            e.getMessage();\n            Log.e(Constant.TAG, \"Erro ParticipantDao updateAsRaffled: \", e);\n            Log.e(Constant.TAG, \"updateAsRaffled: \" + mContext.getString(R.string.app_name));\n        } finally {\n            closeConnection();\n        }\n\n        return false;\n\n    }\n\n    public int getTotalRegistrations(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT, null);\n        mCount.moveToFirst();\n        int totalRegistrations= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRegistrations;\n    }\n\n    public int getTotalAttendance(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1\", null);\n        mCount.moveToFirst();\n        int totalAttendance= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalAttendance;\n    }\n\n    public int getTotalRaffled(){\n        openConnection();\n        Cursor mCount= db.rawQuery(\"select count(*) from \" + Constant.TABLE_PARTICIPANT + \" WHERE attend=1 and raffled=1\", null);\n        mCount.moveToFirst();\n        int totalRaffled= mCount.getInt(0);\n        mCount.close();\n        closeConnection();\n        return totalRaffled;\n    }\n\n    public Resume generateResume() {\n        Resume resume = new Resume();\n        resume.setTotalRegistrations(getTotalRegistrations());\n        resume.setTotalAttendance(getTotalAttendance());\n        resume.setTotalRaffled(getTotalRaffled());\n        return resume;\n    }\n\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnScrollListener.java\npublic abstract class OnScrollListener extends RecyclerView.OnScrollListener {\n\n    private int currentPage = 1;\n    private int totalItemCount;\n    private int visibleItemCount;\n    private int firstVisibleItem;\n\n    private int lastVisibleItem = 0;\n    private boolean checkScroll = true;\n\n    private boolean loading = false;\n    private int currentTotalItems = 0;\n\n    private LinearLayoutManager mLinearLayoutManager;\n    private FloatingActionButton mFloatingActionButton;\n    public OnScrollListener(LinearLayoutManager linearLayoutManager, FloatingActionButton floatingActionButton) {\n        this.mLinearLayoutManager = linearLayoutManager;\n        this.mFloatingActionButton = floatingActionButton;\n    }\n\n    public OnScrollListener(LinearLayoutManager linearLayoutManager) {\n        this.mLinearLayoutManager = linearLayoutManager;\n    }\n\n    @Override\n    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n        super.onScrolled(recyclerView, dx, dy);\n\n        visibleItemCount = recyclerView.getChildCount();\n        totalItemCount = mLinearLayoutManager.getItemCount();\n        firstVisibleItem = mLinearLayoutManager.findFirstVisibleItemPosition();\n\n        if (totalItemCount < currentTotalItems) {\n            this.currentPage = 1;\n            this.currentTotalItems = totalItemCount;\n\n            if (totalItemCount == 0) {\n                this.loading = true;\n            }\n        }\n\n        if (loading && (totalItemCount > currentTotalItems)) {\n            loading = false;\n            currentTotalItems = totalItemCount;\n        }\n\n        if (!loading && (totalItemCount - visibleItemCount)<=(firstVisibleItem + 5)) {\n            onLoadMore(currentPage++);\n            loading = true;\n        }\n\n        if (lastVisibleItem != firstVisibleItem) {\n            if (lastVisibleItem < firstVisibleItem) {\n                if (checkScroll) {\n                    checkScroll = false;\n                    showHideFloatButton(true);\n                    onScroll(recyclerView, dx, dy, true);\n                }\n            } else {\n                if (!checkScroll) {\n                    checkScroll = true;\n                    showHideFloatButton(false);\n                    onScroll(recyclerView, dx, dy, false);\n                }\n            }\n        }\n\n        lastVisibleItem = firstVisibleItem;\n    }\n\n    public void resetEndlessRecyclerView(){\n        this.currentTotalItems = 0;\n        this.loading = false;\n    }\n\n    public abstract void onScroll(RecyclerView recyclerView, int dx, int dy, boolean onScroll);\n    public abstract void onLoadMore(int currentPage);\n\n    //Hide or show the FloatingActionButton based on the list scroll\n    private void showHideFloatButton(boolean status) {\n        if (status) {\n            mFloatingActionButton.setAlpha(1f);\n            mFloatingActionButton.setTranslationY(0f);\n            mFloatingActionButton.animate().alpha(0f)\n                    .translationY(mFloatingActionButton.getHeight())\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.GONE);\n                        }\n                    }).start();\n        } else {\n            mFloatingActionButton.setVisibility(View.VISIBLE);\n            mFloatingActionButton.setAlpha(0f);\n            mFloatingActionButton.setTranslationY(mFloatingActionButton.getHeight());\n            mFloatingActionButton.animate()\n                    .alpha(1f)\n                    .translationY(0f)\n                    .setDuration(175L)\n                    .setListener(new AnimatorListenerAdapter() {\n                        @Override\n                        public void onAnimationEnd(Animator animation) {\n                            mFloatingActionButton.setVisibility(FrameLayout.VISIBLE);\n                        }\n                    })\n                    .start();\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/interfaces/OnItemClickListener.java\npublic interface OnItemClickListener {\n    void onItemClick(View v, int position);\n}\napp/src/main/java/br/com/javace/javou/model/participant/Participant.java\npublic class Participant implements Parcelable {\n\n    private int id;\n    private int code;\n    private boolean sex;\n    private String name;\n    private String phone;\n    private String email;\n    private String photo;\n    private int shirtSize;\n    private boolean group;\n    private boolean attend;\n    private String company;\n    private String nameEvent;\n    private String birthDate;\n    private boolean raffled;\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(this.getId());\n        dest.writeInt(this.getCode());\n        dest.writeByte(isSex() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getName());\n        dest.writeString(this.getPhone());\n        dest.writeString(this.getEmail());\n        dest.writeString(this.getPhoto());\n        dest.writeInt(this.getShirtSize());\n        dest.writeByte(isGroup() ? (byte) 1 : (byte) 0);\n        dest.writeByte(isAttend() ? (byte) 1 : (byte) 0);\n        dest.writeString(this.getCompany());\n        dest.writeString(this.getNameEvent());\n        dest.writeString(this.getBirthDate());\n        dest.writeByte(isRaffled() ? (byte) 1 : (byte) 0);\n    }\n\n    public Participant() {\n    }\n\n    protected Participant(Parcel in) {\n        this.setId(in.readInt());\n        this.setCode(in.readInt());\n        this.setSex(in.readByte() != 0);\n        this.setName(in.readString());\n        this.setPhone(in.readString());\n        this.setEmail(in.readString());\n        this.setPhoto(in.readString());\n        this.setShirtSize(in.readInt());\n        this.setGroup(in.readByte() != 0);\n        this.setAttend(in.readByte() != 0);\n        this.setCompany(in.readString());\n        this.setNameEvent(in.readString());\n        this.setBirthDate(in.readString());\n        this.setRaffled(in.readByte() != 0);\n    }\n\n    public static final Parcelable.Creator<Participant> CREATOR = new Parcelable.Creator<Participant>() {\n        public Participant createFromParcel(Parcel source) {\n            return new Participant(source);\n        }\n\n        public Participant[] newArray(int size) {\n            return new Participant[size];\n        }\n    };\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public boolean isSex() {\n        return sex;\n    }\n\n    public void setSex(boolean sex) {\n        this.sex = sex;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public String getPhoto() {\n        return photo;\n    }\n\n    public void setPhoto(String photo) {\n        this.photo = photo;\n    }\n\n    public int getShirtSize() {\n        return shirtSize;\n    }\n\n    public void setShirtSize(int shirtSize) {\n        this.shirtSize = shirtSize;\n    }\n\n    public boolean isGroup() {\n        return group;\n    }\n\n    public void setGroup(boolean group) {\n        this.group = group;\n    }\n\n    public boolean isAttend() {\n        return attend;\n    }\n\n    public void setAttend(boolean attend) {\n        this.attend = attend;\n    }\n\n    public String getCompany() {\n        return company;\n    }\n\n    public void setCompany(String company) {\n        this.company = company;\n    }\n\n    public String getNameEvent() {\n        return nameEvent;\n    }\n\n    public void setNameEvent(String nameEvent) {\n        this.nameEvent = nameEvent;\n    }\n\n    public String getBirthDate() {\n        return birthDate;\n    }\n\n    public void setBirthDate(String birthDate) {\n        this.birthDate = birthDate;\n    }\n\n    public boolean isRaffled() {\n        return raffled;\n    }\n\n    public void setRaffled(boolean raffled) {\n        this.raffled = raffled;\n    }\n\n    public boolean getSex() {\n        return sex;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantSendTask.java\npublic class ParticipantSendTask extends AsyncTask<Void, Void, Boolean> {\n\n    private ArrayList<Participant> mParticipant;\n\n    protected ParticipantSendTask(ArrayList<Participant> participant){\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n\n        CSVWriter writer;\n        boolean isAttend = false;\n\n        try {\n            writer = new CSVWriter(new FileWriter(Constant.PATH_FILE_JAVOU));\n            List<String[]> data = new ArrayList<>();\n\n            data.add(Constant.FILE_COLS);\n\n            for (Participant participant : mParticipant) {\n                if (participant.isAttend()) {\n                    isAttend = true;\n                    String sex = (participant.isSex() ? \"F\" : \"M\");\n                    data.add(new String[]{String.valueOf(participant.getCode()), participant.getName(), participant.getEmail(), participant.getPhone(), sex, participant.getCompany()});\n                }\n            }\n\n            writer.writeAll(data);\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return isAttend;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantDeleteTask.java\npublic class ParticipantDeleteTask extends AsyncTask<Void, Void, Boolean> {\n\n    private int mId;\n    private Context mContext;\n    public ParticipantDeleteTask(Context context, int id){\n        this.mId = id;\n        this.mContext = context;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.delete(mId);\n    }\n}\napp/src/main/java/br/com/javace/javou/util/Constant.java\npublic class Constant {\n    public static String TAG = \"Javou\";\n    public static final String NAME_EVENT = \"Setic - AppJavou\";\n\n    public static final int DATABASE_VERSION = 1;\n    public static final String DATABASE = \"javou.db\";\n    private static final String NAME_FILE = \"/javou.csv\";\n\n    public static String POSITION = \"POSITION\";\n    public static String FIRST_RUN = \"FIRST_RUN\";\n    static String PREFERENCES_APP = \"JAVOU\";\n    public static String ACTION_MODE = \"ACTION_MODE\";\n    public static String PARTICIPANT = \"Participant\";\n\n    public static String INSERT = \"INSERT\";\n\n    //Tablet participant\n    public static final String TABLE_PARTICIPANT = \"participant\";\n    private static final String PARTICIPANT_id = \"id\";\n    public static final String PARTICIPANT_name = \"name\";\n    public static final String PARTICIPANT_phone = \"phone\";\n    public static final String PARTICIPANT_email = \"email\";\n    public static final String PARTICIPANT_photo = \"photo\";\n    public static final String PARTICIPANT_shirtSize = \"shirtSize\";\n    public static final String PARTICIPANT_attend = \"attend\";\n    public static final String PARTICIPANT_nameEvent = \"nameEvent\";\n    public static final String PARTICIPANT_birthDate = \"birthDate\";\n    public static final String PARTICIPANT_sex = \"sex\";\n    public static final String PARTICIPANT_raffled = \"raffled\";\n    public static final String PARTICIPANT_company = \"company\";\n    public static final String PARTICIPANT_code = \"code\";\n\n    public static String[] CREATE_TABLE() {\n        String CREATE_PARTICIPANT = \" CREATE TABLE participant ( \"\n                + \" id INTEGER CONSTRAINT 'PK_PARTICIPANT' PRIMARY KEY AUTOINCREMENT, \"\n                + \" code INT NULL DEFAULT 0, \"\n                + \" name VARCHAR(100) NOT NULL, \"\n                + \" phone VARCHAR(100) NOT NULL, \"\n                + \" email VARCHAR(250) NULL, \"\n                + \" photo TEXT NULL, \"\n                + \" shirtSize INT NULL DEFAULT 0, \"\n                + \" attend INT NULL DEFAULT 0, \"\n                + \" nameEvent VARCHAR(100) NULL, \"\n                + \" birthDate VARCHAR(10) NULL, \"\n                + \" sex CHAR(1) NULL, \"\n                + \" raffled INT NULL DEFAULT 0, \"\n                + \" company VARCHAR(250) NULL ); \";\n        return new String[] {CREATE_PARTICIPANT};\n    }\n\n    public static final String PATH_FILE_JAVOU = android.os.Environment.getExternalStorageDirectory().getAbsolutePath() + NAME_FILE;\n\n    public static final String PARTICIPANT_COLS[] = {\n            PARTICIPANT_id,\n            PARTICIPANT_name,\n            PARTICIPANT_phone,\n            PARTICIPANT_email,\n            PARTICIPANT_photo,\n            PARTICIPANT_shirtSize,\n            PARTICIPANT_attend,\n            PARTICIPANT_nameEvent,\n            PARTICIPANT_birthDate,\n            PARTICIPANT_sex,\n            PARTICIPANT_raffled,\n            PARTICIPANT_company,\n            PARTICIPANT_code\n    };\n\n    public static final String FILE_COLS[] = {\n            \"CODIGO\", \"NOME\", \"EMAIL\", \"CELULAR\", \"SEXO\", \"EMPRESA\"\n    };\n\n}\napp/src/main/java/br/com/javace/javou/ui/base/BaseActivity.java\npublic class BaseActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n    }\n\n    public enum ActivityAnimation {\n        SLIDE_LEFT, SLIDE_RIGHT\n    }\n\n    public void startActivity(Intent intent, final ActivityAnimation animation) {\n        startActivity(intent);\n        putAnimation(this, animation);\n    }\n\n    public void startActivityForResult(Intent intent, int requestCode, final ActivityAnimation animation) {\n        startActivityForResult(intent, requestCode);\n        putAnimation(this, animation);\n    }\n\n    public void finish(final ActivityAnimation animation) {\n        finish();\n        putAnimation(this, animation);\n    }\n\n    private static void putAnimation(final Activity source,\n                                     final ActivityAnimation animation) {\n        try {\n            Method method = Activity.class.getMethod(\"overridePendingTransition\", int.class, int.class);\n\n            int[] animations = getAnimation(animation);\n            method.invoke(source, animations[0], animations[1]);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    private static int[] getAnimation(final ActivityAnimation animation) {\n        int exitAnim;\n        int enterAnim;\n\n        switch (animation) {\n            case SLIDE_RIGHT:\n                enterAnim = R.anim.slide_right_enter;\n                exitAnim = R.anim.slide_right_exit;\n                break;\n\n            case SLIDE_LEFT:\n            default:\n                enterAnim = R.anim.slide_left_enter;\n                exitAnim = R.anim.slide_left_exit;\n                break;\n        }\n\n        return new int[]{enterAnim, exitAnim};\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/interfaces/OnSearchListener.java\npublic interface OnSearchListener {\n    void changedSearch(CharSequence text);\n}\napp/src/main/java/br/com/javace/javou/ui/activity/ParticipantDetailActivity.java\npublic class ParticipantDetailActivity extends BaseActivity {\n\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.txt_email) TextView mTxtEmail;\n    @BindView(R.id.txt_phone) TextView mTxtPhone;\n    @BindView(R.id.txt_attend) TextView mTxtAttend;\n    @BindView(R.id.img_photo) ImageView mImgPhoto;\n    @BindView(R.id.txt_shirt_size) TextView mTxtShirtSize;\n    @BindView(R.id.float_edit) FloatingActionButton mFloatEdit;\n    @BindView(R.id.collapsing_toolbar) CollapsingToolbarLayout mCollapsingToolbar;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_participant_detail);\n\n        ButterKnife.bind(this);\n        this.setSupportActionBar(mToolbar);\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            getSupportActionBar().setDisplayHomeAsUpEnabled(true);\n        }\n\n        mFloatEdit.setOnClickListener(onClickEdit);\n        mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mCollapsingToolbar.setTitle(mParticipant != null ? mParticipant.getName() : getString(R.string.app_name));\n\n        if (mParticipant != null){\n            mTxtEmail.setText(mParticipant.getEmail());\n            mTxtPhone.setText(mParticipant.getPhone());\n\n            GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(this, Util.shirtSizeColor[mParticipant.getShirtSize()]));\n            mTxtShirtSize.setText(getString(Util.shirtSize[mParticipant.getShirtSize()]));\n\n            if (mParticipant.isAttend()) {\n                mTxtAttend.setText(getString(R.string.attended_event));\n                mTxtAttend.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_check_green_18dp, 0, 0, 0);\n            }\n\n            if (mParticipant.getPhoto() != null && !mParticipant.getPhoto().equals(\"\")) {\n                Glide.with(this).load(mParticipant.getPhoto()).centerCrop().into(mImgPhoto);\n            }else{\n                Glide.with(this).load(R.drawable.ic_suricate).centerCrop().into(mImgPhoto);\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_discart).setVisible(false);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n\n            case R.id.menu_delete:\n                confirmDelete();\n                break;\n        }\n        return true;\n    }\n\n    private View.OnClickListener onClickEdit  = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            Intent intent = new Intent(getApplicationContext(), NewParticipantActivity.class);\n            intent.putExtra(Constant.PARTICIPANT, mParticipant);\n            startActivityForResult(intent, 1, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n        }\n    };\n\n\n//    private void deleteParticipant(){\n//        showDialog();\n//        ParseObject gameScore = new ParseObject(Constant.PARTICIPANT);\n//        gameScore.setObjectId(mParticipant.getObjectId());\n//        gameScore.deleteInBackground(new DeleteCallback() {\n//            @Override\n//            public void done(ParseException error) {\n//                if (error == null) {\n//                    Intent intent = new Intent();\n//                    intent.putExtra(Constant.PARTICIPANT, true);\n//                    setResult(0, intent);\n//                    finish();\n//                    Toast.makeText(getApplicationContext(), R.string.warning_delete_participante, Toast.LENGTH_SHORT).show();\n//                } else {\n//                    Toast.makeText(getApplicationContext(), R.string.error_delete_participante, Toast.LENGTH_SHORT).show();\n//                }\n//\n//                hideDialog();\n//            }\n//        });\n//    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_delete_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    private void confirmDelete(){\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(getString(R.string.warning_participant_excluded));\n        builder.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                //deleteParticipant();\n                dialog.dismiss();\n            }\n        });\n        builder.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                //TODO\n                dialog.dismiss();\n            }\n        });\n        AlertDialog dialog = builder.create();\n        dialog.show();\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/model/raffle/Raffle.java\npublic class Raffle{\n\n    private Random randomGenerator;\n    private ArrayList<Participant> participants;\n\n    public Raffle(ArrayList<Participant> participants) {\n        this.randomGenerator = new Random();\n        this.participants = participants;\n    }\n\n    private List<Participant> getParticipantsAttend(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    private List<Participant> getParticipantsAttendSex(){\n        List<Participant> attendees = new ArrayList<>();\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex()) //It can be drawn\n                attendees.add(participant);\n        }\n        return attendees;\n    }\n\n    public boolean isValid(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled())\n                return true;\n        }\n        return false;\n    }\n\n    public boolean isValidSex(){\n        for (Participant participant : participants) {\n            if(participant.isAttend() && !participant.isRaffled() && participant.getSex())\n                return true;\n        }\n        return false;\n    }\n\n    public Participant getFortunate() {\n        List<Participant> participantsAttend = getParticipantsAttend();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n\n    public Participant getFortunateSex() {\n        List<Participant> participantsAttend = getParticipantsAttendSex();\n\n        if(participantsAttend.isEmpty()) {\n            return null;\n        }\n\n        int index = randomGenerator.nextInt(participantsAttend.size());\n        Participant participantFortunate = participantsAttend.get(index);\n        participantFortunate.setRaffled(true);\n        return participantFortunate;\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantPresenceTask.java\npublic class ParticipantPresenceTask extends AsyncTask<Void, Void, Boolean> {\n\n    private Context mContext;\n    private Participant mParticipant;\n\n    public ParticipantPresenceTask(Context context, Participant participant){\n        this.mContext = context;\n        this.mParticipant = participant;\n    }\n\n    @Override\n    protected Boolean doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.updatePresence(mParticipant);\n    }\n}\nsearchliveo/src/main/java/br/liveo/searchliveo/SearchLiveo.java\npublic class SearchLiveo extends FrameLayout {\n\n    private Activity mContext;\n\n    private EditText mEdtSearch;\n\n    private ImageView mImgArrowSearch;\n    private ImageView mImgVoiceSearch;\n    private ImageView mImgCloseSearch;\n\n    private RecyclerView mRecyclerView;\n    private RelativeLayout mViewSearch;\n\n    private int mColorPrimaryDark;\n\n    private boolean active = false;\n    private boolean isVoice = true;\n\n    private int mColorIcon = -1;\n    private int mColorIconArrow = -1;\n    private int mColorIconVoice = -1;\n    private int mColorIconClose = -1;\n\n    private int mStatusBarHideColor = -1;\n    private int mStatusBarShowColor = -1;\n    private OnSearchListener mSearchListener;\n\n    private static String SEARCH_TEXT = \"SEARCH_TEXT\";\n    public static int REQUEST_CODE_SPEECH_INPUT = 7777;\n    private static String STATE_TO_SAVE = \"STATE_TO_SAVE\";\n    private static String INSTANCE_STATE = \"INSTANCE_STATE\";\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Activity\n     *\n     * @param context - Context Activity\n     */\n    public SearchLiveo with(Context context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = (Activity) context;\n                this.mSearchListener = (OnSearchListener) context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    /**\n     * Start context and the listener Search Live library.\n     * Use this method when you are using an Fragment\n     *\n     * @param getActivity - Context Fragment\n     * @param context - Listener\n     */\n    public SearchLiveo with(Activity getActivity, OnSearchListener context) {\n\n        if (this.mContext == null) {\n            try {\n                this.mContext = getActivity;\n                this.mSearchListener = context;\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_fragment_listener));\n            }\n        }else{\n            build();\n        }\n\n        return this;\n    }\n\n    public void build(){\n\n        if (this.mSearchListener == null){\n            throw new ClassCastException(mContext.getString(R.string.warning_listener));\n        }\n\n        try {\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                Resources.Theme theme = this.mContext.getTheme();\n                TypedArray typedArray = theme.obtainStyledAttributes(new int[]{android.R.attr.colorPrimaryDark});\n                setColorPrimaryDark(typedArray.getResourceId(0, 0));\n            }\n        }catch (Exception e){\n            e.getStackTrace();\n        }\n    }\n\n    public SearchLiveo(Context context) {\n        this(context, null);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public SearchLiveo(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        if(!isInEditMode()) {\n            init(context);\n            initAttribute(context, attrs, defStyleAttr);\n        }\n    }\n\n    private void init(Context context){\n        View view = LayoutInflater.from(context).inflate(R.layout.search_liveo, this, true);\n\n        mEdtSearch = (EditText) view.findViewById(R.id.edt_search);\n\n        mImgArrowSearch = (ImageView) view.findViewById(R.id.img_arrow_search);\n        mImgVoiceSearch = (ImageView) view.findViewById(R.id.img_voice_search);\n\n        mImgCloseSearch = (ImageView) view.findViewById(R.id.img_close_search);\n        mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n\n        mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_search_view);\n\n        View toolbarShadow = view.findViewById(R.id.toolbar_shadow);\n        toolbarShadow.setVisibility(GONE);\n\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\n            toolbarShadow.setVisibility(View.VISIBLE);\n        }\n\n        mViewSearch = (RelativeLayout) view.findViewById(R.id.view_search);\n        mViewSearch.setVisibility(View.INVISIBLE);\n\n        mEdtSearch.setOnKeyListener(onKeyListener);\n\n        mImgArrowSearch.setOnClickListener(onClickSearchArrow);\n        mRecyclerView.setOnClickListener(onClickRecyclerView);\n        mImgVoiceSearch.setOnClickListener(onClickVoiceSearch);\n        mImgCloseSearch.setOnClickListener(onClickCloseSearch);\n\n        mEdtSearch.setOnEditorActionListener(onEditorActionListener);\n        mEdtSearch.addTextChangedListener(new OnTextWatcherEdtSearch());\n    }\n\n    private void initAttribute(Context context, AttributeSet attributeSet, int defStyleAttr) {\n        TypedArray attr = context.obtainStyledAttributes(attributeSet, R.styleable.search_liveo, defStyleAttr, 0);\n        if (attr != null) {\n            try {\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint)) {\n                    hint(attr.getString(R.styleable.search_liveo_search_liveo_hint));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_text_color)) {\n                    mEdtSearch.setTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_text_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_hint_color)) {\n                    mEdtSearch.setHintTextColor(attr.getColor(R.styleable.search_liveo_search_liveo_hint_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_icon)) {\n                    setColorIcon(attr.getColor(R.styleable.search_liveo_search_liveo_color_icon, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_arrow)) {\n                    setColorIconArrow(attr.getColor(R.styleable.search_liveo_search_liveo_color_arrow, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_voice)) {\n                    setColorIconVoice(attr.getColor(R.styleable.search_liveo_search_liveo_color_voice, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_color_close)) {\n                    setColorIconClose(attr.getColor(R.styleable.search_liveo_search_liveo_color_close, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_background)) {\n                    mViewSearch.setBackgroundColor(attr.getColor(R.styleable.search_liveo_search_liveo_background, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_show_color)) {\n                    setStatusBarShowColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_show_color, -1));\n                }\n\n                if (attr.hasValue(R.styleable.search_liveo_search_liveo_status_bar_hide_color)) {\n                    setStatusBarHideColor(attr.getColor(R.styleable.search_liveo_search_liveo_status_bar_hide_color, -1));\n                }\n            } finally {\n                attr.recycle();\n            }\n        }\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     *\n     * @param resId color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundResource(int resId){\n        mViewSearch.setBackgroundResource(resId);\n        return this;\n    }\n\n    /**\n     * Set a new background color. If you do not use this method and standard color is white SearchLiveo.\n     * In his layout.xml you can use the \"app:searchLiveoBackground=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo backgroundColor(int color){\n        mViewSearch.setBackgroundColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new text color.\n     * In his layout.xml you can use the \"app:searchLiveoTextColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo textColor(int color){\n        mEdtSearch.setTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new hint color.\n     * In his layout.xml you can use the \"app:searchLiveoHintColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo hintColor(int color){\n        mEdtSearch.setHintTextColor(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text \"valeu\"\n     */\n    public SearchLiveo text(String text){\n        mEdtSearch.setText(text);\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"value\"\" attribute\n     * @param text \"valeu\"\n     */\n    public SearchLiveo hint(String text){\n        mEdtSearch.setHint(text);\n        return this;\n    };\n\n    /**\n     * Set a new text.\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo text(int text){\n        mEdtSearch.setText(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new hint.\n     * In his layout.xml you can use the \"app:searchLiveoHint=\"@string/...\"\" attribute\n     * @param text string attribute - string.xml file\n     */\n    public SearchLiveo hint(int text){\n        mEdtSearch.setHint(mContext.getString(text));\n        return this;\n    };\n\n    /**\n     * Set a new color for all icons (arrow, voice and close).\n     * In his layout.xml you can use the \"app:searchLiveoColorIcon=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIcon(int color){\n        this.setColorIcon(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for back arrow\n     * In his layout.xml you can use the \"app:searchLiveoColorArrow=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconArrow(int color){\n        this.setColorIconArrow(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for voice\n     * In his layout.xml you can use the \"app:searchLiveoColorVoice=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconVoice(int color){\n        this.setColorIconVoice(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for close\n     * In his layout.xml you can use the \"app:searchLiveoColorClose=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo colorIconClose(int color){\n        this.setColorIconClose(ContextCompat.getColor(mContext, color));\n        return this;\n    };\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo is closed\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarHideColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarHideColor(int color){\n        setStatusBarHideColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Set a new color for statusBar when the SearchLiveo for visible\n     * In his layout.xml you can use the \"app:searchLiveoStatusBarShowColor=\"@color/...\"\" attribute\n     * @param color color attribute - colors.xml file\n     */\n    public SearchLiveo statusBarShowColor(int color){\n        setStatusBarShowColor(ContextCompat.getColor(mContext, color));\n        return this;\n    }\n\n    /**\n     * Hide voice icon\n     */\n    public SearchLiveo hideVoice(){\n        setIsVoice(false);\n        mImgVoiceSearch.setVisibility(View.GONE);\n        return this;\n    }\n\n    /**\n     * Show voice icon\n     */\n    public SearchLiveo showVoice(){\n        setIsVoice(true);\n        mImgVoiceSearch.setVisibility(View.VISIBLE);\n        return this;\n    }\n\n    private void colorIcon(){\n        if (getColorIcon() != -1 && getColorIconArrow() == -1)  {\n            mImgArrowSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconVoice() == -1)  {\n            mImgVoiceSearch.setColorFilter(this.getColorIcon());\n        }\n\n        if (getColorIcon() != -1 && getColorIconClose() == -1)  {\n            mImgCloseSearch.setColorFilter(this.getColorIcon());\n        }\n    };\n\n    private void colorIconArrow(){\n        if (getColorIconArrow() != -1) {\n            mImgArrowSearch.setColorFilter(this.getColorIconArrow());\n        }\n    };\n\n    private void colorIconVoice(){\n        if (this.getColorIconVoice() != -1) {\n            mImgVoiceSearch.setColorFilter(this.getColorIconVoice());\n        }else{\n            mImgVoiceSearch.clearColorFilter();\n        }\n    };\n\n    private void colorIconClose(){\n        if (this.getColorIconClose() != -1) {\n            mImgCloseSearch.setColorFilter(this.getColorIconClose());\n        }else{\n            mImgCloseSearch.clearColorFilter();\n        }\n    };\n\n    private OnKeyListener onKeyListener = new OnKeyListener() {\n        @Override\n        public boolean onKey(View v, int keyCode, KeyEvent event) {\n            if (event.getAction() == KeyEvent.ACTION_DOWN) {\n                if (keyCode == KeyEvent.KEYCODE_BACK) {\n                    hide();\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    private TextView.OnEditorActionListener onEditorActionListener = new TextView.OnEditorActionListener() {\n        @Override\n        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n            if (actionId == EditorInfo.IME_ACTION_SEARCH) {\n                hide();\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                    }\n                });\n                return true;\n            }\n            return false;\n        }\n    };\n\n    private OnClickListener onClickVoiceSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            startVoice(mEdtSearch);\n        }\n    };\n\n    private OnClickListener onClickCloseSearch = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (mEdtSearch.getText().toString().length() != 0) {\n                mEdtSearch.setText(\"\");\n                mContext.runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                    }\n                });\n            }\n        }\n    };\n\n    private OnClickListener onClickSearchArrow = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    private OnClickListener onClickRecyclerView = new OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            hide();\n        }\n    };\n\n    /**\n     * If SearchView is active(show), this method returns the value true\n     */\n    public boolean isActive() {\n        return active;\n    }\n\n    private void setActive(boolean active) {\n        this.active = active;\n    }\n\n    public boolean isVoice() {\n        return isVoice;\n    }\n\n    public void setIsVoice(boolean isVoice) {\n        this.isVoice = isVoice;\n    }\n\n    public int getStatusBarHideColor() {\n        return mStatusBarHideColor;\n    }\n\n    public void setStatusBarHideColor(int mStatusBarHideColor) {\n        this.mStatusBarHideColor = mStatusBarHideColor;\n    }\n\n    public int getStatusBarShowColor() {\n        return mStatusBarShowColor;\n    }\n\n    public void setStatusBarShowColor(int mStatusBarShowColor) {\n        this.mStatusBarShowColor = mStatusBarShowColor;\n    }\n\n    private int getColorIcon() {\n        return mColorIcon;\n    }\n\n    private void setColorIcon(int colorIcon) {\n        this.mColorIcon = colorIcon;\n        this.colorIcon();\n    }\n\n    public int getColorIconArrow() {\n        return mColorIconArrow;\n    }\n\n    public void setColorIconArrow(int color) {\n        this.mColorIconArrow = color;\n        this.colorIconArrow();\n    }\n\n    public int getColorIconVoice() {\n        return mColorIconVoice;\n    }\n\n    public void setColorIconVoice(int color) {\n        this.mColorIconVoice = color;\n        this.colorIconVoice();\n    }\n\n    public int getColorIconClose() {\n        return mColorIconClose;\n    }\n\n    public void setColorIconClose(int color) {\n        this.mColorIconClose = color;\n        this.colorIconClose();\n    }\n\n    private class OnTextWatcherEdtSearch implements TextWatcher {\n\n        @Override\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n        }\n\n        @Override\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\n            try {\n                if (mEdtSearch.getText().toString().length() == 0) {\n                    mImgCloseSearch.setVisibility(isVoice() ? View.GONE : View.VISIBLE);\n                    mImgVoiceSearch.setVisibility(isVoice() ? View.VISIBLE : View.GONE);\n                    mImgVoiceSearch.setImageResource(R.drawable.ic_keyboard_voice_color_24dp);\n                    colorIconVoice();\n                } else {\n                    mImgVoiceSearch.setVisibility(View.GONE);\n                    mImgCloseSearch.setVisibility(View.VISIBLE);\n                    mImgCloseSearch.setImageResource(R.drawable.ic_close_color_24dp);\n                    colorIconClose();\n                }\n\n                colorIcon();\n                colorIconArrow();\n                mSearchListener.changedSearch(mEdtSearch.getText().toString());\n            } catch (Exception e) {\n                e.getStackTrace();\n            }\n        }\n\n        @Override\n        public void afterTextChanged(Editable s) {\n\n        }\n    }\n\n    /**\n     * Hide SearchLiveo\n     */\n    public void hide() {\n        try {\n            hideAnimation();\n            setActive(false);\n        } catch (Exception e) {\n            e.getStackTrace();\n        }\n    }\n\n    /**\n     * Show SearchLiveo\n     */\n    public SearchLiveo show() {\n        setActive(true);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            try {\n                showAnimation();\n            } catch (ClassCastException e) {\n                throw new ClassCastException(mContext.getString(R.string.warning_with));\n            }\n\n        } else {\n\n            Animation mFadeIn = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_in);\n            mViewSearch.setEnabled(true);\n            mViewSearch.setVisibility(View.VISIBLE);\n            mViewSearch.setAnimation(mFadeIn);\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mEdtSearch.requestFocus();\n        return this;\n    }\n\n    @TargetApi(Build.VERSION_CODES.LOLLIPOP)\n    private void showAnimation(){\n        try {\n\n            if (getStatusBarShowColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarShowColor());\n            }else {\n                mContext.getWindow().setStatusBarColor(ContextCompat.getColor(mContext, R.color.search_liveo_primary_dark));\n            }\n\n            final Animator animator = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, this.mContext),\n                    (int) dpToPixel(23, this.mContext), 0,\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()));\n            animator.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n\n            animator.setDuration(300);\n            animator.start();\n        }catch (Exception e){\n            e.getStackTrace();\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY);\n                }\n            });\n        }\n\n        mViewSearch.setVisibility(View.VISIBLE);\n    }\n\n    private SearchLiveo hideAnimation() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n\n            if (getStatusBarHideColor() != -1) {\n                mContext.getWindow().setStatusBarColor(getStatusBarHideColor());\n            } else {\n                mContext.getWindow().setStatusBarColor(getColorPrimaryDark());\n            }\n\n            final Animator animatorHide = ViewAnimationUtils.createCircularReveal(mViewSearch,\n                    mViewSearch.getWidth() - (int) dpToPixel(24, mContext),\n                    (int) dpToPixel(23, mContext),\n                    (float) Math.hypot(mViewSearch.getWidth(), mViewSearch.getHeight()), 0);\n            animatorHide.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n\n                    mContext.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                                    hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                        }\n                    });\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    mViewSearch.setVisibility(View.GONE);\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n            animatorHide.setDuration(200);\n            animatorHide.start();\n\n        } else {\n\n            mContext.runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                            hideSoftInputFromWindow(mRecyclerView.getWindowToken(), 0);\n                }\n            });\n\n            Animation mFadeOut = AnimationUtils.loadAnimation(mContext.getApplicationContext(), android.R.anim.fade_out);\n            mViewSearch.setAnimation(mFadeOut);\n            mViewSearch.setVisibility(View.INVISIBLE);\n        }\n\n        mEdtSearch.setText(\"\");\n        mViewSearch.setEnabled(false);\n        return this;\n    }\n\n    private int getColorPrimaryDark() {\n        return mColorPrimaryDark;\n    }\n\n    private void setColorPrimaryDark(int mColorPrimaryDark) {\n        this.mColorPrimaryDark = ContextCompat.getColor(mContext, mColorPrimaryDark);\n    }\n\n    private float dpToPixel(float dp, Context context) {\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        return dp * (metrics.densityDpi / 160f);\n    }\n\n    @Override\n    public Parcelable onSaveInstanceState() {\n        Bundle bundle = new Bundle();\n        bundle.putParcelable(INSTANCE_STATE, super.onSaveInstanceState());\n        bundle.putBoolean(STATE_TO_SAVE, this.isActive());\n\n        if (!mEdtSearch.getText().toString().trim().equals(\"\")){\n            bundle.putString(SEARCH_TEXT, mEdtSearch.getText().toString());\n        }\n\n        return bundle;\n    }\n\n    @Override\n    public void onRestoreInstanceState(Parcelable state) {\n\n        if (state instanceof Bundle) {\n            Bundle bundle = (Bundle) state;\n            this.setActive(bundle.getBoolean(STATE_TO_SAVE));\n\n            String text = bundle.getString(SEARCH_TEXT, \"\");\n            if (!text.trim().equals(\"\")){\n                mEdtSearch.setText(text);\n            }\n\n            if (this.isActive()){\n                show();\n            }\n\n            state = bundle.getParcelable(INSTANCE_STATE);\n        }\n\n        super.onRestoreInstanceState(state);\n    }\n\n    private void startVoice(EditText editText) {\n        ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).\n                hideSoftInputFromWindow(editText.getWindowToken(), 0);\n\n        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);\n        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault());\n        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, mContext.getString(R.string.searchview_voice));\n        try {\n            mContext.startActivityForResult(intent, REQUEST_CODE_SPEECH_INPUT);\n        } catch (ActivityNotFoundException a) {\n            Toast.makeText(mContext.getApplicationContext(), R.string.not_supported, Toast.LENGTH_SHORT).show();\n        }\n    }\n\n    public void resultVoice(int requestCode, int resultCode, Intent data){\n        if (requestCode == SearchLiveo.REQUEST_CODE_SPEECH_INPUT) {\n            if (resultCode == Activity.RESULT_OK && null != data) {\n                ArrayList<String> result = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);\n                mEdtSearch.setText(result.get(0));\n            }\n        }\n    }\n}\napp/src/main/java/br/com/javace/javou/adapter/ParticipantAdapter.java\npublic class ParticipantAdapter extends RecyclerView.Adapter<ParticipantAdapter.ViewHolder> {\n\n    private int mBackground;\n    private Context mContext;\n    private HashSet<Integer> checkedItems;\n    private ArrayList<Participant> mParticipants;\n    private ArrayList<Participant> mSearchParticipants;\n\n    private static final int ITEM_VIEW_TYPE_ITEM = 1;\n    private static final int ITEM_VIEW_TYPE_HEADER = 0;\n\n    private static OnItemClickListener mOnClickListener;\n    private static OnItemClickListener mOnItemClickListener;\n    private static OnItemLongClickListener mOnItemLongClickListener;\n\n    public ParticipantAdapter(Context context, ArrayList<Participant> participants) {\n        this.mContext = context;\n        this.mParticipants = participants;\n        this.checkedItems = new HashSet<>();\n        this.mSearchParticipants = new ArrayList<>();\n        this.mSearchParticipants.addAll(this.mParticipants);\n\n        if (context != null) {\n            TypedValue mTypedValue = new TypedValue();\n            context.getTheme().resolveAttribute(android.R.attr.selectableItemBackground, mTypedValue, true);\n            this.mBackground = mTypedValue.resourceId;\n        }\n    }\n\n    class ViewHolder extends RecyclerView.ViewHolder {\n        View mContainer;\n\n        TextView mTitle;\n        TextView mName;\n        TextView mEmail;\n        TextView mShirtSize;\n\n        ViewHolder(View view) {\n            super(view);\n\n            mContainer = view;\n\n            mTitle = (TextView) view.findViewById(R.id.txt_title);\n            mName = (TextView) view.findViewById(R.id.txt_name);\n            mEmail = (TextView) view.findViewById(R.id.txt_email);\n            mShirtSize = (TextView) view.findViewById(R.id.txt_shirt_size);\n\n            if (mShirtSize != null) {\n                mShirtSize.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        // -1 Refers to the header\n                        int position = getAdapterPosition() - 1;\n                        if (mOnClickListener != null && position >= 0) {\n                            mOnClickListener.onItemClick(v, position);\n                        }\n                    }\n                });\n            }\n\n            mContainer.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    // -1 Refers to the header\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemClickListener != null && position >= 0) {\n                        mOnItemClickListener.onItemClick(v, position);\n                    }\n                }\n            });\n\n            mContainer.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int position = getAdapterPosition() - 1;\n                    if (mOnItemLongClickListener != null && position >= 0) {\n                        mOnItemLongClickListener.onItemLongClick(v, position);\n                    }\n                    return true;\n                }\n            });\n        }\n    }\n\n    @Override\n    public ParticipantAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view;\n\n        if (viewType == ITEM_VIEW_TYPE_HEADER) {\n            view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_header, parent, false);\n            return new ViewHolder(view);\n        }\n\n        view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fragment_participant_item, parent, false);\n        view.setBackgroundResource(this.mBackground);\n        return new ViewHolder(view);\n    }\n\n    private boolean isHeader(int position) {\n        return position == 0;\n    }\n\n    @Override\n    public int getItemViewType(int position) {\n        return isHeader(position) ? ITEM_VIEW_TYPE_HEADER : ITEM_VIEW_TYPE_ITEM;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder holder, int position) {\n\n        if (mParticipants == null || mParticipants.size() == 0){\n            return;\n        }\n\n        if (isHeader(position)) {\n            holder.mTitle.setText(mParticipants.get(position).getNameEvent());\n            return;\n        }\n\n        // -1 Refers to the header\n        Participant participant = mParticipants.get(position - 1);\n\n        holder.mName.setText(participant.getName());\n        holder.mName.setCompoundDrawablesWithIntrinsicBounds(participant.isAttend() ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n\n        holder.mEmail.setText(participant.getEmail());\n\n        if (participant.isGroup()) {\n            int shirtSize = participant.getShirtSize();\n            holder.mShirtSize.setVisibility(View.VISIBLE);\n            GradientDrawable gradientDrawable = (GradientDrawable) holder.mShirtSize.getBackground();\n            gradientDrawable.setColor(ContextCompat.getColor(mContext, Util.shirtSizeColor[shirtSize]));\n            holder.mShirtSize.setText(this.mContext.getString(Util.shirtSize[shirtSize]));\n        }else{\n            holder.mShirtSize.setVisibility(View.INVISIBLE);\n        }\n\n        if (checkedItems.contains(position)) {\n            holder.mContainer.setBackgroundResource(R.drawable.seletor_long_click_item);\n        } else {\n            holder.mContainer.setBackgroundResource(this.mBackground);\n        }\n    }\n\n    public void readAttendParticipant(int position, boolean attend){\n        mParticipants.get(position).setAttend(attend);\n        notifyDataSetChanged();\n    }\n\n    public void remove(int position){\n        mParticipants.remove(position);\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public int getItemCount() {\n        // +1 Refers to the header\n        return (mParticipants == null ? 0 : mParticipants.size()+1);\n    }\n\n    public void setOnClickListener(OnItemClickListener onClickListener) {\n        mOnClickListener = onClickListener;\n    }\n\n    public void setOnItemClickListener(OnItemClickListener onItemClickListener) {\n        mOnItemClickListener = onItemClickListener;\n    }\n\n    public void setOnItemLongClickListener(OnItemLongClickListener onItemLongClickListener) {\n        mOnItemLongClickListener = onItemLongClickListener;\n    }\n\n    public void resetarCheck() {\n        this.checkedItems.clear();\n        this.notifyDataSetChanged();\n    }\n\n    public void setChecked(int position, boolean checked) {\n        resetarCheck();\n\n        if (checked) {\n            this.checkedItems.add(position);\n        } else {\n            this.checkedItems.remove(position);\n        }\n\n        this.notifyDataSetChanged();\n    }\n\n    public void searchParticipantes(CharSequence charText) {\n\n        charText = Util.removeAccent((String) charText).toLowerCase(Locale.getDefault());\n\n        mParticipants.clear();\n        if (charText.length() == 0) {\n            mParticipants.addAll(mSearchParticipants);\n        } else {\n            for (Participant participant: mSearchParticipants) {\n                String name = Util.removeAccent(participant.getName());\n                if (name.toLowerCase(Locale.getDefault()).contains(charText)) {\n                    mParticipants.add(participant);\n                }\n            }\n        }\n\n        notifyDataSetChanged();\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/NewParticipantActivity.java\npublic class NewParticipantActivity extends BaseActivity{\n\n    private int mShirtSize = 0;\n    private ProgressDialog mDialog;\n    private Participant mParticipant;\n\n    @BindView(R.id.img_sex) ImageView mImgSex;\n    @BindView(R.id.toolbar) Toolbar mToolbar;\n    @BindView(R.id.sw_sex) SwitchCompat mSwSex;\n\n    @BindView(R.id.edt_code) EditText mEdtCode;\n    @BindView(R.id.edt_name) EditText mEdtName;\n    @BindView(R.id.edt_email) EditText mEdtEmail;\n    @BindView(R.id.edt_phone) EditText mEdtPhone;\n    @BindView(R.id.edt_company) EditText mEdtCompany;\n    @BindView(R.id.sw_attend) SwitchCompat mSwAttend;\n\n    @BindView(R.id.txt_shirt_size_p) TextView mTxtShirtSizeP;\n    @BindView(R.id.txt_shirt_size_m) TextView mTxtShirtSizeM;\n    @BindView(R.id.txt_shirt_size_g) TextView mTxtShirtSizeG;\n    @BindView(R.id.txt_shirt_size_gg) TextView mTxtShirtSizeGG;\n    @BindView(R.id.txt_shirt_size_eg) TextView mTxtShirtSizeEG;\n\n    @BindView(R.id.layout_code) LinearLayout mLayoutCode;\n    @BindView(R.id.layout_name) LinearLayout mLayoutName;\n    @BindView(R.id.layout_email) LinearLayout mLayoutEmail;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_new_participant);\n        ButterKnife.bind(this);\n\n        mToolbar.setTitle(getString(R.string.new_participant));\n        mToolbar.setNavigationIcon(R.drawable.ic_done_white_24dp);\n        this.setSupportActionBar(mToolbar);\n\n        setupOnClickListener();\n        if (savedInstanceState != null){\n            mShirtSize = savedInstanceState.getInt(Constant.PARTICIPANT_shirtSize, 0);\n        }\n\n        boolean isInsert = getIntent().getExtras().getBoolean(Constant.INSERT, false);\n        if (!isInsert){\n            mParticipant = getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n            setupUpdate(mParticipant);\n        }\n\n        colorDefaultShirtSize(mShirtSize);\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n\t}\n\n    private void setupUpdate(Participant participant){\n        mEdtCode.setEnabled(false);\n        mEdtCode.setText(String.valueOf(participant.getCode()));\n        mEdtName.setText(participant.getName());\n        mEdtPhone.setText(participant.getPhone());\n        mEdtEmail.setText(participant.getEmail());\n        mShirtSize = participant.getShirtSize();\n        mSwAttend.setChecked(participant.isAttend());\n        mSwSex.setChecked(participant.isSex());\n        mEdtCompany.setText(participant.getCompany());\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.menu, menu);\n        menu.findItem(R.id.menu_raffle).setVisible(false);\n        menu.findItem(R.id.menu_delete).setVisible(false);\n        menu.findItem(R.id.menu_search).setVisible(false);\n        menu.findItem(R.id.menu_send).setVisible(false);\n        menu.findItem(R.id.menu_resume).setVisible(false);\n        return true;\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(Constant.PARTICIPANT_shirtSize, mShirtSize);\n    }\n\n    private CompoundButton.OnCheckedChangeListener onCheckedAttend = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwAttend.setCompoundDrawablesWithIntrinsicBounds(isChecked ? R.drawable.ic_check_green_18dp : 0, 0, 0, 0);\n        }\n    };\n\n    private CompoundButton.OnCheckedChangeListener onCheckedSex = new CompoundButton.OnCheckedChangeListener() {\n        @Override\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n            mSwSex.setText(isChecked ? R.string.female : R.string.male);\n            mImgSex.setColorFilter(ContextCompat.getColor(NewParticipantActivity.this, isChecked ? R.color.shirt_size_g : R.color.shirt_size_m));\n            mImgSex.setImageDrawable(ContextCompat.getDrawable(NewParticipantActivity.this, isChecked ? R.drawable.ic_favorite_grey600_24dp : R.drawable.ic_android_grey600_24dp));\n\n            if (isChecked){\n                YoYo.with(Techniques.Landing).playOn(mImgSex);\n            }\n        }\n    };\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        switch (item.getItemId()){\n            case android.R.id.home:\n                    if (validation()){\n                        if (mParticipant == null) {\n                            saveParticipant();\n                        }else{\n                            updateParticipant();\n                        }\n                    }\n                break;\n\n            case R.id.menu_discart:\n                finish(ActivityAnimation.SLIDE_RIGHT);\n                break;\n        }\n\n        return true;\n    }\n\n    private void setupOnClickListener(){\n        mSwAttend.setOnCheckedChangeListener(onCheckedAttend);\n        mSwAttend.setChecked(true);\n\n        mSwSex.setOnCheckedChangeListener(onCheckedSex);\n        mSwSex.setChecked(false);\n\n        mTxtShirtSizeP.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeM.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeGG.setOnClickListener(onClickShirtSize);\n        mTxtShirtSizeEG.setOnClickListener(onClickShirtSize);\n    }\n\n    private boolean validation(){\n\t\tboolean result = true;\n\n        if (mEdtCode.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtCode.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutCode);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_code, Toast.LENGTH_SHORT).show();\n        }else if (mEdtName.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtName.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutName);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_name, Toast.LENGTH_SHORT).show();\n        }else if (mEdtEmail.getText().toString().trim().equals(\"\")){\n            result = false;\n            mEdtEmail.requestFocus();\n            YoYo.with(Techniques.Shake).playOn(mLayoutEmail);\n            Toast.makeText(getApplicationContext(), R.string.warning_no_email, Toast.LENGTH_SHORT).show();\n        }\n\n\t\treturn result;\n\t}\n\n    private void saveParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(Constant.NAME_EVENT);\n        participant.setBirthDate(\"\");\n        participant.setRaffled(false);\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantInsertTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private void updateParticipant(){\n        showDialog();\n\n        Participant participant = new Participant();\n        participant.setId(mParticipant.getId());\n        participant.setCode(Integer.valueOf(mEdtCode.getText().toString()));\n        participant.setName(mEdtName.getText().toString());\n        participant.setPhone(mEdtPhone.getText().toString());\n        participant.setEmail(mEdtEmail.getText().toString());\n        participant.setShirtSize(mShirtSize);\n        participant.setAttend(mSwAttend.isChecked());\n        participant.setNameEvent(mParticipant.getNameEvent());\n        participant.setBirthDate(mParticipant.getBirthDate());\n        participant.setRaffled(mParticipant.isRaffled());\n        participant.setSex(mSwSex.isChecked());\n        participant.setCompany(mEdtCompany.getText().toString());\n\n        new ParticipantUpdateTask(this, participant){\n            @Override\n            protected void onPreExecute() {\n                super.onPreExecute();\n                showDialog();\n            }\n\n            @Override\n            protected void onPostExecute(Boolean result) {\n                super.onPostExecute(result);\n\n                if (result){\n                    Intent intent = new Intent();\n                    intent.putExtra(Constant.PARTICIPANT, true);\n                    setResult(0, intent);\n                    finish(ActivityAnimation.SLIDE_RIGHT);\n                    Toast.makeText(getApplicationContext(), R.string.warning_save_participante, Toast.LENGTH_SHORT).show();\n                }else{\n                    Toast.makeText(getApplicationContext(), R.string.error_save_participante, Toast.LENGTH_SHORT).show();\n                }\n\n                hideDialog();\n            }\n        }.execute();\n    }\n\n    private View.OnClickListener onClickShirtSize = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            resetColorShirtSize();\n\n            switch (v.getId()){\n\n                case R.id.txt_shirt_size_p:\n                    mShirtSize = 0;\n                    break;\n\n                case R.id.txt_shirt_size_m:\n                    mShirtSize = 1;\n                    break;\n\n                case R.id.txt_shirt_size_g:\n                    mShirtSize = 2;\n                    break;\n\n                case R.id.txt_shirt_size_gg:\n                    mShirtSize = 3;\n                    break;\n\n                case R.id.txt_shirt_size_eg:\n                    mShirtSize = 4;\n                    break;\n\n            }\n\n            colorDefaultShirtSize(mShirtSize);\n        }\n    };\n\n    private void resetColorShirtSize(){\n        GradientDrawable gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n\n        gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n        gradientDrawable.setColor(ContextCompat.getColor(this, R.color.divider));\n    }\n\n    private void colorDefaultShirtSize(int shirtSize){\n        resetColorShirtSize();\n        GradientDrawable gradientDrawable;\n\n        switch (shirtSize) {\n            case 0:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeP.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeP);\n                break;\n\n            case 1:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeM.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeM);\n                break;\n\n            case 2:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeG);\n                break;\n\n            case 3:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeGG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeGG);\n                break;\n\n            case 4:\n                gradientDrawable = (GradientDrawable) mTxtShirtSizeEG.getBackground();\n                YoYo.with(Techniques.Landing).withListener(new AnimatorShirtSize(gradientDrawable, shirtSize)).playOn(mTxtShirtSizeEG);\n                break;\n        }\n    }\n\n    private class AnimatorShirtSize implements Animator.AnimatorListener{\n\n        private int mPosition;\n        private GradientDrawable mGradientDrawable;\n\n        public AnimatorShirtSize(GradientDrawable gradientDrawable, int position){\n            this.mPosition = position;\n            this.mGradientDrawable = gradientDrawable;\n        }\n\n        @Override\n        public void onAnimationStart(Animator animation) {\n            if (mGradientDrawable != null) {\n                mGradientDrawable.setColor(ContextCompat.getColor(NewParticipantActivity.this, Util.shirtSizeColor[mPosition]));\n            }\n        }\n\n        @Override\n        public void onAnimationEnd(Animator animation) {\n        }\n\n        @Override\n        public void onAnimationCancel(Animator animation) {\n\n        }\n\n        @Override\n        public void onAnimationRepeat(Animator animation) {\n\n        }\n    }\n\n    private void showDialog() {\n        mDialog = ProgressDialog.show(this, getString(R.string.wait),\n                getString(R.string.warning_save_wait_participante));\n    }\n\n    private void hideDialog(){\n        if (mDialog != null){\n            mDialog.dismiss();\n        }\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        finish(ActivityAnimation.SLIDE_RIGHT);\n    }\n}\napp/src/main/java/br/com/javace/javou/ui/activity/RaffleActivity.java\npublic class RaffleActivity extends BaseActivity {\n\n    private boolean isFinishOk = false;\n    private Participant mParticipantFortunate;\n    @BindView(R.id.animated_load) AnimatedCircleLoadingView mAnimatedLoad;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_raffle_main);\n        ButterKnife.bind(this);\n\n        mParticipantFortunate =  getIntent().getExtras().getParcelable(Constant.PARTICIPANT);\n        mAnimatedLoad.setOnClickListener(onClickAnimLoad);\n        startPercentMockThread();\n    }\n\n    private View.OnClickListener onClickAnimLoad = new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            if (isFinishOk) {\n                isFinishOk = false;\n                Toast.makeText(getApplicationContext(), \"Terminou\", Toast.LENGTH_SHORT).show();\n            }\n        }\n    };\n\n    private void startLoading() {\n        mAnimatedLoad.startDeterminate();\n    }\n\n    private void startPercentMockThread() {\n        startLoading();\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1500);\n                    for (int i = 0; i <= 100; i++) {\n                        Thread.sleep(10);\n                        changePercent(i);\n                    }\n                    Thread.sleep(3000);\n                    ParticipantDao participantDao = new ParticipantDao(getApplicationContext());\n                    participantDao.updateAsRaffled(mParticipantFortunate);\n                    Intent intent = new Intent(getBaseContext(), ParticipantFortunateActivity.class);\n                    intent.putExtra(Constant.PARTICIPANT, mParticipantFortunate);\n                    startActivityForResult(intent, 0, BaseActivity.ActivityAnimation.SLIDE_LEFT);\n                    finish();\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n\n        new Thread(runnable).start();\n    }\n\n    private void changePercent(final int percent) {\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (mAnimatedLoad != null) {\n                    mAnimatedLoad.setPercent(percent);\n\n                    if (percent == 100){\n                        isFinishOk = true;\n                    }\n                }\n            }\n        });\n    }\n\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n    }\n}\napp/src/main/java/br/com/javace/javou/task/ParticipantTask.java\npublic class ParticipantTask extends AsyncTask<Void, Void, ArrayList<Participant>> {\n\n    private Context mContext;\n    public ParticipantTask(Context context){\n        this.mContext = context;\n    }\n\n    @Override\n    protected ArrayList<Participant> doInBackground(Void... params) {\n        ParticipantDao participantDao = ParticipantDao.getInstance(mContext);\n        return participantDao.getAll();\n    }\n}\n", "answers": ["                Intent intent = new Intent(getActivity(), ParticipantFortunateActivity.class);"], "pred": "  Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle: Raffle:", "length": 6652, "dataset": "repobench-p", "language": "java", "all_classes": null, "_id": "ac6b60475fb35309a7b102618c3472231e77b5bfc8326ece"}
{"prompt": "Please complete the code given below. \npottery/exceptions.py\nclass ExtendUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to extend an unlocked Redlock.'\npottery/exceptions.py\nclass ReleaseUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to release an unlocked Redlock.'\npottery/exceptions.py\nclass QuorumNotAchieved(PrimitiveError, RuntimeError):\n    'Consensus-based algorithm could not achieve quorum.'\npottery/timer.py\nclass ContextTimer:\n    '''Measure the execution time of small code snippets.\n\n    Note that ContextTimer measures wall (real-world) time, not CPU time; and\n    that .elapsed() returns time in milliseconds.\n\n    You can use ContextTimer stand-alone...\n\n        >>> import time\n        >>> timer = ContextTimer()\n        >>> timer.start()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n        >>> timer.stop()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n\n    ...or as a context manager:\n\n        >>> tests = []\n        >>> with ContextTimer() as timer:\n        ...     time.sleep(0.1)\n        ...     tests.append(100 <= timer.elapsed() < 200)\n        >>> time.sleep(0.1)\n        >>> tests.append(100 <= timer.elapsed() < 200)\n        >>> tests\n        [True, True]\n    '''\n\n    __slots__ = ('_started', '_stopped')\n\n    def __init__(self) -> None:\n        self._started = 0.0\n        self._stopped = 0.0\n\n    def __enter__(self) -> ContextTimer:\n        self.__start()\n        return self\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 exc_traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        self.__stop()\n        return False\n\n    def start(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            raise RuntimeError('timer has already been started')\n        else:\n            self._started = timeit.default_timer()\n\n    # Preserve the Open-Closed Principle with name mangling.\n    #   https://youtu.be/miGolgp9xq8?t=2086\n    #   https://stackoverflow.com/a/38534939\n    __start = start\n\n    def stop(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            self._stopped = timeit.default_timer()\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\n\n    __stop = stop\n\n    def elapsed(self) -> int:\n        if self._started:\n            stopped_or_current = self._stopped or timeit.default_timer()\n            elapsed = stopped_or_current - self._started\n            return round(elapsed * 1000)\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\npottery/base.py\ndef random_key(*,\n               redis: Redis,\n               prefix: str = 'pottery:',\n               num_tries: int = 3,\n               ) -> str:\ndef _connection_args(redis: Redis) -> Tuple[str, int, int]:\n    def __init__(self, *, redis: Redis | None = None, key: str = '') -> None:\n    def __del__(self) -> None:\n    def redis(self) -> Redis:\n    def redis(self, value: Redis | None) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _random_key(self) -> str:\n    def _encode(decoded_value: JSONTypes) -> str:\n    def _decode(encoded_value: AnyStr) -> JSONTypes:\n    def redis(self) -> Redis:  # pragma: no cover\n    def key(self) -> str:  # pragma: no cover\n    def clear(self: _HasRedisClientAndKey) -> None:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def __watch_keys(self, *keys: str) -> Generator[Pipeline, None, None]:\n    def __context_managers(self,\n                           *others: Any,\n                           ) -> Generator[ContextManager[Pipeline], None, None]:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def _same_redis(self, *others: Any) -> bool:\n    def __eq__(self, other: Any) -> bool:\n    def __iter__(self) -> Generator[JSONTypes, None, None]:\n    def _KEY_PREFIX(self) -> str:\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 ) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _check_enough_masters_up(self,\n                                 raise_on_redis_errors: bool | None,\n                                 redis_errors: List[RedisError],\n                                 ) -> None:\nclass _Common:\nclass _Encodable:\nclass _HasRedisClientAndKey(Protocol):\nclass _Clearable:\nclass _Pipelined(abc.ABC):\nclass _Comparable(abc.ABC):\nclass Container(_Common, _Encodable, _Clearable, _Pipelined, _Comparable):\nclass Iterable_(abc.ABC):\nclass Primitive(abc.ABC):\nclass AIOPrimitive(Primitive):\n    _RANDOM_KEY_PREFIX: ClassVar[str] = 'pottery:'\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[Redis]] = frozenset({_default_redis})\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[AIORedis]] = frozenset()  # type: ignore\npottery/redlock.py\nclass Redlock(Scripts, Primitive):\n    '''Distributed Redis-powered lock.\n\n    This algorithm safely and reliably provides a mutually-exclusive locking\n    primitive to protect a resource shared across threads, processes, and even\n    machines, without a single point of failure.\n\n    Rationale and algorithm description:\n        http://redis.io/topics/distlock\n\n    Usage:\n\n        >>> from redis import Redis\n        >>> redis = Redis()\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> bool(printer_lock.locked())\n        False\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> printer_lock.release()\n        >>> bool(printer_lock.locked())\n        False\n\n    Redlocks time out (by default, after 10 seconds).  You should take care to\n    ensure that your critical section completes well within the timeout.  The\n    reasons that Redlocks time out are to preserve \"liveness\"\n    (http://redis.io/topics/distlock#liveness-arguments) and to avoid deadlocks\n    (in the event that a process dies inside a critical section before it\n    releases its lock).\n\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time)\n        >>> bool(printer_lock.locked())\n        False\n\n    If 10 seconds isn't enough to complete executing your critical section,\n    then you can specify your own timeout:\n\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        True\n        >>> time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        False\n\n    You can use a Redlock as a context manager:\n\n        >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n\n        >>> with printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n    '''\n\n    __slots__ = (\n        'auto_release_time',\n        'num_extensions',\n        'context_manager_blocking',\n        'context_manager_timeout',\n        '_uuid',\n        '_extension_num',\n    )\n\n    _KEY_PREFIX: ClassVar[str] = 'redlock'\n    _AUTO_RELEASE_TIME: ClassVar[float] = 10\n    _CLOCK_DRIFT_FACTOR: ClassVar[float] = 0.01\n    _RETRY_DELAY: ClassVar[float] = .2\n    _NUM_EXTENSIONS: ClassVar[int] = 3\n\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 auto_release_time: float = _AUTO_RELEASE_TIME,\n                 num_extensions: int = _NUM_EXTENSIONS,\n                 context_manager_blocking: bool = True,\n                 context_manager_timeout: float = -1,\n                 ) -> None:\n        '''Initialize a Redlock.\n\n        Keyword arguments:\n            key -- a string that identifies your resource\n            masters -- the Redis clients used to achieve quorum for this\n                Redlock's state\n            raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n                exception when too many Redis masters throw errors\n            auto_release_time -- the timeout in seconds by which to\n                automatically release this Redlock, unless it's already been\n                released\n            num_extensions -- the number of times that this Redlock's lease can\n                be extended\n            context_manager_blocking -- when using this Redlock as a context\n                manager, whether to block when acquiring\n            context_manager_timeout -- if context_manager_blocking, how long to\n                wait when acquiring before giving up and raising the\n                QuorumNotAchieved exception\n        '''\n        if not context_manager_blocking and context_manager_timeout != -1:\n            raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n        super().__init__(\n            key=key,\n            masters=masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n        self.auto_release_time = auto_release_time\n        self.num_extensions = num_extensions\n        self.context_manager_blocking = context_manager_blocking\n        self.context_manager_timeout = context_manager_timeout\n        self._uuid = ''\n        self._extension_num = 0\n\n    def __acquire_master(self, master: Redis) -> bool:\n        acquired = master.set(\n            self.key,\n            self._uuid,\n            px=int(self.auto_release_time * 1000),\n            nx=True,\n        )\n        return bool(acquired)\n\n    def __acquired_master(self, master: Redis) -> int:\n        if self._uuid:\n            ttl: int = cast(Script, self._acquired_script)(\n                keys=(self.key,),\n                args=(self._uuid,),\n                client=master,\n            )\n        else:\n            ttl = 0\n        return ttl\n\n    def __extend_master(self, master: Redis) -> bool:\n        auto_release_time_ms = int(self.auto_release_time * 1000)\n        extended = cast(Script, self._extend_script)(\n            keys=(self.key,),\n            args=(self._uuid, auto_release_time_ms),\n            client=master,\n        )\n        return bool(extended)\n\n    def __release_master(self, master: Redis) -> bool:\n        released = cast(Script, self._release_script)(\n            keys=(self.key,),\n            args=(self._uuid,),\n            client=master,\n        )\n        return bool(released)\n\n    def __drift(self) -> float:\n        return self.auto_release_time * self._CLOCK_DRIFT_FACTOR + .002\n\n    def _acquire_masters(self,\n                         *,\n                         raise_on_redis_errors: bool | None = None,\n                         ) -> bool:\n        self._uuid = str(uuid.uuid4())\n        self._extension_num = 0\n\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquire_master, master)\n                futures.add(future)\n\n            num_masters_acquired, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_acquired += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.__acquire_masters() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_acquired > len(self.masters) // 2:\n                        validity_time = self.auto_release_time\n                        validity_time -= self.__drift()\n                        validity_time -= timer.elapsed() / 1000\n                        if validity_time > 0:\n                            return True\n\n        with contextlib.suppress(ReleaseUnlockedLock):\n            self.__release(raise_on_redis_errors=raise_on_redis_errors)\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return False\n\n    __acquire_masters = _acquire_masters\n\n    def acquire(self,\n                *,\n                blocking: bool = True,\n                timeout: float = -1,\n                raise_on_redis_errors: bool | None = None,\n                ) -> bool:\n        '''Lock the lock.\n\n        If blocking is True and timeout is -1, then wait for as long as\n        necessary to acquire the lock.  Return True.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n            >>> printer_lock_1.acquire()\n            True\n            >>> timer = ContextTimer()\n            >>> timer.start()\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> timer.elapsed() > printer_lock_1.auto_release_time * 1000\n            True\n            >>> printer_lock_2.release()\n\n        If blocking is True and timeout is not -1, then wait for up to timeout\n        seconds to acquire the lock.  Return True if the lock was acquired;\n        False if it wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.5)\n            True\n            >>> printer_lock_2.release()\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.1)\n            False\n            >>> with contextlib.suppress(ReleaseUnlockedLock):\n            ...     printer_lock_1.release()\n\n        If blocking is False and timeout is -1, then try just once right now to\n        acquire the lock.  Return True if the lock was acquired; False if it\n        wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(blocking=False)\n            False\n            >>> printer_lock_1.release()\n        '''\n        acquire_masters = functools.partial(\n            self.__acquire_masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n\n        if blocking:\n            enqueued = False\n            with ContextTimer() as timer:\n                while timeout == -1 or timer.elapsed() / 1000 < timeout:\n                    if acquire_masters():\n                        if enqueued:\n                            self.__log_time_enqueued(timer, True)\n                        return True\n                    enqueued = True\n                    delay = random.uniform(0, self._RETRY_DELAY)  # nosec\n                    time.sleep(delay)\n            if enqueued:  # pragma: no cover\n                self.__log_time_enqueued(timer, False)\n            return False  # pragma: no cover\n\n        if timeout == -1:\n            return acquire_masters()\n\n        raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n    __acquire = acquire\n\n    def __log_time_enqueued(self, timer: ContextTimer, acquired: bool) -> None:\n        key_suffix = self.key.split(':', maxsplit=1)[1]\n        time_enqueued = math.ceil(timer.elapsed())\n        logger.info(\n            'source=pottery sample#redlock.enqueued.%s=%dms sample#redlock.acquired.%s=%d',\n            key_suffix,\n            time_enqueued,\n            key_suffix,\n            acquired,\n        )\n\n    def locked(self, *, raise_on_redis_errors: bool | None = None) -> float:\n        '''How much longer we'll hold the lock (unless we extend or release it).\n\n        If we don't currently hold the lock, then this method returns 0.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_1.locked()\n            0\n\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> printer_lock_1.locked()\n            0\n            >>> printer_lock_2.release()\n\n        If we do currently hold the lock, then this method returns the current\n        lease's Time To Live (TTL) in ms.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> 9 < printer_lock_1.locked() < 10\n            True\n            >>> printer_lock_1.release()\n        '''\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquired_master, master)\n                futures.add(future)\n\n            ttls, redis_errors = [], []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    ttl = future.result() / 1000\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.locked() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if ttl:\n                        ttls.append(ttl)\n                        if len(ttls) > len(self.masters) // 2:  # pragma: no cover\n                            validity_time = min(ttls)\n                            validity_time -= self.__drift()\n                            validity_time -= timer.elapsed() / 1000\n                            return max(validity_time, 0)\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return 0\n\n    def extend(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Extend our hold on the lock (if we currently hold it).\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> printer_lock.acquire()\n            True\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> time.sleep(1)\n            >>> 8 < printer_lock.locked() < 9\n            True\n            >>> printer_lock.extend()\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> printer_lock.release()\n        '''\n        if self._extension_num >= self.num_extensions:\n            raise TooManyExtensions(self.key, self.masters)\n\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__extend_master, master)\n                futures.add(future)\n\n            num_masters_extended, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_extended += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.extend() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_extended > len(self.masters) // 2:\n                        self._extension_num += 1\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ExtendUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    def release(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Unlock the lock.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> bool(printer_lock.locked())\n            False\n            >>> printer_lock.acquire()\n            True\n            >>> bool(printer_lock.locked())\n            True\n            >>> printer_lock.release()\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__release_master, master)\n                futures.add(future)\n\n            num_masters_released, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_released += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.release() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_released > len(self.masters) // 2:\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ReleaseUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    __release = release\n\n    def __enter__(self) -> Redlock:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        acquired = self.__acquire(\n            blocking=self.context_manager_blocking,\n            timeout=self.context_manager_timeout,\n        )\n        if acquired:\n            return self\n        raise QuorumNotAchieved(self.key, self.masters)\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        self.__release()\n        return False\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} key={self.key}>'\ntests/base.py\nclass TestCase(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls) -> None:\n        logger.setLevel(logging.CRITICAL)\n        warnings.filterwarnings('ignore', category=PotteryWarning)\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        # Choose a random Redis database for this test.\n        self.redis_db = random.randint(1, 15)  # nosec\n        self.redis_url = f'redis://localhost:6379/{self.redis_db}'\n\n        # Set up our Redis clients.\n        self.redis = Redis.from_url(self.redis_url, socket_timeout=1)\n        self.redis_decoded_responses = Redis.from_url(\n            self.redis_url,\n            socket_timeout=1,\n            decode_responses=True,\n        )\n\n        # Clean up the Redis database before and after the test.\n        self.redis.flushdb()\n        self.addCleanup(self.redis.flushdb)\npottery/exceptions.py\nclass QuorumIsImpossible(PrimitiveError, RuntimeError):\n    'Too many Redis masters threw RedisErrors; quorum can not be achieved.'\npottery/redlock.py\ndef synchronize(*,\n                key: str,\n                masters: Iterable[Redis] = frozenset(),\n                raise_on_redis_errors: bool = False,\n                auto_release_time: float = Redlock._AUTO_RELEASE_TIME,\n                blocking: bool = True,\n                timeout: float = -1,\n                ) -> Callable[[F], F]:\n    '''Decorator to synchronize a function's execution across threads.\n\n    synchronize() is a decorator that allows only one thread to execute a\n    function at a time.  Under the hood, synchronize() uses a Redlock.  See\n    help(Redlock) for more details.\n\n    Keyword arguments:\n        key -- a string that identifies your resource\n        masters -- the Redis clients used to achieve quorum for this Redlock's\n            state\n        raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n            exception when too many Redis masters throw errors\n        auto_release_time -- the timeout in seconds by which to automatically\n            release this Redlock, unless it's already been released\n        num_extensions -- the number of times that this Redlock's lease can be\n            extended\n        context_manager_blocking -- when using this Redlock as a context\n            manager, whether to block when acquiring\n        context_manager_timeout -- if context_manager_blocking, how long to wait\n            when acquiring before giving up and raising the QuorumNotAchieved\n            exception\n\n    Usage:\n\n        >>> @synchronize(key='synchronized-func', auto_release_time=1.5)\n        ... def func():\n        ...     # Only one thread can execute this function at a time.\n        ...     return True\n        ...\n        >>> func()\n        True\n    '''\n    RedlockFactory = functools.partial(\n        Redlock,\n        key=key,\n        masters=masters,\n        raise_on_redis_errors=raise_on_redis_errors,\n        auto_release_time=auto_release_time,\n        context_manager_blocking=blocking,\n        context_manager_timeout=timeout,\n    )\n\n    def decorator(func: F) -> F:\n        @functools.wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            redlock = RedlockFactory()\n            waiting_timer, holding_timer = ContextTimer(), ContextTimer()\n\n            try:\n                waiting_timer.start()\n                with redlock:\n                    waiting_timer.stop()\n                    holding_timer.start()\n                    return_value = func(*args, **kwargs)\n                holding_timer.stop()\n            finally:\n                _log_synchronize(func, redlock, waiting_timer, holding_timer)\n\n            return return_value\n        return cast(F, wrapper)\n    return decorator\npottery/exceptions.py\nclass TooManyExtensions(PrimitiveError, RuntimeError):\n    'Redlock has been extended too many times.'\nimport concurrent.futures\nimport contextlib\nimport os\nimport time\nimport unittest.mock\nfrom redis import Redis\nfrom redis.commands.core import Script\nfrom redis.exceptions import TimeoutError\nfrom pottery import ContextTimer\nfrom pottery import ExtendUnlockedLock\nfrom pottery import QuorumIsImpossible\nfrom pottery import QuorumNotAchieved\nfrom pottery import Redlock\nfrom pottery import ReleaseUnlockedLock\nfrom pottery import TooManyExtensions\nfrom pottery import synchronize\nfrom pottery.base import logger\nfrom tests.base import TestCase\n# --------------------------------------------------------------------------- #\n#   test_redlock.py                                                           #\n#                                                                             #\n#   Copyright \u00a9 2015-2022, Rajiv Bakulesh Shah, original author.              #\n#                                                                             #\n#   Licensed under the Apache License, Version 2.0 (the \"License\");           #\n#   you may not use this file except in compliance with the License.          #\n#   You may obtain a copy of the License at:                                  #\n#       http://www.apache.org/licenses/LICENSE-2.0                            #\n#                                                                             #\n#   Unless required by applicable law or agreed to in writing, software       #\n#   distributed under the License is distributed on an \"AS IS\" BASIS,         #\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #\n#   See the License for the specific language governing permissions and       #\n#   limitations under the License.                                            #\n# --------------------------------------------------------------------------- #\n'Distributed Redis-powered lock tests.'\n\n\n\n\n\n\nclass RedlockTests(TestCase):\n    'Distributed Redis-powered lock tests.'\n\n    def setUp(self):\n        super().setUp()\n        self.redlock = Redlock(\n            masters={self.redis},\n            key='printer',\n            auto_release_time=.2,\n        )\n\n    def test_acquire_fails_within_auto_release_time(self):\n        self.redlock.auto_release_time = .001\n        assert not self.redlock._acquire_masters()\n\n    def test_acquire_and_time_out(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        with ContextTimer() as timer, \\\n             unittest.mock.patch.object(logger, 'info') as info:\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert timer.elapsed() / 1000 >= self.redlock.auto_release_time\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    @unittest.skipIf('CI' in os.environ, 'this unit test is flaky on CI')  # pragma: no cover\n    def test_acquire_same_lock_twice_blocking_with_timeout(self):\n        with unittest.mock.patch.object(logger, 'info') as info:\n            assert not self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert not self.redlock.acquire(timeout=0)\n            assert not self.redlock.acquire(timeout=0.025)\n            assert self.redis.exists(self.redlock.key)\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    def test_acquire_same_lock_twice_non_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert not self.redlock.acquire(blocking=False)\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_non_blocking_with_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        with self.assertRaises(ValueError):\n            self.redlock.acquire(blocking=False, timeout=0)\n        assert self.redis.exists(self.redlock.key)\n\n    def test_acquired(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert self.redlock.locked()\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n\n    def test_extend(self):\n        assert not self.redis.exists(self.redlock.key)\n        with self.assertRaises(ExtendUnlockedLock):\n            self.redlock.extend()\n        assert self.redlock.acquire()\n        for extension_num in range(Redlock._NUM_EXTENSIONS):\n            with self.subTest(extension_num=extension_num):\n                self.redlock.extend()\nNext line of code:\n", "input": "import concurrent.futures\nimport contextlib\nimport os\nimport time\nimport unittest.mock\nfrom redis import Redis\nfrom redis.commands.core import Script\nfrom redis.exceptions import TimeoutError\nfrom pottery import ContextTimer\nfrom pottery import ExtendUnlockedLock\nfrom pottery import QuorumIsImpossible\nfrom pottery import QuorumNotAchieved\nfrom pottery import Redlock\nfrom pottery import ReleaseUnlockedLock\nfrom pottery import TooManyExtensions\nfrom pottery import synchronize\nfrom pottery.base import logger\nfrom tests.base import TestCase\n# --------------------------------------------------------------------------- #\n#   test_redlock.py                                                           #\n#                                                                             #\n#   Copyright \u00a9 2015-2022, Rajiv Bakulesh Shah, original author.              #\n#                                                                             #\n#   Licensed under the Apache License, Version 2.0 (the \"License\");           #\n#   you may not use this file except in compliance with the License.          #\n#   You may obtain a copy of the License at:                                  #\n#       http://www.apache.org/licenses/LICENSE-2.0                            #\n#                                                                             #\n#   Unless required by applicable law or agreed to in writing, software       #\n#   distributed under the License is distributed on an \"AS IS\" BASIS,         #\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #\n#   See the License for the specific language governing permissions and       #\n#   limitations under the License.                                            #\n# --------------------------------------------------------------------------- #\n'Distributed Redis-powered lock tests.'\n\n\n\n\n\n\nclass RedlockTests(TestCase):\n    'Distributed Redis-powered lock tests.'\n\n    def setUp(self):\n        super().setUp()\n        self.redlock = Redlock(\n            masters={self.redis},\n            key='printer',\n            auto_release_time=.2,\n        )\n\n    def test_acquire_fails_within_auto_release_time(self):\n        self.redlock.auto_release_time = .001\n        assert not self.redlock._acquire_masters()\n\n    def test_acquire_and_time_out(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        with ContextTimer() as timer, \\\n             unittest.mock.patch.object(logger, 'info') as info:\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert timer.elapsed() / 1000 >= self.redlock.auto_release_time\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    @unittest.skipIf('CI' in os.environ, 'this unit test is flaky on CI')  # pragma: no cover\n    def test_acquire_same_lock_twice_blocking_with_timeout(self):\n        with unittest.mock.patch.object(logger, 'info') as info:\n            assert not self.redis.exists(self.redlock.key)\n            assert self.redlock.acquire()\n            assert self.redis.exists(self.redlock.key)\n            assert not self.redlock.acquire(timeout=0)\n            assert not self.redlock.acquire(timeout=0.025)\n            assert self.redis.exists(self.redlock.key)\n            assert info.call_count == 1, f'_logger.info() called {info.call_count} times'\n\n    def test_acquire_same_lock_twice_non_blocking_without_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert not self.redlock.acquire(blocking=False)\n        assert self.redis.exists(self.redlock.key)\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n\n    def test_acquire_same_lock_twice_non_blocking_with_timeout(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        with self.assertRaises(ValueError):\n            self.redlock.acquire(blocking=False, timeout=0)\n        assert self.redis.exists(self.redlock.key)\n\n    def test_acquired(self):\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n        assert self.redlock.acquire()\n        assert self.redis.exists(self.redlock.key)\n        assert self.redlock.locked()\n        time.sleep(self.redlock.auto_release_time * 2)\n        assert not self.redis.exists(self.redlock.key)\n        assert not self.redlock.locked()\n\n    def test_extend(self):\n        assert not self.redis.exists(self.redlock.key)\n        with self.assertRaises(ExtendUnlockedLock):\n            self.redlock.extend()\n        assert self.redlock.acquire()\n        for extension_num in range(Redlock._NUM_EXTENSIONS):\n            with self.subTest(extension_num=extension_num):\n                self.redlock.extend()\n", "context": "pottery/exceptions.py\nclass ExtendUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to extend an unlocked Redlock.'\npottery/exceptions.py\nclass ReleaseUnlockedLock(PrimitiveError, RuntimeError):\n    'Attempting to release an unlocked Redlock.'\npottery/exceptions.py\nclass QuorumNotAchieved(PrimitiveError, RuntimeError):\n    'Consensus-based algorithm could not achieve quorum.'\npottery/timer.py\nclass ContextTimer:\n    '''Measure the execution time of small code snippets.\n\n    Note that ContextTimer measures wall (real-world) time, not CPU time; and\n    that .elapsed() returns time in milliseconds.\n\n    You can use ContextTimer stand-alone...\n\n        >>> import time\n        >>> timer = ContextTimer()\n        >>> timer.start()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n        >>> timer.stop()\n        >>> time.sleep(0.1)\n        >>> 100 <= timer.elapsed() < 200\n        True\n\n    ...or as a context manager:\n\n        >>> tests = []\n        >>> with ContextTimer() as timer:\n        ...     time.sleep(0.1)\n        ...     tests.append(100 <= timer.elapsed() < 200)\n        >>> time.sleep(0.1)\n        >>> tests.append(100 <= timer.elapsed() < 200)\n        >>> tests\n        [True, True]\n    '''\n\n    __slots__ = ('_started', '_stopped')\n\n    def __init__(self) -> None:\n        self._started = 0.0\n        self._stopped = 0.0\n\n    def __enter__(self) -> ContextTimer:\n        self.__start()\n        return self\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 exc_traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        self.__stop()\n        return False\n\n    def start(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            raise RuntimeError('timer has already been started')\n        else:\n            self._started = timeit.default_timer()\n\n    # Preserve the Open-Closed Principle with name mangling.\n    #   https://youtu.be/miGolgp9xq8?t=2086\n    #   https://stackoverflow.com/a/38534939\n    __start = start\n\n    def stop(self) -> None:\n        if self._stopped:\n            raise RuntimeError('timer has already been stopped')\n        elif self._started:\n            self._stopped = timeit.default_timer()\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\n\n    __stop = stop\n\n    def elapsed(self) -> int:\n        if self._started:\n            stopped_or_current = self._stopped or timeit.default_timer()\n            elapsed = stopped_or_current - self._started\n            return round(elapsed * 1000)\n        else:\n            raise RuntimeError(\"timer hasn't yet been started\")\npottery/base.py\ndef random_key(*,\n               redis: Redis,\n               prefix: str = 'pottery:',\n               num_tries: int = 3,\n               ) -> str:\ndef _connection_args(redis: Redis) -> Tuple[str, int, int]:\n    def __init__(self, *, redis: Redis | None = None, key: str = '') -> None:\n    def __del__(self) -> None:\n    def redis(self) -> Redis:\n    def redis(self, value: Redis | None) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _random_key(self) -> str:\n    def _encode(decoded_value: JSONTypes) -> str:\n    def _decode(encoded_value: AnyStr) -> JSONTypes:\n    def redis(self) -> Redis:  # pragma: no cover\n    def key(self) -> str:  # pragma: no cover\n    def clear(self: _HasRedisClientAndKey) -> None:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def __watch_keys(self, *keys: str) -> Generator[Pipeline, None, None]:\n    def __context_managers(self,\n                           *others: Any,\n                           ) -> Generator[ContextManager[Pipeline], None, None]:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def redis(self) -> Redis:\n    def key(self) -> str:\n    def _watch(self, *others: Any) -> Generator[Pipeline, None, None]:\n    def _same_redis(self, *others: Any) -> bool:\n    def __eq__(self, other: Any) -> bool:\n    def __iter__(self) -> Generator[JSONTypes, None, None]:\n    def _KEY_PREFIX(self) -> str:\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 ) -> None:\n    def key(self) -> str:\n    def key(self, value: str) -> None:\n    def _check_enough_masters_up(self,\n                                 raise_on_redis_errors: bool | None,\n                                 redis_errors: List[RedisError],\n                                 ) -> None:\nclass _Common:\nclass _Encodable:\nclass _HasRedisClientAndKey(Protocol):\nclass _Clearable:\nclass _Pipelined(abc.ABC):\nclass _Comparable(abc.ABC):\nclass Container(_Common, _Encodable, _Clearable, _Pipelined, _Comparable):\nclass Iterable_(abc.ABC):\nclass Primitive(abc.ABC):\nclass AIOPrimitive(Primitive):\n    _RANDOM_KEY_PREFIX: ClassVar[str] = 'pottery:'\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[Redis]] = frozenset({_default_redis})\n    _DEFAULT_MASTERS: ClassVar[FrozenSet[AIORedis]] = frozenset()  # type: ignore\npottery/redlock.py\nclass Redlock(Scripts, Primitive):\n    '''Distributed Redis-powered lock.\n\n    This algorithm safely and reliably provides a mutually-exclusive locking\n    primitive to protect a resource shared across threads, processes, and even\n    machines, without a single point of failure.\n\n    Rationale and algorithm description:\n        http://redis.io/topics/distlock\n\n    Usage:\n\n        >>> from redis import Redis\n        >>> redis = Redis()\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> bool(printer_lock.locked())\n        False\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> printer_lock.release()\n        >>> bool(printer_lock.locked())\n        False\n\n    Redlocks time out (by default, after 10 seconds).  You should take care to\n    ensure that your critical section completes well within the timeout.  The\n    reasons that Redlocks time out are to preserve \"liveness\"\n    (http://redis.io/topics/distlock#liveness-arguments) and to avoid deadlocks\n    (in the event that a process dies inside a critical section before it\n    releases its lock).\n\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time)\n        >>> bool(printer_lock.locked())\n        False\n\n    If 10 seconds isn't enough to complete executing your critical section,\n    then you can specify your own timeout:\n\n        >>> printer_lock = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n        >>> if printer_lock.acquire():\n        ...     # Critical section - print stuff here.\n        ...     time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        True\n        >>> time.sleep(printer_lock.auto_release_time / 2)\n        >>> bool(printer_lock.locked())\n        False\n\n    You can use a Redlock as a context manager:\n\n        >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n\n        >>> with printer_lock:\n        ...     # Critical section - print stuff here.\n        ...     print('printer_lock is locked')\n        printer_lock is locked\n        >>> bool(printer_lock.locked())\n        False\n    '''\n\n    __slots__ = (\n        'auto_release_time',\n        'num_extensions',\n        'context_manager_blocking',\n        'context_manager_timeout',\n        '_uuid',\n        '_extension_num',\n    )\n\n    _KEY_PREFIX: ClassVar[str] = 'redlock'\n    _AUTO_RELEASE_TIME: ClassVar[float] = 10\n    _CLOCK_DRIFT_FACTOR: ClassVar[float] = 0.01\n    _RETRY_DELAY: ClassVar[float] = .2\n    _NUM_EXTENSIONS: ClassVar[int] = 3\n\n    def __init__(self,\n                 *,\n                 key: str,\n                 masters: Iterable[Redis] = frozenset(),\n                 raise_on_redis_errors: bool = False,\n                 auto_release_time: float = _AUTO_RELEASE_TIME,\n                 num_extensions: int = _NUM_EXTENSIONS,\n                 context_manager_blocking: bool = True,\n                 context_manager_timeout: float = -1,\n                 ) -> None:\n        '''Initialize a Redlock.\n\n        Keyword arguments:\n            key -- a string that identifies your resource\n            masters -- the Redis clients used to achieve quorum for this\n                Redlock's state\n            raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n                exception when too many Redis masters throw errors\n            auto_release_time -- the timeout in seconds by which to\n                automatically release this Redlock, unless it's already been\n                released\n            num_extensions -- the number of times that this Redlock's lease can\n                be extended\n            context_manager_blocking -- when using this Redlock as a context\n                manager, whether to block when acquiring\n            context_manager_timeout -- if context_manager_blocking, how long to\n                wait when acquiring before giving up and raising the\n                QuorumNotAchieved exception\n        '''\n        if not context_manager_blocking and context_manager_timeout != -1:\n            raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n        super().__init__(\n            key=key,\n            masters=masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n        self.auto_release_time = auto_release_time\n        self.num_extensions = num_extensions\n        self.context_manager_blocking = context_manager_blocking\n        self.context_manager_timeout = context_manager_timeout\n        self._uuid = ''\n        self._extension_num = 0\n\n    def __acquire_master(self, master: Redis) -> bool:\n        acquired = master.set(\n            self.key,\n            self._uuid,\n            px=int(self.auto_release_time * 1000),\n            nx=True,\n        )\n        return bool(acquired)\n\n    def __acquired_master(self, master: Redis) -> int:\n        if self._uuid:\n            ttl: int = cast(Script, self._acquired_script)(\n                keys=(self.key,),\n                args=(self._uuid,),\n                client=master,\n            )\n        else:\n            ttl = 0\n        return ttl\n\n    def __extend_master(self, master: Redis) -> bool:\n        auto_release_time_ms = int(self.auto_release_time * 1000)\n        extended = cast(Script, self._extend_script)(\n            keys=(self.key,),\n            args=(self._uuid, auto_release_time_ms),\n            client=master,\n        )\n        return bool(extended)\n\n    def __release_master(self, master: Redis) -> bool:\n        released = cast(Script, self._release_script)(\n            keys=(self.key,),\n            args=(self._uuid,),\n            client=master,\n        )\n        return bool(released)\n\n    def __drift(self) -> float:\n        return self.auto_release_time * self._CLOCK_DRIFT_FACTOR + .002\n\n    def _acquire_masters(self,\n                         *,\n                         raise_on_redis_errors: bool | None = None,\n                         ) -> bool:\n        self._uuid = str(uuid.uuid4())\n        self._extension_num = 0\n\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquire_master, master)\n                futures.add(future)\n\n            num_masters_acquired, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_acquired += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.__acquire_masters() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_acquired > len(self.masters) // 2:\n                        validity_time = self.auto_release_time\n                        validity_time -= self.__drift()\n                        validity_time -= timer.elapsed() / 1000\n                        if validity_time > 0:\n                            return True\n\n        with contextlib.suppress(ReleaseUnlockedLock):\n            self.__release(raise_on_redis_errors=raise_on_redis_errors)\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return False\n\n    __acquire_masters = _acquire_masters\n\n    def acquire(self,\n                *,\n                blocking: bool = True,\n                timeout: float = -1,\n                raise_on_redis_errors: bool | None = None,\n                ) -> bool:\n        '''Lock the lock.\n\n        If blocking is True and timeout is -1, then wait for as long as\n        necessary to acquire the lock.  Return True.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis}, auto_release_time=.2)\n            >>> printer_lock_1.acquire()\n            True\n            >>> timer = ContextTimer()\n            >>> timer.start()\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> timer.elapsed() > printer_lock_1.auto_release_time * 1000\n            True\n            >>> printer_lock_2.release()\n\n        If blocking is True and timeout is not -1, then wait for up to timeout\n        seconds to acquire the lock.  Return True if the lock was acquired;\n        False if it wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.5)\n            True\n            >>> printer_lock_2.release()\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(timeout=.1)\n            False\n            >>> with contextlib.suppress(ReleaseUnlockedLock):\n            ...     printer_lock_1.release()\n\n        If blocking is False and timeout is -1, then try just once right now to\n        acquire the lock.  Return True if the lock was acquired; False if it\n        wasn't.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> printer_lock_2.acquire(blocking=False)\n            False\n            >>> printer_lock_1.release()\n        '''\n        acquire_masters = functools.partial(\n            self.__acquire_masters,\n            raise_on_redis_errors=raise_on_redis_errors,\n        )\n\n        if blocking:\n            enqueued = False\n            with ContextTimer() as timer:\n                while timeout == -1 or timer.elapsed() / 1000 < timeout:\n                    if acquire_masters():\n                        if enqueued:\n                            self.__log_time_enqueued(timer, True)\n                        return True\n                    enqueued = True\n                    delay = random.uniform(0, self._RETRY_DELAY)  # nosec\n                    time.sleep(delay)\n            if enqueued:  # pragma: no cover\n                self.__log_time_enqueued(timer, False)\n            return False  # pragma: no cover\n\n        if timeout == -1:\n            return acquire_masters()\n\n        raise ValueError(\"can't specify a timeout for a non-blocking call\")\n\n    __acquire = acquire\n\n    def __log_time_enqueued(self, timer: ContextTimer, acquired: bool) -> None:\n        key_suffix = self.key.split(':', maxsplit=1)[1]\n        time_enqueued = math.ceil(timer.elapsed())\n        logger.info(\n            'source=pottery sample#redlock.enqueued.%s=%dms sample#redlock.acquired.%s=%d',\n            key_suffix,\n            time_enqueued,\n            key_suffix,\n            acquired,\n        )\n\n    def locked(self, *, raise_on_redis_errors: bool | None = None) -> float:\n        '''How much longer we'll hold the lock (unless we extend or release it).\n\n        If we don't currently hold the lock, then this method returns 0.\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock_1 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_1.locked()\n            0\n\n            >>> printer_lock_2 = Redlock(key='printer', masters={redis})\n            >>> printer_lock_2.acquire()\n            True\n            >>> printer_lock_1.locked()\n            0\n            >>> printer_lock_2.release()\n\n        If we do currently hold the lock, then this method returns the current\n        lease's Time To Live (TTL) in ms.\n\n            >>> printer_lock_1.acquire()\n            True\n            >>> 9 < printer_lock_1.locked() < 10\n            True\n            >>> printer_lock_1.release()\n        '''\n        with ContextTimer() as timer, BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__acquired_master, master)\n                futures.add(future)\n\n            ttls, redis_errors = [], []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    ttl = future.result() / 1000\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.locked() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if ttl:\n                        ttls.append(ttl)\n                        if len(ttls) > len(self.masters) // 2:  # pragma: no cover\n                            validity_time = min(ttls)\n                            validity_time -= self.__drift()\n                            validity_time -= timer.elapsed() / 1000\n                            return max(validity_time, 0)\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        return 0\n\n    def extend(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Extend our hold on the lock (if we currently hold it).\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> printer_lock.acquire()\n            True\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> time.sleep(1)\n            >>> 8 < printer_lock.locked() < 9\n            True\n            >>> printer_lock.extend()\n            >>> 9 < printer_lock.locked() < 10\n            True\n            >>> printer_lock.release()\n        '''\n        if self._extension_num >= self.num_extensions:\n            raise TooManyExtensions(self.key, self.masters)\n\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__extend_master, master)\n                futures.add(future)\n\n            num_masters_extended, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_extended += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.extend() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_extended > len(self.masters) // 2:\n                        self._extension_num += 1\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ExtendUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    def release(self, *, raise_on_redis_errors: bool | None = None) -> None:\n        '''Unlock the lock.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> printer_lock = Redlock(key='printer', masters={redis})\n            >>> bool(printer_lock.locked())\n            False\n            >>> printer_lock.acquire()\n            True\n            >>> bool(printer_lock.locked())\n            True\n            >>> printer_lock.release()\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        with BailOutExecutor() as executor:\n            futures = set()\n            for master in self.masters:\n                future = executor.submit(self.__release_master, master)\n                futures.add(future)\n\n            num_masters_released, redis_errors = 0, []\n            for future in concurrent.futures.as_completed(futures):\n                try:\n                    num_masters_released += future.result()\n                except RedisError as error:\n                    redis_errors.append(error)\n                    logger.exception(\n                        '%s.release() caught %s',\n                        self.__class__.__name__,\n                        error.__class__.__name__,\n                    )\n                else:\n                    if num_masters_released > len(self.masters) // 2:\n                        return\n\n        self._check_enough_masters_up(raise_on_redis_errors, redis_errors)\n        raise ReleaseUnlockedLock(\n            self.key,\n            self.masters,\n            redis_errors=redis_errors,\n        )\n\n    __release = release\n\n    def __enter__(self) -> Redlock:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        acquired = self.__acquire(\n            blocking=self.context_manager_blocking,\n            timeout=self.context_manager_timeout,\n        )\n        if acquired:\n            return self\n        raise QuorumNotAchieved(self.key, self.masters)\n\n    @overload\n    def __exit__(self,\n                 exc_type: None,\n                 exc_value: None,\n                 exc_traceback: None,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    @overload\n    def __exit__(self,\n                 exc_type: Type[BaseException],\n                 exc_value: BaseException,\n                 exc_traceback: TracebackType,\n                 ) -> Literal[False]:\n        raise NotImplementedError\n\n    def __exit__(self,\n                 exc_type: Type[BaseException] | None,\n                 exc_value: BaseException | None,\n                 traceback: TracebackType | None,\n                 ) -> Literal[False]:\n        '''You can use a Redlock as a context manager.\n\n        Usage:\n\n            >>> from redis import Redis\n            >>> redis = Redis()\n            >>> with Redlock(key='printer', masters={redis}) as printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n\n            >>> with printer_lock:\n            ...     # Critical section - print stuff here.\n            ...     print('printer_lock is locked')\n            printer_lock is locked\n            >>> bool(printer_lock.locked())\n            False\n        '''\n        self.__release()\n        return False\n\n    def __repr__(self) -> str:\n        return f'<{self.__class__.__name__} key={self.key}>'\ntests/base.py\nclass TestCase(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls) -> None:\n        logger.setLevel(logging.CRITICAL)\n        warnings.filterwarnings('ignore', category=PotteryWarning)\n\n    def setUp(self) -> None:\n        super().setUp()\n\n        # Choose a random Redis database for this test.\n        self.redis_db = random.randint(1, 15)  # nosec\n        self.redis_url = f'redis://localhost:6379/{self.redis_db}'\n\n        # Set up our Redis clients.\n        self.redis = Redis.from_url(self.redis_url, socket_timeout=1)\n        self.redis_decoded_responses = Redis.from_url(\n            self.redis_url,\n            socket_timeout=1,\n            decode_responses=True,\n        )\n\n        # Clean up the Redis database before and after the test.\n        self.redis.flushdb()\n        self.addCleanup(self.redis.flushdb)\npottery/exceptions.py\nclass QuorumIsImpossible(PrimitiveError, RuntimeError):\n    'Too many Redis masters threw RedisErrors; quorum can not be achieved.'\npottery/redlock.py\ndef synchronize(*,\n                key: str,\n                masters: Iterable[Redis] = frozenset(),\n                raise_on_redis_errors: bool = False,\n                auto_release_time: float = Redlock._AUTO_RELEASE_TIME,\n                blocking: bool = True,\n                timeout: float = -1,\n                ) -> Callable[[F], F]:\n    '''Decorator to synchronize a function's execution across threads.\n\n    synchronize() is a decorator that allows only one thread to execute a\n    function at a time.  Under the hood, synchronize() uses a Redlock.  See\n    help(Redlock) for more details.\n\n    Keyword arguments:\n        key -- a string that identifies your resource\n        masters -- the Redis clients used to achieve quorum for this Redlock's\n            state\n        raise_on_redis_errors -- whether to raise the QuorumIsImplssible\n            exception when too many Redis masters throw errors\n        auto_release_time -- the timeout in seconds by which to automatically\n            release this Redlock, unless it's already been released\n        num_extensions -- the number of times that this Redlock's lease can be\n            extended\n        context_manager_blocking -- when using this Redlock as a context\n            manager, whether to block when acquiring\n        context_manager_timeout -- if context_manager_blocking, how long to wait\n            when acquiring before giving up and raising the QuorumNotAchieved\n            exception\n\n    Usage:\n\n        >>> @synchronize(key='synchronized-func', auto_release_time=1.5)\n        ... def func():\n        ...     # Only one thread can execute this function at a time.\n        ...     return True\n        ...\n        >>> func()\n        True\n    '''\n    RedlockFactory = functools.partial(\n        Redlock,\n        key=key,\n        masters=masters,\n        raise_on_redis_errors=raise_on_redis_errors,\n        auto_release_time=auto_release_time,\n        context_manager_blocking=blocking,\n        context_manager_timeout=timeout,\n    )\n\n    def decorator(func: F) -> F:\n        @functools.wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            redlock = RedlockFactory()\n            waiting_timer, holding_timer = ContextTimer(), ContextTimer()\n\n            try:\n                waiting_timer.start()\n                with redlock:\n                    waiting_timer.stop()\n                    holding_timer.start()\n                    return_value = func(*args, **kwargs)\n                holding_timer.stop()\n            finally:\n                _log_synchronize(func, redlock, waiting_timer, holding_timer)\n\n            return return_value\n        return cast(F, wrapper)\n    return decorator\npottery/exceptions.py\nclass TooManyExtensions(PrimitiveError, RuntimeError):\n    'Redlock has been extended too many times.'\n", "answers": ["        with self.assertRaises(TooManyExtensions):"], "pred": " 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n 1\n ", "length": 2794, "dataset": "repobench-p", "language": "python", "all_classes": null, "_id": "c23c39e861f028aa9df65fe01489651a3c7237aeec7f80b4"}

{"prompt": "Please complete the code given below. \nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Server.Commands;\nusing Server.Engines.PartySystem;\nusing Server.Factions;\nusing Server.Gumps;\nusing Server.Items;\nusing Server.Mobiles;\nusing Server.Network;\nusing Server.Spells;\nusing Server.Spells.Bushido;\nusing Server.Spells.Chivalry;\nusing Server.Spells.Necromancy;\nusing Server.Spells.Ninjitsu;\nusing Server.Spells.Seventh;\nusing Server.Spells.Spellweaving;\nnamespace Server.Engines.ConPVP\n{\n    public delegate void CountdownCallback( int count );\n\tpublic class DuelContext\n\t{\n\t\tprivate Mobile m_Initiator;\n\t\tprivate ArrayList m_Participants;\n\t\tprivate Ruleset m_Ruleset;\n\t\tprivate Arena m_Arena;\n\t\tprivate bool m_Registered = true;\n\t\tprivate bool m_Finished, m_Started;\n\t\tprivate bool m_ReadyWait;\n\t\tprivate int m_ReadyCount;\n\t\tprivate bool m_Rematch;\n\t\tpublic bool Rematch{ get{ return m_Rematch; } }\n\t\tpublic bool ReadyWait{ get{ return m_ReadyWait; } }\n\t\tpublic int ReadyCount{ get{ return m_ReadyCount; } }\n\t\tpublic bool Registered{ get{ return m_Registered; } }\n\t\tpublic bool Finished{ get{ return m_Finished; } }\n\t\tpublic bool Started{ get{ return m_Started; } }\n\t\tpublic Mobile Initiator{ get{ return m_Initiator; } }\n\t\tpublic ArrayList Participants{ get{ return m_Participants; } }\n\t\tpublic Ruleset Ruleset{ get{ return m_Ruleset; } }\n\t\tpublic Arena Arena{ get{ return m_Arena; } }\n\t\tprivate bool CantDoAnything( Mobile mob )\n\t\t{\n\t\t\tif ( m_EventGame != null )\n\t\t\t\treturn m_EventGame.CantDoAnything( mob );\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tpublic static bool IsFreeConsume( Mobile mob )\n\t\t{\n\t\t\tPlayerMobile pm = mob as PlayerMobile;\n\t\t\tif ( pm == null || pm.DuelContext == null || pm.DuelContext.m_EventGame == null )\n\t\t\t\treturn false;\n\t\t\treturn pm.DuelContext.m_EventGame.FreeConsume;\n\t\t}\n\t\tpublic void DelayBounce( TimeSpan ts, Mobile mob, Container corpse )\n\t\t{\n\t\t\tTimer.DelayCall( ts, new TimerStateCallback( DelayBounce_Callback ), new object[]{ mob, corpse } );\n\t\t}\n\t\tpublic static bool AllowSpecialMove( Mobile from, string name, SpecialMove move )\n\t\t{\n\t\t\tPlayerMobile pm = from as PlayerMobile;\n\t\t\tif( pm == null )\n\t\t\t\treturn true;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\treturn (dc == null || dc.InstAllowSpecialMove( from, name, move ));\n\t\t}\n\t\tpublic bool InstAllowSpecialMove( Mobile from, string name, SpecialMove move )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tstring title = null;\n\t\t\tif( move is NinjaMove )\n\t\t\t\ttitle = \"Bushido\";\n\t\t\telse if( move is SamuraiMove )\n\t\t\t\ttitle = \"Ninjitsu\";\n\t\t\tif ( title == null || name == null || m_Ruleset.GetOption( title, name ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this move.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowSpellCast( Mobile from, Spell spell )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tif ( spell is Server.Spells.Fourth.RecallSpell )\n\t\t\t\tfrom.SendMessage( \"You may not cast this spell.\" );\n\t\t\tstring title = null, option = null;\n\t\t\tif( spell is ArcanistSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Spellweaving\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is PaladinSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Chivalry\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is NecromancerSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Necromancy\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is NinjaSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Ninjitsu\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is SamuraiSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Bushido\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if( spell is MagerySpell )\n\t\t\t{\n\t\t\t\tswitch( ((MagerySpell)spell).Circle )\n\t\t\t\t{\n\t\t\t\t\tcase SpellCircle.First: title = \"1st Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Second: title = \"2nd Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Third: title = \"3rd Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Fourth: title = \"4th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Fifth: title = \"5th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Sixth: title = \"6th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Seventh: title = \"7th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Eighth: title = \"8th Circle\"; break;\n\t\t\t\t}\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttitle = \"Other Spell\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\tif ( title == null || option == null || m_Ruleset.GetOption( title, option ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from casting this spell.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowItemEquip( Mobile from, Item item )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( item is Dagger || CheckItemEquip( from, item ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from equiping this item.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic static bool AllowSpecialAbility( Mobile from, string name, bool message )\n\t\t{\n\t\t\tPlayerMobile pm = from as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn true;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\treturn ( dc == null || dc.InstAllowSpecialAbility( from, name, message ) );\n\t\t}\n\t\tpublic bool InstAllowSpecialAbility( Mobile from, string name, bool message )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tif ( m_Ruleset.GetOption( \"Combat Abilities\", name ) )\n\t\t\t\treturn true;\n\t\t\tif ( message )\n\t\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this combat ability.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool CheckItemEquip( Mobile from, Item item )\n\t\t{\n\t\t\tif ( item is Fists )\n\t\t\t{\n\t\t\t\tif ( !m_Ruleset.GetOption( \"Weapons\", \"Wrestling\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BaseArmor )\n\t\t\t{\n\t\t\t\tBaseArmor armor = (BaseArmor)item;\n\t\t\t\tif ( armor.ProtectionLevel > ArmorProtectionLevel.Regular && !m_Ruleset.GetOption( \"Armor\", \"Magical\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !Core.AOS && armor.Resource != armor.DefaultResource && !m_Ruleset.GetOption( \"Armor\", \"Colored\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( armor is BaseShield && !m_Ruleset.GetOption( \"Armor\", \"Shields\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BaseWeapon )\n\t\t\t{\n\t\t\t\tBaseWeapon weapon = (BaseWeapon)item;\n\t\t\t\tif ( (weapon.DamageLevel > WeaponDamageLevel.Regular || weapon.AccuracyLevel > WeaponAccuracyLevel.Regular) && !m_Ruleset.GetOption( \"Weapons\", \"Magical\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !Core.AOS && weapon.Resource != CraftResource.Iron && weapon.Resource != CraftResource.None && !m_Ruleset.GetOption( \"Weapons\", \"Runics\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon is BaseRanged && !m_Ruleset.GetOption( \"Weapons\", \"Ranged\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !(weapon is BaseRanged) && !m_Ruleset.GetOption( \"Weapons\", \"Melee\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon.PoisonCharges > 0 && weapon.Poison != null && !m_Ruleset.GetOption( \"Weapons\", \"Poisoned\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon is BaseWand && !m_Ruleset.GetOption( \"Items\", \"Wands\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tpublic bool AllowSkillUse( Mobile from, SkillName skill )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tint id = (int)skill;\n\t\t\tif ( id >= 0 && id < SkillInfo.Table.Length )\n\t\t\t{\n\t\t\t\tif ( m_Ruleset.GetOption( \"Skills\", SkillInfo.Table[id].Name ) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this skill.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowItemUse( Mobile from, Item item )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( !(item is BaseRefreshPotion) )\n\t\t\t{\n\t\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstring title = null, option = null;\n\t\t\tif ( item is BasePotion )\n\t\t\t{\n\t\t\t\ttitle = \"Potions\";\n\t\t\t\tif ( item is BaseAgilityPotion )\n\t\t\t\t\toption = \"Agility\";\n\t\t\t\telse if ( item is BaseCurePotion )\n\t\t\t\t\toption = \"Cure\";\n\t\t\t\telse if ( item is BaseHealPotion )\n\t\t\t\t\toption = \"Heal\";\n\t\t\t\telse if ( item is NightSightPotion )\n\t\t\t\t\toption = \"Nightsight\";\n\t\t\t\telse if ( item is BasePoisonPotion )\n\t\t\t\t\toption = \"Poison\";\n\t\t\t\telse if ( item is BaseStrengthPotion )\n\t\t\t\t\toption = \"Strength\";\n\t\t\t\telse if ( item is BaseExplosionPotion )\n\t\t\t\t\toption = \"Explosion\";\n\t\t\t\telse if ( item is BaseRefreshPotion )\n\t\t\t\t\toption = \"Refresh\";\n\t\t\t}\n\t\t\telse if ( item is Bandage )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Bandages\";\n\t\t\t}\n\t\t\telse if ( item is TrapableContainer )\n\t\t\t{\n\t\t\t\tif ( ((TrapableContainer)item).TrapType != TrapType.None )\n\t\t\t\t{\n\t\t\t\t\ttitle = \"Items\";\n\t\t\t\t\toption = \"Trapped Containers\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( item is Bola )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Bolas\";\n\t\t\t}\n\t\t\telse if ( item is OrangePetals )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Orange Petals\";\n\t\t\t}\n\t\t\telse if ( item is EtherealMount || item.Layer == Layer.Mount )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Mounts\";\n\t\t\t}\n\t\t\telse if ( item is LeatherNinjaBelt )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Shurikens\";\n\t\t\t}\n\t\t\telse if ( item is Fukiya )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Fukiya Darts\";\n\t\t\t}\n\t\t\telse if ( item is FireHorn )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Fire Horns\";\n\t\t\t}\n\t\t\telse if ( item is BaseWand )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Wands\";\n\t\t\t}\n\t\t\tif ( title != null && option != null && m_StartedBeginCountdown && !m_Started )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( \"You may not use this item before the duel begins.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BasePotion && !(item is BaseExplosionPotion) && !(item is BaseRefreshPotion) && IsSuddenDeath )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( 0x22, \"You may not drink potions in sudden death.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is Bandage && IsSuddenDeath )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( 0x22, \"You may not use bandages in sudden death.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( title == null || option == null || m_Ruleset.GetOption( title, option ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this item.\" );\n\t\t\treturn false;\n\t\t}\n\t\tprivate void DelayBounce_Callback( object state )\n\t\t{\n\t\t\tobject[] states = (object[])state;\n\t\t\tMobile mob = (Mobile) states[0];\n\t\t\tContainer corpse = (Container) states[1];\n\t\t\tRemoveAggressions( mob );\n\t\t\tSendOutside( mob );\n\t\t\tRefresh( mob, corpse );\n\t\t\tDebuff( mob );\n\t\t\tCancelSpell( mob );\n\t\t\tmob.Frozen = false;\n\t\t}\n\t\tpublic void OnMapChanged( Mobile mob )\n\t\t{\n\t\t\tOnLocationChanged( mob );\n\t\t}\n\t\tpublic void OnLocationChanged( Mobile mob )\n\t\t{\n\t\t\tif ( !m_Registered || !m_StartedBeginCountdown || m_Finished )\n\t\t\t\treturn;\n\t\t\tArena arena = m_Arena;\n\t\t\tif ( arena == null )\n\t\t\t\treturn;\n\t\t\tif ( mob.Map == arena.Facet && arena.Bounds.Contains( mob.Location ) )\n\t\t\t\treturn;\n\t\t\tDuelPlayer pl = Find( mob );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn;\n\t\t\tif ( mob.Map == Map.Internal ) {\n\t\t\t\t// they've logged out\n\t\t\t\tif ( mob.LogoutMap == arena.Facet && arena.Bounds.Contains( mob.LogoutLocation ) ) {\n\t\t\t\t\t// they logged out inside the arena.. set them to eject on login\n\t\t\t\t\tmob.LogoutLocation = arena.Outside;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpl.Eliminated = true;\n\t\t\tmob.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have forfeited your position in the duel.\" );\n\t\t\tmob.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has forfeited by leaving the dueling arena.\", mob.Name ) );\n\t\t\tParticipant winner = CheckCompletion();\n\t\t\tif ( winner != null )\n\t\t\t\tFinish( winner );\n\t\t}\n\t\tprivate bool m_Yielding;\n\t\tpublic void OnDeath( Mobile mob, Container corpse )\n\t\t{\n\t\t\tif ( !m_Registered || !m_Started )\n\t\t\t\treturn;\n\t\t\tDuelPlayer pl = Find( mob );\n\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t{\n\t\t\t\tif ( m_EventGame != null && !m_EventGame.OnDeath( mob, corpse ) )\n\t\t\t\t\treturn;\n\t\t\t\tpl.Eliminated = true;\n\t\t\t\tif ( mob.Poison != null )\n\t\t\t\t\tmob.Poison = null;\n\t\t\t\tRequip( mob, corpse );\n\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 4.0 ), mob, corpse );\n\t\t\t\tParticipant winner = CheckCompletion();\n\t\t\t\tif ( winner != null )\n\t\t\t\t{\n\t\t\t\t\tFinish( winner );\n\t\t\t\t}\n\t\t\t\telse if ( !m_Yielding )\n\t\t\t\t{\n\t\t\t\t\tmob.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have been defeated.\" );\n\t\t\t\t\tmob.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has been defeated.\", mob.Name ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic bool CheckFull()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.HasOpenSlot )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tpublic void Requip( Mobile from, Container cont )\n\t\t{\n\t\t\tCorpse corpse = cont as Corpse;\n\t\t\tif ( corpse == null )\n\t\t\t\treturn;\n\t\t\tList<Item> items = new List<Item>( corpse.Items );\n\t\t\tbool gathered = false;\n\t\t\tbool didntFit = false;\n\t\t\tContainer pack = from.Backpack;\n\t\t\tfor ( int i = 0; !didntFit && i < items.Count; ++i )\n\t\t\t{\n\t\t\t\tItem item = items[i];\n\t\t\t\tPoint3D loc = item.Location;\n\t\t\t\tif ( (item.Layer == Layer.Hair || item.Layer == Layer.FacialHair) || !item.Movable )\n\t\t\t\t\tcontinue;\n\t\t\t\tif ( pack != null )\n\t\t\t\t{\n\t\t\t\t\tpack.DropItem( item );\n\t\t\t\t\tgathered = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdidntFit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcorpse.Carved = true;\n\t\t\tif ( corpse.ItemID == 0x2006 )\n\t\t\t{\n\t\t\t\tcorpse.ProcessDelta();\n\t\t\t\tcorpse.SendRemovePacket();\n\t\t\t\tcorpse.ItemID = Utility.Random( 0xECA, 9 ); // bone graphic\n\t\t\t\tcorpse.Hue = 0;\n\t\t\t\tcorpse.ProcessDelta();\n\t\t\t\tMobile killer = from.FindMostRecentDamager( false );\n\t\t\t\tif ( killer != null && killer.Player )\n\t\t\t\t\tkiller.AddToBackpack( new Head( m_Tournament == null ? HeadType.Duel : HeadType.Tournament, from.Name ) );\n\t\t\t}\n\t\t\tfrom.PlaySound( 0x3E3 );\n\t\t\tif ( gathered && !didntFit )\n\t\t\t\tfrom.SendLocalizedMessage( 1062471 ); // You quickly gather all of your belongings.\n\t\t\telse if ( gathered && didntFit )\n\t\t\t\tfrom.SendLocalizedMessage( 1062472 ); // You gather some of your belongings. The rest remain on the corpse.\n\t\t}\n\t\tpublic void Refresh( Mobile mob, Container cont )\n\t\t{\n\t\t\tif ( !mob.Alive )\n\t\t\t{\n\t\t\t\tmob.Resurrect();\n\t\t\t\tDeathRobe robe = mob.FindItemOnLayer( Layer.OuterTorso ) as DeathRobe;\n\t\t\t\tif ( robe != null )\n\t\t\t\t\trobe.Delete();\n\t\t\t\tif ( cont is Corpse )\n\t\t\t\t{\n\t\t\t\t\tCorpse corpse = (Corpse) cont;\n\t\t\t\t\tfor ( int i = 0; i < corpse.EquipItems.Count; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = corpse.EquipItems[i];\n\t\t\t\t\t\tif ( item.Movable && item.Layer != Layer.Hair && item.Layer != Layer.FacialHair && item.IsChildOf( mob.Backpack ) )\n\t\t\t\t\t\t\tmob.EquipItem( item );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmob.Hits = mob.HitsMax;\n\t\t\tmob.Stam = mob.StamMax;\n\t\t\tmob.Mana = mob.ManaMax;\n\t\t\tmob.Poison = null;\n\t\t}\n\t\tpublic void SendOutside( Mobile mob )\n\t\t{\n\t\t\tif ( m_Arena == null )\n\t\t\t\treturn;\n\t\t\tmob.Combatant = null;\n\t\t\tmob.MoveToWorld( m_Arena.Outside, m_Arena.Facet );\n\t\t}\n\t\tprivate Point3D m_GatePoint;\n\t\tprivate Map m_GateFacet;\n\t\tpublic void Finish( Participant winner )\n\t\t{\n\t\t\tif ( m_Finished )\n\t\t\t\treturn;\n\t\t\tEndAutoTie();\n\t\t\tStopSDTimers();\n\t\t\tm_Finished = true;\n\t\t\tfor ( int i = 0; i < winner.Players.Length; ++i )\n\t\t\t{\n\t\t\t\tDuelPlayer pl = winner.Players[i];\n\t\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 8.0 ), pl.Mobile, null );\n\t\t\t}\n\t\t\twinner.Broadcast( 0x59, null, winner.Players.Length == 1 ? \"{0} has won the duel.\" : \"{0} and {1} team have won the duel.\", winner.Players.Length == 1 ? \"You have won the duel.\" : \"Your team has won the duel.\" );\n\t\t\tif ( m_Tournament != null && winner.TournyPart != null )\n\t\t\t{\n\t\t\t\tm_Match.Winner = winner.TournyPart;\n\t\t\t\twinner.TournyPart.WonMatch( m_Match );\n\t\t\t\tm_Tournament.HandleWon( m_Arena, m_Match, winner.TournyPart );\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant loser = (Participant)m_Participants[i];\n\t\t\t\tif ( loser != winner )\n\t\t\t\t{\n\t\t\t\t\tloser.Broadcast( 0x22, null, loser.Players.Length == 1 ? \"{0} has lost the duel.\" : \"{0} and {1} team have lost the duel.\", loser.Players.Length == 1 ? \"You have lost the duel.\" : \"Your team has lost the duel.\" );\n\t\t\t\t\tif ( m_Tournament != null && loser.TournyPart != null )\n\t\t\t\t\t\tloser.TournyPart.LostMatch( m_Match );\n\t\t\t\t}\n\t\t\t\tfor ( int j = 0; j < loser.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tif ( loser.Players[j] != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveAggressions( loser.Players[j].Mobile );\n\t\t\t\t\t\tloser.Players[j].Mobile.Delta( MobileDelta.Noto );\n\t\t\t\t\t\tloser.Players[j].Mobile.CloseGump( typeof( BeginGump ) );\n\t\t\t\t\t\tif ( m_Tournament != null )\n\t\t\t\t\t\t\tloser.Players[j].Mobile.SendEverything();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( IsOneVsOne )\n\t\t\t{\n\t\t\t\tDuelPlayer dp1 = ((Participant)m_Participants[0]).Players[0];\n\t\t\t\tDuelPlayer dp2 = ((Participant)m_Participants[1]).Players[0];\n\t\t\t\tif ( dp1 != null && dp2 != null )\n\t\t\t\t{\n\t\t\t\t\tAward( dp1.Mobile, dp2.Mobile, dp1.Participant == winner );\n\t\t\t\t\tAward( dp2.Mobile, dp1.Mobile, dp2.Participant == winner );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_EventGame != null )\n\t\t\t\tm_EventGame.OnStop();\n\t\t\tTimer.DelayCall( TimeSpan.FromSeconds( 9.0 ), new TimerCallback( UnregisterRematch ) );\n\t\t}\n\t\tpublic void Award( Mobile us, Mobile them, bool won )\n\t\t{\n\t\t\tLadder ladder = ( m_Arena == null ? Ladder.Instance : m_Arena.AcquireLadder() );\n\t\t\tif ( ladder == null )\n\t\t\t\treturn;\n\t\t\tLadderEntry ourEntry = ladder.Find( us );\n\t\t\tLadderEntry theirEntry = ladder.Find( them );\n\t\t\tif ( ourEntry == null || theirEntry == null )\n\t\t\t\treturn;\n\t\t\tint xpGain = Ladder.GetExperienceGain( ourEntry, theirEntry, won );\n\t\t\tif ( xpGain == 0 )\n\t\t\t\treturn;\n\t\t\tif ( m_Tournament != null )\n\t\t\t\txpGain *= ( xpGain > 0 ? 5 : 2 );\n\t\t\tif ( won )\n\t\t\t\t++ourEntry.Wins;\n\t\t\telse\n\t\t\t\t++ourEntry.Losses;\n\t\t\tint oldLevel = Ladder.GetLevel( ourEntry.Experience );\n\t\t\tourEntry.Experience += xpGain;\n\t\t\tif ( ourEntry.Experience < 0 )\n\t\t\t\tourEntry.Experience = 0;\n\t\t\tladder.UpdateEntry( ourEntry );\n\t\t\tint newLevel = Ladder.GetLevel( ourEntry.Experience );\n\t\t\tif ( newLevel > oldLevel )\n\t\t\t\tus.SendMessage( 0x59, \"You have achieved level {0}!\", newLevel );\n\t\t\telse if ( newLevel < oldLevel )\n\t\t\t\tus.SendMessage( 0x22, \"You have lost a level. You are now at {0}.\", newLevel );\n\t\t}\n\t\tpublic void UnregisterRematch()\n\t\t{\n\t\t\tUnregister(true);\n\t\t}\n\t\tpublic void Unregister()\n\t\t{\n\t\t\tUnregister(false);\n\t\t}\n\t\tpublic void Unregister( bool queryRematch )\n\t\t{\n\t\t\tDestroyWall();\n\t\t\tif ( !m_Registered )\n\t\t\t\treturn;\n\t\t\tm_Registered = false;\n\t\t\tif ( m_Arena != null )\n\t\t\t\tm_Arena.Evict();\n\t\t\tStopSDTimers();\n\t\t\tType[] types = new Type[]{ typeof( BeginGump ), typeof( DuelContextGump ), typeof( ParticipantGump ), typeof( PickRulesetGump ), typeof( ReadyGump ), typeof( ReadyUpGump ), typeof( RulesetGump ) };\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = (DuelPlayer)p.Players[j];\n\t\t\t\t\tif ( pl == null )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( pl.Mobile is PlayerMobile )\n\t\t\t\t\t\t((PlayerMobile)pl.Mobile).DuelPlayer = null;\n\t\t\t\t\tfor ( int k = 0; k < types.Length; ++k )\n\t\t\t\t\t\tpl.Mobile.CloseGump( types[k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( queryRematch && m_Tournament == null )\n\t\t\t\tQueryRematch();\n\t\t}\n\t\tpublic void QueryRematch()\n\t\t{\n\t\t\tDuelContext dc = new DuelContext( m_Initiator, m_Ruleset.Layout, false );\n\t\t\tdc.m_Ruleset = m_Ruleset;\n\t\t\tdc.m_Rematch = true;\n\t\t\tdc.m_Participants.Clear();\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant oldPart = (Participant)m_Participants[i];\n\t\t\t\tParticipant newPart = new Participant( dc, oldPart.Players.Length );\n\t\t\t\tfor ( int j = 0; j < oldPart.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer oldPlayer = oldPart.Players[j];\n\t\t\t\t\tif ( oldPlayer != null )\n\t\t\t\t\t\tnewPart.Players[j] = new DuelPlayer( oldPlayer.Mobile, newPart );\n\t\t\t\t}\n\t\t\t\tdc.m_Participants.Add( newPart );\n\t\t\t}\n\t\t\tdc.CloseAllGumps();\n\t\t\tdc.SendReadyUpGump();\n\t\t}\n\t\tpublic DuelPlayer Find( Mobile mob )\n\t\t{\n\t\t\tif ( mob is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)mob;\n\t\t\t\tif ( pm.DuelContext == this )\n\t\t\t\t\treturn pm.DuelPlayer;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tDuelPlayer pl = p.Find( mob );\n\t\t\t\tif ( pl != null )\n\t\t\t\t\treturn pl;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tpublic bool IsAlly( Mobile m1, Mobile m2 )\n\t\t{\n\t\t\tDuelPlayer pl1 = Find( m1 );\n\t\t\tDuelPlayer pl2 = Find( m2 );\n\t\t\treturn ( pl1 != null && pl2 != null && pl1.Participant == pl2.Participant );\n\t\t}\n\t\tpublic Participant CheckCompletion()\n\t\t{\n\t\t\tParticipant winner = null;\n\t\t\tbool hasWinner = false;\n\t\t\tint eliminated = 0;\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.Eliminated )\n\t\t\t\t{\n\t\t\t\t\t++eliminated;\n\t\t\t\t\tif ( eliminated == (m_Participants.Count - 1) )\n\t\t\t\t\t\thasWinner = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twinner = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( hasWinner )\n\t\t\t\treturn winner == null ? (Participant) m_Participants[0] : winner;\n\t\t\treturn null;\n\t\t}\n\t\tprivate Timer m_Countdown;\n\t\tpublic void StartCountdown( int count, CountdownCallback cb )\n\t\t{\n\t\t\tcb(count);\n\t\t\tm_Countdown=Timer.DelayCall( TimeSpan.FromSeconds( 1.0 ), TimeSpan.FromSeconds( 1.0 ), count, new TimerStateCallback( Countdown_Callback ), new object[]{ count-1, cb } );\n\t\t}\n\t\tpublic void StopCountdown()\n\t\t{\n\t\t\tif ( m_Countdown != null )\n\t\t\t\tm_Countdown.Stop();\n\t\t\tm_Countdown = null;\n\t\t}\n\t\tprivate void Countdown_Callback( object state )\n\t\t{\n\t\t\tobject[] states = (object[])state;\n\t\t\tint count = (int)states[0];\n\t\t\tCountdownCallback cb = (CountdownCallback)states[1];\n\t\t\tif ( count==0 )\n\t\t\t{\n\t\t\t\tif ( m_Countdown != null )\n\t\t\t\t\tm_Countdown.Stop();\n\t\t\t\tm_Countdown=null;\n\t\t\t}\n\t\t\tcb( count );\n\t\t\tstates[0] = count - 1;\n\t\t}\n\t\tprivate Timer m_AutoTieTimer;\n\t\tprivate bool m_Tied;\n\t\tpublic bool Tied{ get{ return m_Tied; } }\n\t\tprivate bool m_IsSuddenDeath;\n\t\tpublic bool IsSuddenDeath{ get{ return m_IsSuddenDeath; } set{ m_IsSuddenDeath = value; } }\n\t\tprivate Timer m_SDWarnTimer, m_SDActivateTimer;\n\t\tpublic void StopSDTimers()\n\t\t{\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = null;\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = null;\n\t\t}\n\t\tpublic void StartSuddenDeath( TimeSpan timeUntilActive )\n\t\t{\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = Timer.DelayCall( TimeSpan.FromMinutes( timeUntilActive.TotalMinutes * 0.9 ), new TimerCallback( WarnSuddenDeath ) );\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = Timer.DelayCall( timeUntilActive, new TimerCallback( ActivateSuddenDeath ) );\n\t\t}\n\t\tpublic void WarnSuddenDeath()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpl.Mobile.SendSound( 0x1E1 );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Warning! Warning! Warning!\" );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Sudden death will be active soon!\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.Alert( m_Arena, \"Sudden death will be active soon!\" );\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = null;\n\t\t}\n\t\tpublic static bool CheckSuddenDeath( Mobile mob )\n\t\t{\n\t\t\tif ( mob is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)mob;\n\t\t\t\tif ( pm.DuelPlayer != null && !pm.DuelPlayer.Eliminated && pm.DuelContext != null && pm.DuelContext.IsSuddenDeath )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic void ActivateSuddenDeath()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpl.Mobile.SendSound( 0x1E1 );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Warning! Warning! Warning!\" );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Sudden death has ACTIVATED. You are now unable to perform any beneficial actions.\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.Alert( m_Arena, \"Sudden death has been activated!\" );\n\t\t\tm_IsSuddenDeath = true;\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = null;\n\t\t}\n\t\tpublic void BeginAutoTie()\n\t\t{\n\t\t\tif ( m_AutoTieTimer != null )\n\t\t\t\tm_AutoTieTimer.Stop();\n\t\t\tTimeSpan ts = ( m_Tournament == null || m_Tournament.TournyType == TournyType.Standard )\n\t\t\t\t? AutoTieDelay\n\t\t\t\t: TimeSpan.FromMinutes( 90.0 );\n\t\t\tm_AutoTieTimer = Timer.DelayCall( ts, new TimerCallback( InvokeAutoTie ) );\n\t\t}\n\t\tpublic void EndAutoTie()\n\t\t{\n\t\t\tif ( m_AutoTieTimer != null )\n\t\t\t\tm_AutoTieTimer.Stop();\n\t\t\tm_AutoTieTimer = null;\n\t\t}\n\t\tpublic void InvokeAutoTie()\n\t\t{\n\t\t\tm_AutoTieTimer = null;\n\t\t\tif ( !m_Started || m_Finished )\n\t\t\t\treturn;\n\t\t\tm_Tied = true;\n\t\t\tm_Finished = true;\n\t\t\tStopSDTimers();\n\t\t\tArrayList remaining = new ArrayList();\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.Eliminated )\n\t\t\t\t{\n\t\t\t\t\tp.Broadcast( 0x22, null, p.Players.Length == 1 ? \"{0} has lost the duel.\" : \"{0} and {1} team have lost the duel.\", p.Players.Length == 1 ? \"You have lost the duel.\" : \"Your team has lost the duel.\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp.Broadcast( 0x59, null, p.Players.Length == 1 ? \"{0} has tied the duel due to time expiration.\" : \"{0} and {1} team have tied the duel due to time expiration.\", p.Players.Length == 1 ? \"You have tied the duel due to time expiration.\" : \"Your team has tied the duel due to time expiration.\" );\n\t\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t\t{\n\t\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 8.0 ), pl.Mobile, null );\n\t\t\t\t\t}\n\t\t\t\t\tif ( p.TournyPart != null )\n\t\t\t\t\t\tremaining.Add( p.TournyPart );\n\t\t\t\t}\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tpl.Mobile.Delta( MobileDelta.Noto );\n\t\t\t\t\t\tpl.Mobile.SendEverything();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.HandleTie( m_Arena, m_Match, remaining );\n\t\t\tTimer.DelayCall( TimeSpan.FromSeconds( 10.0 ), new TimerCallback( Unregister ) );\n\t\t}\n\t\tpublic bool IsOneVsOne\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif ( m_Participants.Count != 2 )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( ((Participant)m_Participants[0]).Players.Length != 1 )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( ((Participant)m_Participants[1]).Players.Length != 1 )\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpublic static void Initialize()\n\t\t{\n\t\t\tEventSink.Speech += new SpeechEventHandler( EventSink_Speech );\n\t\t\tEventSink.Login += new LoginEventHandler( EventSink_Login );\n\t\t\tCommandSystem.Register( \"vli\", AccessLevel.GameMaster, new CommandEventHandler( vli_oc ) );\n\t\t}\n\t\tprivate static void vli_oc( CommandEventArgs e )\n\t\t{\n\t\t\te.Mobile.BeginTarget( -1, false, Targeting.TargetFlags.None, new TargetCallback( vli_ot ) );\n\t\t}\n\t\tprivate static void vli_ot( Mobile from, object obj )\n\t\t{\n\t\t\tif ( obj is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)obj;\n\t\t\t\tLadder ladder = Ladder.Instance;\n\t\t\t\tif ( ladder == null )\n\t\t\t\t\treturn;\n\t\t\t\tLadderEntry entry = ladder.Find( pm );\n\t\t\t\tif ( entry != null )\n\t\t\t\t\tfrom.SendGump( new PropertiesGump( from, entry ) );\n\t\t\t}\n\t\t}\n\t\tprivate static TimeSpan CombatDelay = TimeSpan.FromSeconds( 30.0 );\n\t\tprivate static TimeSpan AutoTieDelay = TimeSpan.FromMinutes( 15.0 );\n\t\tpublic static bool CheckCombat( Mobile m )\n\t\t{\n\t\t\tfor ( int i = 0; i < m.Aggressed.Count; ++i )\n\t\t\t{\n\t\t\t\tAggressorInfo info = m.Aggressed[i];\n\t\t\t\tif ( info.Defender.Player && (DateTime.UtcNow - info.LastCombatTime) < CombatDelay )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m.Aggressors.Count; ++i )\n\t\t\t{\n\t\t\t\tAggressorInfo info = m.Aggressors[i];\n\t\t\t\tif ( info.Attacker.Player && (DateTime.UtcNow - info.LastCombatTime) < CombatDelay )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tprivate static void EventSink_Login( LoginEventArgs e )\n\t\t{\n\t\t\tPlayerMobile pm = e.Mobile as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\tif ( dc == null )\n\t\t\t\treturn;\n\t\t\tif ( dc.ReadyWait && pm.DuelPlayer.Ready && !dc.Started && !dc.StartedBeginCountdown && !dc.Finished )\n\t\t\t{\n\t\t\t\tif ( dc.m_Tournament == null )\n\t\t\t\t\tpm.SendGump( new ReadyGump( pm, dc, dc.m_ReadyCount ) );\n\t\t\t}\n\t\t\telse if ( dc.ReadyWait && !dc.StartedBeginCountdown && !dc.Started && !dc.Finished )\n\t\t\t{\n\t\t\t\tif ( dc.m_Tournament == null )\n\t\t\t\t\tpm.SendGump( new ReadyUpGump( pm, dc ) );\n\t\t\t}\n\t\t\telse if ( dc.Initiator == pm && !dc.ReadyWait && !dc.StartedBeginCountdown && !dc.Started && !dc.Finished )\n\t\t\t\tpm.SendGump( new DuelContextGump( pm, dc ) );\n\t\t}\n\t\tprivate static void ViewLadder_OnTarget( Mobile from, object obj, object state )\n\t\t{\n\t\t\tif ( obj is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)obj;\n\t\t\t\tLadder ladder = (Ladder)state;\n\t\t\t\tLadderEntry entry = ladder.Find( pm );\n\t\t\t\tif ( entry == null )\n\t\t\t\t\treturn; // sanity\n\t\t\t\tstring text = String.Format( \"{{0}} are ranked {0} at level {1}.\", LadderGump.Rank( entry.Index + 1 ), Ladder.GetLevel( entry.Experience ) );\n\t\t\t\tpm.PrivateOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, from==pm?\"You\":\"They\" ), from.NetState );\n\t\t\t}\n\t\t\telse if ( obj is Mobile )\n\t\t\t{\n\t\t\t\tMobile mob = (Mobile)obj;\n\t\t\t\tif ( mob.Body.IsHuman )\n\t\t\t\t\tmob.PrivateOverheadMessage( MessageType.Regular, mob.SpeechHue, false, \"I'm not a duelist, and quite frankly, I resent the implication.\", from.NetState );\n\t\t\t\telse\n\t\t\t\t\tmob.PrivateOverheadMessage( MessageType.Regular, 0x3B2, true, \"It's probably better than you.\", from.NetState );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfrom.SendMessage( \"That's not a player.\" );\n\t\t\t}\n\t\t}\n\t\tprivate static void EventSink_Speech( SpeechEventArgs e )\n\t\t{\n\t\t\tif ( e.Handled )\n\t\t\t\treturn;\n\t\t\tPlayerMobile pm = e.Mobile as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn;\n\t\t\tif ( Insensitive.Contains( e.Speech, \"i wish to duel\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.Region.IsPartOf( typeof( Regions.Jail ) ) )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( CheckCombat( pm ) )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have recently been in combat with another player and must wait before starting a duel.\" );\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext != null )\n\t\t\t\t{\n\t\t\t\t\tif ( pm.DuelContext.Initiator == pm )\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already started a duel.\" );\n\t\t\t\t\telse\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already been challenged in a duel.\" );\n\t\t\t\t}\n\t\t\t\telse if ( TournamentController.IsActive )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You may not start a duel while a tournament is active.\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpm.SendGump( new DuelContextGump( pm, new DuelContext( pm, RulesetLayout.Root ) ) );\n\t\t\t\t\te.Handled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"change arena preferences\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPreferences prefs = Preferences.Instance;\n\t\t\t\t\tif ( prefs != null )\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.CloseGump( typeof( PreferencesGump ) );\n\t\t\t\t\t\te.Mobile.SendGump( new PreferencesGump( e.Mobile, prefs ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"showladder\" ) )\n\t\t\t{\n\t\t\t\te.Blocked=true;\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLadder instance = Ladder.Instance;\n\t\t\t\t\tif ( instance == null )\n\t\t\t\t\t{\n\t\t\t\t\t\t//pm.SendMessage( \"Ladder not yet initialized.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLadderEntry entry = instance.Find( pm );\n\t\t\t\t\t\tif ( entry == null )\n\t\t\t\t\t\t\treturn; // sanity\n\t\t\t\t\t\tstring text = String.Format( \"{{0}} {{1}} ranked {0} at level {1}.\", LadderGump.Rank( entry.Index + 1 ), Ladder.GetLevel( entry.Experience ) );\n\t\t\t\t\t\tpm.LocalOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, \"You\", \"are\" ) );\n\t\t\t\t\t\tpm.NonlocalOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, pm.Name, \"is\" ) );\n\t\t\t\t\t\t//pm.PublicOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( \"Level {0} with {1} win{2} and {3} loss{4}.\", Ladder.GetLevel( entry.Experience ), entry.Wins, entry.Wins==1?\"\":\"s\", entry.Losses, entry.Losses==1?\"\":\"es\" ) );\n\t\t\t\t\t\t//pm.PublicOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( \"Level {0} with {1} win{2} and {3} loss{4}.\", Ladder.GetLevel( entry.Experience ), entry.Wins, entry.Wins==1?\"\":\"s\", entry.Losses, entry.Losses==1?\"\":\"es\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"viewladder\" ) )\n\t\t\t{\n\t\t\t\te.Blocked=true;\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLadder instance = Ladder.Instance;\n\t\t\t\t\tif ( instance == null )\n\t\t\t\t\t{\n\t\t\t\t\t\t//pm.SendMessage( \"Ladder not yet initialized.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpm.SendMessage( \"Target a player to view their ranking and level.\" );\n\t\t\t\t\t\tpm.BeginTarget( 16, false, Targeting.TargetFlags.None, new TargetStateCallback( ViewLadder_OnTarget ), instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Contains( e.Speech, \"i yield\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext == null )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext.Finished )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"The duel is already finished.\" );\n\t\t\t\t}\n\t\t\t\telse if ( !pm.DuelContext.Started )\n\t\t\t\t{\n\t\t\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\t\t\tMobile init = dc.Initiator;\n\t\t\t\t\tif ( pm.DuelContext.StartedBeginCountdown )\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"The duel has not yet started.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDuelPlayer pl = pm.DuelContext.Find( pm );\n\t\t\t\t\t\tif ( pl == null )\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tParticipant p = pl.Participant;\n\t\t\t\t\t\tif ( !pm.DuelContext.ReadyWait ) // still setting stuff up\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( !pm.DuelContext.StartedReadyCountdown ) // at ready stage\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tdc.m_Yielding=true;\n\t\t\t\t\t\t\tdc.RejectReady( pm, null );\n\t\t\t\t\t\t\tdc.m_Yielding=false;\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ( dc.m_Registered )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbool send=true;\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( send )\n\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( pm.DuelContext.m_Countdown != null )\n\t\t\t\t\t\t\t\tpm.DuelContext.m_Countdown.Stop();\n\t\t\t\t\t\t\tpm.DuelContext.m_Countdown= null;\n\t\t\t\t\t\t\tpm.DuelContext.m_StartedReadyCountdown=false;\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tdc.m_Yielding=true;\n\t\t\t\t\t\t\tdc.RejectReady( pm, null );\n\t\t\t\t\t\t\tdc.m_Yielding=false;\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ( dc.m_Registered )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbool send=true;\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( send )\n\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = pm.DuelContext.Find( pm );\n\t\t\t\t\tif ( pl != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( pm.DuelContext.IsOneVsOne )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You may not yield a 1 on 1 match.\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( pl.Eliminated )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already been eliminated.\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpm.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have yielded.\" );\n\t\t\t\t\t\t\tpm.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has yielded.\", pm.Name ) );\n\t\t\t\t\t\t\tpm.DuelContext.m_Yielding=true;\n\t\t\t\t\t\t\tpm.Kill();\n\t\t\t\t\t\t\tpm.DuelContext.m_Yielding=false;\n\t\t\t\t\t\t\tif ( pm.Alive ) // invul, ...\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpl.Eliminated = true;\n\t\t\t\t\t\t\t\tpm.DuelContext.RemoveAggressions( pm );\n\t\t\t\t\t\t\t\tpm.DuelContext.SendOutside( pm );\n\t\t\t\t\t\t\t\tpm.DuelContext.Refresh( pm, null );\n\t\t\t\t\t\t\t\tDebuff( pm );\n\t\t\t\t\t\t\t\tCancelSpell( pm );\n\t\t\t\t\t\t\t\tpm.Frozen = false;\n\t\t\t\t\t\t\t\tParticipant winner = pm.DuelContext.CheckCompletion();\n\t\t\t\t\t\t\t\tif ( winner != null )\n\t\t\t\t\t\t\t\t\tpm.DuelContext.Finish( winner );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"BUG: Unable to find duel context.\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic DuelContext( Mobile initiator, RulesetLayout layout ) : this( initiator, layout, true )\n\t\t{\n\t\t}\n\t\tpublic DuelContext( Mobile initiator, RulesetLayout layout, bool addNew )\n\t\t{\n\t\t\tm_Initiator = initiator;\n\t\t\tm_Participants = new ArrayList();\n\t\t\tm_Ruleset = new Ruleset( layout );\n\t\t\tm_Ruleset.ApplyDefault( layout.Defaults[0] );\n\t\t\tif ( addNew )\n\t\t\t{\n\t\t\t\tm_Participants.Add( new Participant( this, 1 ) );\n\t\t\t\tm_Participants.Add( new Participant( this, 1 ) );\n\t\t\t\t((Participant)m_Participants[0]).Add( initiator );\n\t\t\t}\n\t\t}\n\t\tpublic void CloseAllGumps()\n\t\t{\n\t\t\tType[] types = new Type[]{ typeof( DuelContextGump ), typeof( ParticipantGump ), typeof( RulesetGump ) };\n\t\t\tint[] defs = new int[]{ -1, -1, -1 };\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\nNext line of code:\n", "input": "", "context": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Server.Commands;\nusing Server.Engines.PartySystem;\nusing Server.Factions;\nusing Server.Gumps;\nusing Server.Items;\nusing Server.Mobiles;\nusing Server.Network;\nusing Server.Spells;\nusing Server.Spells.Bushido;\nusing Server.Spells.Chivalry;\nusing Server.Spells.Necromancy;\nusing Server.Spells.Ninjitsu;\nusing Server.Spells.Seventh;\nusing Server.Spells.Spellweaving;\nnamespace Server.Engines.ConPVP\n{\n    public delegate void CountdownCallback( int count );\n\tpublic class DuelContext\n\t{\n\t\tprivate Mobile m_Initiator;\n\t\tprivate ArrayList m_Participants;\n\t\tprivate Ruleset m_Ruleset;\n\t\tprivate Arena m_Arena;\n\t\tprivate bool m_Registered = true;\n\t\tprivate bool m_Finished, m_Started;\n\t\tprivate bool m_ReadyWait;\n\t\tprivate int m_ReadyCount;\n\t\tprivate bool m_Rematch;\n\t\tpublic bool Rematch{ get{ return m_Rematch; } }\n\t\tpublic bool ReadyWait{ get{ return m_ReadyWait; } }\n\t\tpublic int ReadyCount{ get{ return m_ReadyCount; } }\n\t\tpublic bool Registered{ get{ return m_Registered; } }\n\t\tpublic bool Finished{ get{ return m_Finished; } }\n\t\tpublic bool Started{ get{ return m_Started; } }\n\t\tpublic Mobile Initiator{ get{ return m_Initiator; } }\n\t\tpublic ArrayList Participants{ get{ return m_Participants; } }\n\t\tpublic Ruleset Ruleset{ get{ return m_Ruleset; } }\n\t\tpublic Arena Arena{ get{ return m_Arena; } }\n\t\tprivate bool CantDoAnything( Mobile mob )\n\t\t{\n\t\t\tif ( m_EventGame != null )\n\t\t\t\treturn m_EventGame.CantDoAnything( mob );\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tpublic static bool IsFreeConsume( Mobile mob )\n\t\t{\n\t\t\tPlayerMobile pm = mob as PlayerMobile;\n\t\t\tif ( pm == null || pm.DuelContext == null || pm.DuelContext.m_EventGame == null )\n\t\t\t\treturn false;\n\t\t\treturn pm.DuelContext.m_EventGame.FreeConsume;\n\t\t}\n\t\tpublic void DelayBounce( TimeSpan ts, Mobile mob, Container corpse )\n\t\t{\n\t\t\tTimer.DelayCall( ts, new TimerStateCallback( DelayBounce_Callback ), new object[]{ mob, corpse } );\n\t\t}\n\t\tpublic static bool AllowSpecialMove( Mobile from, string name, SpecialMove move )\n\t\t{\n\t\t\tPlayerMobile pm = from as PlayerMobile;\n\t\t\tif( pm == null )\n\t\t\t\treturn true;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\treturn (dc == null || dc.InstAllowSpecialMove( from, name, move ));\n\t\t}\n\t\tpublic bool InstAllowSpecialMove( Mobile from, string name, SpecialMove move )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tstring title = null;\n\t\t\tif( move is NinjaMove )\n\t\t\t\ttitle = \"Bushido\";\n\t\t\telse if( move is SamuraiMove )\n\t\t\t\ttitle = \"Ninjitsu\";\n\t\t\tif ( title == null || name == null || m_Ruleset.GetOption( title, name ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this move.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowSpellCast( Mobile from, Spell spell )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tif ( spell is Server.Spells.Fourth.RecallSpell )\n\t\t\t\tfrom.SendMessage( \"You may not cast this spell.\" );\n\t\t\tstring title = null, option = null;\n\t\t\tif( spell is ArcanistSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Spellweaving\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is PaladinSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Chivalry\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is NecromancerSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Necromancy\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is NinjaSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Ninjitsu\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if ( spell is SamuraiSpell )\n\t\t\t{\n\t\t\t\ttitle = \"Bushido\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse if( spell is MagerySpell )\n\t\t\t{\n\t\t\t\tswitch( ((MagerySpell)spell).Circle )\n\t\t\t\t{\n\t\t\t\t\tcase SpellCircle.First: title = \"1st Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Second: title = \"2nd Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Third: title = \"3rd Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Fourth: title = \"4th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Fifth: title = \"5th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Sixth: title = \"6th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Seventh: title = \"7th Circle\"; break;\n\t\t\t\t\tcase SpellCircle.Eighth: title = \"8th Circle\"; break;\n\t\t\t\t}\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttitle = \"Other Spell\";\n\t\t\t\toption = spell.Name;\n\t\t\t}\n\t\t\tif ( title == null || option == null || m_Ruleset.GetOption( title, option ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from casting this spell.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowItemEquip( Mobile from, Item item )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( item is Dagger || CheckItemEquip( from, item ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from equiping this item.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic static bool AllowSpecialAbility( Mobile from, string name, bool message )\n\t\t{\n\t\t\tPlayerMobile pm = from as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn true;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\treturn ( dc == null || dc.InstAllowSpecialAbility( from, name, message ) );\n\t\t}\n\t\tpublic bool InstAllowSpecialAbility( Mobile from, string name, bool message )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tif ( m_Ruleset.GetOption( \"Combat Abilities\", name ) )\n\t\t\t\treturn true;\n\t\t\tif ( message )\n\t\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this combat ability.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool CheckItemEquip( Mobile from, Item item )\n\t\t{\n\t\t\tif ( item is Fists )\n\t\t\t{\n\t\t\t\tif ( !m_Ruleset.GetOption( \"Weapons\", \"Wrestling\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BaseArmor )\n\t\t\t{\n\t\t\t\tBaseArmor armor = (BaseArmor)item;\n\t\t\t\tif ( armor.ProtectionLevel > ArmorProtectionLevel.Regular && !m_Ruleset.GetOption( \"Armor\", \"Magical\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !Core.AOS && armor.Resource != armor.DefaultResource && !m_Ruleset.GetOption( \"Armor\", \"Colored\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( armor is BaseShield && !m_Ruleset.GetOption( \"Armor\", \"Shields\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BaseWeapon )\n\t\t\t{\n\t\t\t\tBaseWeapon weapon = (BaseWeapon)item;\n\t\t\t\tif ( (weapon.DamageLevel > WeaponDamageLevel.Regular || weapon.AccuracyLevel > WeaponAccuracyLevel.Regular) && !m_Ruleset.GetOption( \"Weapons\", \"Magical\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !Core.AOS && weapon.Resource != CraftResource.Iron && weapon.Resource != CraftResource.None && !m_Ruleset.GetOption( \"Weapons\", \"Runics\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon is BaseRanged && !m_Ruleset.GetOption( \"Weapons\", \"Ranged\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( !(weapon is BaseRanged) && !m_Ruleset.GetOption( \"Weapons\", \"Melee\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon.PoisonCharges > 0 && weapon.Poison != null && !m_Ruleset.GetOption( \"Weapons\", \"Poisoned\" ) )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( weapon is BaseWand && !m_Ruleset.GetOption( \"Items\", \"Wands\" ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tpublic bool AllowSkillUse( Mobile from, SkillName skill )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\treturn false;\n\t\t\tint id = (int)skill;\n\t\t\tif ( id >= 0 && id < SkillInfo.Table.Length )\n\t\t\t{\n\t\t\t\tif ( m_Ruleset.GetOption( \"Skills\", SkillInfo.Table[id].Name ) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this skill.\" );\n\t\t\treturn false;\n\t\t}\n\t\tpublic bool AllowItemUse( Mobile from, Item item )\n\t\t{\n\t\t\tif ( !m_StartedBeginCountdown )\n\t\t\t\treturn true;\n\t\t\tDuelPlayer pl = Find( from );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn true;\n\t\t\tif ( !(item is BaseRefreshPotion) )\n\t\t\t{\n\t\t\t\tif ( CantDoAnything( from ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstring title = null, option = null;\n\t\t\tif ( item is BasePotion )\n\t\t\t{\n\t\t\t\ttitle = \"Potions\";\n\t\t\t\tif ( item is BaseAgilityPotion )\n\t\t\t\t\toption = \"Agility\";\n\t\t\t\telse if ( item is BaseCurePotion )\n\t\t\t\t\toption = \"Cure\";\n\t\t\t\telse if ( item is BaseHealPotion )\n\t\t\t\t\toption = \"Heal\";\n\t\t\t\telse if ( item is NightSightPotion )\n\t\t\t\t\toption = \"Nightsight\";\n\t\t\t\telse if ( item is BasePoisonPotion )\n\t\t\t\t\toption = \"Poison\";\n\t\t\t\telse if ( item is BaseStrengthPotion )\n\t\t\t\t\toption = \"Strength\";\n\t\t\t\telse if ( item is BaseExplosionPotion )\n\t\t\t\t\toption = \"Explosion\";\n\t\t\t\telse if ( item is BaseRefreshPotion )\n\t\t\t\t\toption = \"Refresh\";\n\t\t\t}\n\t\t\telse if ( item is Bandage )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Bandages\";\n\t\t\t}\n\t\t\telse if ( item is TrapableContainer )\n\t\t\t{\n\t\t\t\tif ( ((TrapableContainer)item).TrapType != TrapType.None )\n\t\t\t\t{\n\t\t\t\t\ttitle = \"Items\";\n\t\t\t\t\toption = \"Trapped Containers\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( item is Bola )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Bolas\";\n\t\t\t}\n\t\t\telse if ( item is OrangePetals )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Orange Petals\";\n\t\t\t}\n\t\t\telse if ( item is EtherealMount || item.Layer == Layer.Mount )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Mounts\";\n\t\t\t}\n\t\t\telse if ( item is LeatherNinjaBelt )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Shurikens\";\n\t\t\t}\n\t\t\telse if ( item is Fukiya )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Fukiya Darts\";\n\t\t\t}\n\t\t\telse if ( item is FireHorn )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Fire Horns\";\n\t\t\t}\n\t\t\telse if ( item is BaseWand )\n\t\t\t{\n\t\t\t\ttitle = \"Items\";\n\t\t\t\toption = \"Wands\";\n\t\t\t}\n\t\t\tif ( title != null && option != null && m_StartedBeginCountdown && !m_Started )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( \"You may not use this item before the duel begins.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is BasePotion && !(item is BaseExplosionPotion) && !(item is BaseRefreshPotion) && IsSuddenDeath )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( 0x22, \"You may not drink potions in sudden death.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if ( item is Bandage && IsSuddenDeath )\n\t\t\t{\n\t\t\t\tfrom.SendMessage( 0x22, \"You may not use bandages in sudden death.\" );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( title == null || option == null || m_Ruleset.GetOption( title, option ) )\n\t\t\t\treturn true;\n\t\t\tfrom.SendMessage( \"The dueling ruleset prevents you from using this item.\" );\n\t\t\treturn false;\n\t\t}\n\t\tprivate void DelayBounce_Callback( object state )\n\t\t{\n\t\t\tobject[] states = (object[])state;\n\t\t\tMobile mob = (Mobile) states[0];\n\t\t\tContainer corpse = (Container) states[1];\n\t\t\tRemoveAggressions( mob );\n\t\t\tSendOutside( mob );\n\t\t\tRefresh( mob, corpse );\n\t\t\tDebuff( mob );\n\t\t\tCancelSpell( mob );\n\t\t\tmob.Frozen = false;\n\t\t}\n\t\tpublic void OnMapChanged( Mobile mob )\n\t\t{\n\t\t\tOnLocationChanged( mob );\n\t\t}\n\t\tpublic void OnLocationChanged( Mobile mob )\n\t\t{\n\t\t\tif ( !m_Registered || !m_StartedBeginCountdown || m_Finished )\n\t\t\t\treturn;\n\t\t\tArena arena = m_Arena;\n\t\t\tif ( arena == null )\n\t\t\t\treturn;\n\t\t\tif ( mob.Map == arena.Facet && arena.Bounds.Contains( mob.Location ) )\n\t\t\t\treturn;\n\t\t\tDuelPlayer pl = Find( mob );\n\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\treturn;\n\t\t\tif ( mob.Map == Map.Internal ) {\n\t\t\t\t// they've logged out\n\t\t\t\tif ( mob.LogoutMap == arena.Facet && arena.Bounds.Contains( mob.LogoutLocation ) ) {\n\t\t\t\t\t// they logged out inside the arena.. set them to eject on login\n\t\t\t\t\tmob.LogoutLocation = arena.Outside;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpl.Eliminated = true;\n\t\t\tmob.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have forfeited your position in the duel.\" );\n\t\t\tmob.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has forfeited by leaving the dueling arena.\", mob.Name ) );\n\t\t\tParticipant winner = CheckCompletion();\n\t\t\tif ( winner != null )\n\t\t\t\tFinish( winner );\n\t\t}\n\t\tprivate bool m_Yielding;\n\t\tpublic void OnDeath( Mobile mob, Container corpse )\n\t\t{\n\t\t\tif ( !m_Registered || !m_Started )\n\t\t\t\treturn;\n\t\t\tDuelPlayer pl = Find( mob );\n\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t{\n\t\t\t\tif ( m_EventGame != null && !m_EventGame.OnDeath( mob, corpse ) )\n\t\t\t\t\treturn;\n\t\t\t\tpl.Eliminated = true;\n\t\t\t\tif ( mob.Poison != null )\n\t\t\t\t\tmob.Poison = null;\n\t\t\t\tRequip( mob, corpse );\n\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 4.0 ), mob, corpse );\n\t\t\t\tParticipant winner = CheckCompletion();\n\t\t\t\tif ( winner != null )\n\t\t\t\t{\n\t\t\t\t\tFinish( winner );\n\t\t\t\t}\n\t\t\t\telse if ( !m_Yielding )\n\t\t\t\t{\n\t\t\t\t\tmob.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have been defeated.\" );\n\t\t\t\t\tmob.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has been defeated.\", mob.Name ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic bool CheckFull()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.HasOpenSlot )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tpublic void Requip( Mobile from, Container cont )\n\t\t{\n\t\t\tCorpse corpse = cont as Corpse;\n\t\t\tif ( corpse == null )\n\t\t\t\treturn;\n\t\t\tList<Item> items = new List<Item>( corpse.Items );\n\t\t\tbool gathered = false;\n\t\t\tbool didntFit = false;\n\t\t\tContainer pack = from.Backpack;\n\t\t\tfor ( int i = 0; !didntFit && i < items.Count; ++i )\n\t\t\t{\n\t\t\t\tItem item = items[i];\n\t\t\t\tPoint3D loc = item.Location;\n\t\t\t\tif ( (item.Layer == Layer.Hair || item.Layer == Layer.FacialHair) || !item.Movable )\n\t\t\t\t\tcontinue;\n\t\t\t\tif ( pack != null )\n\t\t\t\t{\n\t\t\t\t\tpack.DropItem( item );\n\t\t\t\t\tgathered = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdidntFit = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcorpse.Carved = true;\n\t\t\tif ( corpse.ItemID == 0x2006 )\n\t\t\t{\n\t\t\t\tcorpse.ProcessDelta();\n\t\t\t\tcorpse.SendRemovePacket();\n\t\t\t\tcorpse.ItemID = Utility.Random( 0xECA, 9 ); // bone graphic\n\t\t\t\tcorpse.Hue = 0;\n\t\t\t\tcorpse.ProcessDelta();\n\t\t\t\tMobile killer = from.FindMostRecentDamager( false );\n\t\t\t\tif ( killer != null && killer.Player )\n\t\t\t\t\tkiller.AddToBackpack( new Head( m_Tournament == null ? HeadType.Duel : HeadType.Tournament, from.Name ) );\n\t\t\t}\n\t\t\tfrom.PlaySound( 0x3E3 );\n\t\t\tif ( gathered && !didntFit )\n\t\t\t\tfrom.SendLocalizedMessage( 1062471 ); // You quickly gather all of your belongings.\n\t\t\telse if ( gathered && didntFit )\n\t\t\t\tfrom.SendLocalizedMessage( 1062472 ); // You gather some of your belongings. The rest remain on the corpse.\n\t\t}\n\t\tpublic void Refresh( Mobile mob, Container cont )\n\t\t{\n\t\t\tif ( !mob.Alive )\n\t\t\t{\n\t\t\t\tmob.Resurrect();\n\t\t\t\tDeathRobe robe = mob.FindItemOnLayer( Layer.OuterTorso ) as DeathRobe;\n\t\t\t\tif ( robe != null )\n\t\t\t\t\trobe.Delete();\n\t\t\t\tif ( cont is Corpse )\n\t\t\t\t{\n\t\t\t\t\tCorpse corpse = (Corpse) cont;\n\t\t\t\t\tfor ( int i = 0; i < corpse.EquipItems.Count; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = corpse.EquipItems[i];\n\t\t\t\t\t\tif ( item.Movable && item.Layer != Layer.Hair && item.Layer != Layer.FacialHair && item.IsChildOf( mob.Backpack ) )\n\t\t\t\t\t\t\tmob.EquipItem( item );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmob.Hits = mob.HitsMax;\n\t\t\tmob.Stam = mob.StamMax;\n\t\t\tmob.Mana = mob.ManaMax;\n\t\t\tmob.Poison = null;\n\t\t}\n\t\tpublic void SendOutside( Mobile mob )\n\t\t{\n\t\t\tif ( m_Arena == null )\n\t\t\t\treturn;\n\t\t\tmob.Combatant = null;\n\t\t\tmob.MoveToWorld( m_Arena.Outside, m_Arena.Facet );\n\t\t}\n\t\tprivate Point3D m_GatePoint;\n\t\tprivate Map m_GateFacet;\n\t\tpublic void Finish( Participant winner )\n\t\t{\n\t\t\tif ( m_Finished )\n\t\t\t\treturn;\n\t\t\tEndAutoTie();\n\t\t\tStopSDTimers();\n\t\t\tm_Finished = true;\n\t\t\tfor ( int i = 0; i < winner.Players.Length; ++i )\n\t\t\t{\n\t\t\t\tDuelPlayer pl = winner.Players[i];\n\t\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 8.0 ), pl.Mobile, null );\n\t\t\t}\n\t\t\twinner.Broadcast( 0x59, null, winner.Players.Length == 1 ? \"{0} has won the duel.\" : \"{0} and {1} team have won the duel.\", winner.Players.Length == 1 ? \"You have won the duel.\" : \"Your team has won the duel.\" );\n\t\t\tif ( m_Tournament != null && winner.TournyPart != null )\n\t\t\t{\n\t\t\t\tm_Match.Winner = winner.TournyPart;\n\t\t\t\twinner.TournyPart.WonMatch( m_Match );\n\t\t\t\tm_Tournament.HandleWon( m_Arena, m_Match, winner.TournyPart );\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant loser = (Participant)m_Participants[i];\n\t\t\t\tif ( loser != winner )\n\t\t\t\t{\n\t\t\t\t\tloser.Broadcast( 0x22, null, loser.Players.Length == 1 ? \"{0} has lost the duel.\" : \"{0} and {1} team have lost the duel.\", loser.Players.Length == 1 ? \"You have lost the duel.\" : \"Your team has lost the duel.\" );\n\t\t\t\t\tif ( m_Tournament != null && loser.TournyPart != null )\n\t\t\t\t\t\tloser.TournyPart.LostMatch( m_Match );\n\t\t\t\t}\n\t\t\t\tfor ( int j = 0; j < loser.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tif ( loser.Players[j] != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveAggressions( loser.Players[j].Mobile );\n\t\t\t\t\t\tloser.Players[j].Mobile.Delta( MobileDelta.Noto );\n\t\t\t\t\t\tloser.Players[j].Mobile.CloseGump( typeof( BeginGump ) );\n\t\t\t\t\t\tif ( m_Tournament != null )\n\t\t\t\t\t\t\tloser.Players[j].Mobile.SendEverything();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( IsOneVsOne )\n\t\t\t{\n\t\t\t\tDuelPlayer dp1 = ((Participant)m_Participants[0]).Players[0];\n\t\t\t\tDuelPlayer dp2 = ((Participant)m_Participants[1]).Players[0];\n\t\t\t\tif ( dp1 != null && dp2 != null )\n\t\t\t\t{\n\t\t\t\t\tAward( dp1.Mobile, dp2.Mobile, dp1.Participant == winner );\n\t\t\t\t\tAward( dp2.Mobile, dp1.Mobile, dp2.Participant == winner );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_EventGame != null )\n\t\t\t\tm_EventGame.OnStop();\n\t\t\tTimer.DelayCall( TimeSpan.FromSeconds( 9.0 ), new TimerCallback( UnregisterRematch ) );\n\t\t}\n\t\tpublic void Award( Mobile us, Mobile them, bool won )\n\t\t{\n\t\t\tLadder ladder = ( m_Arena == null ? Ladder.Instance : m_Arena.AcquireLadder() );\n\t\t\tif ( ladder == null )\n\t\t\t\treturn;\n\t\t\tLadderEntry ourEntry = ladder.Find( us );\n\t\t\tLadderEntry theirEntry = ladder.Find( them );\n\t\t\tif ( ourEntry == null || theirEntry == null )\n\t\t\t\treturn;\n\t\t\tint xpGain = Ladder.GetExperienceGain( ourEntry, theirEntry, won );\n\t\t\tif ( xpGain == 0 )\n\t\t\t\treturn;\n\t\t\tif ( m_Tournament != null )\n\t\t\t\txpGain *= ( xpGain > 0 ? 5 : 2 );\n\t\t\tif ( won )\n\t\t\t\t++ourEntry.Wins;\n\t\t\telse\n\t\t\t\t++ourEntry.Losses;\n\t\t\tint oldLevel = Ladder.GetLevel( ourEntry.Experience );\n\t\t\tourEntry.Experience += xpGain;\n\t\t\tif ( ourEntry.Experience < 0 )\n\t\t\t\tourEntry.Experience = 0;\n\t\t\tladder.UpdateEntry( ourEntry );\n\t\t\tint newLevel = Ladder.GetLevel( ourEntry.Experience );\n\t\t\tif ( newLevel > oldLevel )\n\t\t\t\tus.SendMessage( 0x59, \"You have achieved level {0}!\", newLevel );\n\t\t\telse if ( newLevel < oldLevel )\n\t\t\t\tus.SendMessage( 0x22, \"You have lost a level. You are now at {0}.\", newLevel );\n\t\t}\n\t\tpublic void UnregisterRematch()\n\t\t{\n\t\t\tUnregister(true);\n\t\t}\n\t\tpublic void Unregister()\n\t\t{\n\t\t\tUnregister(false);\n\t\t}\n\t\tpublic void Unregister( bool queryRematch )\n\t\t{\n\t\t\tDestroyWall();\n\t\t\tif ( !m_Registered )\n\t\t\t\treturn;\n\t\t\tm_Registered = false;\n\t\t\tif ( m_Arena != null )\n\t\t\t\tm_Arena.Evict();\n\t\t\tStopSDTimers();\n\t\t\tType[] types = new Type[]{ typeof( BeginGump ), typeof( DuelContextGump ), typeof( ParticipantGump ), typeof( PickRulesetGump ), typeof( ReadyGump ), typeof( ReadyUpGump ), typeof( RulesetGump ) };\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = (DuelPlayer)p.Players[j];\n\t\t\t\t\tif ( pl == null )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( pl.Mobile is PlayerMobile )\n\t\t\t\t\t\t((PlayerMobile)pl.Mobile).DuelPlayer = null;\n\t\t\t\t\tfor ( int k = 0; k < types.Length; ++k )\n\t\t\t\t\t\tpl.Mobile.CloseGump( types[k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( queryRematch && m_Tournament == null )\n\t\t\t\tQueryRematch();\n\t\t}\n\t\tpublic void QueryRematch()\n\t\t{\n\t\t\tDuelContext dc = new DuelContext( m_Initiator, m_Ruleset.Layout, false );\n\t\t\tdc.m_Ruleset = m_Ruleset;\n\t\t\tdc.m_Rematch = true;\n\t\t\tdc.m_Participants.Clear();\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant oldPart = (Participant)m_Participants[i];\n\t\t\t\tParticipant newPart = new Participant( dc, oldPart.Players.Length );\n\t\t\t\tfor ( int j = 0; j < oldPart.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer oldPlayer = oldPart.Players[j];\n\t\t\t\t\tif ( oldPlayer != null )\n\t\t\t\t\t\tnewPart.Players[j] = new DuelPlayer( oldPlayer.Mobile, newPart );\n\t\t\t\t}\n\t\t\t\tdc.m_Participants.Add( newPart );\n\t\t\t}\n\t\t\tdc.CloseAllGumps();\n\t\t\tdc.SendReadyUpGump();\n\t\t}\n\t\tpublic DuelPlayer Find( Mobile mob )\n\t\t{\n\t\t\tif ( mob is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)mob;\n\t\t\t\tif ( pm.DuelContext == this )\n\t\t\t\t\treturn pm.DuelPlayer;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tDuelPlayer pl = p.Find( mob );\n\t\t\t\tif ( pl != null )\n\t\t\t\t\treturn pl;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tpublic bool IsAlly( Mobile m1, Mobile m2 )\n\t\t{\n\t\t\tDuelPlayer pl1 = Find( m1 );\n\t\t\tDuelPlayer pl2 = Find( m2 );\n\t\t\treturn ( pl1 != null && pl2 != null && pl1.Participant == pl2.Participant );\n\t\t}\n\t\tpublic Participant CheckCompletion()\n\t\t{\n\t\t\tParticipant winner = null;\n\t\t\tbool hasWinner = false;\n\t\t\tint eliminated = 0;\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.Eliminated )\n\t\t\t\t{\n\t\t\t\t\t++eliminated;\n\t\t\t\t\tif ( eliminated == (m_Participants.Count - 1) )\n\t\t\t\t\t\thasWinner = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twinner = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( hasWinner )\n\t\t\t\treturn winner == null ? (Participant) m_Participants[0] : winner;\n\t\t\treturn null;\n\t\t}\n\t\tprivate Timer m_Countdown;\n\t\tpublic void StartCountdown( int count, CountdownCallback cb )\n\t\t{\n\t\t\tcb(count);\n\t\t\tm_Countdown=Timer.DelayCall( TimeSpan.FromSeconds( 1.0 ), TimeSpan.FromSeconds( 1.0 ), count, new TimerStateCallback( Countdown_Callback ), new object[]{ count-1, cb } );\n\t\t}\n\t\tpublic void StopCountdown()\n\t\t{\n\t\t\tif ( m_Countdown != null )\n\t\t\t\tm_Countdown.Stop();\n\t\t\tm_Countdown = null;\n\t\t}\n\t\tprivate void Countdown_Callback( object state )\n\t\t{\n\t\t\tobject[] states = (object[])state;\n\t\t\tint count = (int)states[0];\n\t\t\tCountdownCallback cb = (CountdownCallback)states[1];\n\t\t\tif ( count==0 )\n\t\t\t{\n\t\t\t\tif ( m_Countdown != null )\n\t\t\t\t\tm_Countdown.Stop();\n\t\t\t\tm_Countdown=null;\n\t\t\t}\n\t\t\tcb( count );\n\t\t\tstates[0] = count - 1;\n\t\t}\n\t\tprivate Timer m_AutoTieTimer;\n\t\tprivate bool m_Tied;\n\t\tpublic bool Tied{ get{ return m_Tied; } }\n\t\tprivate bool m_IsSuddenDeath;\n\t\tpublic bool IsSuddenDeath{ get{ return m_IsSuddenDeath; } set{ m_IsSuddenDeath = value; } }\n\t\tprivate Timer m_SDWarnTimer, m_SDActivateTimer;\n\t\tpublic void StopSDTimers()\n\t\t{\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = null;\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = null;\n\t\t}\n\t\tpublic void StartSuddenDeath( TimeSpan timeUntilActive )\n\t\t{\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = Timer.DelayCall( TimeSpan.FromMinutes( timeUntilActive.TotalMinutes * 0.9 ), new TimerCallback( WarnSuddenDeath ) );\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = Timer.DelayCall( timeUntilActive, new TimerCallback( ActivateSuddenDeath ) );\n\t\t}\n\t\tpublic void WarnSuddenDeath()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpl.Mobile.SendSound( 0x1E1 );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Warning! Warning! Warning!\" );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Sudden death will be active soon!\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.Alert( m_Arena, \"Sudden death will be active soon!\" );\n\t\t\tif ( m_SDWarnTimer != null )\n\t\t\t\tm_SDWarnTimer.Stop();\n\t\t\tm_SDWarnTimer = null;\n\t\t}\n\t\tpublic static bool CheckSuddenDeath( Mobile mob )\n\t\t{\n\t\t\tif ( mob is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)mob;\n\t\t\t\tif ( pm.DuelPlayer != null && !pm.DuelPlayer.Eliminated && pm.DuelContext != null && pm.DuelContext.IsSuddenDeath )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic void ActivateSuddenDeath()\n\t\t{\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl == null || pl.Eliminated )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpl.Mobile.SendSound( 0x1E1 );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Warning! Warning! Warning!\" );\n\t\t\t\t\tpl.Mobile.SendMessage( 0x22, \"Sudden death has ACTIVATED. You are now unable to perform any beneficial actions.\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.Alert( m_Arena, \"Sudden death has been activated!\" );\n\t\t\tm_IsSuddenDeath = true;\n\t\t\tif ( m_SDActivateTimer != null )\n\t\t\t\tm_SDActivateTimer.Stop();\n\t\t\tm_SDActivateTimer = null;\n\t\t}\n\t\tpublic void BeginAutoTie()\n\t\t{\n\t\t\tif ( m_AutoTieTimer != null )\n\t\t\t\tm_AutoTieTimer.Stop();\n\t\t\tTimeSpan ts = ( m_Tournament == null || m_Tournament.TournyType == TournyType.Standard )\n\t\t\t\t? AutoTieDelay\n\t\t\t\t: TimeSpan.FromMinutes( 90.0 );\n\t\t\tm_AutoTieTimer = Timer.DelayCall( ts, new TimerCallback( InvokeAutoTie ) );\n\t\t}\n\t\tpublic void EndAutoTie()\n\t\t{\n\t\t\tif ( m_AutoTieTimer != null )\n\t\t\t\tm_AutoTieTimer.Stop();\n\t\t\tm_AutoTieTimer = null;\n\t\t}\n\t\tpublic void InvokeAutoTie()\n\t\t{\n\t\t\tm_AutoTieTimer = null;\n\t\t\tif ( !m_Started || m_Finished )\n\t\t\t\treturn;\n\t\t\tm_Tied = true;\n\t\t\tm_Finished = true;\n\t\t\tStopSDTimers();\n\t\t\tArrayList remaining = new ArrayList();\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n\t\t\t\tParticipant p = (Participant)m_Participants[i];\n\t\t\t\tif ( p.Eliminated )\n\t\t\t\t{\n\t\t\t\t\tp.Broadcast( 0x22, null, p.Players.Length == 1 ? \"{0} has lost the duel.\" : \"{0} and {1} team have lost the duel.\", p.Players.Length == 1 ? \"You have lost the duel.\" : \"Your team has lost the duel.\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp.Broadcast( 0x59, null, p.Players.Length == 1 ? \"{0} has tied the duel due to time expiration.\" : \"{0} and {1} team have tied the duel due to time expiration.\", p.Players.Length == 1 ? \"You have tied the duel due to time expiration.\" : \"Your team has tied the duel due to time expiration.\" );\n\t\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t\t{\n\t\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\t\tif ( pl != null && !pl.Eliminated )\n\t\t\t\t\t\t\tDelayBounce( TimeSpan.FromSeconds( 8.0 ), pl.Mobile, null );\n\t\t\t\t\t}\n\t\t\t\t\tif ( p.TournyPart != null )\n\t\t\t\t\t\tremaining.Add( p.TournyPart );\n\t\t\t\t}\n\t\t\t\tfor ( int j = 0; j < p.Players.Length; ++j )\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = p.Players[j];\n\t\t\t\t\tif ( pl != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tpl.Mobile.Delta( MobileDelta.Noto );\n\t\t\t\t\t\tpl.Mobile.SendEverything();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( m_Tournament != null )\n\t\t\t\tm_Tournament.HandleTie( m_Arena, m_Match, remaining );\n\t\t\tTimer.DelayCall( TimeSpan.FromSeconds( 10.0 ), new TimerCallback( Unregister ) );\n\t\t}\n\t\tpublic bool IsOneVsOne\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif ( m_Participants.Count != 2 )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( ((Participant)m_Participants[0]).Players.Length != 1 )\n\t\t\t\t\treturn false;\n\t\t\t\tif ( ((Participant)m_Participants[1]).Players.Length != 1 )\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpublic static void Initialize()\n\t\t{\n\t\t\tEventSink.Speech += new SpeechEventHandler( EventSink_Speech );\n\t\t\tEventSink.Login += new LoginEventHandler( EventSink_Login );\n\t\t\tCommandSystem.Register( \"vli\", AccessLevel.GameMaster, new CommandEventHandler( vli_oc ) );\n\t\t}\n\t\tprivate static void vli_oc( CommandEventArgs e )\n\t\t{\n\t\t\te.Mobile.BeginTarget( -1, false, Targeting.TargetFlags.None, new TargetCallback( vli_ot ) );\n\t\t}\n\t\tprivate static void vli_ot( Mobile from, object obj )\n\t\t{\n\t\t\tif ( obj is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)obj;\n\t\t\t\tLadder ladder = Ladder.Instance;\n\t\t\t\tif ( ladder == null )\n\t\t\t\t\treturn;\n\t\t\t\tLadderEntry entry = ladder.Find( pm );\n\t\t\t\tif ( entry != null )\n\t\t\t\t\tfrom.SendGump( new PropertiesGump( from, entry ) );\n\t\t\t}\n\t\t}\n\t\tprivate static TimeSpan CombatDelay = TimeSpan.FromSeconds( 30.0 );\n\t\tprivate static TimeSpan AutoTieDelay = TimeSpan.FromMinutes( 15.0 );\n\t\tpublic static bool CheckCombat( Mobile m )\n\t\t{\n\t\t\tfor ( int i = 0; i < m.Aggressed.Count; ++i )\n\t\t\t{\n\t\t\t\tAggressorInfo info = m.Aggressed[i];\n\t\t\t\tif ( info.Defender.Player && (DateTime.UtcNow - info.LastCombatTime) < CombatDelay )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < m.Aggressors.Count; ++i )\n\t\t\t{\n\t\t\t\tAggressorInfo info = m.Aggressors[i];\n\t\t\t\tif ( info.Attacker.Player && (DateTime.UtcNow - info.LastCombatTime) < CombatDelay )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tprivate static void EventSink_Login( LoginEventArgs e )\n\t\t{\n\t\t\tPlayerMobile pm = e.Mobile as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn;\n\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\tif ( dc == null )\n\t\t\t\treturn;\n\t\t\tif ( dc.ReadyWait && pm.DuelPlayer.Ready && !dc.Started && !dc.StartedBeginCountdown && !dc.Finished )\n\t\t\t{\n\t\t\t\tif ( dc.m_Tournament == null )\n\t\t\t\t\tpm.SendGump( new ReadyGump( pm, dc, dc.m_ReadyCount ) );\n\t\t\t}\n\t\t\telse if ( dc.ReadyWait && !dc.StartedBeginCountdown && !dc.Started && !dc.Finished )\n\t\t\t{\n\t\t\t\tif ( dc.m_Tournament == null )\n\t\t\t\t\tpm.SendGump( new ReadyUpGump( pm, dc ) );\n\t\t\t}\n\t\t\telse if ( dc.Initiator == pm && !dc.ReadyWait && !dc.StartedBeginCountdown && !dc.Started && !dc.Finished )\n\t\t\t\tpm.SendGump( new DuelContextGump( pm, dc ) );\n\t\t}\n\t\tprivate static void ViewLadder_OnTarget( Mobile from, object obj, object state )\n\t\t{\n\t\t\tif ( obj is PlayerMobile )\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)obj;\n\t\t\t\tLadder ladder = (Ladder)state;\n\t\t\t\tLadderEntry entry = ladder.Find( pm );\n\t\t\t\tif ( entry == null )\n\t\t\t\t\treturn; // sanity\n\t\t\t\tstring text = String.Format( \"{{0}} are ranked {0} at level {1}.\", LadderGump.Rank( entry.Index + 1 ), Ladder.GetLevel( entry.Experience ) );\n\t\t\t\tpm.PrivateOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, from==pm?\"You\":\"They\" ), from.NetState );\n\t\t\t}\n\t\t\telse if ( obj is Mobile )\n\t\t\t{\n\t\t\t\tMobile mob = (Mobile)obj;\n\t\t\t\tif ( mob.Body.IsHuman )\n\t\t\t\t\tmob.PrivateOverheadMessage( MessageType.Regular, mob.SpeechHue, false, \"I'm not a duelist, and quite frankly, I resent the implication.\", from.NetState );\n\t\t\t\telse\n\t\t\t\t\tmob.PrivateOverheadMessage( MessageType.Regular, 0x3B2, true, \"It's probably better than you.\", from.NetState );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfrom.SendMessage( \"That's not a player.\" );\n\t\t\t}\n\t\t}\n\t\tprivate static void EventSink_Speech( SpeechEventArgs e )\n\t\t{\n\t\t\tif ( e.Handled )\n\t\t\t\treturn;\n\t\t\tPlayerMobile pm = e.Mobile as PlayerMobile;\n\t\t\tif ( pm == null )\n\t\t\t\treturn;\n\t\t\tif ( Insensitive.Contains( e.Speech, \"i wish to duel\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.Region.IsPartOf( typeof( Regions.Jail ) ) )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( CheckCombat( pm ) )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have recently been in combat with another player and must wait before starting a duel.\" );\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext != null )\n\t\t\t\t{\n\t\t\t\t\tif ( pm.DuelContext.Initiator == pm )\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already started a duel.\" );\n\t\t\t\t\telse\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already been challenged in a duel.\" );\n\t\t\t\t}\n\t\t\t\telse if ( TournamentController.IsActive )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You may not start a duel while a tournament is active.\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpm.SendGump( new DuelContextGump( pm, new DuelContext( pm, RulesetLayout.Root ) ) );\n\t\t\t\t\te.Handled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"change arena preferences\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPreferences prefs = Preferences.Instance;\n\t\t\t\t\tif ( prefs != null )\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.CloseGump( typeof( PreferencesGump ) );\n\t\t\t\t\t\te.Mobile.SendGump( new PreferencesGump( e.Mobile, prefs ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"showladder\" ) )\n\t\t\t{\n\t\t\t\te.Blocked=true;\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLadder instance = Ladder.Instance;\n\t\t\t\t\tif ( instance == null )\n\t\t\t\t\t{\n\t\t\t\t\t\t//pm.SendMessage( \"Ladder not yet initialized.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tLadderEntry entry = instance.Find( pm );\n\t\t\t\t\t\tif ( entry == null )\n\t\t\t\t\t\t\treturn; // sanity\n\t\t\t\t\t\tstring text = String.Format( \"{{0}} {{1}} ranked {0} at level {1}.\", LadderGump.Rank( entry.Index + 1 ), Ladder.GetLevel( entry.Experience ) );\n\t\t\t\t\t\tpm.LocalOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, \"You\", \"are\" ) );\n\t\t\t\t\t\tpm.NonlocalOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( text, pm.Name, \"is\" ) );\n\t\t\t\t\t\t//pm.PublicOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( \"Level {0} with {1} win{2} and {3} loss{4}.\", Ladder.GetLevel( entry.Experience ), entry.Wins, entry.Wins==1?\"\":\"s\", entry.Losses, entry.Losses==1?\"\":\"es\" ) );\n\t\t\t\t\t\t//pm.PublicOverheadMessage( MessageType.Regular, pm.SpeechHue, true, String.Format( \"Level {0} with {1} win{2} and {3} loss{4}.\", Ladder.GetLevel( entry.Experience ), entry.Wins, entry.Wins==1?\"\":\"s\", entry.Losses, entry.Losses==1?\"\":\"es\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Equals( e.Speech, \"viewladder\" ) )\n\t\t\t{\n\t\t\t\te.Blocked=true;\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLadder instance = Ladder.Instance;\n\t\t\t\t\tif ( instance == null )\n\t\t\t\t\t{\n\t\t\t\t\t\t//pm.SendMessage( \"Ladder not yet initialized.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpm.SendMessage( \"Target a player to view their ranking and level.\" );\n\t\t\t\t\t\tpm.BeginTarget( 16, false, Targeting.TargetFlags.None, new TargetStateCallback( ViewLadder_OnTarget ), instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( Insensitive.Contains( e.Speech, \"i yield\" ) )\n\t\t\t{\n\t\t\t\tif ( !pm.CheckAlive() )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext == null )\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse if ( pm.DuelContext.Finished )\n\t\t\t\t{\n\t\t\t\t\te.Mobile.SendMessage( 0x22, \"The duel is already finished.\" );\n\t\t\t\t}\n\t\t\t\telse if ( !pm.DuelContext.Started )\n\t\t\t\t{\n\t\t\t\t\tDuelContext dc = pm.DuelContext;\n\t\t\t\t\tMobile init = dc.Initiator;\n\t\t\t\t\tif ( pm.DuelContext.StartedBeginCountdown )\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"The duel has not yet started.\" );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tDuelPlayer pl = pm.DuelContext.Find( pm );\n\t\t\t\t\t\tif ( pl == null )\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tParticipant p = pl.Participant;\n\t\t\t\t\t\tif ( !pm.DuelContext.ReadyWait ) // still setting stuff up\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( !pm.DuelContext.StartedReadyCountdown ) // at ready stage\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tdc.m_Yielding=true;\n\t\t\t\t\t\t\tdc.RejectReady( pm, null );\n\t\t\t\t\t\t\tdc.m_Yielding=false;\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ( dc.m_Registered )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbool send=true;\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( send )\n\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( pm.DuelContext.m_Countdown != null )\n\t\t\t\t\t\t\t\tpm.DuelContext.m_Countdown.Stop();\n\t\t\t\t\t\t\tpm.DuelContext.m_Countdown= null;\n\t\t\t\t\t\t\tpm.DuelContext.m_StartedReadyCountdown=false;\n\t\t\t\t\t\t\tp.Broadcast( 0x22, null, \"{0} has yielded.\", \"You have yielded.\" );\n\t\t\t\t\t\t\tdc.m_Yielding=true;\n\t\t\t\t\t\t\tdc.RejectReady( pm, null );\n\t\t\t\t\t\t\tdc.m_Yielding=false;\n\t\t\t\t\t\t\tif ( init == pm )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdc.Unregister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ( dc.m_Registered )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.Nullify( pl );\n\t\t\t\t\t\t\t\tpm.DuelPlayer=null;\n\t\t\t\t\t\t\t\tNetState ns = init.NetState;\n\t\t\t\t\t\t\t\tif ( ns != null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbool send=true;\n\t\t\t\t\t\t\t\t\tforeach ( Gump g in ns.Gumps )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( g is ParticipantGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tParticipantGump pg = (ParticipantGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( pg.Participant == p )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new ParticipantGump( init, dc, p ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if ( g is DuelContextGump )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tDuelContextGump dcg = (DuelContextGump)g;\n\t\t\t\t\t\t\t\t\t\t\tif ( dcg.Context == dc )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t\t\t\t\tsend=false;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( send )\n\t\t\t\t\t\t\t\t\t\tinit.SendGump( new DuelContextGump( init, dc ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDuelPlayer pl = pm.DuelContext.Find( pm );\n\t\t\t\t\tif ( pl != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( pm.DuelContext.IsOneVsOne )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You may not yield a 1 on 1 match.\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( pl.Eliminated )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"You have already been eliminated.\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpm.LocalOverheadMessage( MessageType.Regular, 0x22, false, \"You have yielded.\" );\n\t\t\t\t\t\t\tpm.NonlocalOverheadMessage( MessageType.Regular, 0x22, false, String.Format( \"{0} has yielded.\", pm.Name ) );\n\t\t\t\t\t\t\tpm.DuelContext.m_Yielding=true;\n\t\t\t\t\t\t\tpm.Kill();\n\t\t\t\t\t\t\tpm.DuelContext.m_Yielding=false;\n\t\t\t\t\t\t\tif ( pm.Alive ) // invul, ...\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpl.Eliminated = true;\n\t\t\t\t\t\t\t\tpm.DuelContext.RemoveAggressions( pm );\n\t\t\t\t\t\t\t\tpm.DuelContext.SendOutside( pm );\n\t\t\t\t\t\t\t\tpm.DuelContext.Refresh( pm, null );\n\t\t\t\t\t\t\t\tDebuff( pm );\n\t\t\t\t\t\t\t\tCancelSpell( pm );\n\t\t\t\t\t\t\t\tpm.Frozen = false;\n\t\t\t\t\t\t\t\tParticipant winner = pm.DuelContext.CheckCompletion();\n\t\t\t\t\t\t\t\tif ( winner != null )\n\t\t\t\t\t\t\t\t\tpm.DuelContext.Finish( winner );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\te.Mobile.SendMessage( 0x22, \"BUG: Unable to find duel context.\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic DuelContext( Mobile initiator, RulesetLayout layout ) : this( initiator, layout, true )\n\t\t{\n\t\t}\n\t\tpublic DuelContext( Mobile initiator, RulesetLayout layout, bool addNew )\n\t\t{\n\t\t\tm_Initiator = initiator;\n\t\t\tm_Participants = new ArrayList();\n\t\t\tm_Ruleset = new Ruleset( layout );\n\t\t\tm_Ruleset.ApplyDefault( layout.Defaults[0] );\n\t\t\tif ( addNew )\n\t\t\t{\n\t\t\t\tm_Participants.Add( new Participant( this, 1 ) );\n\t\t\t\tm_Participants.Add( new Participant( this, 1 ) );\n\t\t\t\t((Participant)m_Participants[0]).Add( initiator );\n\t\t\t}\n\t\t}\n\t\tpublic void CloseAllGumps()\n\t\t{\n\t\t\tType[] types = new Type[]{ typeof( DuelContextGump ), typeof( ParticipantGump ), typeof( RulesetGump ) };\n\t\t\tint[] defs = new int[]{ -1, -1, -1 };\n\t\t\tfor ( int i = 0; i < m_Participants.Count; ++i )\n\t\t\t{\n", "answers": ["\t\t\t\tParticipant p = (Participant)m_Participants[i];"], "pred": "  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: 0\n  Code: ", "length": 5243, "dataset": "lcc", "language": "csharp", "all_classes": null, "_id": "28ce5cf5e0beeb47248c6cba20ae17fa71d60d402770d464"}
{"prompt": "Please complete the code given below. \nimport networkx as nx \nimport pickle\nfrom Queue import PriorityQueue \nimport copy\nimport random\nimport string\nimport sys\nclass MultiDiGraph_EdgeKey(nx.MultiDiGraph):\n    \"\"\"\n    MultiDiGraph which assigns unique keys to every edge.\n    Adds a dictionary edge_index which maps edge keys to (u, v, data) tuples.\n    This is not a complete implementation. For Edmonds algorithm, we only use\n    add_node and add_edge, so that is all that is implemented here. During\n    additions, any specified keys are ignored---this means that you also\n    cannot update edge attributes through add_node and add_edge.\n    \"\"\"\n    def __init__(self, data=None, **attr):\n        cls = super(MultiDiGraph_EdgeKey, self)\n        cls.__init__(data=data, **attr)\n        self._cls = cls\n        self.edge_index = {}\n    def remove_node(self, n):\n        keys = set([])\n        for keydict in self.pred[n].values():\n            keys.update(keydict)\n        for keydict in self.succ[n].values():\n            keys.update(keydict)\n        for key in keys:\n            del self.edge_index[key]\n        self._cls.remove_node(n)\n    def remove_nodes_from(self, nbunch):\n        for n in nbunch:\n            self.remove_node(n)\n    def add_edge(self, u, v, key, attr_dict=None, **attr):\n        \"\"\"\n        Key is now required.\n        \"\"\"\n        if key in self.edge_index:\n            uu, vv, _ = self.edge_index[key]\n            if (u != uu) or (v != vv):\n                raise Exception(\"Key {0!r} is already in use.\".format(key))\n        self._cls.add_edge(u, v, key=key, attr_dict=attr_dict, **attr)\n        self.edge_index[key] = (u, v, self.succ[u][v][key])\n    def add_edges_from(self, ebunch, attr_dict=None, **attr):\n        for edge in ebunch:\n        \tself.add_edge(*edge)\n    def remove_edge_with_key(self, key):\n        try:\n            u, v, _  = self.edge_index[key]\n            # print ('***',u,v,key)\n        except KeyError:\n            raise KeyError('Invalid edge key {0!r}'.format(key))\n        else:\n            del self.edge_index[key]\n            # print ('***** self.edge_index',self.edge_index)\n            self._cls.remove_edge(u, v, key)\n    def remove_edges_from(self, ebunch):\n        raise NotImplementedError\ndef random_string(L=15, seed=None):\n    random.seed(seed)\n    return ''.join([random.choice(string.ascii_letters) for n in range(L)])\nclass Camerini():\n\tdef __init__(self, graph, Y=nx.DiGraph(), Z=nx.DiGraph(), attr='weight'):\n\t\tself.original_graph = graph\n\t\tself.attr = attr\n\t\tself._init(Y=Y, Z=Z)\n\t\tself.template = random_string()\n\t\n\tdef _init(self, graph=None, Y=nx.DiGraph(), Z=nx.DiGraph()):\n\t\tself.graph = MultiDiGraph_EdgeKey()\n\t\tif graph is None:\n\t\t\tgraph = self.original_graph\n\t\tfor key, (u, v, data) in enumerate(graph.edges(data=True)):\n\t\t\tif (u,v) not in Z.edges():\n\t\t\t\tself.graph.add_edge(u,v,key,data.copy())\n\t\t\t\n\t\tfor Y_edge in Y.edges(data=True):\n\t\t\tfor (u,v) in self.graph.in_edges([Y_edge[1]]):\n\t\t\t\tif u != Y_edge[0]:\n\t\t\t\t\tself.graph.remove_edge(u,v)\n\tdef best_incoming_edge(self, node, graph):\n\t\tmax_weight = float('-inf')\n\t\te = None\n\t\t# print ('Graph',graph.edges())\n\t\tfor u,v,key,data in graph.in_edges([node], data=True, keys=True):\n\t\t\t# print ('edge',u,v,data)\n\t\t\tif max_weight <= data[self.attr]:\n\t\t\t\tmax_weight = data[self.attr]\n\t\t\t\te = (u,v,key,data)\n\t\treturn e\n\tdef collapse_cycle(self, graph, cycle, B, new_node):\t\t\t\n\t\tfor node in cycle:\n\t\t\tfor u,v,key,data in graph.out_edges([node], data=True, keys=True):\n\t\t\t\tgraph.remove_edge_with_key(key)\n\t\t\t\tif v not in cycle:\n\t\t\t\t\tdd = data.copy()\n\t\t\t\t\tgraph.add_edge(new_node,v,key,**dd)\t\t\n\t\t\tfor u,v,key,data in graph.in_edges([node], data=True, keys=True):\n\t\t\t\tif u in cycle:\n\t\t\t\t\t# it will be delete later\n\t\t\t\t\tcontinue\n\t\t\t\tgraph.remove_edge_with_key(key)\n\t\t\t\tdd = data.copy()\n\t\t\t\tdd_eh = list(B.in_edges([node], data=True))[0][2] \n\t\t\t\tdd[self.attr] = dd[self.attr] - dd_eh[self.attr]\n\t\t\t\tgraph.add_edge(u, new_node, key, **dd)\n\t\tfor node in cycle:\n\t\t\tB.remove_node(node)\n\t\treturn graph, B\n\tdef add_b_to_branching(self, exposed_nodes, order, M, supernodes, B):\n\t\tv = exposed_nodes.pop(0)\n\t\torder.append(v)\n\t\tb = self.best_incoming_edge(v, M)\n\t\tif b is None:\n\t\t\tif v in supernodes:\n\t\t\t\tsupernodes.remove(v)\n\t\t\treturn exposed_nodes, order, M, supernodes, B, None\n\t\tb_u, b_v, b_key, b_data = b\n\t\tdata = {self.attr: b_data[self.attr], 'origin': b_data['origin']}\n\t\tB.add_edge(b_u, b_v, **data)\n\t\treturn exposed_nodes, order, M, supernodes, B, b\n\tdef contracting_phase(self, B, n, supernodes, exposed_nodes, M, C, root):\n\t\tcycles = list(nx.simple_cycles(B))\n\t\tif len(cycles) > 0:\n\t\t\tu = 'v_'+str(n)\n\t\t\tsupernodes.append(str(u))\n\t\t\texposed_nodes.append(u)\n\t\t\tfor node in cycles[0]:\n\t\t\t\tC[str(node)] = str(u)\n\t\t\tM, B = self.collapse_cycle(M, cycles[0], B, u)\n\t\t\tfor node in B.nodes():\n\t\t\t\tif B.in_edges([node]) == []:\n\t\t\t\t\tif B.out_edges([node]) == []:\n\t\t\t\t\t\tB.remove_node(node)\n\t\t\t\t\tif node != root and node not in exposed_nodes:\n\t\t\t\t\t\texposed_nodes.append(node)\n\t\t\tn += 1\n\t\treturn B, n, supernodes, exposed_nodes, M, C\n\tdef best(self, root):\n\t\tM = self.graph\n\t\tfor u,v,key,data in M.edges(data=True, keys=True):\n\t\t\tdata['origin'] = (u,v,key,{self.attr: data[self.attr]})\n\t\tn = 0\n\t\tB = nx.DiGraph()\n\t\t# C contains for every node its parent node, so it will be easy to find the path in the collapsing phase\n\t\t# from an isolated root v_1 to v_k\n\t\tnodes = M.nodes()\n\t\tif len(nodes) == 1:\n\t\t\tA = nx.DiGraph()\n\t\t\tA.add_node(nodes[0])\n\t\tC = {str(node): None for node in nodes} \n\t\tdel C[str(root)]\n\t\texposed_nodes = [node for node in nodes]\n\t\texposed_nodes.remove(root)\n\t\tsupernodes = []\n\t\tbeta = {}\n\t\torder = []\n\t\t# collapsing phase\n\t\twhile len(exposed_nodes) > 0:\n\t\t\texposed_nodes, order, M, supernodes, B, b = self.add_b_to_branching(exposed_nodes, order, M, supernodes, B)\n\t\t\tif b is None:\n\t\t\t\tcontinue\n\t\t\tb_u, b_v, b_key, b_data = b\n\t\t\tbeta[b_v] = (b_u, b_v, b_key, b_data)\n\t\t\tB, n, supernodes, exposed_nodes, M, C = self.contracting_phase(B, n, supernodes, exposed_nodes, M, C, root)\n\t\t# expanding phase\n\t\twhile len(supernodes) > 0:\n\t\t\tv_1 = supernodes.pop()\n\t\t\torigin_edge_v_1 = beta[v_1][3]['origin']  \n\t\t\tv_k = origin_edge_v_1[1]\n\t\t\tbeta[v_k] = beta[v_1]\n\t\t\tv_i = str(C[str(v_k)])\n\t\t\twhile v_i != v_1:\n\t\t\t\tsupernodes.remove(v_i)\n\t\t\t\tv_i = C.pop(v_i)\n\t\tA = nx.DiGraph()\n\t\tfor k, edge in beta.items():\n\t\t\tif k in nodes:\n\t\t\t\tu,v,key,data = edge[3]['origin']\n\t\t\t\tA.add_edge(u,v,**data.copy())\n\t\treturn A\n\tdef get_priority_queue_for_incoming_node(self, graph, v, b):\n\t\tQ = PriorityQueue()\n\t\tfor u,v,key,data in graph.in_edges([v], data=True, keys=True):\n\t\t\tif key == b[2]:\n\t\t\t\tcontinue\n\t\t\tQ.put((-data[self.attr], (u,v,key,data)))\n\t\treturn Q\n\tdef seek(self, b, A, graph):\n\t\tv = b[1]\n\t\tQ = self.get_priority_queue_for_incoming_node(graph, v, b)\n\t\twhile not Q.empty():\n\t\t\tf = Q.get()\n\t\t\ttry:\n\t\t\t\t# v = T(b) is an ancestor of O(f)=f[1][1]?\n\t\t\t\tv_origin = b[3]['origin'][1]\n\t\t\t\tf_origin = f[1][3]['origin'][0] \n\t\t\t\tnx.shortest_path(A, v_origin, f_origin)\n\t\t\texcept nx.exception.NetworkXNoPath:\n\t\t\t\treturn f[1]\n\t\treturn None\n\tdef next(self, A, Y, Z, graph=None, root='R'):\n\t\td = float('inf')\n\t\tedge = None\n\t\tif graph is not None:\n\t\t\tself._init(graph)\n\t\tM = self.graph\n\t\tfor u,v,key,data in M.edges(data=True, keys=True):\n\t\t\tdata['origin'] = (u,v,key,{self.attr: data[self.attr]})\n\t\tn = 0\n\t\tB = nx.DiGraph()\n\t\tnodes = M.nodes()\n\t\tC = {str(node): None for node in nodes} \n\t\texposed_nodes = [node for node in nodes]\n\t\tif 'R' in exposed_nodes: \n\t\t\texposed_nodes.remove('R')\n\t\torder = []\n\t\tsupernodes = []\n\t\twhile len(exposed_nodes) > 0:\n\t\t\texposed_nodes, order, M, supernodes, B, b = self.add_b_to_branching(exposed_nodes, order, M, supernodes, B)\n\t\t\tif b is None:\n\t\t\t\tcontinue\n\t\t\tb_u, b_v, b_key, b_data = b\n\t\t\torigin_u, origin_v = b_data['origin'][:2]\n\t\t\tif (origin_u, origin_v) in A.edges():\n\t\t\t\tif (origin_u, origin_v) not in Y.edges():\n\t\t\t\t\tf = self.seek(b, A, M)\n\t\t\t\t\tif f is not None:\n\t\t\t\t\t\tf_u, f_v, f_key, f_data = f\n\t\t\t\t\t\tif b_data[self.attr] - f_data[self.attr] < d:\n\t\t\t\t\t\t\tedge = b\n\t\t\t\t\t\t\td = b_data[self.attr] - f_data[self.attr]\n\t\t\tB, n, supernodes, exposed_nodes, M, C = self.contracting_phase(B, n, supernodes, exposed_nodes, M, C, root)\n\t\treturn edge[3]['origin'], d\n\tdef ranking(self, k, graph=None, Y=nx.DiGraph(), Z=nx.DiGraph(), mode='branching', root='R'):\n\t\tif graph is not None:\n\t\t\tself._init(graph, Y, Z)\n\t\tif root == 'R' and mode == 'branching':\n\t\t\tbest = self.best_branching\n\t\telif root == 'R' and mode == 'arborescence_no_rooted':\n\t\t\tbest = self.best_arborescence_no_rooted\n\t\telse:\n\t\t\tbest = self.best_arborescence_rooted\n\t\t\n\t\tgraph = self.graph.copy()\n\t\tA = best(root)  \n\t\troots = self.find_roots(A)\n\t\tif 'R' in roots:\n\t\t\troots.remove('R')\n\t\tprint ('roots for ranking',roots)\n\t\tself._init(graph)\n\t\te, d = self.next(A, Y, Z)  \n\t\tP = PriorityQueue()\n\t\tw = self.get_graph_score(A) - d if d != float('inf') else float('inf') \n\t\tP.put( (-w, e, A, Y, Z) )\n\t\tsolutions = [A]\n\t\tfor j in range(1,k+1):\n\t\t\tw, e, A, Y, Z = P.get()\n\t\t\tw = -w \t\t\t\n\t\t\troots.extend([root for root in self.find_roots(A) if root not in roots])\n\t\t\tif 'R' in roots:\n\t\t\t\troots.remove('R')\n\t\t\tif w == float('-inf'):\n\t\t\t\treturn solutions\n\t\t\te_u, e_v, e_key, data = e\n\t\t\t\n\t\t\tY_ = Y.copy()\n\t\t\tY_.add_edge(e_u, e_v, **data.copy())\n\t\t\t\n\t\t\tZ_ = Z.copy()\nNext line of code:\n", "input": "", "context": "import networkx as nx \nimport pickle\nfrom Queue import PriorityQueue \nimport copy\nimport random\nimport string\nimport sys\nclass MultiDiGraph_EdgeKey(nx.MultiDiGraph):\n    \"\"\"\n    MultiDiGraph which assigns unique keys to every edge.\n    Adds a dictionary edge_index which maps edge keys to (u, v, data) tuples.\n    This is not a complete implementation. For Edmonds algorithm, we only use\n    add_node and add_edge, so that is all that is implemented here. During\n    additions, any specified keys are ignored---this means that you also\n    cannot update edge attributes through add_node and add_edge.\n    \"\"\"\n    def __init__(self, data=None, **attr):\n        cls = super(MultiDiGraph_EdgeKey, self)\n        cls.__init__(data=data, **attr)\n        self._cls = cls\n        self.edge_index = {}\n    def remove_node(self, n):\n        keys = set([])\n        for keydict in self.pred[n].values():\n            keys.update(keydict)\n        for keydict in self.succ[n].values():\n            keys.update(keydict)\n        for key in keys:\n            del self.edge_index[key]\n        self._cls.remove_node(n)\n    def remove_nodes_from(self, nbunch):\n        for n in nbunch:\n            self.remove_node(n)\n    def add_edge(self, u, v, key, attr_dict=None, **attr):\n        \"\"\"\n        Key is now required.\n        \"\"\"\n        if key in self.edge_index:\n            uu, vv, _ = self.edge_index[key]\n            if (u != uu) or (v != vv):\n                raise Exception(\"Key {0!r} is already in use.\".format(key))\n        self._cls.add_edge(u, v, key=key, attr_dict=attr_dict, **attr)\n        self.edge_index[key] = (u, v, self.succ[u][v][key])\n    def add_edges_from(self, ebunch, attr_dict=None, **attr):\n        for edge in ebunch:\n        \tself.add_edge(*edge)\n    def remove_edge_with_key(self, key):\n        try:\n            u, v, _  = self.edge_index[key]\n            # print ('***',u,v,key)\n        except KeyError:\n            raise KeyError('Invalid edge key {0!r}'.format(key))\n        else:\n            del self.edge_index[key]\n            # print ('***** self.edge_index',self.edge_index)\n            self._cls.remove_edge(u, v, key)\n    def remove_edges_from(self, ebunch):\n        raise NotImplementedError\ndef random_string(L=15, seed=None):\n    random.seed(seed)\n    return ''.join([random.choice(string.ascii_letters) for n in range(L)])\nclass Camerini():\n\tdef __init__(self, graph, Y=nx.DiGraph(), Z=nx.DiGraph(), attr='weight'):\n\t\tself.original_graph = graph\n\t\tself.attr = attr\n\t\tself._init(Y=Y, Z=Z)\n\t\tself.template = random_string()\n\t\n\tdef _init(self, graph=None, Y=nx.DiGraph(), Z=nx.DiGraph()):\n\t\tself.graph = MultiDiGraph_EdgeKey()\n\t\tif graph is None:\n\t\t\tgraph = self.original_graph\n\t\tfor key, (u, v, data) in enumerate(graph.edges(data=True)):\n\t\t\tif (u,v) not in Z.edges():\n\t\t\t\tself.graph.add_edge(u,v,key,data.copy())\n\t\t\t\n\t\tfor Y_edge in Y.edges(data=True):\n\t\t\tfor (u,v) in self.graph.in_edges([Y_edge[1]]):\n\t\t\t\tif u != Y_edge[0]:\n\t\t\t\t\tself.graph.remove_edge(u,v)\n\tdef best_incoming_edge(self, node, graph):\n\t\tmax_weight = float('-inf')\n\t\te = None\n\t\t# print ('Graph',graph.edges())\n\t\tfor u,v,key,data in graph.in_edges([node], data=True, keys=True):\n\t\t\t# print ('edge',u,v,data)\n\t\t\tif max_weight <= data[self.attr]:\n\t\t\t\tmax_weight = data[self.attr]\n\t\t\t\te = (u,v,key,data)\n\t\treturn e\n\tdef collapse_cycle(self, graph, cycle, B, new_node):\t\t\t\n\t\tfor node in cycle:\n\t\t\tfor u,v,key,data in graph.out_edges([node], data=True, keys=True):\n\t\t\t\tgraph.remove_edge_with_key(key)\n\t\t\t\tif v not in cycle:\n\t\t\t\t\tdd = data.copy()\n\t\t\t\t\tgraph.add_edge(new_node,v,key,**dd)\t\t\n\t\t\tfor u,v,key,data in graph.in_edges([node], data=True, keys=True):\n\t\t\t\tif u in cycle:\n\t\t\t\t\t# it will be delete later\n\t\t\t\t\tcontinue\n\t\t\t\tgraph.remove_edge_with_key(key)\n\t\t\t\tdd = data.copy()\n\t\t\t\tdd_eh = list(B.in_edges([node], data=True))[0][2] \n\t\t\t\tdd[self.attr] = dd[self.attr] - dd_eh[self.attr]\n\t\t\t\tgraph.add_edge(u, new_node, key, **dd)\n\t\tfor node in cycle:\n\t\t\tB.remove_node(node)\n\t\treturn graph, B\n\tdef add_b_to_branching(self, exposed_nodes, order, M, supernodes, B):\n\t\tv = exposed_nodes.pop(0)\n\t\torder.append(v)\n\t\tb = self.best_incoming_edge(v, M)\n\t\tif b is None:\n\t\t\tif v in supernodes:\n\t\t\t\tsupernodes.remove(v)\n\t\t\treturn exposed_nodes, order, M, supernodes, B, None\n\t\tb_u, b_v, b_key, b_data = b\n\t\tdata = {self.attr: b_data[self.attr], 'origin': b_data['origin']}\n\t\tB.add_edge(b_u, b_v, **data)\n\t\treturn exposed_nodes, order, M, supernodes, B, b\n\tdef contracting_phase(self, B, n, supernodes, exposed_nodes, M, C, root):\n\t\tcycles = list(nx.simple_cycles(B))\n\t\tif len(cycles) > 0:\n\t\t\tu = 'v_'+str(n)\n\t\t\tsupernodes.append(str(u))\n\t\t\texposed_nodes.append(u)\n\t\t\tfor node in cycles[0]:\n\t\t\t\tC[str(node)] = str(u)\n\t\t\tM, B = self.collapse_cycle(M, cycles[0], B, u)\n\t\t\tfor node in B.nodes():\n\t\t\t\tif B.in_edges([node]) == []:\n\t\t\t\t\tif B.out_edges([node]) == []:\n\t\t\t\t\t\tB.remove_node(node)\n\t\t\t\t\tif node != root and node not in exposed_nodes:\n\t\t\t\t\t\texposed_nodes.append(node)\n\t\t\tn += 1\n\t\treturn B, n, supernodes, exposed_nodes, M, C\n\tdef best(self, root):\n\t\tM = self.graph\n\t\tfor u,v,key,data in M.edges(data=True, keys=True):\n\t\t\tdata['origin'] = (u,v,key,{self.attr: data[self.attr]})\n\t\tn = 0\n\t\tB = nx.DiGraph()\n\t\t# C contains for every node its parent node, so it will be easy to find the path in the collapsing phase\n\t\t# from an isolated root v_1 to v_k\n\t\tnodes = M.nodes()\n\t\tif len(nodes) == 1:\n\t\t\tA = nx.DiGraph()\n\t\t\tA.add_node(nodes[0])\n\t\tC = {str(node): None for node in nodes} \n\t\tdel C[str(root)]\n\t\texposed_nodes = [node for node in nodes]\n\t\texposed_nodes.remove(root)\n\t\tsupernodes = []\n\t\tbeta = {}\n\t\torder = []\n\t\t# collapsing phase\n\t\twhile len(exposed_nodes) > 0:\n\t\t\texposed_nodes, order, M, supernodes, B, b = self.add_b_to_branching(exposed_nodes, order, M, supernodes, B)\n\t\t\tif b is None:\n\t\t\t\tcontinue\n\t\t\tb_u, b_v, b_key, b_data = b\n\t\t\tbeta[b_v] = (b_u, b_v, b_key, b_data)\n\t\t\tB, n, supernodes, exposed_nodes, M, C = self.contracting_phase(B, n, supernodes, exposed_nodes, M, C, root)\n\t\t# expanding phase\n\t\twhile len(supernodes) > 0:\n\t\t\tv_1 = supernodes.pop()\n\t\t\torigin_edge_v_1 = beta[v_1][3]['origin']  \n\t\t\tv_k = origin_edge_v_1[1]\n\t\t\tbeta[v_k] = beta[v_1]\n\t\t\tv_i = str(C[str(v_k)])\n\t\t\twhile v_i != v_1:\n\t\t\t\tsupernodes.remove(v_i)\n\t\t\t\tv_i = C.pop(v_i)\n\t\tA = nx.DiGraph()\n\t\tfor k, edge in beta.items():\n\t\t\tif k in nodes:\n\t\t\t\tu,v,key,data = edge[3]['origin']\n\t\t\t\tA.add_edge(u,v,**data.copy())\n\t\treturn A\n\tdef get_priority_queue_for_incoming_node(self, graph, v, b):\n\t\tQ = PriorityQueue()\n\t\tfor u,v,key,data in graph.in_edges([v], data=True, keys=True):\n\t\t\tif key == b[2]:\n\t\t\t\tcontinue\n\t\t\tQ.put((-data[self.attr], (u,v,key,data)))\n\t\treturn Q\n\tdef seek(self, b, A, graph):\n\t\tv = b[1]\n\t\tQ = self.get_priority_queue_for_incoming_node(graph, v, b)\n\t\twhile not Q.empty():\n\t\t\tf = Q.get()\n\t\t\ttry:\n\t\t\t\t# v = T(b) is an ancestor of O(f)=f[1][1]?\n\t\t\t\tv_origin = b[3]['origin'][1]\n\t\t\t\tf_origin = f[1][3]['origin'][0] \n\t\t\t\tnx.shortest_path(A, v_origin, f_origin)\n\t\t\texcept nx.exception.NetworkXNoPath:\n\t\t\t\treturn f[1]\n\t\treturn None\n\tdef next(self, A, Y, Z, graph=None, root='R'):\n\t\td = float('inf')\n\t\tedge = None\n\t\tif graph is not None:\n\t\t\tself._init(graph)\n\t\tM = self.graph\n\t\tfor u,v,key,data in M.edges(data=True, keys=True):\n\t\t\tdata['origin'] = (u,v,key,{self.attr: data[self.attr]})\n\t\tn = 0\n\t\tB = nx.DiGraph()\n\t\tnodes = M.nodes()\n\t\tC = {str(node): None for node in nodes} \n\t\texposed_nodes = [node for node in nodes]\n\t\tif 'R' in exposed_nodes: \n\t\t\texposed_nodes.remove('R')\n\t\torder = []\n\t\tsupernodes = []\n\t\twhile len(exposed_nodes) > 0:\n\t\t\texposed_nodes, order, M, supernodes, B, b = self.add_b_to_branching(exposed_nodes, order, M, supernodes, B)\n\t\t\tif b is None:\n\t\t\t\tcontinue\n\t\t\tb_u, b_v, b_key, b_data = b\n\t\t\torigin_u, origin_v = b_data['origin'][:2]\n\t\t\tif (origin_u, origin_v) in A.edges():\n\t\t\t\tif (origin_u, origin_v) not in Y.edges():\n\t\t\t\t\tf = self.seek(b, A, M)\n\t\t\t\t\tif f is not None:\n\t\t\t\t\t\tf_u, f_v, f_key, f_data = f\n\t\t\t\t\t\tif b_data[self.attr] - f_data[self.attr] < d:\n\t\t\t\t\t\t\tedge = b\n\t\t\t\t\t\t\td = b_data[self.attr] - f_data[self.attr]\n\t\t\tB, n, supernodes, exposed_nodes, M, C = self.contracting_phase(B, n, supernodes, exposed_nodes, M, C, root)\n\t\treturn edge[3]['origin'], d\n\tdef ranking(self, k, graph=None, Y=nx.DiGraph(), Z=nx.DiGraph(), mode='branching', root='R'):\n\t\tif graph is not None:\n\t\t\tself._init(graph, Y, Z)\n\t\tif root == 'R' and mode == 'branching':\n\t\t\tbest = self.best_branching\n\t\telif root == 'R' and mode == 'arborescence_no_rooted':\n\t\t\tbest = self.best_arborescence_no_rooted\n\t\telse:\n\t\t\tbest = self.best_arborescence_rooted\n\t\t\n\t\tgraph = self.graph.copy()\n\t\tA = best(root)  \n\t\troots = self.find_roots(A)\n\t\tif 'R' in roots:\n\t\t\troots.remove('R')\n\t\tprint ('roots for ranking',roots)\n\t\tself._init(graph)\n\t\te, d = self.next(A, Y, Z)  \n\t\tP = PriorityQueue()\n\t\tw = self.get_graph_score(A) - d if d != float('inf') else float('inf') \n\t\tP.put( (-w, e, A, Y, Z) )\n\t\tsolutions = [A]\n\t\tfor j in range(1,k+1):\n\t\t\tw, e, A, Y, Z = P.get()\n\t\t\tw = -w \t\t\t\n\t\t\troots.extend([root for root in self.find_roots(A) if root not in roots])\n\t\t\tif 'R' in roots:\n\t\t\t\troots.remove('R')\n\t\t\tif w == float('-inf'):\n\t\t\t\treturn solutions\n\t\t\te_u, e_v, e_key, data = e\n\t\t\t\n\t\t\tY_ = Y.copy()\n\t\t\tY_.add_edge(e_u, e_v, **data.copy())\n\t\t\t\n\t\t\tZ_ = Z.copy()\n", "answers": ["\t\t\tZ_.add_edge(e_u, e_v, **data.copy())"], "pred": "```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```\n", "length": 1069, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "ca807f49d7c6f84dcae3df694bde685aa7f75a02e9d4f574"}
{"prompt": "Please complete the code given below. \n#! /usr/bin/env python\n# Last Change: Sun Dec 14 07:00 PM 2008 J\n\"\"\"Test for the sndfile class.\"\"\"\nfrom os.path import join, dirname\nimport os\nimport sys\nfrom numpy.testing import TestCase, assert_array_equal, dec\nimport numpy as np\nfrom audiolab import Sndfile, Format, available_encodings, available_file_formats\nfrom testcommon import open_tmp_file, close_tmp_file, TEST_DATA_DIR\n_DTYPE_TO_ENC = {np.float64 : 'float64', np.float32: 'float32', \n                 np.int32: 'pcm32', np.int16: 'pcm16'}\n# XXX: there is a lot to refactor here\nclass TestSndfile(TestCase):\n    def test_basic_io(self):\n        \"\"\" Check open, close and basic read/write\"\"\"\n        # dirty !\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            nbuff = 22050\n            # Open the test file for reading\n            a = Sndfile(ofilename, 'r')\n            nframes = a.nframes\n            # Open the copy file for writing\n            format = Format('wav', 'pcm16')\n            b = Sndfile(fd, 'w', format, a.channels, a.samplerate)\n            # Copy the data\n            for i in range(nframes / nbuff):\n                tmpa    = a.read_frames(nbuff)\n                assert tmpa.dtype == np.float\n                b.write_frames(tmpa)\n            nrem    = nframes % nbuff\n            tmpa    = a.read_frames(nrem)\n            assert tmpa.dtype == np.float\n            b.write_frames(tmpa)\n            a.close()\n            b.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    @dec.skipif(sys.platform=='win32', \n                \"Not testing opening by fd because does not work on win32\")\n    def test_basic_io_fd(self):\n        \"\"\" Check open from fd works\"\"\"\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        fd = os.open(ofilename, os.O_RDONLY)\n        hdl = Sndfile(fd, 'r')\n        hdl.close()\n    def test_raw(self):\n        rawname = join(TEST_DATA_DIR, 'test.raw')\n        format = Format('raw', 'pcm16', 'little')\n        a = Sndfile(rawname, 'r', format, 1, 11025)\n        assert a.nframes == 11290\n        a.close()\n    def test_float64(self):\n        \"\"\"Check float64 write/read works\"\"\"\n        self._test_read_write(np.float64)\n    def test_float32(self):\n        \"\"\"Check float32 write/read works\"\"\"\n        self._test_read_write(np.float32)\n    def test_int32(self):\n        \"\"\"Check 32 bits pcm write/read works\"\"\"\n        self._test_read_write(np.int32)\n    def test_int16(self):\n        \"\"\"Check 16 bits pcm write/read works\"\"\"\n        self._test_read_write(np.int16)\n    def _test_read_write(self, dtype):\n        # dirty !\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            nbuff = 22050\n            # Open the test file for reading\n            a = Sndfile(ofilename, 'r')\n            nframes = a.nframes\n            # Open the copy file for writing\n            format = Format('wav', _DTYPE_TO_ENC[dtype])\n            b = Sndfile(fd, 'w', format, a.channels, a.samplerate)\n            # Copy the data in the wav file\n            for i in range(nframes / nbuff):\n                tmpa    = a.read_frames(nbuff, dtype=dtype)\n                assert tmpa.dtype == dtype\n                b.write_frames(tmpa)\n            nrem = nframes % nbuff\n            tmpa = a.read_frames(nrem)\n            b.write_frames(tmpa)\n            a.close()\n            b.close()\n            # Now, reopen both files in for reading, and check data are\n            # the same\n            a = Sndfile(ofilename, 'r')\n            b = Sndfile(cfilename, 'r')\n            for i in range(nframes / nbuff):\n                tmpa = a.read_frames(nbuff, dtype=dtype)\n                tmpb = b.read_frames(nbuff, dtype=dtype)\n                assert_array_equal(tmpa, tmpb)\n            a.close()\n            b.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    #def test_supported_features(self):\n    #    for i in available_file_formats():\n    #        print \"Available encodings for format %s are : \" % i\n    #        for j in available_encodings(i):\n    #            print '\\t%s' % j\n    def test_short_io(self):\n        self._test_int_io(np.short)\n    def test_int32_io(self):\n        self._test_int_io(np.int32)\n    def _test_int_io(self, dt):\n        # TODO: check if neg or pos value is the highest in abs\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Use almost full possible range possible for the given data-type\n            nb = 2 ** (8 * np.dtype(dt).itemsize - 3)\n            fs = 22050\n            nbuff = fs\n            a = np.random.random_integers(-nb, nb, nbuff)\n            a = a.astype(dt)\n            # Open the file for writing\n            format = Format('wav', _DTYPE_TO_ENC[dt])\n            b = Sndfile(fd, 'w', format, 1, fs)\n            b.write_frames(a)\n            b.close()\n            b = Sndfile(cfilename, 'r')\n            read_a  = b.read_frames(nbuff, dtype=dt)\n            b.close()\n            assert_array_equal(a, read_a)\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_mismatch(self):\n        \"\"\"Check for bad arguments.\"\"\"\n        # This test open a file for writing, but with bad args (channels and\n        # nframes inverted)\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Open the file for writing\n            format = Format('wav', 'pcm16')\n            try:\n                b = Sndfile(fd, 'w', format, channels=22000, samplerate=1)\n                raise AssertionError(\"Try to open a file with more than 256 \"\\\n                                     \"channels, this should not succeed !\")\n            except ValueError, e:\n                pass\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_bigframes(self):\n        \"\"\" Try to seek really far.\"\"\"\n        rawname = join(TEST_DATA_DIR, 'test.wav')\n        a = Sndfile(rawname, 'r')\n        try:\n            try:\n                a.seek(2 ** 60)\n                raise Exception, \\\n                      \"Seek really succeded ! This should not happen\"\n            except IOError, e:\n                pass\n        finally:\n            a.close()\n    def test_float_frames(self):\n        \"\"\" Check nframes can be a float\"\"\"\n        rfd, fd, cfilename   = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Open the file for writing\n            format = Format('wav', 'pcm16')\n            a = Sndfile(fd, 'rw', format, channels=1, samplerate=22050)\n            tmp = np.random.random_integers(-100, 100, 1000)\n            tmp = tmp.astype(np.short)\n            a.write_frames(tmp)\n            a.seek(0)\n            a.sync()\n            ctmp = a.read_frames(1e2, dtype=np.short)\n            a.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_nofile(self):\n        \"\"\" Check the failure when opening a non existing file.\"\"\"\n        try:\n            f = Sndfile(\"floupi.wav\", \"r\")\n            raise AssertionError(\"call to non existing file should not succeed\")\n        except IOError:\n            pass\n        except Exception, e:\n            raise AssertionError(\"opening non existing file should raise\" \\\n                                 \" a IOError exception, got %s instead\" %\n                                 e.__class__)\nclass TestSeek(TestCase):\n    def test_simple(self):\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        # Open the test file for reading\n        a = Sndfile(ofilename, 'r')\n        nframes = a.nframes\n        buffsize = 1024\n        buffsize = min(nframes, buffsize)\n        # First, read some frames, go back, and compare buffers\n        buff = a.read_frames(buffsize)\n        a.seek(0)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff, buff2)\n        a.close()\n        # Now, read some frames, go back, and compare buffers\n        # (check whence == 1 == SEEK_CUR)\n        a = Sndfile(ofilename, 'r')\n        a.read_frames(buffsize)\n        buff = a.read_frames(buffsize)\n        a.seek(-buffsize, 1)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff, buff2)\n        a.close()\n        # Now, read some frames, go back, and compare buffers\n        # (check whence == 2 == SEEK_END)\n        a = Sndfile(ofilename, 'r')\n        buff = a.read_frames(nframes)\n        a.seek(-buffsize, 2)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff[-buffsize:], buff2)\n    def test_rw(self):\n        \"\"\"Test read/write pointers for seek.\"\"\"\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\nNext line of code:\n", "input": "", "context": "#! /usr/bin/env python\n# Last Change: Sun Dec 14 07:00 PM 2008 J\n\"\"\"Test for the sndfile class.\"\"\"\nfrom os.path import join, dirname\nimport os\nimport sys\nfrom numpy.testing import TestCase, assert_array_equal, dec\nimport numpy as np\nfrom audiolab import Sndfile, Format, available_encodings, available_file_formats\nfrom testcommon import open_tmp_file, close_tmp_file, TEST_DATA_DIR\n_DTYPE_TO_ENC = {np.float64 : 'float64', np.float32: 'float32', \n                 np.int32: 'pcm32', np.int16: 'pcm16'}\n# XXX: there is a lot to refactor here\nclass TestSndfile(TestCase):\n    def test_basic_io(self):\n        \"\"\" Check open, close and basic read/write\"\"\"\n        # dirty !\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            nbuff = 22050\n            # Open the test file for reading\n            a = Sndfile(ofilename, 'r')\n            nframes = a.nframes\n            # Open the copy file for writing\n            format = Format('wav', 'pcm16')\n            b = Sndfile(fd, 'w', format, a.channels, a.samplerate)\n            # Copy the data\n            for i in range(nframes / nbuff):\n                tmpa    = a.read_frames(nbuff)\n                assert tmpa.dtype == np.float\n                b.write_frames(tmpa)\n            nrem    = nframes % nbuff\n            tmpa    = a.read_frames(nrem)\n            assert tmpa.dtype == np.float\n            b.write_frames(tmpa)\n            a.close()\n            b.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    @dec.skipif(sys.platform=='win32', \n                \"Not testing opening by fd because does not work on win32\")\n    def test_basic_io_fd(self):\n        \"\"\" Check open from fd works\"\"\"\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        fd = os.open(ofilename, os.O_RDONLY)\n        hdl = Sndfile(fd, 'r')\n        hdl.close()\n    def test_raw(self):\n        rawname = join(TEST_DATA_DIR, 'test.raw')\n        format = Format('raw', 'pcm16', 'little')\n        a = Sndfile(rawname, 'r', format, 1, 11025)\n        assert a.nframes == 11290\n        a.close()\n    def test_float64(self):\n        \"\"\"Check float64 write/read works\"\"\"\n        self._test_read_write(np.float64)\n    def test_float32(self):\n        \"\"\"Check float32 write/read works\"\"\"\n        self._test_read_write(np.float32)\n    def test_int32(self):\n        \"\"\"Check 32 bits pcm write/read works\"\"\"\n        self._test_read_write(np.int32)\n    def test_int16(self):\n        \"\"\"Check 16 bits pcm write/read works\"\"\"\n        self._test_read_write(np.int16)\n    def _test_read_write(self, dtype):\n        # dirty !\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            nbuff = 22050\n            # Open the test file for reading\n            a = Sndfile(ofilename, 'r')\n            nframes = a.nframes\n            # Open the copy file for writing\n            format = Format('wav', _DTYPE_TO_ENC[dtype])\n            b = Sndfile(fd, 'w', format, a.channels, a.samplerate)\n            # Copy the data in the wav file\n            for i in range(nframes / nbuff):\n                tmpa    = a.read_frames(nbuff, dtype=dtype)\n                assert tmpa.dtype == dtype\n                b.write_frames(tmpa)\n            nrem = nframes % nbuff\n            tmpa = a.read_frames(nrem)\n            b.write_frames(tmpa)\n            a.close()\n            b.close()\n            # Now, reopen both files in for reading, and check data are\n            # the same\n            a = Sndfile(ofilename, 'r')\n            b = Sndfile(cfilename, 'r')\n            for i in range(nframes / nbuff):\n                tmpa = a.read_frames(nbuff, dtype=dtype)\n                tmpb = b.read_frames(nbuff, dtype=dtype)\n                assert_array_equal(tmpa, tmpb)\n            a.close()\n            b.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    #def test_supported_features(self):\n    #    for i in available_file_formats():\n    #        print \"Available encodings for format %s are : \" % i\n    #        for j in available_encodings(i):\n    #            print '\\t%s' % j\n    def test_short_io(self):\n        self._test_int_io(np.short)\n    def test_int32_io(self):\n        self._test_int_io(np.int32)\n    def _test_int_io(self, dt):\n        # TODO: check if neg or pos value is the highest in abs\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Use almost full possible range possible for the given data-type\n            nb = 2 ** (8 * np.dtype(dt).itemsize - 3)\n            fs = 22050\n            nbuff = fs\n            a = np.random.random_integers(-nb, nb, nbuff)\n            a = a.astype(dt)\n            # Open the file for writing\n            format = Format('wav', _DTYPE_TO_ENC[dt])\n            b = Sndfile(fd, 'w', format, 1, fs)\n            b.write_frames(a)\n            b.close()\n            b = Sndfile(cfilename, 'r')\n            read_a  = b.read_frames(nbuff, dtype=dt)\n            b.close()\n            assert_array_equal(a, read_a)\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_mismatch(self):\n        \"\"\"Check for bad arguments.\"\"\"\n        # This test open a file for writing, but with bad args (channels and\n        # nframes inverted)\n        rfd, fd, cfilename = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Open the file for writing\n            format = Format('wav', 'pcm16')\n            try:\n                b = Sndfile(fd, 'w', format, channels=22000, samplerate=1)\n                raise AssertionError(\"Try to open a file with more than 256 \"\\\n                                     \"channels, this should not succeed !\")\n            except ValueError, e:\n                pass\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_bigframes(self):\n        \"\"\" Try to seek really far.\"\"\"\n        rawname = join(TEST_DATA_DIR, 'test.wav')\n        a = Sndfile(rawname, 'r')\n        try:\n            try:\n                a.seek(2 ** 60)\n                raise Exception, \\\n                      \"Seek really succeded ! This should not happen\"\n            except IOError, e:\n                pass\n        finally:\n            a.close()\n    def test_float_frames(self):\n        \"\"\" Check nframes can be a float\"\"\"\n        rfd, fd, cfilename   = open_tmp_file('pysndfiletest.wav')\n        try:\n            # Open the file for writing\n            format = Format('wav', 'pcm16')\n            a = Sndfile(fd, 'rw', format, channels=1, samplerate=22050)\n            tmp = np.random.random_integers(-100, 100, 1000)\n            tmp = tmp.astype(np.short)\n            a.write_frames(tmp)\n            a.seek(0)\n            a.sync()\n            ctmp = a.read_frames(1e2, dtype=np.short)\n            a.close()\n        finally:\n            close_tmp_file(rfd, cfilename)\n    def test_nofile(self):\n        \"\"\" Check the failure when opening a non existing file.\"\"\"\n        try:\n            f = Sndfile(\"floupi.wav\", \"r\")\n            raise AssertionError(\"call to non existing file should not succeed\")\n        except IOError:\n            pass\n        except Exception, e:\n            raise AssertionError(\"opening non existing file should raise\" \\\n                                 \" a IOError exception, got %s instead\" %\n                                 e.__class__)\nclass TestSeek(TestCase):\n    def test_simple(self):\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n        # Open the test file for reading\n        a = Sndfile(ofilename, 'r')\n        nframes = a.nframes\n        buffsize = 1024\n        buffsize = min(nframes, buffsize)\n        # First, read some frames, go back, and compare buffers\n        buff = a.read_frames(buffsize)\n        a.seek(0)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff, buff2)\n        a.close()\n        # Now, read some frames, go back, and compare buffers\n        # (check whence == 1 == SEEK_CUR)\n        a = Sndfile(ofilename, 'r')\n        a.read_frames(buffsize)\n        buff = a.read_frames(buffsize)\n        a.seek(-buffsize, 1)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff, buff2)\n        a.close()\n        # Now, read some frames, go back, and compare buffers\n        # (check whence == 2 == SEEK_END)\n        a = Sndfile(ofilename, 'r')\n        buff = a.read_frames(nframes)\n        a.seek(-buffsize, 2)\n        buff2 = a.read_frames(buffsize)\n        assert_array_equal(buff[-buffsize:], buff2)\n    def test_rw(self):\n        \"\"\"Test read/write pointers for seek.\"\"\"\n        ofilename = join(TEST_DATA_DIR, 'test.wav')\n", "answers": ["        rfd, fd, cfilename   = open_tmp_file('rwseektest.wav')"], "pred": "  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n  \"Test read/write pointers for seek.\"\n ", "length": 844, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "04429037d9380b6e9c3f7b2070992a5af10745895025113c"}
{"prompt": "Please complete the code given below. \n#!/usr/bin/env python\nfrom apps.webdriver_testing.pages.site_pages import UnisubsPage\nfrom urlparse import urlsplit\nclass VideoPage(UnisubsPage):\n    \"\"\"\n     Video Page contains the common elements in the video page.\n    \"\"\"\n    _URL = \"videos/%s/info/\"  # %s is the unique onsite video id\n    _VIDEO_TITLE = \".main-title a\"\n    _SPEAKER_NAME = \"div.content div div > h4\"\n    _LOCATION = \"div.content div div h4:nth-child(2)\"\n    _DESCRIPTION = \"div#description\"\n    _EMBEDDED_VIDEO = \"div.unisubs-widget div.unisubs-videoTab-container\"\n    _SUBTITLE_MENU = \"a.unisubs-subtitleMeLink span.unisubs-tabTextchoose\"\n    _LIKE_FACEBOOK = \"li.unisubs-facebook-like button\"\n    _POST_FACEBOOK = \"a.facebook\"\n    _POST_TWITTER = \"a.twittter\"\n    _EMAIL_FRIENDS = \"a.email\"\n    _FOLLOW = \"button.follow-button\"\n    #FOLLOW CONFIRMATION\n    _UNFOLLOW_ALL = 'input#unfollow-all-languages-button'\n    _SUBTITLES_OK = 'input#popup_ok'\n    _EMBED_HELP = \"div.unisubs-share h3 a.embed_options_link\"\n    _EMBED_CODE = (\"div#embed-modal.modal div.modal-body form fieldset \"\n        \"textarea\")\n    #TOP TABS\n    _URLS_TAB = 'href=\"?tab=urls\"]'\n    _VIDEO_TAB = 'a[href=\"?tab=video\"]'\n    _COMMENTS_TAB = 'a[href=\"?tab=comments\"]'\n    _ACTIVITY_TAB = 'a[href=\"?tab=activity\"]'\n    _ADD_SUBTITLES = \"a.add_subtitles\"\n    #VIDEO SIDE SECTION\n    _INFO = \"ul#video-menu.left_nav li:nth-child(1) > a\"\n    _ADD_TRANSLATION = \"li.contribute a#add_translation\"\n    _UPLOAD_SUBTITLES = \"a#upload-subtitles-link\"\n    #SUBTITLES_SIDE_SECTION\n    _SUB_LANGUAGES = \"ul#subtitles-menu li\"\n    _STATUS_TAGS = \"span.tags\"\n    #TEAM_SIDE_SECTION\n    _ADD_TO_TEAM_PULLDOWN = (\"ul#moderation-menu.left_nav li div.sort_button \"\n        \"div.arrow\")\n    _TEAM_LINK = (\"ul#moderation-menu.left_nav li div.sort_button ul li \"\n        \"a[href*='%s']\")\n    #ADMIN_SIDE_SECTION\n    _DEBUG_INFO = \"\"\n    _EDIT = \"\"\n    #UPLOAD SUBTITLES DIALOG\n    _SELECT_LANGUAGE = 'select#id_language_code'\n    _TRANSLATE_FROM = 'select#id_from_language_code'\n    _PRIMARY_AUDIO = 'select#id_primary_audio_language_code'\n    _SUBTITLES_FILE = 'input#subtitles-file-field'\n    _IS_COMPLETE = 'input#updload-subtitles-form-is_complete' #checked default\n    _UPLOAD_SUBMIT = 'form#upload-subtitles-form button.green_button'\n    _FEEDBACK_MESSAGE = 'p.feedback-message'\n    _CLOSE = 'div#upload_subs-div a.close'\n    UPLOAD_SUCCESS_TEXT = ('Thank you for uploading. It may take a minute or '\n                           'so for your subtitles to appear.')\n    #TAB FIELDS\n    _COMMENTS_BOX = 'textarea#id_comment_form_content'\n    _ACTIVITY_LIST = 'ul.activity li p'    \n    def open_video_page(self, video_id):\n        self.open_page(self._URL % video_id)\n    def open_video_activity(self, video_id):\n        self.open_video_page(video_id)\n        self.click_by_css(self._ACTIVITY_TAB)\n    def video_title(self):\n        return self.get_text_by_css(self._VIDEO_TITLE)\n    def add_translation(self):\n        self.click_by_css(self._ADD_TRANSLATION)\n    def upload_subtitles(self, \n                         sub_lang, \n                         sub_file,\n                         audio_lang = None,\n                         translated_from = None, \n                         is_complete = True):\n        #Open the dialog\n        self.wait_for_element_visible(self._UPLOAD_SUBTITLES)\n        self.click_by_css(self._UPLOAD_SUBTITLES)\n        #Choose the language\n        self.wait_for_element_visible(self._SELECT_LANGUAGE)\n        self.select_option_by_text(self._SELECT_LANGUAGE, sub_lang)\n        #Set the audio language\n        if audio_lang:\n            self.select_option_by_text(self._PRIMARY_AUDIO, audio_lang)\n        #Set the translation_from field\n        if translated_from:\n            self.select_option_by_text(self._TRANSLATE_FROM, translated_from)\n        #Input the subtitle file\n        self.type_by_css(self._SUBTITLES_FILE, sub_file)\n        #Set complete\n        if not is_complete:\n            self.click_by_css(self._IS_COMPLETE)\n        #Start the upload\n        self.wait_for_element_present(self._UPLOAD_SUBMIT)\n        self.click_by_css(self._UPLOAD_SUBMIT)\n        #Get the the response message\n        self.wait_for_element_present(self._FEEDBACK_MESSAGE, wait_time=20)\n        message_text = self.get_text_by_css(self._FEEDBACK_MESSAGE)\n        #Close the dialog\n        self.click_by_css(self._CLOSE)\n        self.wait_for_element_not_visible(self._CLOSE)\n        return message_text\n    def open_info_page(self):\n        self.click_by_css(self._INFO)\n    def add_video_to_team(self, team_name):\n        self.click_by_css(self._ADD_TO_TEAM_PULLDOWN)\n        self.click_by_css(self._TEAM_LINK % team_name)\n    def video_id(self):\n        page_url = self.browser.current_url\n        url_parts = urlsplit(page_url).path\n        urlfrag = url_parts.split('/')[3]\n        return urlfrag\n    def description_text(self):\n        return self.get_text_by_css(self._DESCRIPTION)\n    def speaker_name(self):\n        return self.get_text_by_css(self._SPEAKER_NAME)\n    def location(self):\n        return self.get_text_by_css(self._LOCATION)\n    def video_embed_present(self):\n        if self.is_element_present(self._EMBEDDED_VIDEO):\n            return True\n    def add_subtitles(self):\n        self.click_by_css(self._ADD_SUBTITLES)\n    def team_slug(self, slug):\n        \"\"\"Return true if the team stub is linked on the video page.\n        \"\"\"\n        team_link = \"a[href*='/teams/%s/']\" % slug\n        if self.is_element_present(team_link):\n            return True\n    def feature_video(self):\n        self.click_link_text('Feature video')\n    def unfeature_video(self):\n        self.click_link_text('Unfeature video')\n    def displays_subtitle_me(self):\n        return self.is_element_visible(self._SUBTITLE_MENU)\n    def click_subtitle_me(self):\n        self.click_by_css(self._SUBTITLE_MENU)\n    def displays_add_subtitles(self):\n        return self.is_element_visible(self._ADD_SUBTITLES)\n    def displays_add_translation(self):\n        return self.is_element_visible(self._ADD_TRANSLATION)\n    def displays_upload_subtitles(self):\n        return self.is_element_visible(self._UPLOAD_SUBTITLES)\n    def follow_text(self):\n        return self.get_text_by_css(self._FOLLOW)\n    def toggle_follow(self, lang=False):\n        self.click_by_css(self._FOLLOW)\n        if lang:\n            self.click_by_css(self._SUBTITLES_OK)\n        else:\n            self.click_by_css(self._UNFOLLOW_ALL)\n    def subtitle_languages(self):\n        langs = []\n        els = self.get_elements_list(self._SUB_LANGUAGES + \" a\")\n        for el in els:\n            langs.append(el.text)\n        return langs\n    def language_status(self, language):\n        els =  self.get_elements_list(self._SUB_LANGUAGES)\n        for el in els:\n            e = el.find_element_by_css_selector(\"a\")\n            self.logger.info(e.text)\nNext line of code:\n", "input": "", "context": "#!/usr/bin/env python\nfrom apps.webdriver_testing.pages.site_pages import UnisubsPage\nfrom urlparse import urlsplit\nclass VideoPage(UnisubsPage):\n    \"\"\"\n     Video Page contains the common elements in the video page.\n    \"\"\"\n    _URL = \"videos/%s/info/\"  # %s is the unique onsite video id\n    _VIDEO_TITLE = \".main-title a\"\n    _SPEAKER_NAME = \"div.content div div > h4\"\n    _LOCATION = \"div.content div div h4:nth-child(2)\"\n    _DESCRIPTION = \"div#description\"\n    _EMBEDDED_VIDEO = \"div.unisubs-widget div.unisubs-videoTab-container\"\n    _SUBTITLE_MENU = \"a.unisubs-subtitleMeLink span.unisubs-tabTextchoose\"\n    _LIKE_FACEBOOK = \"li.unisubs-facebook-like button\"\n    _POST_FACEBOOK = \"a.facebook\"\n    _POST_TWITTER = \"a.twittter\"\n    _EMAIL_FRIENDS = \"a.email\"\n    _FOLLOW = \"button.follow-button\"\n    #FOLLOW CONFIRMATION\n    _UNFOLLOW_ALL = 'input#unfollow-all-languages-button'\n    _SUBTITLES_OK = 'input#popup_ok'\n    _EMBED_HELP = \"div.unisubs-share h3 a.embed_options_link\"\n    _EMBED_CODE = (\"div#embed-modal.modal div.modal-body form fieldset \"\n        \"textarea\")\n    #TOP TABS\n    _URLS_TAB = 'href=\"?tab=urls\"]'\n    _VIDEO_TAB = 'a[href=\"?tab=video\"]'\n    _COMMENTS_TAB = 'a[href=\"?tab=comments\"]'\n    _ACTIVITY_TAB = 'a[href=\"?tab=activity\"]'\n    _ADD_SUBTITLES = \"a.add_subtitles\"\n    #VIDEO SIDE SECTION\n    _INFO = \"ul#video-menu.left_nav li:nth-child(1) > a\"\n    _ADD_TRANSLATION = \"li.contribute a#add_translation\"\n    _UPLOAD_SUBTITLES = \"a#upload-subtitles-link\"\n    #SUBTITLES_SIDE_SECTION\n    _SUB_LANGUAGES = \"ul#subtitles-menu li\"\n    _STATUS_TAGS = \"span.tags\"\n    #TEAM_SIDE_SECTION\n    _ADD_TO_TEAM_PULLDOWN = (\"ul#moderation-menu.left_nav li div.sort_button \"\n        \"div.arrow\")\n    _TEAM_LINK = (\"ul#moderation-menu.left_nav li div.sort_button ul li \"\n        \"a[href*='%s']\")\n    #ADMIN_SIDE_SECTION\n    _DEBUG_INFO = \"\"\n    _EDIT = \"\"\n    #UPLOAD SUBTITLES DIALOG\n    _SELECT_LANGUAGE = 'select#id_language_code'\n    _TRANSLATE_FROM = 'select#id_from_language_code'\n    _PRIMARY_AUDIO = 'select#id_primary_audio_language_code'\n    _SUBTITLES_FILE = 'input#subtitles-file-field'\n    _IS_COMPLETE = 'input#updload-subtitles-form-is_complete' #checked default\n    _UPLOAD_SUBMIT = 'form#upload-subtitles-form button.green_button'\n    _FEEDBACK_MESSAGE = 'p.feedback-message'\n    _CLOSE = 'div#upload_subs-div a.close'\n    UPLOAD_SUCCESS_TEXT = ('Thank you for uploading. It may take a minute or '\n                           'so for your subtitles to appear.')\n    #TAB FIELDS\n    _COMMENTS_BOX = 'textarea#id_comment_form_content'\n    _ACTIVITY_LIST = 'ul.activity li p'    \n    def open_video_page(self, video_id):\n        self.open_page(self._URL % video_id)\n    def open_video_activity(self, video_id):\n        self.open_video_page(video_id)\n        self.click_by_css(self._ACTIVITY_TAB)\n    def video_title(self):\n        return self.get_text_by_css(self._VIDEO_TITLE)\n    def add_translation(self):\n        self.click_by_css(self._ADD_TRANSLATION)\n    def upload_subtitles(self, \n                         sub_lang, \n                         sub_file,\n                         audio_lang = None,\n                         translated_from = None, \n                         is_complete = True):\n        #Open the dialog\n        self.wait_for_element_visible(self._UPLOAD_SUBTITLES)\n        self.click_by_css(self._UPLOAD_SUBTITLES)\n        #Choose the language\n        self.wait_for_element_visible(self._SELECT_LANGUAGE)\n        self.select_option_by_text(self._SELECT_LANGUAGE, sub_lang)\n        #Set the audio language\n        if audio_lang:\n            self.select_option_by_text(self._PRIMARY_AUDIO, audio_lang)\n        #Set the translation_from field\n        if translated_from:\n            self.select_option_by_text(self._TRANSLATE_FROM, translated_from)\n        #Input the subtitle file\n        self.type_by_css(self._SUBTITLES_FILE, sub_file)\n        #Set complete\n        if not is_complete:\n            self.click_by_css(self._IS_COMPLETE)\n        #Start the upload\n        self.wait_for_element_present(self._UPLOAD_SUBMIT)\n        self.click_by_css(self._UPLOAD_SUBMIT)\n        #Get the the response message\n        self.wait_for_element_present(self._FEEDBACK_MESSAGE, wait_time=20)\n        message_text = self.get_text_by_css(self._FEEDBACK_MESSAGE)\n        #Close the dialog\n        self.click_by_css(self._CLOSE)\n        self.wait_for_element_not_visible(self._CLOSE)\n        return message_text\n    def open_info_page(self):\n        self.click_by_css(self._INFO)\n    def add_video_to_team(self, team_name):\n        self.click_by_css(self._ADD_TO_TEAM_PULLDOWN)\n        self.click_by_css(self._TEAM_LINK % team_name)\n    def video_id(self):\n        page_url = self.browser.current_url\n        url_parts = urlsplit(page_url).path\n        urlfrag = url_parts.split('/')[3]\n        return urlfrag\n    def description_text(self):\n        return self.get_text_by_css(self._DESCRIPTION)\n    def speaker_name(self):\n        return self.get_text_by_css(self._SPEAKER_NAME)\n    def location(self):\n        return self.get_text_by_css(self._LOCATION)\n    def video_embed_present(self):\n        if self.is_element_present(self._EMBEDDED_VIDEO):\n            return True\n    def add_subtitles(self):\n        self.click_by_css(self._ADD_SUBTITLES)\n    def team_slug(self, slug):\n        \"\"\"Return true if the team stub is linked on the video page.\n        \"\"\"\n        team_link = \"a[href*='/teams/%s/']\" % slug\n        if self.is_element_present(team_link):\n            return True\n    def feature_video(self):\n        self.click_link_text('Feature video')\n    def unfeature_video(self):\n        self.click_link_text('Unfeature video')\n    def displays_subtitle_me(self):\n        return self.is_element_visible(self._SUBTITLE_MENU)\n    def click_subtitle_me(self):\n        self.click_by_css(self._SUBTITLE_MENU)\n    def displays_add_subtitles(self):\n        return self.is_element_visible(self._ADD_SUBTITLES)\n    def displays_add_translation(self):\n        return self.is_element_visible(self._ADD_TRANSLATION)\n    def displays_upload_subtitles(self):\n        return self.is_element_visible(self._UPLOAD_SUBTITLES)\n    def follow_text(self):\n        return self.get_text_by_css(self._FOLLOW)\n    def toggle_follow(self, lang=False):\n        self.click_by_css(self._FOLLOW)\n        if lang:\n            self.click_by_css(self._SUBTITLES_OK)\n        else:\n            self.click_by_css(self._UNFOLLOW_ALL)\n    def subtitle_languages(self):\n        langs = []\n        els = self.get_elements_list(self._SUB_LANGUAGES + \" a\")\n        for el in els:\n            langs.append(el.text)\n        return langs\n    def language_status(self, language):\n        els =  self.get_elements_list(self._SUB_LANGUAGES)\n        for el in els:\n            e = el.find_element_by_css_selector(\"a\")\n            self.logger.info(e.text)\n", "answers": ["            if e.text == language:"], "pred": "  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e\n  e = e", "length": 462, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "9bc1f81e1a4c4b44da11ffc093a0c9fecbe5f99e4eff3aa5"}
{"prompt": "Please complete the code given below. \n/*\n * $Header: it.geosolutions.geobatch.wmc.WMCStream,v. 0.1 03/dic/2009 01:55:21 created by Fabiani $\n * $Revision: 0.1 $\n * $Date: 03/dic/2009 01:55:21 $\n *\n * ====================================================================\n *\n * Copyright (C) 2007-2008 GeoSolutions S.A.S.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. \n *\n * ====================================================================\n *\n * This software consists of voluntary contributions made by developers\n * of GeoSolutions.  For more information on GeoSolutions, please see\n * <http://www.geo-solutions.it/>.\n *\n */\npackage it.geosolutions.geobatch.wmc;\nimport it.geosolutions.geobatch.wmc.model.GeneralWMCConfiguration;\nimport it.geosolutions.geobatch.wmc.model.OLBaseClass;\nimport it.geosolutions.geobatch.wmc.model.OLDimension;\nimport it.geosolutions.geobatch.wmc.model.OLExtent;\nimport it.geosolutions.geobatch.wmc.model.OLStyleColorRamps;\nimport it.geosolutions.geobatch.wmc.model.OLStyleValue;\nimport it.geosolutions.geobatch.wmc.model.ViewContext;\nimport it.geosolutions.geobatch.wmc.model.WMCBoundingBox;\nimport it.geosolutions.geobatch.wmc.model.WMCExtension;\nimport it.geosolutions.geobatch.wmc.model.WMCFormat;\nimport it.geosolutions.geobatch.wmc.model.WMCLayer;\nimport it.geosolutions.geobatch.wmc.model.WMCOnlineResource;\nimport it.geosolutions.geobatch.wmc.model.WMCSLD;\nimport it.geosolutions.geobatch.wmc.model.WMCServer;\nimport it.geosolutions.geobatch.wmc.model.WMCStyle;\nimport it.geosolutions.geobatch.wmc.model.WMCWindow;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.xml.DomDriver;\n/**\n * @author Fabiani\n *\n */\npublic class WMCStream {\n\tprivate XStream xstream = new XStream(new DomDriver(\"UTF-8\"));\n\t\n\t/**\n\t * \n\t */\n\tpublic WMCStream() {\n    \t// WMC ViewContext\n    \txstream.alias(\"ViewContext\", ViewContext.class);\n    \txstream.useAttributeFor(ViewContext.class, \"xmlns\");\n    \txstream.useAttributeFor(ViewContext.class, \"xlink\");\n    \txstream.useAttributeFor(ViewContext.class, \"id\");\n    \txstream.useAttributeFor(ViewContext.class, \"version\");\n    \txstream.aliasField(\"xmlns:xlink\", ViewContext.class, \"xlink\");\n    \txstream.aliasField(\"General\", ViewContext.class, \"general\");\n    \txstream.aliasField(\"LayerList\", ViewContext.class, \"layerList\");\n    \t// WMC ViewContext::General\n    \txstream.aliasField(\"Window\", GeneralWMCConfiguration.class, \"window\");\n    \txstream.aliasField(\"Title\", GeneralWMCConfiguration.class, \"title\");\n    \txstream.aliasField(\"Abstract\", GeneralWMCConfiguration.class, \"_abstract\");\n    \t// WMC ViewContext::General::Window\n    \txstream.useAttributeFor(WMCWindow.class, \"height\");\n    \txstream.useAttributeFor(WMCWindow.class, \"width\");\n    \txstream.aliasField(\"BoundingBox\", WMCWindow.class, \"bbox\");\n    \t// WMC ViewContext::General::Window::BoundingBox\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"srs\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"maxx\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"maxy\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"minx\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"miny\");\n    \txstream.aliasField(\"SRS\", WMCBoundingBox.class, \"srs\");\n    \t// WMC ViewContext::LayerList::Layer\n    \txstream.alias(\"Layer\", WMCLayer.class);\n    \txstream.useAttributeFor(WMCLayer.class, \"queryable\");\n    \txstream.useAttributeFor(WMCLayer.class, \"hidden\");\n    \txstream.aliasField(\"SRS\", WMCLayer.class, \"srs\");\n    \txstream.aliasField(\"Name\", WMCLayer.class, \"name\");\n    \txstream.aliasField(\"Title\", WMCLayer.class, \"title\");\n    \txstream.aliasField(\"Server\", WMCLayer.class, \"server\");\n    \txstream.aliasField(\"FormatList\", WMCLayer.class, \"formatList\");\n    \txstream.aliasField(\"StyleList\", WMCLayer.class, \"styleList\");\n    \txstream.aliasField(\"Extension\", WMCLayer.class, \"extension\");\n    \t// WMC ViewContext::LayerList::Layer::Server\n    \txstream.useAttributeFor(WMCServer.class, \"service\");\n    \txstream.useAttributeFor(WMCServer.class, \"version\");\n    \txstream.useAttributeFor(WMCServer.class, \"title\");\n    \txstream.aliasField(\"OnlineResource\", WMCServer.class, \"onlineResource\");\n    \t// WMC ViewContext::LayerList::Layer::Server::OnlineResource\n    \txstream.useAttributeFor(WMCOnlineResource.class, \"xlink_type\");\n    \txstream.useAttributeFor(WMCOnlineResource.class, \"xlink_href\");\n    \txstream.aliasField(\"xlink:type\", WMCOnlineResource.class, \"xlink_type\");\n    \txstream.aliasField(\"xlink:href\", WMCOnlineResource.class, \"xlink_href\");\n    \t// WMC ViewContext::LayerList::Layer::FormatList::Format\n    \txstream.alias(\"Format\", WMCFormat.class);\n    \txstream.registerConverter(new Converter() {\n\t\t\tpublic boolean canConvert(Class clazz) {\n\t\t\t\treturn WMCFormat.class.isAssignableFrom(clazz);\n\t\t\t}\n\t\t\tpublic void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {\n\t\t\t\tWMCFormat format = (WMCFormat) value;\n\t\t\t\t\n\t\t\t\twriter.addAttribute(\"current\", format.getCurrent());\n\t\t\t\tif (format.getContent() != null)\n\t\t\t\t\twriter.setValue(format.getContent());\n\t\t\t}\n\t\t\tpublic Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n\t\t\t\tWMCFormat format = new WMCFormat(\"1\", reader.getValue());\n\t\t\t\t\n\t\t\t\treturn format;\n\t\t\t}\n    \t\t\n    \t});\n    \t// WMC ViewContext::LayerList::Layer::FormatList::Style\n    \txstream.alias(\"Style\", WMCStyle.class);\n    \txstream.useAttributeFor(WMCStyle.class, \"current\");\n    \txstream.aliasField(\"SLD\", WMCStyle.class, \"sld\");\n    \txstream.aliasField(\"OnlineResource\", WMCSLD.class, \"onlineResource\");\n    \t// WMC ViewContext::LayerList::Layer::Extension\n    \txstream.alias(\"Extension\", WMCExtension.class);\n    \t\n    \t// WMC ViewContext::LayerList::Layer::Extension::OL\n    \txstream.aliasField(\"ol:id\", WMCExtension.class, \"id\");\n    \txstream.aliasField(\"ol:transparent\", WMCExtension.class, \"transparent\");\n    \txstream.aliasField(\"ol:isBaseLayer\", WMCExtension.class, \"isBaseLayer\");\n    \txstream.aliasField(\"ol:opacity\", WMCExtension.class, \"opacity\");\n    \txstream.aliasField(\"ol:displayInLayerSwitcher\", WMCExtension.class, \"displayInLayerSwitcher\");\n    \txstream.aliasField(\"ol:singleTile\", WMCExtension.class, \"singleTile\");\n    \txstream.aliasField(\"ol:numZoomLevels\", WMCExtension.class, \"numZoomLevels\");\n    \txstream.aliasField(\"ol:units\", WMCExtension.class, \"units\");\n    \txstream.aliasField(\"ol:maxExtent\", WMCExtension.class, \"maxExtent\");\n    \txstream.aliasField(\"ol:dimension\", WMCExtension.class, \"time\");\n    \txstream.aliasField(\"ol:dimension\", WMCExtension.class, \"elevation\");\n    \t\n    \txstream.aliasField(\"ol:mainLayer\", WMCExtension.class, \"mainLayer\");\n    \txstream.aliasField(\"ol:styleClassNumber\", WMCExtension.class, \"styleClassNumber\");\n    \txstream.aliasField(\"ol:styleColorRamps\", WMCExtension.class, \"styleColorRamps\");\n    \txstream.aliasField(\"ol:styleMaxValue\", WMCExtension.class, \"styleMaxValue\");\n    \txstream.aliasField(\"ol:styleMinValue\", WMCExtension.class, \"styleMinValue\");\n    \txstream.aliasField(\"ol:styleRestService\", WMCExtension.class, \"styleRestService\");\n    \txstream.aliasField(\"ol:styleLegendService\", WMCExtension.class, \"styleLegendService\");\n    \t\n    \txstream.useAttributeFor(OLStyleColorRamps.class, \"defaultRamp\");\n    \txstream.aliasField(\"default\", OLStyleColorRamps.class, \"defaultRamp\");\n    \t\n    \txstream.registerConverter(new Converter() {\n\t\t\tpublic boolean canConvert(Class clazz) {\n\t\t\t\treturn OLBaseClass.class.isAssignableFrom(clazz);\n\t\t\t}\n\t\t\tpublic void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {\n\t\t\t\tOLBaseClass ol = (OLBaseClass) value;\n\t\t\t\t\n\t\t\t\twriter.addAttribute(\"xmlns:ol\", ol.getXmlns_ol());\n\t\t\t\t\n\t\t\t\tif (value instanceof OLExtent) {\n\t\t\t\t\tOLExtent extent = (OLExtent) value;\n\t\t\t\t\twriter.addAttribute(\"minx\", extent.getMinx());\n\t\t\t\t\twriter.addAttribute(\"miny\", extent.getMiny());\n\t\t\t\t\twriter.addAttribute(\"maxx\", extent.getMaxx());\n\t\t\t\t\twriter.addAttribute(\"maxy\", extent.getMaxy());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value instanceof OLDimension) {\n\t\t\t\t\tOLDimension dimension = (OLDimension) value;\n\t\t\t\t\twriter.addAttribute(\"name\", dimension.getName());\n\t\t\t\t\twriter.addAttribute(\"default\", dimension.getDefaultValue());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value instanceof OLStyleValue) {\nNext line of code:\n", "input": "", "context": "/*\n * $Header: it.geosolutions.geobatch.wmc.WMCStream,v. 0.1 03/dic/2009 01:55:21 created by Fabiani $\n * $Revision: 0.1 $\n * $Date: 03/dic/2009 01:55:21 $\n *\n * ====================================================================\n *\n * Copyright (C) 2007-2008 GeoSolutions S.A.S.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. \n *\n * ====================================================================\n *\n * This software consists of voluntary contributions made by developers\n * of GeoSolutions.  For more information on GeoSolutions, please see\n * <http://www.geo-solutions.it/>.\n *\n */\npackage it.geosolutions.geobatch.wmc;\nimport it.geosolutions.geobatch.wmc.model.GeneralWMCConfiguration;\nimport it.geosolutions.geobatch.wmc.model.OLBaseClass;\nimport it.geosolutions.geobatch.wmc.model.OLDimension;\nimport it.geosolutions.geobatch.wmc.model.OLExtent;\nimport it.geosolutions.geobatch.wmc.model.OLStyleColorRamps;\nimport it.geosolutions.geobatch.wmc.model.OLStyleValue;\nimport it.geosolutions.geobatch.wmc.model.ViewContext;\nimport it.geosolutions.geobatch.wmc.model.WMCBoundingBox;\nimport it.geosolutions.geobatch.wmc.model.WMCExtension;\nimport it.geosolutions.geobatch.wmc.model.WMCFormat;\nimport it.geosolutions.geobatch.wmc.model.WMCLayer;\nimport it.geosolutions.geobatch.wmc.model.WMCOnlineResource;\nimport it.geosolutions.geobatch.wmc.model.WMCSLD;\nimport it.geosolutions.geobatch.wmc.model.WMCServer;\nimport it.geosolutions.geobatch.wmc.model.WMCStyle;\nimport it.geosolutions.geobatch.wmc.model.WMCWindow;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.xml.DomDriver;\n/**\n * @author Fabiani\n *\n */\npublic class WMCStream {\n\tprivate XStream xstream = new XStream(new DomDriver(\"UTF-8\"));\n\t\n\t/**\n\t * \n\t */\n\tpublic WMCStream() {\n    \t// WMC ViewContext\n    \txstream.alias(\"ViewContext\", ViewContext.class);\n    \txstream.useAttributeFor(ViewContext.class, \"xmlns\");\n    \txstream.useAttributeFor(ViewContext.class, \"xlink\");\n    \txstream.useAttributeFor(ViewContext.class, \"id\");\n    \txstream.useAttributeFor(ViewContext.class, \"version\");\n    \txstream.aliasField(\"xmlns:xlink\", ViewContext.class, \"xlink\");\n    \txstream.aliasField(\"General\", ViewContext.class, \"general\");\n    \txstream.aliasField(\"LayerList\", ViewContext.class, \"layerList\");\n    \t// WMC ViewContext::General\n    \txstream.aliasField(\"Window\", GeneralWMCConfiguration.class, \"window\");\n    \txstream.aliasField(\"Title\", GeneralWMCConfiguration.class, \"title\");\n    \txstream.aliasField(\"Abstract\", GeneralWMCConfiguration.class, \"_abstract\");\n    \t// WMC ViewContext::General::Window\n    \txstream.useAttributeFor(WMCWindow.class, \"height\");\n    \txstream.useAttributeFor(WMCWindow.class, \"width\");\n    \txstream.aliasField(\"BoundingBox\", WMCWindow.class, \"bbox\");\n    \t// WMC ViewContext::General::Window::BoundingBox\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"srs\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"maxx\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"maxy\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"minx\");\n    \txstream.useAttributeFor(WMCBoundingBox.class, \"miny\");\n    \txstream.aliasField(\"SRS\", WMCBoundingBox.class, \"srs\");\n    \t// WMC ViewContext::LayerList::Layer\n    \txstream.alias(\"Layer\", WMCLayer.class);\n    \txstream.useAttributeFor(WMCLayer.class, \"queryable\");\n    \txstream.useAttributeFor(WMCLayer.class, \"hidden\");\n    \txstream.aliasField(\"SRS\", WMCLayer.class, \"srs\");\n    \txstream.aliasField(\"Name\", WMCLayer.class, \"name\");\n    \txstream.aliasField(\"Title\", WMCLayer.class, \"title\");\n    \txstream.aliasField(\"Server\", WMCLayer.class, \"server\");\n    \txstream.aliasField(\"FormatList\", WMCLayer.class, \"formatList\");\n    \txstream.aliasField(\"StyleList\", WMCLayer.class, \"styleList\");\n    \txstream.aliasField(\"Extension\", WMCLayer.class, \"extension\");\n    \t// WMC ViewContext::LayerList::Layer::Server\n    \txstream.useAttributeFor(WMCServer.class, \"service\");\n    \txstream.useAttributeFor(WMCServer.class, \"version\");\n    \txstream.useAttributeFor(WMCServer.class, \"title\");\n    \txstream.aliasField(\"OnlineResource\", WMCServer.class, \"onlineResource\");\n    \t// WMC ViewContext::LayerList::Layer::Server::OnlineResource\n    \txstream.useAttributeFor(WMCOnlineResource.class, \"xlink_type\");\n    \txstream.useAttributeFor(WMCOnlineResource.class, \"xlink_href\");\n    \txstream.aliasField(\"xlink:type\", WMCOnlineResource.class, \"xlink_type\");\n    \txstream.aliasField(\"xlink:href\", WMCOnlineResource.class, \"xlink_href\");\n    \t// WMC ViewContext::LayerList::Layer::FormatList::Format\n    \txstream.alias(\"Format\", WMCFormat.class);\n    \txstream.registerConverter(new Converter() {\n\t\t\tpublic boolean canConvert(Class clazz) {\n\t\t\t\treturn WMCFormat.class.isAssignableFrom(clazz);\n\t\t\t}\n\t\t\tpublic void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {\n\t\t\t\tWMCFormat format = (WMCFormat) value;\n\t\t\t\t\n\t\t\t\twriter.addAttribute(\"current\", format.getCurrent());\n\t\t\t\tif (format.getContent() != null)\n\t\t\t\t\twriter.setValue(format.getContent());\n\t\t\t}\n\t\t\tpublic Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n\t\t\t\tWMCFormat format = new WMCFormat(\"1\", reader.getValue());\n\t\t\t\t\n\t\t\t\treturn format;\n\t\t\t}\n    \t\t\n    \t});\n    \t// WMC ViewContext::LayerList::Layer::FormatList::Style\n    \txstream.alias(\"Style\", WMCStyle.class);\n    \txstream.useAttributeFor(WMCStyle.class, \"current\");\n    \txstream.aliasField(\"SLD\", WMCStyle.class, \"sld\");\n    \txstream.aliasField(\"OnlineResource\", WMCSLD.class, \"onlineResource\");\n    \t// WMC ViewContext::LayerList::Layer::Extension\n    \txstream.alias(\"Extension\", WMCExtension.class);\n    \t\n    \t// WMC ViewContext::LayerList::Layer::Extension::OL\n    \txstream.aliasField(\"ol:id\", WMCExtension.class, \"id\");\n    \txstream.aliasField(\"ol:transparent\", WMCExtension.class, \"transparent\");\n    \txstream.aliasField(\"ol:isBaseLayer\", WMCExtension.class, \"isBaseLayer\");\n    \txstream.aliasField(\"ol:opacity\", WMCExtension.class, \"opacity\");\n    \txstream.aliasField(\"ol:displayInLayerSwitcher\", WMCExtension.class, \"displayInLayerSwitcher\");\n    \txstream.aliasField(\"ol:singleTile\", WMCExtension.class, \"singleTile\");\n    \txstream.aliasField(\"ol:numZoomLevels\", WMCExtension.class, \"numZoomLevels\");\n    \txstream.aliasField(\"ol:units\", WMCExtension.class, \"units\");\n    \txstream.aliasField(\"ol:maxExtent\", WMCExtension.class, \"maxExtent\");\n    \txstream.aliasField(\"ol:dimension\", WMCExtension.class, \"time\");\n    \txstream.aliasField(\"ol:dimension\", WMCExtension.class, \"elevation\");\n    \t\n    \txstream.aliasField(\"ol:mainLayer\", WMCExtension.class, \"mainLayer\");\n    \txstream.aliasField(\"ol:styleClassNumber\", WMCExtension.class, \"styleClassNumber\");\n    \txstream.aliasField(\"ol:styleColorRamps\", WMCExtension.class, \"styleColorRamps\");\n    \txstream.aliasField(\"ol:styleMaxValue\", WMCExtension.class, \"styleMaxValue\");\n    \txstream.aliasField(\"ol:styleMinValue\", WMCExtension.class, \"styleMinValue\");\n    \txstream.aliasField(\"ol:styleRestService\", WMCExtension.class, \"styleRestService\");\n    \txstream.aliasField(\"ol:styleLegendService\", WMCExtension.class, \"styleLegendService\");\n    \t\n    \txstream.useAttributeFor(OLStyleColorRamps.class, \"defaultRamp\");\n    \txstream.aliasField(\"default\", OLStyleColorRamps.class, \"defaultRamp\");\n    \t\n    \txstream.registerConverter(new Converter() {\n\t\t\tpublic boolean canConvert(Class clazz) {\n\t\t\t\treturn OLBaseClass.class.isAssignableFrom(clazz);\n\t\t\t}\n\t\t\tpublic void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {\n\t\t\t\tOLBaseClass ol = (OLBaseClass) value;\n\t\t\t\t\n\t\t\t\twriter.addAttribute(\"xmlns:ol\", ol.getXmlns_ol());\n\t\t\t\t\n\t\t\t\tif (value instanceof OLExtent) {\n\t\t\t\t\tOLExtent extent = (OLExtent) value;\n\t\t\t\t\twriter.addAttribute(\"minx\", extent.getMinx());\n\t\t\t\t\twriter.addAttribute(\"miny\", extent.getMiny());\n\t\t\t\t\twriter.addAttribute(\"maxx\", extent.getMaxx());\n\t\t\t\t\twriter.addAttribute(\"maxy\", extent.getMaxy());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value instanceof OLDimension) {\n\t\t\t\t\tOLDimension dimension = (OLDimension) value;\n\t\t\t\t\twriter.addAttribute(\"name\", dimension.getName());\n\t\t\t\t\twriter.addAttribute(\"default\", dimension.getDefaultValue());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value instanceof OLStyleValue) {\n", "answers": ["\t\t\t\t\tOLStyleValue styleValue = (OLStyleValue) value;"], "pred": "}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n", "length": 570, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "a5da7e173afd5ba71e0185228a1df77238c2949ba3ea2935"}
{"prompt": "Please complete the code given below. \n#!/usr/bin/env python\nimport sys\n#begin dependent modules\n#sys.path.insert(0, \"../\")\nimport yobot_interfaces\nimport yobotproto\nfrom client_support import YCAccount, SimpleNotice\nfrom gui import gui_util\nfrom gui.gui_util import signal_connect, ConnectionWidget\n#end\nimport triviadb\nimport PyQt4\nfrom PyQt4.QtGui import (QComboBox, QMainWindow, QStandardItemModel, QStandardItem,\n                         QIcon, QPixmap, QImage, QPainter, QDialog, QMessageBox,\n                         QApplication, QFont, QTextEdit, QColorDialog, QPalette,\n                         QListWidget, QListWidgetItem, QStyledItemDelegate,\n                         QStyleOptionViewItem, QRegion, QWidget, QBrush, QStyle,\n                         QPushButton, QStyleOption, QMenu, QAction, QCursor,\n                        QLineEdit, QFileDialog, QErrorMessage,\n                         QFontDialog, QColor, QDockWidget, QSizePolicy,\n                         QStackedWidget,\n                         QGridLayout, QLayout, QFrame,\n                         )\nfrom PyQt4.QtCore import (QPoint, QSize, QModelIndex, Qt, QObject, SIGNAL, QVariant,\n                          QAbstractItemModel, QRect, QRectF, QPointF, QT_VERSION)\nfrom debuglog import log_debug, log_info, log_err, log_crit, log_warn\nimport sqlite3.dbapi2 as sqlite3\nimport pickle\nimport lxml.html\nimport re\nfrom time import time\nfrom collections import defaultdict\nimport random\nfrom gui.html_fmt import point_to_html\nimport os.path\nimport yobotops\nfrom cgi import escape as html_escape\nimport datetime\nimport gui_new\n#trivia types\nTYPE_ANAGRAMS, TYPE_TRIVIA, TYPE_BOTH = range(1, 4)\nTRIVIA_ROOT = \"/home/mordy/src/purple/py/triviabot\"\narticle_start_re = re.compile(\"^(the|a) \")\ndef get_categories_list(dbname):\n    dbconn = sqlite3.connect(dbname)\n    ret = []\n    for r in dbconn.cursor().execute(\"select distinct category from questions\"):\n        ret.append(r[0])\n    return ret\ndef scramble_word(word):\n    return \"\".join(random.sample(word, len(word)))\nclass _BlackHole(str):\n    def __init__(self, *args, **kwargs):\n        pass\n    def __getattr__(self, name):\n        return _BlackHole()\n    def __setattr__(self, name, value):\n        pass\n    def __call__(self, *args, **kwargs):\n        pass\n    def __bool__(self):\n        return False\n    def __str__(self):\n        return \"\"\nclass TriviaGui(gui_new.TGui):\n    def __init__(self, parent=None):\n        gui_new.TGui.__init__(self, parent)\n        self.widgets = self\n        w = self.widgets\n        self.model = yobot_interfaces.component_registry.get_component(\"account-model\")\n        self.client_ops = yobot_interfaces.component_registry.get_component(\"client-operations\")\n        assert self.client_ops\n        \n        def _handle_connect(username, password, improto, **proxy_params):\n            self.client_ops.connect(username, password, improto, **proxy_params)\n        \n        def offset_pos_fn():\n            return QPoint(0, self.menubar.height())\n        self.connwidget = gui_util.OverlayConnectionWidget(offset_pos_fn, _handle_connect, self)\n        signal_connect(w.actionConnect, SIGNAL(\"toggled(bool)\"), self.connwidget.setVisible)\n        signal_connect(self.connwidget.widgets.conn_close, SIGNAL(\"clicked()\"),\n                       lambda: w.actionConnect.setChecked(False))\n        if not self.model:\n            w.actionConnect.setChecked(True)\n            self.model = gui_util.AccountModel(None)\n            self.menubar.show()\n        else:\n            self.connwidget.hide()\n        #notification widgets:\n        qdw = QFrame(self)\n        if QT_VERSION >= 0x040600:\n            from PyQt4.QtGui import QGraphicsDropShadowEffect\n            self.notification_shadow = QGraphicsDropShadowEffect(qdw)\n            self.notification_shadow.setBlurRadius(10.0)\n            qdw.setGraphicsEffect(self.notification_shadow)\n        qdw.setFrameShadow(qdw.Raised)\n        qdw.setFrameShape(qdw.StyledPanel)\n        qdw.setAutoFillBackground(True)\n        qsw = QStackedWidget(qdw)\n        qdw.setLayout(QGridLayout())\n        qdw.layout().setSizeConstraint(QLayout.SetMinimumSize)\n        qdw.layout().addWidget(qsw)\n        self._notification_dlg = qdw\n        self.qdw = qdw\n        self.qsw = qsw\n        self.notifications = gui_util.NotificationBox(qdw, qsw, noTitleBar=False)\n        #self.qdw.show()\n        \n        #resize/show events\n        def _force_bottom(event, superclass_fn):\n            log_err(\"\")\n            superclass_fn(self.qdw, event)\n            self.qdw.move(0, self.height()-self.qdw.height())\n        self.qdw.resizeEvent = lambda e: _force_bottom(e, QWidget.resizeEvent)\n        self.qdw.showEvent = lambda e: _force_bottom(e, QWidget.showEvent)\n        \n        #set up account menu\n        w.account.setModel(self.model)\n        \n        for a in (\"start\", \"stop\", \"pause\", \"next\"):\n            gui_util.signal_connect(getattr(w, a), SIGNAL(\"clicked()\"),\n                                    lambda cls=self, a=a: getattr(cls, a + \"_requested\")())\n            getattr(w, a).setEnabled(False)\n        w.start.setEnabled(True)\n                \n        self.anagrams_prefix_blacklist = set()\n        self.anagrams_suffix_blacklist = set()\n        \n        #listWidgetItems\n        def _add_nfix(typestr):\n            txt = getattr(w, typestr + \"_input\").text()\n            if not txt:\n                return\n            txt = str(txt)\n            st = getattr(self, \"anagrams_\" + typestr + \"_blacklist\")\n            target = getattr(w, typestr + \"_list\")\n            if not txt in st:\n                target.addItem(txt)\n                st.add(txt)\n            getattr(w, typestr + \"_input\").clear()\n        def _remove_nfix(typestr):\n            target = getattr(w, typestr + \"_list\")\n            st = getattr(self, \"anagrams_\" + typestr + \"_blacklist\")\n            item = target.currentItem()\n            if item:\n                txt = str(item.text())\n                assert txt in st\n                target.takeItem(target.row(item))\n                st.remove(txt)\n            else:\n                log_warn(\"item is None\")\n        for nfix in (\"suffix\", \"prefix\"):\n            signal_connect(getattr(w, nfix + \"_add\"), SIGNAL(\"clicked()\"),\n                lambda typestr=nfix: _add_nfix(typestr))\n            signal_connect(getattr(w, nfix + \"_del\"), SIGNAL(\"clicked()\"),\n                lambda typestr=nfix: _remove_nfix(typestr))\n            \n        #hide the extended options\n        w.questions_categories_params.hide()\n        w.suffix_prefix_options.hide()\n        \n        self.resize(self.minimumSizeHint())\n    \n        #connect signals for enabling the start button\n        signal_connect(w.account, SIGNAL(\"currentIndexChanged(int)\"), self._enable_start)\n        signal_connect(w.room, SIGNAL(\"activated(int)\"), self._enable_start)\n        signal_connect(w.room, SIGNAL(\"editTextchanged(QString)\"), self._enable_start)\n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self.questions_dbfile_changed)\n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self._validate_questions_db)\n        signal_connect(w.anagrams_database, SIGNAL(\"textChanged(QString)\"), self._validate_anagrams_db)\n        \n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self._enable_start)\n        signal_connect(w.anagrams_database, SIGNAL(\"textChanged(QString)\"), self._enable_start)\n        \n        #category list for questions:\n        self.selected_questions_categories = set()\n        def _unselect(lwitem):\n            row = w.selected_categories.row(lwitem)\n            self.selected_questions_categories.remove(str(lwitem.text()))\n            self.widgets.selected_categories.takeItem(row)\n        def _select(lwitem):\n            category = str(lwitem.text())\n            if not category in self.selected_questions_categories:\n                log_debug(\"Adding\", category)\n                self.selected_questions_categories.add(category)\n                w.selected_categories.addItem(category)\n        signal_connect(w.questions_categories, SIGNAL(\"itemDoubleClicked(QListWidgetItem*)\"), _select)\n        signal_connect(w.selected_categories, SIGNAL(\"itemDoubleClicked(QListWidgetItem*)\"), _unselect)\n        \n        \n        self.anagrams_db_is_valid = False\n        self.questions_db_is_valid = False\n        \n        #profile stuff..\n        signal_connect(w.actionLoad, SIGNAL(\"activated()\"), lambda: self.profile_handler(load=True))\n        signal_connect(w.actionSave, SIGNAL(\"activated()\"), lambda: self.profile_handler(save=True))\n        signal_connect(w.actionSave_As, SIGNAL(\"activated()\"), lambda: self.profile_handler(save_as=True))\n        self.current_profile_name = \"\"\n                \n        w.suffix_prefix_options.sizeHint = lambda: QSize(1,1)\n        w.questions_categories_params.sizeHint = lambda: QSize(1,1)\n                \n        self.show()\n            \n    def _validate_anagrams_db(self, db):\n        dbconn = None\n        db = str(db)\n        try:\n            assert os.path.exists(db)\n            dbconn = sqlite3.connect(db)\n            cursor = dbconn.cursor()\n            cursor.execute(\"select word from words limit 1\").fetchone()[0]\n            self.anagrams_db_is_valid = True\n        except Exception, e:\n            log_err(e)\n            self.anagrams_db_is_valid = False\n            QErrorMessage(self).showMessage(\"Anagrams database is invalid: \" + str(e))\n        finally:\n            if dbconn:\n                dbconn.close()\n    def _validate_questions_db(self, db):\n        dbconn = None\n        db = str(db)\n        try:\n            assert os.path.exists(db)\n            dbconn = sqlite3.connect(db)\n            cursor = dbconn.cursor()\n            cursor.execute(\"select id, frequency, question, answer, alt_answers from questions limit 1\").fetchone()[0]\n            self.questions_db_is_valid = True\n        except Exception, e:\n            log_err(e)\n            self.questions_db_is_valid = False\n            QErrorMessage(self).showMessage(\"Questions database is invalid: \" + str(e))\n        finally:\n            if dbconn:\n                dbconn.close()    \n    \n    def _dbs_are_valid(self):\n        type = str(self.widgets.questions_type.currentText()).lower()\n        if type == \"mix\" and not ( self.anagrams_db_is_valid and self.questions_db_is_valid):\n            return False\n        elif type == \"anagrams\" and not self.anagrams_db_is_valid:\n            return False\n        elif type == \"trivia\" and not self.questions_db_is_valid:\n            return False        \n        return True\n        \n    def _enable_start(self, *args):\n        w = self.widgets\n        if w.account.currentText() and w.room.currentText() and self._dbs_are_valid():\n            w.start.setEnabled(True)\n        else:\n            w.start.setEnabled(False)        \n            \n    #some hooks\n    def questions_dbfile_changed(self, dbname):\n        self.widgets.questions_categories.clear()\n        try:\n            l = get_categories_list(str(dbname))\n        except Exception, e:\n            log_err(e)\n            return\n        for s in l:\n            if s:\n                self.widgets.questions_categories.addItem(str(s))\n    @staticmethod\n    def create_profile_mappings():\n        #make a tuple.\n        #format: (cast_fn, get_fn, set_fn)\n        d = {}\n        \n        #integers\n        for a in (\"post_interval\", \"answer_timeout\", \"percent_anagrams\", \"percent_trivia\",\n                  \"amount\", \"anagrams_letters_min\", \"anagrams_letters_max\"):\n            d[a] = (\"int\", \"value\", \"setValue\")\n        \n        #strings\n        for a in (\"anagrams_database\", \"questions_database\"):\n            d[a] = (\"str\", \"text\", \"setText\")\n        \n        #booleans\n        for a in (\"updatedb_bool\", \"anagrams_caps_hint\", \"questions_blacklist\",\n                  \"questions_use_categories\", \"anagrams_use_nfixes\"):\n            d[a] = (\"bool\", \"isChecked\", \"setChecked\")\n        \n        #room combobox\n        d[\"room\"] = (\"str\", \"currentText\", \"addItem\")\n        \n        return d\n        #for accounts, we need to do some special handling because they are\n        #referenced by index\n    \n    def save_profile(self, profile_name):\n        try:\n            f = open(profile_name, \"w\")\n            f.write(\"#Yobot Trivia Profile Settings automatically generated on %s\\n\" %\n                    str(datetime.datetime.now()))\n            f.write(\"#Configuration is case-sensitive. Use 'True' and 'False' for boolean values\\n\")\n            f.write(\"#this file is parsed directly using python's eval\\n\")\n            \n            d = TriviaGui.create_profile_mappings()\n            for k, v in d.items():\n                #k is the attribute\n                field = getattr(self.widgets, k)\n                cast, getter, setter = v\n                value = getattr(field, getter)() if getter else field\n                \n                if cast == \"str\":\n                    value = str(value)\n                #if not value and cast == \"bool\":\n                #    value = int(value)\n                if not value and cast == \"str\":\n                    value = \"\"\n                    \n                f.write(k + \"=\" + repr(value) + \"\\n\")\n            \n            #for account..\n            acct_index = self.widgets.account.currentIndex()\n            acct_index = self.model.index(acct_index)\n            account = acct_index.internalPointer()\n            if account:\n                f.write(\"account_username=\" + account.user + \"\\n\")\n                f.write(\"account_improto=\" + yobotops.imprototostr(account.improto) + \"\\n\")\n            \n            #for complex types\n            for c in (\"anagrams_suffix_blacklist\", \"anagrams_prefix_blacklist\",\n                      \"selected_questions_categories\"):\n                log_info(getattr(self, c))\n                f.write(c + \"=\" + repr(getattr(self, c)) + \"\\n\")\n            \n            #for font and color:\n            if self.font:\n                f.write(\"font=\" + self.font.toString() + \"\\n\")\n            if self.color:\n                f.write(\"color=\" + self.color.name() + \"\\n\")\n            #for type, just write the current type\n            f.write(\"questions_type=\" + self.widgets.questions_type.currentText() + \"\\n\")\n            #for the blacklists/whitelists..\n            \n            f.close()\n            return True\n        except Exception, e:\n            QErrorMessage(self).showMessage(str(e))\n            return False\n    def load_profile(self, profile_name):\n        d = TriviaGui.create_profile_mappings()\n        try:\n            f = open(profile_name, \"r\")\n            for l in f.readlines():\n                if l.strip()[0] in (\"#\", \";\"):\n                    continue\n                k, v = [s.strip() for s in l.split(\"=\")]\n                dkey = d.get(k, None)\n                if not dkey:\n                    #complex handling\n                    if k in (\"anagrams_prefix_blacklist\", \"anagrams_suffix_blacklist\"):\n                        tmp = k.split(\"_\")[1]\n                        getattr(self, k).clear()\n                        getattr(self, k).update([str(s) for s in eval(v)])\n                        getattr(self.widgets, tmp + \"_list\").clear()\n                        getattr(self.widgets, tmp + \"_list\").addItems(list(getattr(self, k)))\n                    elif k == \"selected_questions_categories\":\n                        getattr(self, k).clear()\n                        getattr(self, k).update(eval(v))\n                        getattr(self.widgets, \"selected_categories\").clear()\n                        getattr(self.widgets, \"selected_categories\").addItems(list(getattr(self, k)))\n                    elif k == \"font\":\n                        self.font = QFont()\n                        self.font.fromString(v)\n                        self._gen_font_stylesheet()\n                        self._update_fmtstr()\n                    elif k == \"color\":\n                        self.color = QColor(v)\n                        self._gen_font_stylesheet()\n                        self._update_fmtstr()\n                    else:\n                        log_warn(\"unknown key\", k)\n                    continue\n                cast, getter, setter = dkey\n                field = getattr(self.widgets, k)\n                #getattr(field, setter)(eval(cast)(v))\n                getattr(field, setter)(eval(v))\n            f.close()\n            return True\n        except Exception, e:\n            QErrorMessage(self).showMessage(str(e))\n            return False\n        \n    def profile_handler(self, load=False, save=False, save_as=False):\n        if load:\n            profile = QFileDialog.getOpenFileName(self, \"Select Profile\", TRIVIA_ROOT)\n            if profile and self.load_profile(profile):\n                self.current_profile_name = profile\n        elif save:\n            if self.current_profile_name:\n                self.save_profile(self.current_profile_name)\n        elif save_as:\n            profile = QFileDialog.getSaveFileName(self, \"Save Profile\", TRIVIA_ROOT)\n            if profile:\n                self.save_profile(profile)\n                \n    def start_requested(self):\n        log_err(\"implement me\")\n    def stop_requested(self):\n        log_err(\"implement me\")\n    def pause_requested(self):\n        log_err(\"implement me\")\n    def next_requested(self):\n        log_err(\"implement me\")\n        \n    def got_notification(self, notification_object):\n        self.notifications.addItem(notification_object)\n        self._notification_dlg.show()\n    def del_notification(self, notification_object):\n        self.notifications.delItem(notification_object)\nclass _QAData(object):\n    def __init__(self):\n        self.question = None\n        self.answers = []\n        self.id = -1\n        self.category = None\n        self.type = None\n    def ask_string(self):\n        pass\n    def hint_string(self):\n        pass\n    def is_correct(self, answer):\n        for a in self.answers:\n            if a.lower() in answer.lower():\n                return True\n        return False\nclass _QuestionData(_QAData):\n    def ask_string(self):\n        return \"Category %s: %s\" % (self.category, self.question)\n    def hint_string(self):\n        ret = \"\"\nNext line of code:\n", "input": "", "context": "#!/usr/bin/env python\nimport sys\n#begin dependent modules\n#sys.path.insert(0, \"../\")\nimport yobot_interfaces\nimport yobotproto\nfrom client_support import YCAccount, SimpleNotice\nfrom gui import gui_util\nfrom gui.gui_util import signal_connect, ConnectionWidget\n#end\nimport triviadb\nimport PyQt4\nfrom PyQt4.QtGui import (QComboBox, QMainWindow, QStandardItemModel, QStandardItem,\n                         QIcon, QPixmap, QImage, QPainter, QDialog, QMessageBox,\n                         QApplication, QFont, QTextEdit, QColorDialog, QPalette,\n                         QListWidget, QListWidgetItem, QStyledItemDelegate,\n                         QStyleOptionViewItem, QRegion, QWidget, QBrush, QStyle,\n                         QPushButton, QStyleOption, QMenu, QAction, QCursor,\n                        QLineEdit, QFileDialog, QErrorMessage,\n                         QFontDialog, QColor, QDockWidget, QSizePolicy,\n                         QStackedWidget,\n                         QGridLayout, QLayout, QFrame,\n                         )\nfrom PyQt4.QtCore import (QPoint, QSize, QModelIndex, Qt, QObject, SIGNAL, QVariant,\n                          QAbstractItemModel, QRect, QRectF, QPointF, QT_VERSION)\nfrom debuglog import log_debug, log_info, log_err, log_crit, log_warn\nimport sqlite3.dbapi2 as sqlite3\nimport pickle\nimport lxml.html\nimport re\nfrom time import time\nfrom collections import defaultdict\nimport random\nfrom gui.html_fmt import point_to_html\nimport os.path\nimport yobotops\nfrom cgi import escape as html_escape\nimport datetime\nimport gui_new\n#trivia types\nTYPE_ANAGRAMS, TYPE_TRIVIA, TYPE_BOTH = range(1, 4)\nTRIVIA_ROOT = \"/home/mordy/src/purple/py/triviabot\"\narticle_start_re = re.compile(\"^(the|a) \")\ndef get_categories_list(dbname):\n    dbconn = sqlite3.connect(dbname)\n    ret = []\n    for r in dbconn.cursor().execute(\"select distinct category from questions\"):\n        ret.append(r[0])\n    return ret\ndef scramble_word(word):\n    return \"\".join(random.sample(word, len(word)))\nclass _BlackHole(str):\n    def __init__(self, *args, **kwargs):\n        pass\n    def __getattr__(self, name):\n        return _BlackHole()\n    def __setattr__(self, name, value):\n        pass\n    def __call__(self, *args, **kwargs):\n        pass\n    def __bool__(self):\n        return False\n    def __str__(self):\n        return \"\"\nclass TriviaGui(gui_new.TGui):\n    def __init__(self, parent=None):\n        gui_new.TGui.__init__(self, parent)\n        self.widgets = self\n        w = self.widgets\n        self.model = yobot_interfaces.component_registry.get_component(\"account-model\")\n        self.client_ops = yobot_interfaces.component_registry.get_component(\"client-operations\")\n        assert self.client_ops\n        \n        def _handle_connect(username, password, improto, **proxy_params):\n            self.client_ops.connect(username, password, improto, **proxy_params)\n        \n        def offset_pos_fn():\n            return QPoint(0, self.menubar.height())\n        self.connwidget = gui_util.OverlayConnectionWidget(offset_pos_fn, _handle_connect, self)\n        signal_connect(w.actionConnect, SIGNAL(\"toggled(bool)\"), self.connwidget.setVisible)\n        signal_connect(self.connwidget.widgets.conn_close, SIGNAL(\"clicked()\"),\n                       lambda: w.actionConnect.setChecked(False))\n        if not self.model:\n            w.actionConnect.setChecked(True)\n            self.model = gui_util.AccountModel(None)\n            self.menubar.show()\n        else:\n            self.connwidget.hide()\n        #notification widgets:\n        qdw = QFrame(self)\n        if QT_VERSION >= 0x040600:\n            from PyQt4.QtGui import QGraphicsDropShadowEffect\n            self.notification_shadow = QGraphicsDropShadowEffect(qdw)\n            self.notification_shadow.setBlurRadius(10.0)\n            qdw.setGraphicsEffect(self.notification_shadow)\n        qdw.setFrameShadow(qdw.Raised)\n        qdw.setFrameShape(qdw.StyledPanel)\n        qdw.setAutoFillBackground(True)\n        qsw = QStackedWidget(qdw)\n        qdw.setLayout(QGridLayout())\n        qdw.layout().setSizeConstraint(QLayout.SetMinimumSize)\n        qdw.layout().addWidget(qsw)\n        self._notification_dlg = qdw\n        self.qdw = qdw\n        self.qsw = qsw\n        self.notifications = gui_util.NotificationBox(qdw, qsw, noTitleBar=False)\n        #self.qdw.show()\n        \n        #resize/show events\n        def _force_bottom(event, superclass_fn):\n            log_err(\"\")\n            superclass_fn(self.qdw, event)\n            self.qdw.move(0, self.height()-self.qdw.height())\n        self.qdw.resizeEvent = lambda e: _force_bottom(e, QWidget.resizeEvent)\n        self.qdw.showEvent = lambda e: _force_bottom(e, QWidget.showEvent)\n        \n        #set up account menu\n        w.account.setModel(self.model)\n        \n        for a in (\"start\", \"stop\", \"pause\", \"next\"):\n            gui_util.signal_connect(getattr(w, a), SIGNAL(\"clicked()\"),\n                                    lambda cls=self, a=a: getattr(cls, a + \"_requested\")())\n            getattr(w, a).setEnabled(False)\n        w.start.setEnabled(True)\n                \n        self.anagrams_prefix_blacklist = set()\n        self.anagrams_suffix_blacklist = set()\n        \n        #listWidgetItems\n        def _add_nfix(typestr):\n            txt = getattr(w, typestr + \"_input\").text()\n            if not txt:\n                return\n            txt = str(txt)\n            st = getattr(self, \"anagrams_\" + typestr + \"_blacklist\")\n            target = getattr(w, typestr + \"_list\")\n            if not txt in st:\n                target.addItem(txt)\n                st.add(txt)\n            getattr(w, typestr + \"_input\").clear()\n        def _remove_nfix(typestr):\n            target = getattr(w, typestr + \"_list\")\n            st = getattr(self, \"anagrams_\" + typestr + \"_blacklist\")\n            item = target.currentItem()\n            if item:\n                txt = str(item.text())\n                assert txt in st\n                target.takeItem(target.row(item))\n                st.remove(txt)\n            else:\n                log_warn(\"item is None\")\n        for nfix in (\"suffix\", \"prefix\"):\n            signal_connect(getattr(w, nfix + \"_add\"), SIGNAL(\"clicked()\"),\n                lambda typestr=nfix: _add_nfix(typestr))\n            signal_connect(getattr(w, nfix + \"_del\"), SIGNAL(\"clicked()\"),\n                lambda typestr=nfix: _remove_nfix(typestr))\n            \n        #hide the extended options\n        w.questions_categories_params.hide()\n        w.suffix_prefix_options.hide()\n        \n        self.resize(self.minimumSizeHint())\n    \n        #connect signals for enabling the start button\n        signal_connect(w.account, SIGNAL(\"currentIndexChanged(int)\"), self._enable_start)\n        signal_connect(w.room, SIGNAL(\"activated(int)\"), self._enable_start)\n        signal_connect(w.room, SIGNAL(\"editTextchanged(QString)\"), self._enable_start)\n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self.questions_dbfile_changed)\n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self._validate_questions_db)\n        signal_connect(w.anagrams_database, SIGNAL(\"textChanged(QString)\"), self._validate_anagrams_db)\n        \n        signal_connect(w.questions_database, SIGNAL(\"textChanged(QString)\"), self._enable_start)\n        signal_connect(w.anagrams_database, SIGNAL(\"textChanged(QString)\"), self._enable_start)\n        \n        #category list for questions:\n        self.selected_questions_categories = set()\n        def _unselect(lwitem):\n            row = w.selected_categories.row(lwitem)\n            self.selected_questions_categories.remove(str(lwitem.text()))\n            self.widgets.selected_categories.takeItem(row)\n        def _select(lwitem):\n            category = str(lwitem.text())\n            if not category in self.selected_questions_categories:\n                log_debug(\"Adding\", category)\n                self.selected_questions_categories.add(category)\n                w.selected_categories.addItem(category)\n        signal_connect(w.questions_categories, SIGNAL(\"itemDoubleClicked(QListWidgetItem*)\"), _select)\n        signal_connect(w.selected_categories, SIGNAL(\"itemDoubleClicked(QListWidgetItem*)\"), _unselect)\n        \n        \n        self.anagrams_db_is_valid = False\n        self.questions_db_is_valid = False\n        \n        #profile stuff..\n        signal_connect(w.actionLoad, SIGNAL(\"activated()\"), lambda: self.profile_handler(load=True))\n        signal_connect(w.actionSave, SIGNAL(\"activated()\"), lambda: self.profile_handler(save=True))\n        signal_connect(w.actionSave_As, SIGNAL(\"activated()\"), lambda: self.profile_handler(save_as=True))\n        self.current_profile_name = \"\"\n                \n        w.suffix_prefix_options.sizeHint = lambda: QSize(1,1)\n        w.questions_categories_params.sizeHint = lambda: QSize(1,1)\n                \n        self.show()\n            \n    def _validate_anagrams_db(self, db):\n        dbconn = None\n        db = str(db)\n        try:\n            assert os.path.exists(db)\n            dbconn = sqlite3.connect(db)\n            cursor = dbconn.cursor()\n            cursor.execute(\"select word from words limit 1\").fetchone()[0]\n            self.anagrams_db_is_valid = True\n        except Exception, e:\n            log_err(e)\n            self.anagrams_db_is_valid = False\n            QErrorMessage(self).showMessage(\"Anagrams database is invalid: \" + str(e))\n        finally:\n            if dbconn:\n                dbconn.close()\n    def _validate_questions_db(self, db):\n        dbconn = None\n        db = str(db)\n        try:\n            assert os.path.exists(db)\n            dbconn = sqlite3.connect(db)\n            cursor = dbconn.cursor()\n            cursor.execute(\"select id, frequency, question, answer, alt_answers from questions limit 1\").fetchone()[0]\n            self.questions_db_is_valid = True\n        except Exception, e:\n            log_err(e)\n            self.questions_db_is_valid = False\n            QErrorMessage(self).showMessage(\"Questions database is invalid: \" + str(e))\n        finally:\n            if dbconn:\n                dbconn.close()    \n    \n    def _dbs_are_valid(self):\n        type = str(self.widgets.questions_type.currentText()).lower()\n        if type == \"mix\" and not ( self.anagrams_db_is_valid and self.questions_db_is_valid):\n            return False\n        elif type == \"anagrams\" and not self.anagrams_db_is_valid:\n            return False\n        elif type == \"trivia\" and not self.questions_db_is_valid:\n            return False        \n        return True\n        \n    def _enable_start(self, *args):\n        w = self.widgets\n        if w.account.currentText() and w.room.currentText() and self._dbs_are_valid():\n            w.start.setEnabled(True)\n        else:\n            w.start.setEnabled(False)        \n            \n    #some hooks\n    def questions_dbfile_changed(self, dbname):\n        self.widgets.questions_categories.clear()\n        try:\n            l = get_categories_list(str(dbname))\n        except Exception, e:\n            log_err(e)\n            return\n        for s in l:\n            if s:\n                self.widgets.questions_categories.addItem(str(s))\n    @staticmethod\n    def create_profile_mappings():\n        #make a tuple.\n        #format: (cast_fn, get_fn, set_fn)\n        d = {}\n        \n        #integers\n        for a in (\"post_interval\", \"answer_timeout\", \"percent_anagrams\", \"percent_trivia\",\n                  \"amount\", \"anagrams_letters_min\", \"anagrams_letters_max\"):\n            d[a] = (\"int\", \"value\", \"setValue\")\n        \n        #strings\n        for a in (\"anagrams_database\", \"questions_database\"):\n            d[a] = (\"str\", \"text\", \"setText\")\n        \n        #booleans\n        for a in (\"updatedb_bool\", \"anagrams_caps_hint\", \"questions_blacklist\",\n                  \"questions_use_categories\", \"anagrams_use_nfixes\"):\n            d[a] = (\"bool\", \"isChecked\", \"setChecked\")\n        \n        #room combobox\n        d[\"room\"] = (\"str\", \"currentText\", \"addItem\")\n        \n        return d\n        #for accounts, we need to do some special handling because they are\n        #referenced by index\n    \n    def save_profile(self, profile_name):\n        try:\n            f = open(profile_name, \"w\")\n            f.write(\"#Yobot Trivia Profile Settings automatically generated on %s\\n\" %\n                    str(datetime.datetime.now()))\n            f.write(\"#Configuration is case-sensitive. Use 'True' and 'False' for boolean values\\n\")\n            f.write(\"#this file is parsed directly using python's eval\\n\")\n            \n            d = TriviaGui.create_profile_mappings()\n            for k, v in d.items():\n                #k is the attribute\n                field = getattr(self.widgets, k)\n                cast, getter, setter = v\n                value = getattr(field, getter)() if getter else field\n                \n                if cast == \"str\":\n                    value = str(value)\n                #if not value and cast == \"bool\":\n                #    value = int(value)\n                if not value and cast == \"str\":\n                    value = \"\"\n                    \n                f.write(k + \"=\" + repr(value) + \"\\n\")\n            \n            #for account..\n            acct_index = self.widgets.account.currentIndex()\n            acct_index = self.model.index(acct_index)\n            account = acct_index.internalPointer()\n            if account:\n                f.write(\"account_username=\" + account.user + \"\\n\")\n                f.write(\"account_improto=\" + yobotops.imprototostr(account.improto) + \"\\n\")\n            \n            #for complex types\n            for c in (\"anagrams_suffix_blacklist\", \"anagrams_prefix_blacklist\",\n                      \"selected_questions_categories\"):\n                log_info(getattr(self, c))\n                f.write(c + \"=\" + repr(getattr(self, c)) + \"\\n\")\n            \n            #for font and color:\n            if self.font:\n                f.write(\"font=\" + self.font.toString() + \"\\n\")\n            if self.color:\n                f.write(\"color=\" + self.color.name() + \"\\n\")\n            #for type, just write the current type\n            f.write(\"questions_type=\" + self.widgets.questions_type.currentText() + \"\\n\")\n            #for the blacklists/whitelists..\n            \n            f.close()\n            return True\n        except Exception, e:\n            QErrorMessage(self).showMessage(str(e))\n            return False\n    def load_profile(self, profile_name):\n        d = TriviaGui.create_profile_mappings()\n        try:\n            f = open(profile_name, \"r\")\n            for l in f.readlines():\n                if l.strip()[0] in (\"#\", \";\"):\n                    continue\n                k, v = [s.strip() for s in l.split(\"=\")]\n                dkey = d.get(k, None)\n                if not dkey:\n                    #complex handling\n                    if k in (\"anagrams_prefix_blacklist\", \"anagrams_suffix_blacklist\"):\n                        tmp = k.split(\"_\")[1]\n                        getattr(self, k).clear()\n                        getattr(self, k).update([str(s) for s in eval(v)])\n                        getattr(self.widgets, tmp + \"_list\").clear()\n                        getattr(self.widgets, tmp + \"_list\").addItems(list(getattr(self, k)))\n                    elif k == \"selected_questions_categories\":\n                        getattr(self, k).clear()\n                        getattr(self, k).update(eval(v))\n                        getattr(self.widgets, \"selected_categories\").clear()\n                        getattr(self.widgets, \"selected_categories\").addItems(list(getattr(self, k)))\n                    elif k == \"font\":\n                        self.font = QFont()\n                        self.font.fromString(v)\n                        self._gen_font_stylesheet()\n                        self._update_fmtstr()\n                    elif k == \"color\":\n                        self.color = QColor(v)\n                        self._gen_font_stylesheet()\n                        self._update_fmtstr()\n                    else:\n                        log_warn(\"unknown key\", k)\n                    continue\n                cast, getter, setter = dkey\n                field = getattr(self.widgets, k)\n                #getattr(field, setter)(eval(cast)(v))\n                getattr(field, setter)(eval(v))\n            f.close()\n            return True\n        except Exception, e:\n            QErrorMessage(self).showMessage(str(e))\n            return False\n        \n    def profile_handler(self, load=False, save=False, save_as=False):\n        if load:\n            profile = QFileDialog.getOpenFileName(self, \"Select Profile\", TRIVIA_ROOT)\n            if profile and self.load_profile(profile):\n                self.current_profile_name = profile\n        elif save:\n            if self.current_profile_name:\n                self.save_profile(self.current_profile_name)\n        elif save_as:\n            profile = QFileDialog.getSaveFileName(self, \"Save Profile\", TRIVIA_ROOT)\n            if profile:\n                self.save_profile(profile)\n                \n    def start_requested(self):\n        log_err(\"implement me\")\n    def stop_requested(self):\n        log_err(\"implement me\")\n    def pause_requested(self):\n        log_err(\"implement me\")\n    def next_requested(self):\n        log_err(\"implement me\")\n        \n    def got_notification(self, notification_object):\n        self.notifications.addItem(notification_object)\n        self._notification_dlg.show()\n    def del_notification(self, notification_object):\n        self.notifications.delItem(notification_object)\nclass _QAData(object):\n    def __init__(self):\n        self.question = None\n        self.answers = []\n        self.id = -1\n        self.category = None\n        self.type = None\n    def ask_string(self):\n        pass\n    def hint_string(self):\n        pass\n    def is_correct(self, answer):\n        for a in self.answers:\n            if a.lower() in answer.lower():\n                return True\n        return False\nclass _QuestionData(_QAData):\n    def ask_string(self):\n        return \"Category %s: %s\" % (self.category, self.question)\n    def hint_string(self):\n        ret = \"\"\n", "answers": ["        longest = max(self.answers)"], "pred": "    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n    code = \"\"\n", "length": 1229, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "3bd5a501fc0327fd7bcda8389c7d11b3a821c9b5ce5a93cc"}
{"prompt": "Please complete the code given below. \n/**************************************\n*Script Name: Staff Runebook          *\n*Author: Joeku                        *\n*For use with RunUO 2.0 RC2           *\n*Client Tested with: 6.0.9.2          *\n*Version: 1.10                        *\n*Initial Release: 11/25/07            *\n*Revision Date: 02/04/09              *\n**************************************/\nusing System;\nusing System.Collections.Generic;\nusing Server;\nusing Server.Gumps;\nusing Server.Items;\nusing Server.Network;\nnamespace Joeku.SR\n{\n    public class SR_Gump : Gump\n    {\n        public SR_RuneAccount RuneAcc { get; set; }\n        public SR_Gump(Mobile m, SR_RuneAccount runeAcc)\n            : base(0, 27)\n        {\n            RuneAcc = runeAcc;\n            int count = 0;\n            if (RuneAcc.ChildRune == null)\n                count = RuneAcc.Count;\n            else\n                count = RuneAcc.ChildRune.Count;\n            int RunebooksH = 0,\n            RunebooksW = 0;\n            int tier = -1;\n            if (RuneAcc.ChildRune != null)\n                tier = RuneAcc.ChildRune.Tier;\n            if (tier > -1)\n            {\n                if (tier == 0)\n                {\n                    RunebooksH = 42;\n                    RunebooksW = 278;\n                }\n                else\n                {\n                    RunebooksH = 37 + 42;\n                    RunebooksW = 278 + (tier * 5);\n                }\n            }\n            int RunesH = 10 * 2;\n            if (count > 10)\n                count = 10;\n            if (count > 0)\n                RunesH += (count * 22);\n            if (count > 1)\n                RunesH += ((count - 1) * 5);\n            DisplayHeader();\n            int labelHue = m != null && m.NetState != null && m.NetState.IsEnhancedClient ? 2101 : 2100;\n            if (tier > -1)\n                DisplayRunebooks(42, RunebooksH, RunebooksW, tier, labelHue);\n            DisplayAddNew(42 + RunebooksH + RunesH, labelHue);\n            DisplayRunes(42 + RunebooksH, RunesH, labelHue);\n        }\n        public static void Send(Mobile mob, SR_RuneAccount runeAcc)\n        {\n            mob.CloseGump(typeof(SR_Gump));\n            mob.SendGump(new SR_Gump(mob, runeAcc));\n        }\n        public void DisplayHeader()\n        {\n            AddPage(0);\n            AddBackground(0, 0, 210, 42, 9270); \n            AddImageTiled(10, 10, 190, 22, 2624); \n            AddAlphaRegion(10, 10, 190, 22);\n            AddHtml(0, 11, 210, 20, \"<CENTER><BASEFONT COLOR=#FFFFFF><BIG>Joeku's Staff Runebook</CENTER>\", false, false);\n        }\n        public void DisplayRunebooks(int y, int h, int w, int tiers, int labelHue)\n        {\n            AddBackground(0, y, w, h, 9270);\n            AddImageTiled(10, y + 10, w - 20, h - 20, 2624); \n            AddAlphaRegion(10, y + 10, w - 20, h - 20); \n            for (int i = tiers, j = 1; i > 0; i--, j++)\n            {\n                AddBackground(j * 5, y + 37, ((i - 1) * 5) + 278, 42, 9270);\n                if (i == 1)\n                {\n                    AddImageTiled((j * 5) + 10, y + 47, ((i - 1) * 5) + 258, 22, 2624); \n                    AddAlphaRegion((j * 5) + 10, y + 47, ((i - 1) * 5) + 258, 22); \n                }\n            }\n            SR_Rune rune = RuneAcc.Runes[RuneAcc.PageIndex];\n            AddItem(SR_Utilities.ItemOffsetX(rune), y + SR_Utilities.ItemOffsetY(rune) + 12, SR_Utilities.RunebookID, SR_Utilities.ItemHue(rune));\n            AddLabelCropped(35, y + 12, w - 108, 20, labelHue, rune.Name); \n            AddButton(w - 70, y + 10, 4014, 4016, 5, GumpButtonType.Reply, 0); \n            AddButton(w - 40, y + 10, 4017, 4019, 4, GumpButtonType.Reply, 0); \n            if (tiers > 0)\n            {\n                rune = RuneAcc.ChildRune;\n                AddItem(SR_Utilities.ItemOffsetX(rune) + tiers * 5, y + SR_Utilities.ItemOffsetY(rune) + 12 + 37, SR_Utilities.RunebookID, SR_Utilities.ItemHue(rune));\n                AddLabelCropped(35 + tiers * 5, y + 12 + 37, 170, 20, labelHue, rune.Name); \n                AddButton(w - 70, y + 10 + 37, 4014, 4016, 7, GumpButtonType.Reply, 0); \n                AddButton(w - 40, y + 10 + 37, 4017, 4019, 6, GumpButtonType.Reply, 0); \n            }\n            // AddButton(238, 30 + bgY + 10, 4011, 4013, 0, GumpButtonType.Reply, 0); \n        }\n        public void DisplayAddNew(int y, int labelHue)\n        { \n            AddBackground(0, y, 278, 42, 9270); \n            AddImageTiled(10, y + 10, 258, 22, 2624); \n            AddAlphaRegion(10, y + 10, 258, 22);\n            AddLabel(15, y + 10, labelHue, @\"New Rune\"); \n            AddButton(80, y + 10, 4011, 4013, 1, GumpButtonType.Reply, 0); \n            AddButton(110, y + 10, 4029, 4031, 2, GumpButtonType.Reply, 0);\n            AddLabel(150, y + 10, labelHue, @\"New Runebook\"); \n            AddButton(238, y + 10, 4011, 4013, 3, GumpButtonType.Reply, 0); \n        }\n        public void DisplayRunes(int y, int h, int labelHue)\n        {\n            AddBackground(0, y, 430/*400*/, h, 9270); \n            AddImageTiled(10, y + 10, 410, h - 20, 2624); \n            AddAlphaRegion(10, y + 10, 410, h - 20); \n            List<SR_Rune> runes = null;\n            int count, runebooks;\n            if (RuneAcc.ChildRune == null)\n            {\n                runes = RuneAcc.Runes;\n                count = RuneAcc.Count;\n                runebooks = RuneAcc.RunebookCount;\n            }\n            else\n            {\n                runes = RuneAcc.ChildRune.Runes;\n                count = RuneAcc.ChildRune.Count;\n                runebooks = RuneAcc.ChildRune.RunebookCount;\n            }\n\t\t\t\n            AddPage(1);\n            int pages = (int)Math.Ceiling((double)count / 9.0), temp = 0;\n            for (int i = 0, loc = 0, page = 1; i < count; i++, loc++)\n            {\n                temp = 10 + y + (22 + 5) * loc;\n                AddItem(SR_Utilities.ItemOffsetX(runes[i]), 2 + SR_Utilities.ItemOffsetY(runes[i]) + temp, runes[i].IsRunebook ? SR_Utilities.RunebookID : SR_Utilities.RuneID, SR_Utilities.ItemHue(runes[i])); \n                if (runes[i].IsRunebook)\n                    AddLabelCropped(35, 2 + temp, 175, 20, labelHue, String.Format(\"{0}. {1}\", i + 1, runes[i].Name)); \n                else\n                {\n                    AddLabelCropped(35, 2 + temp, 175, 20, labelHue, String.Format(\"{0}. {1} ({2})\", i + 1 - runebooks, runes[i].Name, runes[i].TargetMap.ToString()));\n                    AddLabelCropped(215, 2 + temp, 110, 20, labelHue, runes[i].TargetLoc.ToString()); \n                    AddButton(360, temp, 4008, 4010, i + 30010, GumpButtonType.Reply, 0); \n                }\n                AddButton(330 + (runes[i].IsRunebook ? 30 : 0), temp, 4005, 4007, i + 10, GumpButtonType.Reply, 0); \n                //AddButton(340, 40 + ((22+5)*i), 4026, 4028, 0, GumpButtonType.Reply, 0); \n                //AddImage(340, 40 + ((22+5)*i), 4026, 1000); \n                AddButton(390, temp, 4017, 4019, i + 60010, GumpButtonType.Reply, 0); // delete\n                if (pages > 1 && ((loc == 8 && i < count - 1) || i == count - 1))\n                {\n                    temp = 10 + y + (22 + 5) * 9;\n                    // (430(bg) - 20 (buffer) - 70 (txt/buffer) - 60(buttons)) / 2 = 140\n                    if (page > 1)\n                        AddButton(140, temp, 4014, 4016, 0, GumpButtonType.Page, page - 1);\n                    else\n                        AddImage(140, temp, 4014, 1000);\n                    AddHtml(170, 2 + temp, 90, 20, String.Format(\"<BASEFONT COLOR=#FFFFFF><CENTER>Page {0}/{1}\", page, pages), false, false);\n\t\t\t\t\t\n                    if (page < pages)\n                        AddButton(260, temp, 4005, 4007, 0, GumpButtonType.Page, page + 1);\n                    else\n                        AddImage(260, temp, 4005, 1000);\n                    page++;\n                    AddPage(page);\n                    loc = -1;\n                }\n            }\n        }\n        public override void OnResponse(NetState sender, RelayInfo info)\n        {\n            int button = info.ButtonID;\n            Mobile mob = sender.Mobile;\n            switch( button )\n            {\n                case 0:\n                    break;\n                case 1:\t\n                    mob.SendMessage(\"Enter a description:\");\n                    mob.Prompt = new SR_NewRunePrompt(RuneAcc, mob.Location, mob.Map);\n                    Send(mob, SR_Utilities.FetchInfo(mob.Account));\n                    break;\n                case 2:\n                    mob.SendMessage(\"Target a location to mark:\");\nNext line of code:\n", "input": "", "context": "/**************************************\n*Script Name: Staff Runebook          *\n*Author: Joeku                        *\n*For use with RunUO 2.0 RC2           *\n*Client Tested with: 6.0.9.2          *\n*Version: 1.10                        *\n*Initial Release: 11/25/07            *\n*Revision Date: 02/04/09              *\n**************************************/\nusing System;\nusing System.Collections.Generic;\nusing Server;\nusing Server.Gumps;\nusing Server.Items;\nusing Server.Network;\nnamespace Joeku.SR\n{\n    public class SR_Gump : Gump\n    {\n        public SR_RuneAccount RuneAcc { get; set; }\n        public SR_Gump(Mobile m, SR_RuneAccount runeAcc)\n            : base(0, 27)\n        {\n            RuneAcc = runeAcc;\n            int count = 0;\n            if (RuneAcc.ChildRune == null)\n                count = RuneAcc.Count;\n            else\n                count = RuneAcc.ChildRune.Count;\n            int RunebooksH = 0,\n            RunebooksW = 0;\n            int tier = -1;\n            if (RuneAcc.ChildRune != null)\n                tier = RuneAcc.ChildRune.Tier;\n            if (tier > -1)\n            {\n                if (tier == 0)\n                {\n                    RunebooksH = 42;\n                    RunebooksW = 278;\n                }\n                else\n                {\n                    RunebooksH = 37 + 42;\n                    RunebooksW = 278 + (tier * 5);\n                }\n            }\n            int RunesH = 10 * 2;\n            if (count > 10)\n                count = 10;\n            if (count > 0)\n                RunesH += (count * 22);\n            if (count > 1)\n                RunesH += ((count - 1) * 5);\n            DisplayHeader();\n            int labelHue = m != null && m.NetState != null && m.NetState.IsEnhancedClient ? 2101 : 2100;\n            if (tier > -1)\n                DisplayRunebooks(42, RunebooksH, RunebooksW, tier, labelHue);\n            DisplayAddNew(42 + RunebooksH + RunesH, labelHue);\n            DisplayRunes(42 + RunebooksH, RunesH, labelHue);\n        }\n        public static void Send(Mobile mob, SR_RuneAccount runeAcc)\n        {\n            mob.CloseGump(typeof(SR_Gump));\n            mob.SendGump(new SR_Gump(mob, runeAcc));\n        }\n        public void DisplayHeader()\n        {\n            AddPage(0);\n            AddBackground(0, 0, 210, 42, 9270); \n            AddImageTiled(10, 10, 190, 22, 2624); \n            AddAlphaRegion(10, 10, 190, 22);\n            AddHtml(0, 11, 210, 20, \"<CENTER><BASEFONT COLOR=#FFFFFF><BIG>Joeku's Staff Runebook</CENTER>\", false, false);\n        }\n        public void DisplayRunebooks(int y, int h, int w, int tiers, int labelHue)\n        {\n            AddBackground(0, y, w, h, 9270);\n            AddImageTiled(10, y + 10, w - 20, h - 20, 2624); \n            AddAlphaRegion(10, y + 10, w - 20, h - 20); \n            for (int i = tiers, j = 1; i > 0; i--, j++)\n            {\n                AddBackground(j * 5, y + 37, ((i - 1) * 5) + 278, 42, 9270);\n                if (i == 1)\n                {\n                    AddImageTiled((j * 5) + 10, y + 47, ((i - 1) * 5) + 258, 22, 2624); \n                    AddAlphaRegion((j * 5) + 10, y + 47, ((i - 1) * 5) + 258, 22); \n                }\n            }\n            SR_Rune rune = RuneAcc.Runes[RuneAcc.PageIndex];\n            AddItem(SR_Utilities.ItemOffsetX(rune), y + SR_Utilities.ItemOffsetY(rune) + 12, SR_Utilities.RunebookID, SR_Utilities.ItemHue(rune));\n            AddLabelCropped(35, y + 12, w - 108, 20, labelHue, rune.Name); \n            AddButton(w - 70, y + 10, 4014, 4016, 5, GumpButtonType.Reply, 0); \n            AddButton(w - 40, y + 10, 4017, 4019, 4, GumpButtonType.Reply, 0); \n            if (tiers > 0)\n            {\n                rune = RuneAcc.ChildRune;\n                AddItem(SR_Utilities.ItemOffsetX(rune) + tiers * 5, y + SR_Utilities.ItemOffsetY(rune) + 12 + 37, SR_Utilities.RunebookID, SR_Utilities.ItemHue(rune));\n                AddLabelCropped(35 + tiers * 5, y + 12 + 37, 170, 20, labelHue, rune.Name); \n                AddButton(w - 70, y + 10 + 37, 4014, 4016, 7, GumpButtonType.Reply, 0); \n                AddButton(w - 40, y + 10 + 37, 4017, 4019, 6, GumpButtonType.Reply, 0); \n            }\n            // AddButton(238, 30 + bgY + 10, 4011, 4013, 0, GumpButtonType.Reply, 0); \n        }\n        public void DisplayAddNew(int y, int labelHue)\n        { \n            AddBackground(0, y, 278, 42, 9270); \n            AddImageTiled(10, y + 10, 258, 22, 2624); \n            AddAlphaRegion(10, y + 10, 258, 22);\n            AddLabel(15, y + 10, labelHue, @\"New Rune\"); \n            AddButton(80, y + 10, 4011, 4013, 1, GumpButtonType.Reply, 0); \n            AddButton(110, y + 10, 4029, 4031, 2, GumpButtonType.Reply, 0);\n            AddLabel(150, y + 10, labelHue, @\"New Runebook\"); \n            AddButton(238, y + 10, 4011, 4013, 3, GumpButtonType.Reply, 0); \n        }\n        public void DisplayRunes(int y, int h, int labelHue)\n        {\n            AddBackground(0, y, 430/*400*/, h, 9270); \n            AddImageTiled(10, y + 10, 410, h - 20, 2624); \n            AddAlphaRegion(10, y + 10, 410, h - 20); \n            List<SR_Rune> runes = null;\n            int count, runebooks;\n            if (RuneAcc.ChildRune == null)\n            {\n                runes = RuneAcc.Runes;\n                count = RuneAcc.Count;\n                runebooks = RuneAcc.RunebookCount;\n            }\n            else\n            {\n                runes = RuneAcc.ChildRune.Runes;\n                count = RuneAcc.ChildRune.Count;\n                runebooks = RuneAcc.ChildRune.RunebookCount;\n            }\n\t\t\t\n            AddPage(1);\n            int pages = (int)Math.Ceiling((double)count / 9.0), temp = 0;\n            for (int i = 0, loc = 0, page = 1; i < count; i++, loc++)\n            {\n                temp = 10 + y + (22 + 5) * loc;\n                AddItem(SR_Utilities.ItemOffsetX(runes[i]), 2 + SR_Utilities.ItemOffsetY(runes[i]) + temp, runes[i].IsRunebook ? SR_Utilities.RunebookID : SR_Utilities.RuneID, SR_Utilities.ItemHue(runes[i])); \n                if (runes[i].IsRunebook)\n                    AddLabelCropped(35, 2 + temp, 175, 20, labelHue, String.Format(\"{0}. {1}\", i + 1, runes[i].Name)); \n                else\n                {\n                    AddLabelCropped(35, 2 + temp, 175, 20, labelHue, String.Format(\"{0}. {1} ({2})\", i + 1 - runebooks, runes[i].Name, runes[i].TargetMap.ToString()));\n                    AddLabelCropped(215, 2 + temp, 110, 20, labelHue, runes[i].TargetLoc.ToString()); \n                    AddButton(360, temp, 4008, 4010, i + 30010, GumpButtonType.Reply, 0); \n                }\n                AddButton(330 + (runes[i].IsRunebook ? 30 : 0), temp, 4005, 4007, i + 10, GumpButtonType.Reply, 0); \n                //AddButton(340, 40 + ((22+5)*i), 4026, 4028, 0, GumpButtonType.Reply, 0); \n                //AddImage(340, 40 + ((22+5)*i), 4026, 1000); \n                AddButton(390, temp, 4017, 4019, i + 60010, GumpButtonType.Reply, 0); // delete\n                if (pages > 1 && ((loc == 8 && i < count - 1) || i == count - 1))\n                {\n                    temp = 10 + y + (22 + 5) * 9;\n                    // (430(bg) - 20 (buffer) - 70 (txt/buffer) - 60(buttons)) / 2 = 140\n                    if (page > 1)\n                        AddButton(140, temp, 4014, 4016, 0, GumpButtonType.Page, page - 1);\n                    else\n                        AddImage(140, temp, 4014, 1000);\n                    AddHtml(170, 2 + temp, 90, 20, String.Format(\"<BASEFONT COLOR=#FFFFFF><CENTER>Page {0}/{1}\", page, pages), false, false);\n\t\t\t\t\t\n                    if (page < pages)\n                        AddButton(260, temp, 4005, 4007, 0, GumpButtonType.Page, page + 1);\n                    else\n                        AddImage(260, temp, 4005, 1000);\n                    page++;\n                    AddPage(page);\n                    loc = -1;\n                }\n            }\n        }\n        public override void OnResponse(NetState sender, RelayInfo info)\n        {\n            int button = info.ButtonID;\n            Mobile mob = sender.Mobile;\n            switch( button )\n            {\n                case 0:\n                    break;\n                case 1:\t\n                    mob.SendMessage(\"Enter a description:\");\n                    mob.Prompt = new SR_NewRunePrompt(RuneAcc, mob.Location, mob.Map);\n                    Send(mob, SR_Utilities.FetchInfo(mob.Account));\n                    break;\n                case 2:\n                    mob.SendMessage(\"Target a location to mark:\");\n", "answers": ["                    mob.Target = new SR_NewRuneTarget(RuneAcc);"], "pred": "  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.", "length": 907, "dataset": "lcc", "language": "csharp", "all_classes": null, "_id": "227b063979c62ee1de7436be168450b5a7712a7a637fa6d4"}
{"prompt": "Please complete the code given below. \n/*\n * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage sun.security.ssl;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.security.*;\nimport java.security.interfaces.*;\nimport java.security.spec.*;\nimport java.security.cert.*;\nimport java.security.cert.Certificate;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.lang.reflect.*;\nimport javax.security.auth.x500.X500Principal;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.DHPublicKeySpec;\nimport javax.net.ssl.*;\nimport sun.security.internal.spec.TlsPrfParameterSpec;\nimport sun.security.ssl.CipherSuite.*;\nimport static sun.security.ssl.CipherSuite.PRF.*;\nimport sun.security.util.KeyUtil;\n/**\n * Many data structures are involved in the handshake messages.  These\n * classes are used as structures, with public data members.  They are\n * not visible outside the SSL package.\n *\n * Handshake messages all have a common header format, and they are all\n * encoded in a \"handshake data\" SSL record substream.  The base class\n * here (HandshakeMessage) provides a common framework and records the\n * SSL record type of the particular handshake message.\n *\n * This file contains subclasses for all the basic handshake messages.\n * All handshake messages know how to encode and decode themselves on\n * SSL streams; this facilitates using the same code on SSL client and\n * server sides, although they don't send and receive the same messages.\n *\n * Messages also know how to print themselves, which is quite handy\n * for debugging.  They always identify their type, and can optionally\n * dump all of their content.\n *\n * @author David Brownell\n */\npublic abstract class HandshakeMessage {\n    HandshakeMessage() { }\n    // enum HandshakeType:\n    static final byte   ht_hello_request = 0;\n    static final byte   ht_client_hello = 1;\n    static final byte   ht_server_hello = 2;\n    static final byte   ht_certificate = 11;\n    static final byte   ht_server_key_exchange = 12;\n    static final byte   ht_certificate_request = 13;\n    static final byte   ht_server_hello_done = 14;\n    static final byte   ht_certificate_verify = 15;\n    static final byte   ht_client_key_exchange = 16;\n    static final byte   ht_finished = 20;\n    /* Class and subclass dynamic debugging support */\n    public static final Debug debug = Debug.getInstance(\"ssl\");\n    /**\n     * Utility method to convert a BigInteger to a byte array in unsigned\n     * format as needed in the handshake messages. BigInteger uses\n     * 2's complement format, i.e. it prepends an extra zero if the MSB\n     * is set. We remove that.\n     */\n    static byte[] toByteArray(BigInteger bi) {\n        byte[] b = bi.toByteArray();\n        if ((b.length > 1) && (b[0] == 0)) {\n            int n = b.length - 1;\n            byte[] newarray = new byte[n];\n            System.arraycopy(b, 1, newarray, 0, n);\n            b = newarray;\n        }\n        return b;\n    }\n    /*\n     * SSL 3.0 MAC padding constants.\n     * Also used by CertificateVerify and Finished during the handshake.\n     */\n    static final byte[] MD5_pad1 = genPad(0x36, 48);\n    static final byte[] MD5_pad2 = genPad(0x5c, 48);\n    static final byte[] SHA_pad1 = genPad(0x36, 40);\n    static final byte[] SHA_pad2 = genPad(0x5c, 40);\n    private static byte[] genPad(int b, int count) {\n        byte[] padding = new byte[count];\n        Arrays.fill(padding, (byte)b);\n        return padding;\n    }\n    /*\n     * Write a handshake message on the (handshake) output stream.\n     * This is just a four byte header followed by the data.\n     *\n     * NOTE that huge messages -- notably, ones with huge cert\n     * chains -- are handled correctly.\n     */\n    final void write(HandshakeOutStream s) throws IOException {\n        int len = messageLength();\n        if (len >= Record.OVERFLOW_OF_INT24) {\n            throw new SSLException(\"Handshake message too big\"\n                + \", type = \" + messageType() + \", len = \" + len);\n        }\n        s.write(messageType());\n        s.putInt24(len);\n        send(s);\n    }\n    /*\n     * Subclasses implement these methods so those kinds of\n     * messages can be emitted.  Base class delegates to subclass.\n     */\n    abstract int  messageType();\n    abstract int  messageLength();\n    abstract void send(HandshakeOutStream s) throws IOException;\n    /*\n     * Write a descriptive message on the output stream; for debugging.\n     */\n    abstract void print(PrintStream p) throws IOException;\n//\n// NOTE:  the rest of these classes are nested within this one, and are\n// imported by other classes in this package.  There are a few other\n// handshake message classes, not neatly nested here because of current\n// licensing requirement for native (RSA) methods.  They belong here,\n// but those native methods complicate things a lot!\n//\n/*\n * HelloRequest ... SERVER --> CLIENT\n *\n * Server can ask the client to initiate a new handshake, e.g. to change\n * session parameters after a connection has been (re)established.\n */\nstatic final class HelloRequest extends HandshakeMessage {\n    @Override\n    int messageType() { return ht_hello_request; }\n    HelloRequest() { }\n    HelloRequest(HandshakeInStream in) throws IOException\n    {\n        // nothing in this message\n    }\n    @Override\n    int messageLength() { return 0; }\n    @Override\n    void send(HandshakeOutStream out) throws IOException\n    {\n        // nothing in this messaage\n    }\n    @Override\n    void print(PrintStream out) throws IOException\n    {\n        out.println(\"*** HelloRequest (empty)\");\n    }\n}\n/*\n * ClientHello ... CLIENT --> SERVER\n *\n * Client initiates handshake by telling server what it wants, and what it\n * can support (prioritized by what's first in the ciphe suite list).\n *\n * By RFC2246:7.4.1.2 it's explicitly anticipated that this message\n * will have more data added at the end ... e.g. what CAs the client trusts.\n * Until we know how to parse it, we will just read what we know\n * about, and let our caller handle the jumps over unknown data.\n */\nstatic final class ClientHello extends HandshakeMessage {\n    ProtocolVersion     protocolVersion;\n    RandomCookie        clnt_random;\n    SessionId           sessionId;\n    private CipherSuiteList    cipherSuites;\n    byte[]              compression_methods;\n    HelloExtensions extensions = new HelloExtensions();\n    private final static byte[]  NULL_COMPRESSION = new byte[] {0};\n    ClientHello(SecureRandom generator, ProtocolVersion protocolVersion,\n            SessionId sessionId, CipherSuiteList cipherSuites) {\n        this.protocolVersion = protocolVersion;\n        this.sessionId = sessionId;\n        this.cipherSuites = cipherSuites;\n        if (cipherSuites.containsEC()) {\n            extensions.add(SupportedEllipticCurvesExtension.DEFAULT);\n            extensions.add(SupportedEllipticPointFormatsExtension.DEFAULT);\n        }\n        clnt_random = new RandomCookie(generator);\n        compression_methods = NULL_COMPRESSION;\n    }\n    ClientHello(HandshakeInStream s, int messageLength) throws IOException {\n        protocolVersion = ProtocolVersion.valueOf(s.getInt8(), s.getInt8());\n        clnt_random = new RandomCookie(s);\n        sessionId = new SessionId(s.getBytes8());\n        cipherSuites = new CipherSuiteList(s);\n        compression_methods = s.getBytes8();\n        if (messageLength() != messageLength) {\n            extensions = new HelloExtensions(s);\n        }\n    }\n    CipherSuiteList getCipherSuites() {\n        return cipherSuites;\n    }\n    // add renegotiation_info extension\n    void addRenegotiationInfoExtension(byte[] clientVerifyData) {\n        HelloExtension renegotiationInfo = new RenegotiationInfoExtension(\n                    clientVerifyData, new byte[0]);\n        extensions.add(renegotiationInfo);\n    }\n    // add server_name extension\n    void addSNIExtension(List<SNIServerName> serverNames) {\n        try {\n            extensions.add(new ServerNameExtension(serverNames));\n        } catch (IOException ioe) {\n            // ignore the exception and return\n        }\n    }\n    // add signature_algorithm extension\n    void addSignatureAlgorithmsExtension(\n            Collection<SignatureAndHashAlgorithm> algorithms) {\n        HelloExtension signatureAlgorithm =\n                new SignatureAlgorithmsExtension(algorithms);\n        extensions.add(signatureAlgorithm);\n    }\n    @Override\n    int messageType() { return ht_client_hello; }\n    @Override\n    int messageLength() {\n        /*\n         * Add fixed size parts of each field...\n         * version + random + session + cipher + compress\n         */\n        return (2 + 32 + 1 + 2 + 1\n            + sessionId.length()                /* ... + variable parts */\n            + (cipherSuites.size() * 2)\n            + compression_methods.length)\n            + extensions.length();\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException {\n        s.putInt8(protocolVersion.major);\n        s.putInt8(protocolVersion.minor);\n        clnt_random.send(s);\n        s.putBytes8(sessionId.getId());\n        cipherSuites.send(s);\n        s.putBytes8(compression_methods);\n        extensions.send(s);\n    }\n    @Override\n    void print(PrintStream s) throws IOException {\n        s.println(\"*** ClientHello, \" + protocolVersion);\n        if (debug != null && Debug.isOn(\"verbose\")) {\n            s.print(\"RandomCookie:  \");\n            clnt_random.print(s);\n            s.print(\"Session ID:  \");\n            s.println(sessionId);\n            s.println(\"Cipher Suites: \" + cipherSuites);\n            Debug.println(s, \"Compression Methods\", compression_methods);\n            extensions.print(s);\n            s.println(\"***\");\n        }\n    }\n}\n/*\n * ServerHello ... SERVER --> CLIENT\n *\n * Server chooses protocol options from among those it supports and the\n * client supports.  Then it sends the basic session descriptive parameters\n * back to the client.\n */\nstatic final\nclass ServerHello extends HandshakeMessage\n{\n    @Override\n    int messageType() { return ht_server_hello; }\n    ProtocolVersion     protocolVersion;\n    RandomCookie        svr_random;\n    SessionId           sessionId;\n    CipherSuite         cipherSuite;\n    byte                compression_method;\n    HelloExtensions extensions = new HelloExtensions();\n    ServerHello() {\n        // empty\n    }\n    ServerHello(HandshakeInStream input, int messageLength)\n            throws IOException {\n        protocolVersion = ProtocolVersion.valueOf(input.getInt8(),\n                                                  input.getInt8());\n        svr_random = new RandomCookie(input);\n        sessionId = new SessionId(input.getBytes8());\n        cipherSuite = CipherSuite.valueOf(input.getInt8(), input.getInt8());\n        compression_method = (byte)input.getInt8();\n        if (messageLength() != messageLength) {\n            extensions = new HelloExtensions(input);\n        }\n    }\n    @Override\n    int messageLength()\n    {\n        // almost fixed size, except session ID and extensions:\n        //      major + minor = 2\n        //      random = 32\n        //      session ID len field = 1\n        //      cipher suite + compression = 3\n        //      extensions: if present, 2 + length of extensions\n        return 38 + sessionId.length() + extensions.length();\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException\n    {\n        s.putInt8(protocolVersion.major);\n        s.putInt8(protocolVersion.minor);\n        svr_random.send(s);\n        s.putBytes8(sessionId.getId());\n        s.putInt8(cipherSuite.id >> 8);\n        s.putInt8(cipherSuite.id & 0xff);\n        s.putInt8(compression_method);\n        extensions.send(s);\n    }\n    @Override\n    void print(PrintStream s) throws IOException\n    {\n        s.println(\"*** ServerHello, \" + protocolVersion);\n        if (debug != null && Debug.isOn(\"verbose\")) {\n            s.print(\"RandomCookie:  \");\n            svr_random.print(s);\n            s.print(\"Session ID:  \");\n            s.println(sessionId);\n            s.println(\"Cipher Suite: \" + cipherSuite);\n            s.println(\"Compression Method: \" + compression_method);\n            extensions.print(s);\n            s.println(\"***\");\n        }\n    }\n}\n/*\n * CertificateMsg ... send by both CLIENT and SERVER\n *\n * Each end of a connection may need to pass its certificate chain to\n * the other end.  Such chains are intended to validate an identity with\n * reference to some certifying authority.  Examples include companies\n * like Verisign, or financial institutions.  There's some control over\n * the certifying authorities which are sent.\n *\n * NOTE: that these messages might be huge, taking many handshake records.\n * Up to 2^48 bytes of certificate may be sent, in records of at most 2^14\n * bytes each ... up to 2^32 records sent on the output stream.\n */\nstatic final\nclass CertificateMsg extends HandshakeMessage\n{\n    @Override\n    int messageType() { return ht_certificate; }\n    private X509Certificate[] chain;\n    private List<byte[]> encodedChain;\n    private int messageLength;\n    CertificateMsg(X509Certificate[] certs) {\n        chain = certs;\n    }\n    CertificateMsg(HandshakeInStream input) throws IOException {\n        int chainLen = input.getInt24();\n        List<Certificate> v = new ArrayList<>(4);\n        CertificateFactory cf = null;\n        while (chainLen > 0) {\n            byte[] cert = input.getBytes24();\n            chainLen -= (3 + cert.length);\n            try {\n                if (cf == null) {\n                    cf = CertificateFactory.getInstance(\"X.509\");\n                }\n                v.add(cf.generateCertificate(new ByteArrayInputStream(cert)));\n            } catch (CertificateException e) {\n                throw (SSLProtocolException)new SSLProtocolException(\n                    e.getMessage()).initCause(e);\n            }\n        }\n        chain = v.toArray(new X509Certificate[v.size()]);\n    }\n    @Override\n    int messageLength() {\n        if (encodedChain == null) {\n            messageLength = 3;\n            encodedChain = new ArrayList<byte[]>(chain.length);\n            try {\n                for (X509Certificate cert : chain) {\n                    byte[] b = cert.getEncoded();\n                    encodedChain.add(b);\n                    messageLength += b.length + 3;\n                }\n            } catch (CertificateEncodingException e) {\n                encodedChain = null;\n                throw new RuntimeException(\"Could not encode certificates\", e);\n            }\n        }\n        return messageLength;\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException {\n        s.putInt24(messageLength() - 3);\n        for (byte[] b : encodedChain) {\n            s.putBytes24(b);\n        }\n    }\n    @Override\n    void print(PrintStream s) throws IOException {\n        s.println(\"*** Certificate chain\");\n        if (debug != null && Debug.isOn(\"verbose\")) {\nNext line of code:\n", "input": "", "context": "/*\n * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage sun.security.ssl;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.security.*;\nimport java.security.interfaces.*;\nimport java.security.spec.*;\nimport java.security.cert.*;\nimport java.security.cert.Certificate;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.lang.reflect.*;\nimport javax.security.auth.x500.X500Principal;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.DHPublicKeySpec;\nimport javax.net.ssl.*;\nimport sun.security.internal.spec.TlsPrfParameterSpec;\nimport sun.security.ssl.CipherSuite.*;\nimport static sun.security.ssl.CipherSuite.PRF.*;\nimport sun.security.util.KeyUtil;\n/**\n * Many data structures are involved in the handshake messages.  These\n * classes are used as structures, with public data members.  They are\n * not visible outside the SSL package.\n *\n * Handshake messages all have a common header format, and they are all\n * encoded in a \"handshake data\" SSL record substream.  The base class\n * here (HandshakeMessage) provides a common framework and records the\n * SSL record type of the particular handshake message.\n *\n * This file contains subclasses for all the basic handshake messages.\n * All handshake messages know how to encode and decode themselves on\n * SSL streams; this facilitates using the same code on SSL client and\n * server sides, although they don't send and receive the same messages.\n *\n * Messages also know how to print themselves, which is quite handy\n * for debugging.  They always identify their type, and can optionally\n * dump all of their content.\n *\n * @author David Brownell\n */\npublic abstract class HandshakeMessage {\n    HandshakeMessage() { }\n    // enum HandshakeType:\n    static final byte   ht_hello_request = 0;\n    static final byte   ht_client_hello = 1;\n    static final byte   ht_server_hello = 2;\n    static final byte   ht_certificate = 11;\n    static final byte   ht_server_key_exchange = 12;\n    static final byte   ht_certificate_request = 13;\n    static final byte   ht_server_hello_done = 14;\n    static final byte   ht_certificate_verify = 15;\n    static final byte   ht_client_key_exchange = 16;\n    static final byte   ht_finished = 20;\n    /* Class and subclass dynamic debugging support */\n    public static final Debug debug = Debug.getInstance(\"ssl\");\n    /**\n     * Utility method to convert a BigInteger to a byte array in unsigned\n     * format as needed in the handshake messages. BigInteger uses\n     * 2's complement format, i.e. it prepends an extra zero if the MSB\n     * is set. We remove that.\n     */\n    static byte[] toByteArray(BigInteger bi) {\n        byte[] b = bi.toByteArray();\n        if ((b.length > 1) && (b[0] == 0)) {\n            int n = b.length - 1;\n            byte[] newarray = new byte[n];\n            System.arraycopy(b, 1, newarray, 0, n);\n            b = newarray;\n        }\n        return b;\n    }\n    /*\n     * SSL 3.0 MAC padding constants.\n     * Also used by CertificateVerify and Finished during the handshake.\n     */\n    static final byte[] MD5_pad1 = genPad(0x36, 48);\n    static final byte[] MD5_pad2 = genPad(0x5c, 48);\n    static final byte[] SHA_pad1 = genPad(0x36, 40);\n    static final byte[] SHA_pad2 = genPad(0x5c, 40);\n    private static byte[] genPad(int b, int count) {\n        byte[] padding = new byte[count];\n        Arrays.fill(padding, (byte)b);\n        return padding;\n    }\n    /*\n     * Write a handshake message on the (handshake) output stream.\n     * This is just a four byte header followed by the data.\n     *\n     * NOTE that huge messages -- notably, ones with huge cert\n     * chains -- are handled correctly.\n     */\n    final void write(HandshakeOutStream s) throws IOException {\n        int len = messageLength();\n        if (len >= Record.OVERFLOW_OF_INT24) {\n            throw new SSLException(\"Handshake message too big\"\n                + \", type = \" + messageType() + \", len = \" + len);\n        }\n        s.write(messageType());\n        s.putInt24(len);\n        send(s);\n    }\n    /*\n     * Subclasses implement these methods so those kinds of\n     * messages can be emitted.  Base class delegates to subclass.\n     */\n    abstract int  messageType();\n    abstract int  messageLength();\n    abstract void send(HandshakeOutStream s) throws IOException;\n    /*\n     * Write a descriptive message on the output stream; for debugging.\n     */\n    abstract void print(PrintStream p) throws IOException;\n//\n// NOTE:  the rest of these classes are nested within this one, and are\n// imported by other classes in this package.  There are a few other\n// handshake message classes, not neatly nested here because of current\n// licensing requirement for native (RSA) methods.  They belong here,\n// but those native methods complicate things a lot!\n//\n/*\n * HelloRequest ... SERVER --> CLIENT\n *\n * Server can ask the client to initiate a new handshake, e.g. to change\n * session parameters after a connection has been (re)established.\n */\nstatic final class HelloRequest extends HandshakeMessage {\n    @Override\n    int messageType() { return ht_hello_request; }\n    HelloRequest() { }\n    HelloRequest(HandshakeInStream in) throws IOException\n    {\n        // nothing in this message\n    }\n    @Override\n    int messageLength() { return 0; }\n    @Override\n    void send(HandshakeOutStream out) throws IOException\n    {\n        // nothing in this messaage\n    }\n    @Override\n    void print(PrintStream out) throws IOException\n    {\n        out.println(\"*** HelloRequest (empty)\");\n    }\n}\n/*\n * ClientHello ... CLIENT --> SERVER\n *\n * Client initiates handshake by telling server what it wants, and what it\n * can support (prioritized by what's first in the ciphe suite list).\n *\n * By RFC2246:7.4.1.2 it's explicitly anticipated that this message\n * will have more data added at the end ... e.g. what CAs the client trusts.\n * Until we know how to parse it, we will just read what we know\n * about, and let our caller handle the jumps over unknown data.\n */\nstatic final class ClientHello extends HandshakeMessage {\n    ProtocolVersion     protocolVersion;\n    RandomCookie        clnt_random;\n    SessionId           sessionId;\n    private CipherSuiteList    cipherSuites;\n    byte[]              compression_methods;\n    HelloExtensions extensions = new HelloExtensions();\n    private final static byte[]  NULL_COMPRESSION = new byte[] {0};\n    ClientHello(SecureRandom generator, ProtocolVersion protocolVersion,\n            SessionId sessionId, CipherSuiteList cipherSuites) {\n        this.protocolVersion = protocolVersion;\n        this.sessionId = sessionId;\n        this.cipherSuites = cipherSuites;\n        if (cipherSuites.containsEC()) {\n            extensions.add(SupportedEllipticCurvesExtension.DEFAULT);\n            extensions.add(SupportedEllipticPointFormatsExtension.DEFAULT);\n        }\n        clnt_random = new RandomCookie(generator);\n        compression_methods = NULL_COMPRESSION;\n    }\n    ClientHello(HandshakeInStream s, int messageLength) throws IOException {\n        protocolVersion = ProtocolVersion.valueOf(s.getInt8(), s.getInt8());\n        clnt_random = new RandomCookie(s);\n        sessionId = new SessionId(s.getBytes8());\n        cipherSuites = new CipherSuiteList(s);\n        compression_methods = s.getBytes8();\n        if (messageLength() != messageLength) {\n            extensions = new HelloExtensions(s);\n        }\n    }\n    CipherSuiteList getCipherSuites() {\n        return cipherSuites;\n    }\n    // add renegotiation_info extension\n    void addRenegotiationInfoExtension(byte[] clientVerifyData) {\n        HelloExtension renegotiationInfo = new RenegotiationInfoExtension(\n                    clientVerifyData, new byte[0]);\n        extensions.add(renegotiationInfo);\n    }\n    // add server_name extension\n    void addSNIExtension(List<SNIServerName> serverNames) {\n        try {\n            extensions.add(new ServerNameExtension(serverNames));\n        } catch (IOException ioe) {\n            // ignore the exception and return\n        }\n    }\n    // add signature_algorithm extension\n    void addSignatureAlgorithmsExtension(\n            Collection<SignatureAndHashAlgorithm> algorithms) {\n        HelloExtension signatureAlgorithm =\n                new SignatureAlgorithmsExtension(algorithms);\n        extensions.add(signatureAlgorithm);\n    }\n    @Override\n    int messageType() { return ht_client_hello; }\n    @Override\n    int messageLength() {\n        /*\n         * Add fixed size parts of each field...\n         * version + random + session + cipher + compress\n         */\n        return (2 + 32 + 1 + 2 + 1\n            + sessionId.length()                /* ... + variable parts */\n            + (cipherSuites.size() * 2)\n            + compression_methods.length)\n            + extensions.length();\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException {\n        s.putInt8(protocolVersion.major);\n        s.putInt8(protocolVersion.minor);\n        clnt_random.send(s);\n        s.putBytes8(sessionId.getId());\n        cipherSuites.send(s);\n        s.putBytes8(compression_methods);\n        extensions.send(s);\n    }\n    @Override\n    void print(PrintStream s) throws IOException {\n        s.println(\"*** ClientHello, \" + protocolVersion);\n        if (debug != null && Debug.isOn(\"verbose\")) {\n            s.print(\"RandomCookie:  \");\n            clnt_random.print(s);\n            s.print(\"Session ID:  \");\n            s.println(sessionId);\n            s.println(\"Cipher Suites: \" + cipherSuites);\n            Debug.println(s, \"Compression Methods\", compression_methods);\n            extensions.print(s);\n            s.println(\"***\");\n        }\n    }\n}\n/*\n * ServerHello ... SERVER --> CLIENT\n *\n * Server chooses protocol options from among those it supports and the\n * client supports.  Then it sends the basic session descriptive parameters\n * back to the client.\n */\nstatic final\nclass ServerHello extends HandshakeMessage\n{\n    @Override\n    int messageType() { return ht_server_hello; }\n    ProtocolVersion     protocolVersion;\n    RandomCookie        svr_random;\n    SessionId           sessionId;\n    CipherSuite         cipherSuite;\n    byte                compression_method;\n    HelloExtensions extensions = new HelloExtensions();\n    ServerHello() {\n        // empty\n    }\n    ServerHello(HandshakeInStream input, int messageLength)\n            throws IOException {\n        protocolVersion = ProtocolVersion.valueOf(input.getInt8(),\n                                                  input.getInt8());\n        svr_random = new RandomCookie(input);\n        sessionId = new SessionId(input.getBytes8());\n        cipherSuite = CipherSuite.valueOf(input.getInt8(), input.getInt8());\n        compression_method = (byte)input.getInt8();\n        if (messageLength() != messageLength) {\n            extensions = new HelloExtensions(input);\n        }\n    }\n    @Override\n    int messageLength()\n    {\n        // almost fixed size, except session ID and extensions:\n        //      major + minor = 2\n        //      random = 32\n        //      session ID len field = 1\n        //      cipher suite + compression = 3\n        //      extensions: if present, 2 + length of extensions\n        return 38 + sessionId.length() + extensions.length();\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException\n    {\n        s.putInt8(protocolVersion.major);\n        s.putInt8(protocolVersion.minor);\n        svr_random.send(s);\n        s.putBytes8(sessionId.getId());\n        s.putInt8(cipherSuite.id >> 8);\n        s.putInt8(cipherSuite.id & 0xff);\n        s.putInt8(compression_method);\n        extensions.send(s);\n    }\n    @Override\n    void print(PrintStream s) throws IOException\n    {\n        s.println(\"*** ServerHello, \" + protocolVersion);\n        if (debug != null && Debug.isOn(\"verbose\")) {\n            s.print(\"RandomCookie:  \");\n            svr_random.print(s);\n            s.print(\"Session ID:  \");\n            s.println(sessionId);\n            s.println(\"Cipher Suite: \" + cipherSuite);\n            s.println(\"Compression Method: \" + compression_method);\n            extensions.print(s);\n            s.println(\"***\");\n        }\n    }\n}\n/*\n * CertificateMsg ... send by both CLIENT and SERVER\n *\n * Each end of a connection may need to pass its certificate chain to\n * the other end.  Such chains are intended to validate an identity with\n * reference to some certifying authority.  Examples include companies\n * like Verisign, or financial institutions.  There's some control over\n * the certifying authorities which are sent.\n *\n * NOTE: that these messages might be huge, taking many handshake records.\n * Up to 2^48 bytes of certificate may be sent, in records of at most 2^14\n * bytes each ... up to 2^32 records sent on the output stream.\n */\nstatic final\nclass CertificateMsg extends HandshakeMessage\n{\n    @Override\n    int messageType() { return ht_certificate; }\n    private X509Certificate[] chain;\n    private List<byte[]> encodedChain;\n    private int messageLength;\n    CertificateMsg(X509Certificate[] certs) {\n        chain = certs;\n    }\n    CertificateMsg(HandshakeInStream input) throws IOException {\n        int chainLen = input.getInt24();\n        List<Certificate> v = new ArrayList<>(4);\n        CertificateFactory cf = null;\n        while (chainLen > 0) {\n            byte[] cert = input.getBytes24();\n            chainLen -= (3 + cert.length);\n            try {\n                if (cf == null) {\n                    cf = CertificateFactory.getInstance(\"X.509\");\n                }\n                v.add(cf.generateCertificate(new ByteArrayInputStream(cert)));\n            } catch (CertificateException e) {\n                throw (SSLProtocolException)new SSLProtocolException(\n                    e.getMessage()).initCause(e);\n            }\n        }\n        chain = v.toArray(new X509Certificate[v.size()]);\n    }\n    @Override\n    int messageLength() {\n        if (encodedChain == null) {\n            messageLength = 3;\n            encodedChain = new ArrayList<byte[]>(chain.length);\n            try {\n                for (X509Certificate cert : chain) {\n                    byte[] b = cert.getEncoded();\n                    encodedChain.add(b);\n                    messageLength += b.length + 3;\n                }\n            } catch (CertificateEncodingException e) {\n                encodedChain = null;\n                throw new RuntimeException(\"Could not encode certificates\", e);\n            }\n        }\n        return messageLength;\n    }\n    @Override\n    void send(HandshakeOutStream s) throws IOException {\n        s.putInt24(messageLength() - 3);\n        for (byte[] b : encodedChain) {\n            s.putBytes24(b);\n        }\n    }\n    @Override\n    void print(PrintStream s) throws IOException {\n        s.println(\"*** Certificate chain\");\n        if (debug != null && Debug.isOn(\"verbose\")) {\n", "answers": ["            for (int i = 0; i < chain.length; i++)"], "pred": "  }  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 1820, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "f652398c3e8be338b4a7873ba6fecc5a686204d99a1a8d10"}
{"prompt": "Please complete the code given below. \n/*\n * jPOS Project [http://jpos.org]\n * Copyright (C) 2000-2015 Alejandro P. Revilla\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.jpos.space;\nimport java.io.*;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport com.sleepycat.je.*;\nimport com.sleepycat.persist.EntityStore; \nimport com.sleepycat.persist.StoreConfig; \nimport com.sleepycat.persist.EntityCursor;\nimport com.sleepycat.persist.PrimaryIndex;\nimport com.sleepycat.persist.SecondaryIndex;\nimport com.sleepycat.persist.model.Entity;\nimport com.sleepycat.persist.model.Persistent;\nimport com.sleepycat.persist.model.PrimaryKey;\nimport com.sleepycat.persist.model.SecondaryKey;\nimport com.sleepycat.persist.model.Relationship;\nimport java.util.HashSet;\nimport java.util.concurrent.TimeUnit;\nimport org.jpos.util.Log;\nimport org.jpos.util.Loggeable;\n/**\n * BerkeleyDB Jave Edition based persistent space implementation\n *\n * @author Alejandro Revilla\n * @since 1.6.5\n */\n@SuppressWarnings(\"unchecked\")\npublic class JESpace<K,V> extends Log implements LocalSpace<K,V>, Loggeable, Runnable {\n    Environment dbe = null;\n    EntityStore store = null;\n    PrimaryIndex<Long, Ref> pIndex = null;\n    PrimaryIndex<Long,GCRef> gcpIndex = null;\n    SecondaryIndex<String,Long, Ref> sIndex = null;\n    SecondaryIndex<Long,Long,GCRef> gcsIndex = null;\n    Semaphore gcSem = new Semaphore(1);\n    LocalSpace<Object,SpaceListener> sl;\n    private static final long NRD_RESOLUTION = 500L;\n    public static final long GC_DELAY = 60*1000L;\n    private Future gcTask;\n    static final Map<String,Space> spaceRegistrar = \n        new HashMap<String,Space> ();\n    public JESpace(String name, String path) throws SpaceError {\n        super();\n        try {\n            EnvironmentConfig envConfig = new EnvironmentConfig();\n            StoreConfig storeConfig = new StoreConfig();\n            envConfig.setAllowCreate (true);\n            envConfig.setTransactional(true);\n            // envConfig.setTxnTimeout(5L, TimeUnit.MINUTES);\n            envConfig.setLockTimeout(5, TimeUnit.SECONDS);\n            storeConfig.setAllowCreate (true);\n            storeConfig.setTransactional (true);\n            File dir = new File(path);\n            dir.mkdirs();\n            dbe = new Environment (dir, envConfig);\n            store = new EntityStore (dbe, name, storeConfig);\n            pIndex = store.getPrimaryIndex (Long.class, Ref.class);\n            gcpIndex = store.getPrimaryIndex (Long.class, GCRef.class);\n            sIndex = store.getSecondaryIndex (pIndex, String.class, \"key\");\n            gcsIndex = store.getSecondaryIndex (gcpIndex, Long.class, \"expires\");\n            gcTask = SpaceFactory.getGCExecutor().scheduleAtFixedRate(this, GC_DELAY, GC_DELAY, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        }\n    }\n    public void out (K key, V value) {\n        out (key, value, 0L);\n    }\n    public void out (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            if (timeout > 0L)\n                gcpIndex.putNoReturn (\n                    new GCRef (ref.getId(), ref.getExpiration())\n                );\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            pIndex.delete (ref.getId());\n            ref.reverseId();\n            pIndex.put (ref);\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value) {\n        push (key, value, 0L);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V rdp (Object key) {\n        try {\n            return (V) getObject (key, false);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key) {\n        Object obj;\n        while ((obj = inp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = inp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key) {\n        Object obj;\n        while ((obj = rdp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    public synchronized void nrd  (Object key) {\n        while (rdp (key) != null) {\n            try {\n                this.wait (NRD_RESOLUTION);\n            } catch (InterruptedException ignored) { }\n        }\n    }\n    public synchronized V nrd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) != null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (Math.min(NRD_RESOLUTION, end - now));\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V inp (Object key) {\n        try {\n            return (V) getObject (key, true);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    public boolean existAny (Object[] keys) {\n        for (Object key : keys) {\n            if (rdp(key) != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public boolean existAny (Object[] keys, long timeout) {\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((now = System.currentTimeMillis()) < end) {\n            if (existAny (keys))\n                return true;\n            synchronized (this) {\n                try {\n                    wait (end - now);\n                } catch (InterruptedException ignored) { }\n            }\n        }\n        return false;\n    }\n    public synchronized void put (K key, V value, long timeout) {\n        while (inp (key) != null)\n            ;\n        out (key, value, timeout);\n    }\n    public synchronized void put (K key, V value) {\n        while (inp (key) != null)\n            ;\n        out (key, value);\n    }\n    public void gc () throws DatabaseException {\n        Transaction txn = null;\n        EntityCursor<GCRef> cursor = null;\n        try {\n            if (!gcSem.tryAcquire())\n                return;\n            txn = dbe.beginTransaction (null, null);\n            cursor = gcsIndex.entities (\n                txn, 0L, true, System.currentTimeMillis(), false, null\n            );\n            for (GCRef gcRef: cursor) {\n                pIndex.delete (gcRef.getId());\n                cursor.delete ();\n            }\n            cursor.close();\n            cursor = null;\n            txn.commit();\n            txn = null;\n            if (sl != null) {\n                synchronized (this) {\n                    if (sl != null && sl.getKeySet().isEmpty())\n                        sl = null;\n                }\n            }\n        } finally {\n            if (cursor != null)\n                cursor.close();\n            if (txn != null)\n                abort (txn);\n            gcSem.release();\n        }\n    }\n    public void run() {\n        try {\n            gc();\n        } catch (DatabaseException e) {\n            warn(e);\n        }\n    }\n    public void close () throws DatabaseException {\n        gcSem.acquireUninterruptibly();\n        gcTask.cancel(false);\n        while (!gcTask.isDone()) {\n            try {\n                Thread.sleep(500L);\n            } catch (InterruptedException ignored) { }\n        }\n        store.close ();\n        dbe.close();\n    }\n    public synchronized static JESpace getSpace (String name, String path)\n    {\n        JESpace sp = (JESpace) spaceRegistrar.get (name);\n        if (sp == null) {\nNext line of code:\n", "input": "", "context": "/*\n * jPOS Project [http://jpos.org]\n * Copyright (C) 2000-2015 Alejandro P. Revilla\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage org.jpos.space;\nimport java.io.*;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport com.sleepycat.je.*;\nimport com.sleepycat.persist.EntityStore; \nimport com.sleepycat.persist.StoreConfig; \nimport com.sleepycat.persist.EntityCursor;\nimport com.sleepycat.persist.PrimaryIndex;\nimport com.sleepycat.persist.SecondaryIndex;\nimport com.sleepycat.persist.model.Entity;\nimport com.sleepycat.persist.model.Persistent;\nimport com.sleepycat.persist.model.PrimaryKey;\nimport com.sleepycat.persist.model.SecondaryKey;\nimport com.sleepycat.persist.model.Relationship;\nimport java.util.HashSet;\nimport java.util.concurrent.TimeUnit;\nimport org.jpos.util.Log;\nimport org.jpos.util.Loggeable;\n/**\n * BerkeleyDB Jave Edition based persistent space implementation\n *\n * @author Alejandro Revilla\n * @since 1.6.5\n */\n@SuppressWarnings(\"unchecked\")\npublic class JESpace<K,V> extends Log implements LocalSpace<K,V>, Loggeable, Runnable {\n    Environment dbe = null;\n    EntityStore store = null;\n    PrimaryIndex<Long, Ref> pIndex = null;\n    PrimaryIndex<Long,GCRef> gcpIndex = null;\n    SecondaryIndex<String,Long, Ref> sIndex = null;\n    SecondaryIndex<Long,Long,GCRef> gcsIndex = null;\n    Semaphore gcSem = new Semaphore(1);\n    LocalSpace<Object,SpaceListener> sl;\n    private static final long NRD_RESOLUTION = 500L;\n    public static final long GC_DELAY = 60*1000L;\n    private Future gcTask;\n    static final Map<String,Space> spaceRegistrar = \n        new HashMap<String,Space> ();\n    public JESpace(String name, String path) throws SpaceError {\n        super();\n        try {\n            EnvironmentConfig envConfig = new EnvironmentConfig();\n            StoreConfig storeConfig = new StoreConfig();\n            envConfig.setAllowCreate (true);\n            envConfig.setTransactional(true);\n            // envConfig.setTxnTimeout(5L, TimeUnit.MINUTES);\n            envConfig.setLockTimeout(5, TimeUnit.SECONDS);\n            storeConfig.setAllowCreate (true);\n            storeConfig.setTransactional (true);\n            File dir = new File(path);\n            dir.mkdirs();\n            dbe = new Environment (dir, envConfig);\n            store = new EntityStore (dbe, name, storeConfig);\n            pIndex = store.getPrimaryIndex (Long.class, Ref.class);\n            gcpIndex = store.getPrimaryIndex (Long.class, GCRef.class);\n            sIndex = store.getSecondaryIndex (pIndex, String.class, \"key\");\n            gcsIndex = store.getSecondaryIndex (gcpIndex, Long.class, \"expires\");\n            gcTask = SpaceFactory.getGCExecutor().scheduleAtFixedRate(this, GC_DELAY, GC_DELAY, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        }\n    }\n    public void out (K key, V value) {\n        out (key, value, 0L);\n    }\n    public void out (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            if (timeout > 0L)\n                gcpIndex.putNoReturn (\n                    new GCRef (ref.getId(), ref.getExpiration())\n                );\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value, long timeout) {\n        Transaction txn = null;\n        try {\n            txn = dbe.beginTransaction (null, null);\n            Ref ref = new Ref(key.toString(), value, timeout);\n            pIndex.put (ref);\n            pIndex.delete (ref.getId());\n            ref.reverseId();\n            pIndex.put (ref);\n            txn.commit();\n            txn = null;\n            synchronized (this) {\n                notifyAll ();\n            }\n            if (sl != null)\n                notifyListeners(key, value);\n        } catch (Exception e) {\n            throw new SpaceError (e);\n        } finally {\n            if (txn != null)\n                abort (txn);\n        }\n    }\n    public void push (K key, V value) {\n        push (key, value, 0L);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V rdp (Object key) {\n        try {\n            return (V) getObject (key, false);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key) {\n        Object obj;\n        while ((obj = inp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V in (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = inp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key) {\n        Object obj;\n        while ((obj = rdp (key)) == null) {\n            try {\n                this.wait ();\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public synchronized V rd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) == null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (end - now);\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    public synchronized void nrd  (Object key) {\n        while (rdp (key) != null) {\n            try {\n                this.wait (NRD_RESOLUTION);\n            } catch (InterruptedException ignored) { }\n        }\n    }\n    public synchronized V nrd  (Object key, long timeout) {\n        Object obj;\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((obj = rdp (key)) != null &&\n                (now = System.currentTimeMillis()) < end)\n        {\n            try {\n                this.wait (Math.min(NRD_RESOLUTION, end - now));\n            } catch (InterruptedException ignored) { }\n        }\n        return (V) obj;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public V inp (Object key) {\n        try {\n            return (V) getObject (key, true);\n        } catch (DatabaseException e) {\n            throw new SpaceError (e);\n        }\n    }\n    public boolean existAny (Object[] keys) {\n        for (Object key : keys) {\n            if (rdp(key) != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public boolean existAny (Object[] keys, long timeout) {\n        long now = System.currentTimeMillis();\n        long end = now + timeout;\n        while ((now = System.currentTimeMillis()) < end) {\n            if (existAny (keys))\n                return true;\n            synchronized (this) {\n                try {\n                    wait (end - now);\n                } catch (InterruptedException ignored) { }\n            }\n        }\n        return false;\n    }\n    public synchronized void put (K key, V value, long timeout) {\n        while (inp (key) != null)\n            ;\n        out (key, value, timeout);\n    }\n    public synchronized void put (K key, V value) {\n        while (inp (key) != null)\n            ;\n        out (key, value);\n    }\n    public void gc () throws DatabaseException {\n        Transaction txn = null;\n        EntityCursor<GCRef> cursor = null;\n        try {\n            if (!gcSem.tryAcquire())\n                return;\n            txn = dbe.beginTransaction (null, null);\n            cursor = gcsIndex.entities (\n                txn, 0L, true, System.currentTimeMillis(), false, null\n            );\n            for (GCRef gcRef: cursor) {\n                pIndex.delete (gcRef.getId());\n                cursor.delete ();\n            }\n            cursor.close();\n            cursor = null;\n            txn.commit();\n            txn = null;\n            if (sl != null) {\n                synchronized (this) {\n                    if (sl != null && sl.getKeySet().isEmpty())\n                        sl = null;\n                }\n            }\n        } finally {\n            if (cursor != null)\n                cursor.close();\n            if (txn != null)\n                abort (txn);\n            gcSem.release();\n        }\n    }\n    public void run() {\n        try {\n            gc();\n        } catch (DatabaseException e) {\n            warn(e);\n        }\n    }\n    public void close () throws DatabaseException {\n        gcSem.acquireUninterruptibly();\n        gcTask.cancel(false);\n        while (!gcTask.isDone()) {\n            try {\n                Thread.sleep(500L);\n            } catch (InterruptedException ignored) { }\n        }\n        store.close ();\n        dbe.close();\n    }\n    public synchronized static JESpace getSpace (String name, String path)\n    {\n        JESpace sp = (JESpace) spaceRegistrar.get (name);\n        if (sp == null) {\n", "answers": ["            sp = new JESpace(name, path);"], "pred": "  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of code:\n  Next line of", "length": 1096, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "01b11dc980d93775ce16fd5e630cf5619f66f281ee12947b"}
{"prompt": "Please complete the code given below. \n/*\n * Pixel Dungeon\n * Copyright (C) 2012-2015 Oleg Dolya\n *\n * Shattered Pixel Dungeon\n * Copyright (C) 2014-2021 Evan Debenham\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n */\npackage com.shatteredpixel.shatteredpixeldungeon.items.spells;\nimport com.shatteredpixel.shatteredpixeldungeon.Assets;\nimport com.shatteredpixel.shatteredpixeldungeon.Dungeon;\nimport com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;\nimport com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;\nimport com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Shopkeeper;\nimport com.shatteredpixel.shatteredpixeldungeon.items.Item;\nimport com.shatteredpixel.shatteredpixeldungeon.items.potions.AlchemicalCatalyst;\nimport com.shatteredpixel.shatteredpixeldungeon.messages.Messages;\nimport com.shatteredpixel.shatteredpixeldungeon.scenes.AlchemyScene;\nimport com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;\nimport com.shatteredpixel.shatteredpixeldungeon.sprites.ItemSprite;\nimport com.shatteredpixel.shatteredpixeldungeon.sprites.ItemSpriteSheet;\nimport com.shatteredpixel.shatteredpixeldungeon.ui.RedButton;\nimport com.shatteredpixel.shatteredpixeldungeon.utils.GLog;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndBag;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndEnergizeItem;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndImp;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndInfoItem;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;\nimport com.watabou.noosa.audio.Sample;\npublic class Alchemize extends Spell {\n\t\n\t{\n\t\timage = ItemSpriteSheet.ALCHEMIZE;\n\t}\n\t\n\t@Override\n\tprotected void onCast(Hero hero) {\n\t\tGameScene.selectItem( itemSelector );\n\t}\n\t\n\t@Override\n\tpublic int value() {\n\t\t//prices of ingredients, divided by output quantity\n\t\treturn Math.round(quantity * (40 / 8f));\n\t}\n\t//TODO also allow alchemical catalyst? Or save that for an elixir/brew?\n\tpublic static class Recipe extends com.shatteredpixel.shatteredpixeldungeon.items.Recipe.SimpleRecipe {\n\t\t{\n\t\t\tinputs =  new Class[]{ArcaneCatalyst.class};\n\t\t\tinQuantity = new int[]{1};\n\t\t\t\n\t\t\tcost = 3;\n\t\t\t\n\t\t\toutput = Alchemize.class;\n\t\t\toutQuantity = 8;\n\t\t}\n\t\t\n\t}\n\tprivate static WndBag.ItemSelector itemSelector = new WndBag.ItemSelector() {\n\t\t@Override\n\t\tpublic String textPrompt() {\n\t\t\treturn Messages.get(Alchemize.class, \"prompt\");\n\t\t}\n\t\t@Override\n\t\tpublic boolean itemSelectable(Item item) {\n\t\t\treturn !(item instanceof Alchemize)\n\t\t\t\t\t&& (Shopkeeper.canSell(item) || item.energyVal() > 0);\n\t\t}\n\t\t@Override\n\t\tpublic void onSelect( Item item ) {\n\t\t\tif (item != null) {\n\t\t\t\tWndBag parentWnd = GameScene.selectItem( itemSelector );\n\t\t\t\tGameScene.show( new WndAlchemizeItem( item, parentWnd ) );\n\t\t\t}\n\t\t}\n\t};\n\tpublic static class WndAlchemizeItem extends WndInfoItem {\n\t\tprivate static final float GAP\t\t= 2;\n\t\tprivate static final int BTN_HEIGHT\t= 18;\n\t\tprivate WndBag owner;\n\t\tpublic WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\t\t\tthis.owner = owner;\n\t\t\tfloat pos = height;\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\t\t\t\t\tpos = btnSell.bottom();\n\t\t\t\t} else {\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\t\t\t\t\tpos = btnSellAll.bottom();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\t\t\t\t\tpos = btnEnergize.bottom();\n\t\t\t\t} else {\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\nNext line of code:\n", "input": "", "context": "/*\n * Pixel Dungeon\n * Copyright (C) 2012-2015 Oleg Dolya\n *\n * Shattered Pixel Dungeon\n * Copyright (C) 2014-2021 Evan Debenham\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n */\npackage com.shatteredpixel.shatteredpixeldungeon.items.spells;\nimport com.shatteredpixel.shatteredpixeldungeon.Assets;\nimport com.shatteredpixel.shatteredpixeldungeon.Dungeon;\nimport com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;\nimport com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;\nimport com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Shopkeeper;\nimport com.shatteredpixel.shatteredpixeldungeon.items.Item;\nimport com.shatteredpixel.shatteredpixeldungeon.items.potions.AlchemicalCatalyst;\nimport com.shatteredpixel.shatteredpixeldungeon.messages.Messages;\nimport com.shatteredpixel.shatteredpixeldungeon.scenes.AlchemyScene;\nimport com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;\nimport com.shatteredpixel.shatteredpixeldungeon.sprites.ItemSprite;\nimport com.shatteredpixel.shatteredpixeldungeon.sprites.ItemSpriteSheet;\nimport com.shatteredpixel.shatteredpixeldungeon.ui.RedButton;\nimport com.shatteredpixel.shatteredpixeldungeon.utils.GLog;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndBag;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndEnergizeItem;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndImp;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndInfoItem;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;\nimport com.watabou.noosa.audio.Sample;\npublic class Alchemize extends Spell {\n\t\n\t{\n\t\timage = ItemSpriteSheet.ALCHEMIZE;\n\t}\n\t\n\t@Override\n\tprotected void onCast(Hero hero) {\n\t\tGameScene.selectItem( itemSelector );\n\t}\n\t\n\t@Override\n\tpublic int value() {\n\t\t//prices of ingredients, divided by output quantity\n\t\treturn Math.round(quantity * (40 / 8f));\n\t}\n\t//TODO also allow alchemical catalyst? Or save that for an elixir/brew?\n\tpublic static class Recipe extends com.shatteredpixel.shatteredpixeldungeon.items.Recipe.SimpleRecipe {\n\t\t{\n\t\t\tinputs =  new Class[]{ArcaneCatalyst.class};\n\t\t\tinQuantity = new int[]{1};\n\t\t\t\n\t\t\tcost = 3;\n\t\t\t\n\t\t\toutput = Alchemize.class;\n\t\t\toutQuantity = 8;\n\t\t}\n\t\t\n\t}\n\tprivate static WndBag.ItemSelector itemSelector = new WndBag.ItemSelector() {\n\t\t@Override\n\t\tpublic String textPrompt() {\n\t\t\treturn Messages.get(Alchemize.class, \"prompt\");\n\t\t}\n\t\t@Override\n\t\tpublic boolean itemSelectable(Item item) {\n\t\t\treturn !(item instanceof Alchemize)\n\t\t\t\t\t&& (Shopkeeper.canSell(item) || item.energyVal() > 0);\n\t\t}\n\t\t@Override\n\t\tpublic void onSelect( Item item ) {\n\t\t\tif (item != null) {\n\t\t\t\tWndBag parentWnd = GameScene.selectItem( itemSelector );\n\t\t\t\tGameScene.show( new WndAlchemizeItem( item, parentWnd ) );\n\t\t\t}\n\t\t}\n\t};\n\tpublic static class WndAlchemizeItem extends WndInfoItem {\n\t\tprivate static final float GAP\t\t= 2;\n\t\tprivate static final int BTN_HEIGHT\t= 18;\n\t\tprivate WndBag owner;\n\t\tpublic WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\t\t\tthis.owner = owner;\n\t\t\tfloat pos = height;\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\t\t\t\t\tpos = btnSell.bottom();\n\t\t\t\t} else {\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\t\t\t\t\tpos = btnSellAll.bottom();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\t\t\t\t\tpos = btnEnergize.bottom();\n\t\t\t\t} else {\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\n", "answers": ["\t\t\t\t\tpos = btnEnergizeAll.bottom();"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 567, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "64d5f26d486a85e85284229e8d254f996cfafd844cd321c5"}
{"prompt": "Please complete the code given below. \n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by the\n# Free Software Foundation; either version 3, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY\n# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n# for more details.\n\"\"\"Pythonic simple SOAP Server implementation\"\"\"\nfrom __future__ import unicode_literals\nimport sys\nimport logging\nimport re\nimport traceback\ntry:\n    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nexcept ImportError:\n    from http.server import BaseHTTPRequestHandler, HTTPServer\nfrom . import __author__, __copyright__, __license__, __version__\nfrom .simplexml import SimpleXMLElement, TYPE_MAP, Date, Decimal\nlog = logging.getLogger(__name__)\n# Deprecated?\nNS_RX = re.compile(r'xmlns:(\\w+)=\"(.+?)\"')\nclass SoapDispatcher(object):\n    \"\"\"Simple Dispatcher for SOAP Server\"\"\"\n    def __init__(self, name, documentation='', action='', location='',\n                 namespace=None, prefix=False,\n                 soap_uri=\"http://schemas.xmlsoap.org/soap/envelope/\",\n                 soap_ns='soap',\n                 namespaces={},\n                 pretty=False,\n                 debug=False,\n                 **kwargs):\n        \"\"\"\n        :param namespace: Target namespace; xmlns=targetNamespace\n        :param prefix: Prefix for target namespace; xmlns:prefix=targetNamespace\n        :param namespaces: Specify additional namespaces; example: {'external': 'http://external.mt.moboperator'}\n        :param pretty: Prettifies generated xmls\n        :param debug: Use to add tracebacks in generated xmls.\n        Multiple namespaces\n        ===================\n        It is possible to support multiple namespaces.\n        You need to specify additional namespaces by passing `namespace` parameter.\n        >>> dispatcher = SoapDispatcher(\n        ...    name = \"MTClientWS\",\n        ...    location = \"http://localhost:8008/ws/MTClientWS\",\n        ...    action = 'http://localhost:8008/ws/MTClientWS', # SOAPAction\n        ...    namespace = \"http://external.mt.moboperator\", prefix=\"external\",\n        ...    documentation = 'moboperator MTClientWS',\n        ...    namespaces = {\n        ...        'external': 'http://external.mt.moboperator',\n        ...        'model': 'http://model.common.mt.moboperator'\n        ...    },\n        ...    ns = True)\n        Now the registered method must return node names with namespaces' prefixes.\n        >>> def _multi_ns_func(self, serviceMsisdn):\n        ...    ret = {\n        ...        'external:activateSubscriptionsReturn': [\n        ...            {'model:code': '0'},\n        ...            {'model:description': 'desc'},\n        ...        ]}\n        ...    return ret\n        Our prefixes will be changed to those used by the client.\n        \"\"\"\n        self.methods = {}\n        self.name = name\n        self.documentation = documentation\n        self.action = action  # base SoapAction\n        self.location = location\n        self.namespace = namespace  # targetNamespace\n        self.prefix = prefix\n        self.soap_ns = soap_ns\n        self.soap_uri = soap_uri\n        self.namespaces = namespaces\n        self.pretty = pretty\n        self.debug = debug\n    @staticmethod\n    def _extra_namespaces(xml, ns):\n        \"\"\"Extends xml with extra namespaces.\n        :param ns: dict with namespaceUrl:prefix pairs\n        :param xml: XML node to modify\n        \"\"\"\n        if ns:\n            _tpl = 'xmlns:%s=\"%s\"'\n            _ns_str = \" \".join([_tpl % (prefix, uri) for uri, prefix in ns.items() if uri not in xml])\n            xml = xml.replace('/>', ' ' + _ns_str + '/>')\n        return xml\n    def register_function(self, name, fn, returns=None, args=None, doc=None):\n        self.methods[name] = fn, returns, args, doc or getattr(fn, \"__doc__\", \"\")\n    def dispatch(self, xml, action=None):\n        \"\"\"Receive and process SOAP call\"\"\"\n        # default values:\n        prefix = self.prefix\n        ret = fault = None\n        soap_ns, soap_uri = self.soap_ns, self.soap_uri\n        soap_fault_code = 'VersionMismatch'\n        name = None\n        # namespaces = [('model', 'http://model.common.mt.moboperator'), ('external', 'http://external.mt.moboperator')]\n        _ns_reversed = dict(((v, k) for k, v in self.namespaces.items()))  # Switch keys-values\n        # _ns_reversed = {'http://external.mt.moboperator': 'external', 'http://model.common.mt.moboperator': 'model'}\n        try:\n            request = SimpleXMLElement(xml, namespace=self.namespace)\n            # detect soap prefix and uri (xmlns attributes of Envelope)\n            for k, v in request[:]:\n                if v in (\"http://schemas.xmlsoap.org/soap/envelope/\",\n                         \"http://www.w3.org/2003/05/soap-env\",):\n                    soap_ns = request.attributes()[k].localName\n                    soap_uri = request.attributes()[k].value\n                # If the value from attributes on Envelope is in additional namespaces\n                elif v in self.namespaces.values():\n                    _ns = request.attributes()[k].localName\n                    _uri = request.attributes()[k].value\n                    _ns_reversed[_uri] = _ns  # update with received alias\n                    # Now we change 'external' and 'model' to the received forms i.e. 'ext' and 'mod'\n                # After that we know how the client has prefixed additional namespaces\n            ns = NS_RX.findall(xml)\n            for k, v in ns:\n                if v in self.namespaces.values():\n                    _ns_reversed[v] = k\n            soap_fault_code = 'Client'\n            # parse request message and get local method\n            method = request('Body', ns=soap_uri).children()(0)\n            if action:\n                # method name = action\n                name = action[len(self.action)+1:-1]\n                prefix = self.prefix\n            if not action or not name:\n                # method name = input message name\n                name = method.get_local_name()\n                prefix = method.get_prefix()\n            log.debug('dispatch method: %s', name)\n            function, returns_types, args_types, doc = self.methods[name]\n            log.debug('returns_types %s', returns_types)\n            # de-serialize parameters (if type definitions given)\n            if args_types:\n                args = method.children().unmarshall(args_types)\n            elif args_types is None:\n                args = {'request': method}  # send raw request\n            else:\n                args = {}  # no parameters\n            soap_fault_code = 'Server'\n            # execute function\n            ret = function(**args)\n            log.debug('dispathed method returns: %s', ret)\n        except Exception:  # This shouldn't be one huge try/except\n            import sys\n            etype, evalue, etb = sys.exc_info()\n            log.error(traceback.format_exc())\n            if self.debug:\n                detail = ''.join(traceback.format_exception(etype, evalue, etb))\n                detail += '\\n\\nXML REQUEST\\n\\n' + xml\n            else:\n                detail = None\n            fault = {'faultcode': \"%s.%s\" % (soap_fault_code, etype.__name__),\n                     'faultstring': evalue,\n                     'detail': detail}\n        # build response message\n        if not prefix:\n            xml = \"\"\"<%(soap_ns)s:Envelope xmlns:%(soap_ns)s=\"%(soap_uri)s\"/>\"\"\"\n        else:\n            xml = \"\"\"<%(soap_ns)s:Envelope xmlns:%(soap_ns)s=\"%(soap_uri)s\"\n                       xmlns:%(prefix)s=\"%(namespace)s\"/>\"\"\"\n        xml %= {    # a %= {} is a shortcut for a = a % {}\n            'namespace': self.namespace,\n            'prefix': prefix,\n            'soap_ns': soap_ns,\n            'soap_uri': soap_uri\n        }\n        # Now we add extra namespaces\n        xml = SoapDispatcher._extra_namespaces(xml, _ns_reversed)\n        # Change our namespace alias to that given by the client.\n        # We put [('model', 'http://model.common.mt.moboperator'), ('external', 'http://external.mt.moboperator')]\n        # mix it with {'http://external.mt.moboperator': 'ext', 'http://model.common.mt.moboperator': 'mod'}\n        mapping = dict(((k, _ns_reversed[v]) for k, v in self.namespaces.items()))  # Switch keys-values and change value\n        # and get {'model': u'mod', 'external': u'ext'}\n        response = SimpleXMLElement(xml,\n                                    namespace=self.namespace,\n                                    namespaces_map=mapping,\n                                    prefix=prefix)\n        response['xmlns:xsi'] = \"http://www.w3.org/2001/XMLSchema-instance\"\n        response['xmlns:xsd'] = \"http://www.w3.org/2001/XMLSchema\"\n        body = response.add_child(\"%s:Body\" % soap_ns, ns=False)\n        if fault:\n            # generate a Soap Fault (with the python exception)\n            body.marshall(\"%s:Fault\" % soap_ns, fault, ns=False)\n        else:\n            # return normal value\n            res = body.add_child(\"%sResponse\" % name, ns=prefix)\n            if not prefix:\n                res['xmlns'] = self.namespace  # add target namespace\n            # serialize returned values (response) if type definition available\n            if returns_types:\n                if not isinstance(ret, dict):\n                    res.marshall(returns_types.keys()[0], ret, )\n                else:\n                    for k, v in ret.items():\n                        res.marshall(k, v)\n            elif returns_types is None:\n                # merge xmlelement returned\n                res.import_node(ret)\n            elif returns_types == {}:\n                log.warning('Given returns_types is an empty dict.')\n        return response.as_xml(pretty=self.pretty)\n    # Introspection functions:\n    def list_methods(self):\n        \"\"\"Return a list of aregistered operations\"\"\"\n        return [(method, doc) for method, (function, returns, args, doc) in self.methods.items()]\n    def help(self, method=None):\n        \"\"\"Generate sample request and response messages\"\"\"\n        (function, returns, args, doc) = self.methods[method]\n        xml = \"\"\"\n<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n<soap:Body><%(method)s xmlns=\"%(namespace)s\"/></soap:Body>\n</soap:Envelope>\"\"\" % {'method': method, 'namespace': self.namespace}\n        request = SimpleXMLElement(xml, namespace=self.namespace, prefix=self.prefix)\n        if args:\n            items = args.items()\n        elif args is None:\n            items = [('value', None)]\n        else:\n            items = []\n        for k, v in items:\n            request(method).marshall(k, v, add_comments=True, ns=False)\n        xml = \"\"\"\n<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n<soap:Body><%(method)sResponse xmlns=\"%(namespace)s\"/></soap:Body>\n</soap:Envelope>\"\"\" % {'method': method, 'namespace': self.namespace}\n        response = SimpleXMLElement(xml, namespace=self.namespace, prefix=self.prefix)\n        if returns:\n            items = returns.items()\n        elif args is None:\n            items = [('value', None)]\n        else:\n            items = []\n        for k, v in items:\n            response('%sResponse' % method).marshall(k, v, add_comments=True, ns=False)\n        return request.as_xml(pretty=True), response.as_xml(pretty=True), doc\n    def wsdl(self):\n        \"\"\"Generate Web Service Description v1.1\"\"\"\n        xml = \"\"\"<?xml version=\"1.0\"?>\n<wsdl:definitions name=\"%(name)s\"\n          targetNamespace=\"%(namespace)s\"\n          xmlns:tns=\"%(namespace)s\"\n          xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\"\n          xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n          xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <wsdl:documentation xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\">%(documentation)s</wsdl:documentation>\n    <wsdl:types>\n       <xsd:schema targetNamespace=\"%(namespace)s\"\n              elementFormDefault=\"qualified\"\n              xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n       </xsd:schema>\n    </wsdl:types>\n</wsdl:definitions>\n\"\"\" % {'namespace': self.namespace, 'name': self.name, 'documentation': self.documentation}\n        wsdl = SimpleXMLElement(xml)\n        for method, (function, returns, args, doc) in self.methods.items():\n            # create elements:\n            def parse_element(name, values, array=False, complex=False):\n                if not complex:\n                    element = wsdl('wsdl:types')('xsd:schema').add_child('xsd:element')\n                    complex = element.add_child(\"xsd:complexType\")\n                else:\n                    complex = wsdl('wsdl:types')('xsd:schema').add_child('xsd:complexType')\n                    element = complex\n                element['name'] = name\n                if values:\n                    items = values\n                elif values is None:\n                    items = [('value', None)]\n                else:\n                    items = []\n                if not array and items:\n                    all = complex.add_child(\"xsd:all\")\n                elif items:\n                    all = complex.add_child(\"xsd:sequence\")\n                for k, v in items:\n                    e = all.add_child(\"xsd:element\")\n                    e['name'] = k\n                    if array:\n                        e[:] = {'minOccurs': \"0\", 'maxOccurs': \"unbounded\"}\n                    if v in TYPE_MAP.keys():\n                        t = 'xsd:%s' % TYPE_MAP[v]\n                    elif v is None:\n                        t = 'xsd:anyType'\n                    elif isinstance(v, list):\n                        n = \"ArrayOf%s%s\" % (name, k)\n                        l = []\n                        for d in v:\n                            l.extend(d.items())\n                        parse_element(n, l, array=True, complex=True)\n                        t = \"tns:%s\" % n\n                    elif isinstance(v, dict):\n                        n = \"%s%s\" % (name, k)\n                        parse_element(n, v.items(), complex=True)\n                        t = \"tns:%s\" % n\n                    e.add_attribute('type', t)\n            parse_element(\"%s\" % method, args and args.items())\n            parse_element(\"%sResponse\" % method, returns and returns.items())\n            # create messages:\n            for m, e in ('Input', ''), ('Output', 'Response'):\n                message = wsdl.add_child('wsdl:message')\n                message['name'] = \"%s%s\" % (method, m)\n                part = message.add_child(\"wsdl:part\")\n                part[:] = {'name': 'parameters',\n                           'element': 'tns:%s%s' % (method, e)}\n        # create ports\n        portType = wsdl.add_child('wsdl:portType')\n        portType['name'] = \"%sPortType\" % self.name\n        for method, (function, returns, args, doc) in self.methods.items():\n            op = portType.add_child('wsdl:operation')\n            op['name'] = method\n            if doc:\n                op.add_child(\"wsdl:documentation\", doc)\n            input = op.add_child(\"wsdl:input\")\n            input['message'] = \"tns:%sInput\" % method\n            output = op.add_child(\"wsdl:output\")\n            output['message'] = \"tns:%sOutput\" % method\n        # create bindings\n        binding = wsdl.add_child('wsdl:binding')\n        binding['name'] = \"%sBinding\" % self.name\n        binding['type'] = \"tns:%sPortType\" % self.name\n        soapbinding = binding.add_child('soap:binding')\n        soapbinding['style'] = \"document\"\n        soapbinding['transport'] = \"http://schemas.xmlsoap.org/soap/http\"\n        for method in self.methods.keys():\n            op = binding.add_child('wsdl:operation')\n            op['name'] = method\n            soapop = op.add_child('soap:operation')\n            soapop['soapAction'] = self.action + method\n            soapop['style'] = 'document'\n            input = op.add_child(\"wsdl:input\")\n            ##input.add_attribute('name', \"%sInput\" % method)\n            soapbody = input.add_child(\"soap:body\")\n            soapbody[\"use\"] = \"literal\"\n            output = op.add_child(\"wsdl:output\")\n            ##output.add_attribute('name', \"%sOutput\" % method)\n            soapbody = output.add_child(\"soap:body\")\n            soapbody[\"use\"] = \"literal\"\n        service = wsdl.add_child('wsdl:service')\n        service[\"name\"] = \"%sService\" % self.name\n        service.add_child('wsdl:documentation', text=self.documentation)\n        port = service.add_child('wsdl:port')\n        port[\"name\"] = \"%s\" % self.name\n        port[\"binding\"] = \"tns:%sBinding\" % self.name\n        soapaddress = port.add_child('soap:address')\n        soapaddress[\"location\"] = self.location\n        return wsdl.as_xml(pretty=True)\nclass SOAPHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        \"\"\"User viewable help information and wsdl\"\"\"\n        args = self.path[1:].split(\"?\")\n        if self.path != \"/\" and args[0] not in self.server.dispatcher.methods.keys():\n            self.send_error(404, \"Method not found: %s\" % args[0])\n        else:\n            if self.path == \"/\":\n                # return wsdl if no method supplied\n                response = self.server.dispatcher.wsdl()\n            else:\n                # return supplied method help (?request or ?response messages)\n                req, res, doc = self.server.dispatcher.help(args[0])\n                if len(args) == 1 or args[1] == \"request\":\n                    response = req\n                else:\n                    response = res\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.end_headers()\n            self.wfile.write(response)\n    def do_POST(self):\n        \"\"\"SOAP POST gateway\"\"\"\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/xml\")\n        self.end_headers()\n        request = self.rfile.read(int(self.headers.getheader('content-length')))\n        response = self.server.dispatcher.dispatch(request)\n        self.wfile.write(response)\nclass WSGISOAPHandler(object):\n    def __init__(self, dispatcher):\n        self.dispatcher = dispatcher\n    def __call__(self, environ, start_response):\n        return self.handler(environ, start_response)\n    def handler(self, environ, start_response):\n        if environ['REQUEST_METHOD'] == 'GET':\n            return self.do_get(environ, start_response)\n        elif environ['REQUEST_METHOD'] == 'POST':\n            return self.do_post(environ, start_response)\n        else:\n            start_response('405 Method not allowed', [('Content-Type', 'text/plain')])\n            return ['Method not allowed']\n    def do_get(self, environ, start_response):\n        path = environ.get('PATH_INFO').lstrip('/')\n        query = environ.get('QUERY_STRING')\n        if path != \"\" and path not in self.dispatcher.methods.keys():\n            start_response('404 Not Found', [('Content-Type', 'text/plain')])\n            return [\"Method not found: %s\" % path]\n        elif path == \"\":\n            # return wsdl if no method supplied\n            response = self.dispatcher.wsdl()\n        else:\n            # return supplied method help (?request or ?response messages)\n            req, res, doc = self.dispatcher.help(path)\n            if len(query) == 0 or query == \"request\":\n                response = req\n            else:\n                response = res\n        start_response('200 OK', [('Content-Type', 'text/xml'), ('Content-Length', str(len(response)))])\n        return [response]\n    def do_post(self, environ, start_response):\nNext line of code:\n", "input": "", "context": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by the\n# Free Software Foundation; either version 3, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY\n# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n# for more details.\n\"\"\"Pythonic simple SOAP Server implementation\"\"\"\nfrom __future__ import unicode_literals\nimport sys\nimport logging\nimport re\nimport traceback\ntry:\n    from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nexcept ImportError:\n    from http.server import BaseHTTPRequestHandler, HTTPServer\nfrom . import __author__, __copyright__, __license__, __version__\nfrom .simplexml import SimpleXMLElement, TYPE_MAP, Date, Decimal\nlog = logging.getLogger(__name__)\n# Deprecated?\nNS_RX = re.compile(r'xmlns:(\\w+)=\"(.+?)\"')\nclass SoapDispatcher(object):\n    \"\"\"Simple Dispatcher for SOAP Server\"\"\"\n    def __init__(self, name, documentation='', action='', location='',\n                 namespace=None, prefix=False,\n                 soap_uri=\"http://schemas.xmlsoap.org/soap/envelope/\",\n                 soap_ns='soap',\n                 namespaces={},\n                 pretty=False,\n                 debug=False,\n                 **kwargs):\n        \"\"\"\n        :param namespace: Target namespace; xmlns=targetNamespace\n        :param prefix: Prefix for target namespace; xmlns:prefix=targetNamespace\n        :param namespaces: Specify additional namespaces; example: {'external': 'http://external.mt.moboperator'}\n        :param pretty: Prettifies generated xmls\n        :param debug: Use to add tracebacks in generated xmls.\n        Multiple namespaces\n        ===================\n        It is possible to support multiple namespaces.\n        You need to specify additional namespaces by passing `namespace` parameter.\n        >>> dispatcher = SoapDispatcher(\n        ...    name = \"MTClientWS\",\n        ...    location = \"http://localhost:8008/ws/MTClientWS\",\n        ...    action = 'http://localhost:8008/ws/MTClientWS', # SOAPAction\n        ...    namespace = \"http://external.mt.moboperator\", prefix=\"external\",\n        ...    documentation = 'moboperator MTClientWS',\n        ...    namespaces = {\n        ...        'external': 'http://external.mt.moboperator',\n        ...        'model': 'http://model.common.mt.moboperator'\n        ...    },\n        ...    ns = True)\n        Now the registered method must return node names with namespaces' prefixes.\n        >>> def _multi_ns_func(self, serviceMsisdn):\n        ...    ret = {\n        ...        'external:activateSubscriptionsReturn': [\n        ...            {'model:code': '0'},\n        ...            {'model:description': 'desc'},\n        ...        ]}\n        ...    return ret\n        Our prefixes will be changed to those used by the client.\n        \"\"\"\n        self.methods = {}\n        self.name = name\n        self.documentation = documentation\n        self.action = action  # base SoapAction\n        self.location = location\n        self.namespace = namespace  # targetNamespace\n        self.prefix = prefix\n        self.soap_ns = soap_ns\n        self.soap_uri = soap_uri\n        self.namespaces = namespaces\n        self.pretty = pretty\n        self.debug = debug\n    @staticmethod\n    def _extra_namespaces(xml, ns):\n        \"\"\"Extends xml with extra namespaces.\n        :param ns: dict with namespaceUrl:prefix pairs\n        :param xml: XML node to modify\n        \"\"\"\n        if ns:\n            _tpl = 'xmlns:%s=\"%s\"'\n            _ns_str = \" \".join([_tpl % (prefix, uri) for uri, prefix in ns.items() if uri not in xml])\n            xml = xml.replace('/>', ' ' + _ns_str + '/>')\n        return xml\n    def register_function(self, name, fn, returns=None, args=None, doc=None):\n        self.methods[name] = fn, returns, args, doc or getattr(fn, \"__doc__\", \"\")\n    def dispatch(self, xml, action=None):\n        \"\"\"Receive and process SOAP call\"\"\"\n        # default values:\n        prefix = self.prefix\n        ret = fault = None\n        soap_ns, soap_uri = self.soap_ns, self.soap_uri\n        soap_fault_code = 'VersionMismatch'\n        name = None\n        # namespaces = [('model', 'http://model.common.mt.moboperator'), ('external', 'http://external.mt.moboperator')]\n        _ns_reversed = dict(((v, k) for k, v in self.namespaces.items()))  # Switch keys-values\n        # _ns_reversed = {'http://external.mt.moboperator': 'external', 'http://model.common.mt.moboperator': 'model'}\n        try:\n            request = SimpleXMLElement(xml, namespace=self.namespace)\n            # detect soap prefix and uri (xmlns attributes of Envelope)\n            for k, v in request[:]:\n                if v in (\"http://schemas.xmlsoap.org/soap/envelope/\",\n                         \"http://www.w3.org/2003/05/soap-env\",):\n                    soap_ns = request.attributes()[k].localName\n                    soap_uri = request.attributes()[k].value\n                # If the value from attributes on Envelope is in additional namespaces\n                elif v in self.namespaces.values():\n                    _ns = request.attributes()[k].localName\n                    _uri = request.attributes()[k].value\n                    _ns_reversed[_uri] = _ns  # update with received alias\n                    # Now we change 'external' and 'model' to the received forms i.e. 'ext' and 'mod'\n                # After that we know how the client has prefixed additional namespaces\n            ns = NS_RX.findall(xml)\n            for k, v in ns:\n                if v in self.namespaces.values():\n                    _ns_reversed[v] = k\n            soap_fault_code = 'Client'\n            # parse request message and get local method\n            method = request('Body', ns=soap_uri).children()(0)\n            if action:\n                # method name = action\n                name = action[len(self.action)+1:-1]\n                prefix = self.prefix\n            if not action or not name:\n                # method name = input message name\n                name = method.get_local_name()\n                prefix = method.get_prefix()\n            log.debug('dispatch method: %s', name)\n            function, returns_types, args_types, doc = self.methods[name]\n            log.debug('returns_types %s', returns_types)\n            # de-serialize parameters (if type definitions given)\n            if args_types:\n                args = method.children().unmarshall(args_types)\n            elif args_types is None:\n                args = {'request': method}  # send raw request\n            else:\n                args = {}  # no parameters\n            soap_fault_code = 'Server'\n            # execute function\n            ret = function(**args)\n            log.debug('dispathed method returns: %s', ret)\n        except Exception:  # This shouldn't be one huge try/except\n            import sys\n            etype, evalue, etb = sys.exc_info()\n            log.error(traceback.format_exc())\n            if self.debug:\n                detail = ''.join(traceback.format_exception(etype, evalue, etb))\n                detail += '\\n\\nXML REQUEST\\n\\n' + xml\n            else:\n                detail = None\n            fault = {'faultcode': \"%s.%s\" % (soap_fault_code, etype.__name__),\n                     'faultstring': evalue,\n                     'detail': detail}\n        # build response message\n        if not prefix:\n            xml = \"\"\"<%(soap_ns)s:Envelope xmlns:%(soap_ns)s=\"%(soap_uri)s\"/>\"\"\"\n        else:\n            xml = \"\"\"<%(soap_ns)s:Envelope xmlns:%(soap_ns)s=\"%(soap_uri)s\"\n                       xmlns:%(prefix)s=\"%(namespace)s\"/>\"\"\"\n        xml %= {    # a %= {} is a shortcut for a = a % {}\n            'namespace': self.namespace,\n            'prefix': prefix,\n            'soap_ns': soap_ns,\n            'soap_uri': soap_uri\n        }\n        # Now we add extra namespaces\n        xml = SoapDispatcher._extra_namespaces(xml, _ns_reversed)\n        # Change our namespace alias to that given by the client.\n        # We put [('model', 'http://model.common.mt.moboperator'), ('external', 'http://external.mt.moboperator')]\n        # mix it with {'http://external.mt.moboperator': 'ext', 'http://model.common.mt.moboperator': 'mod'}\n        mapping = dict(((k, _ns_reversed[v]) for k, v in self.namespaces.items()))  # Switch keys-values and change value\n        # and get {'model': u'mod', 'external': u'ext'}\n        response = SimpleXMLElement(xml,\n                                    namespace=self.namespace,\n                                    namespaces_map=mapping,\n                                    prefix=prefix)\n        response['xmlns:xsi'] = \"http://www.w3.org/2001/XMLSchema-instance\"\n        response['xmlns:xsd'] = \"http://www.w3.org/2001/XMLSchema\"\n        body = response.add_child(\"%s:Body\" % soap_ns, ns=False)\n        if fault:\n            # generate a Soap Fault (with the python exception)\n            body.marshall(\"%s:Fault\" % soap_ns, fault, ns=False)\n        else:\n            # return normal value\n            res = body.add_child(\"%sResponse\" % name, ns=prefix)\n            if not prefix:\n                res['xmlns'] = self.namespace  # add target namespace\n            # serialize returned values (response) if type definition available\n            if returns_types:\n                if not isinstance(ret, dict):\n                    res.marshall(returns_types.keys()[0], ret, )\n                else:\n                    for k, v in ret.items():\n                        res.marshall(k, v)\n            elif returns_types is None:\n                # merge xmlelement returned\n                res.import_node(ret)\n            elif returns_types == {}:\n                log.warning('Given returns_types is an empty dict.')\n        return response.as_xml(pretty=self.pretty)\n    # Introspection functions:\n    def list_methods(self):\n        \"\"\"Return a list of aregistered operations\"\"\"\n        return [(method, doc) for method, (function, returns, args, doc) in self.methods.items()]\n    def help(self, method=None):\n        \"\"\"Generate sample request and response messages\"\"\"\n        (function, returns, args, doc) = self.methods[method]\n        xml = \"\"\"\n<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n<soap:Body><%(method)s xmlns=\"%(namespace)s\"/></soap:Body>\n</soap:Envelope>\"\"\" % {'method': method, 'namespace': self.namespace}\n        request = SimpleXMLElement(xml, namespace=self.namespace, prefix=self.prefix)\n        if args:\n            items = args.items()\n        elif args is None:\n            items = [('value', None)]\n        else:\n            items = []\n        for k, v in items:\n            request(method).marshall(k, v, add_comments=True, ns=False)\n        xml = \"\"\"\n<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n<soap:Body><%(method)sResponse xmlns=\"%(namespace)s\"/></soap:Body>\n</soap:Envelope>\"\"\" % {'method': method, 'namespace': self.namespace}\n        response = SimpleXMLElement(xml, namespace=self.namespace, prefix=self.prefix)\n        if returns:\n            items = returns.items()\n        elif args is None:\n            items = [('value', None)]\n        else:\n            items = []\n        for k, v in items:\n            response('%sResponse' % method).marshall(k, v, add_comments=True, ns=False)\n        return request.as_xml(pretty=True), response.as_xml(pretty=True), doc\n    def wsdl(self):\n        \"\"\"Generate Web Service Description v1.1\"\"\"\n        xml = \"\"\"<?xml version=\"1.0\"?>\n<wsdl:definitions name=\"%(name)s\"\n          targetNamespace=\"%(namespace)s\"\n          xmlns:tns=\"%(namespace)s\"\n          xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\"\n          xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n          xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <wsdl:documentation xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\">%(documentation)s</wsdl:documentation>\n    <wsdl:types>\n       <xsd:schema targetNamespace=\"%(namespace)s\"\n              elementFormDefault=\"qualified\"\n              xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n       </xsd:schema>\n    </wsdl:types>\n</wsdl:definitions>\n\"\"\" % {'namespace': self.namespace, 'name': self.name, 'documentation': self.documentation}\n        wsdl = SimpleXMLElement(xml)\n        for method, (function, returns, args, doc) in self.methods.items():\n            # create elements:\n            def parse_element(name, values, array=False, complex=False):\n                if not complex:\n                    element = wsdl('wsdl:types')('xsd:schema').add_child('xsd:element')\n                    complex = element.add_child(\"xsd:complexType\")\n                else:\n                    complex = wsdl('wsdl:types')('xsd:schema').add_child('xsd:complexType')\n                    element = complex\n                element['name'] = name\n                if values:\n                    items = values\n                elif values is None:\n                    items = [('value', None)]\n                else:\n                    items = []\n                if not array and items:\n                    all = complex.add_child(\"xsd:all\")\n                elif items:\n                    all = complex.add_child(\"xsd:sequence\")\n                for k, v in items:\n                    e = all.add_child(\"xsd:element\")\n                    e['name'] = k\n                    if array:\n                        e[:] = {'minOccurs': \"0\", 'maxOccurs': \"unbounded\"}\n                    if v in TYPE_MAP.keys():\n                        t = 'xsd:%s' % TYPE_MAP[v]\n                    elif v is None:\n                        t = 'xsd:anyType'\n                    elif isinstance(v, list):\n                        n = \"ArrayOf%s%s\" % (name, k)\n                        l = []\n                        for d in v:\n                            l.extend(d.items())\n                        parse_element(n, l, array=True, complex=True)\n                        t = \"tns:%s\" % n\n                    elif isinstance(v, dict):\n                        n = \"%s%s\" % (name, k)\n                        parse_element(n, v.items(), complex=True)\n                        t = \"tns:%s\" % n\n                    e.add_attribute('type', t)\n            parse_element(\"%s\" % method, args and args.items())\n            parse_element(\"%sResponse\" % method, returns and returns.items())\n            # create messages:\n            for m, e in ('Input', ''), ('Output', 'Response'):\n                message = wsdl.add_child('wsdl:message')\n                message['name'] = \"%s%s\" % (method, m)\n                part = message.add_child(\"wsdl:part\")\n                part[:] = {'name': 'parameters',\n                           'element': 'tns:%s%s' % (method, e)}\n        # create ports\n        portType = wsdl.add_child('wsdl:portType')\n        portType['name'] = \"%sPortType\" % self.name\n        for method, (function, returns, args, doc) in self.methods.items():\n            op = portType.add_child('wsdl:operation')\n            op['name'] = method\n            if doc:\n                op.add_child(\"wsdl:documentation\", doc)\n            input = op.add_child(\"wsdl:input\")\n            input['message'] = \"tns:%sInput\" % method\n            output = op.add_child(\"wsdl:output\")\n            output['message'] = \"tns:%sOutput\" % method\n        # create bindings\n        binding = wsdl.add_child('wsdl:binding')\n        binding['name'] = \"%sBinding\" % self.name\n        binding['type'] = \"tns:%sPortType\" % self.name\n        soapbinding = binding.add_child('soap:binding')\n        soapbinding['style'] = \"document\"\n        soapbinding['transport'] = \"http://schemas.xmlsoap.org/soap/http\"\n        for method in self.methods.keys():\n            op = binding.add_child('wsdl:operation')\n            op['name'] = method\n            soapop = op.add_child('soap:operation')\n            soapop['soapAction'] = self.action + method\n            soapop['style'] = 'document'\n            input = op.add_child(\"wsdl:input\")\n            ##input.add_attribute('name', \"%sInput\" % method)\n            soapbody = input.add_child(\"soap:body\")\n            soapbody[\"use\"] = \"literal\"\n            output = op.add_child(\"wsdl:output\")\n            ##output.add_attribute('name', \"%sOutput\" % method)\n            soapbody = output.add_child(\"soap:body\")\n            soapbody[\"use\"] = \"literal\"\n        service = wsdl.add_child('wsdl:service')\n        service[\"name\"] = \"%sService\" % self.name\n        service.add_child('wsdl:documentation', text=self.documentation)\n        port = service.add_child('wsdl:port')\n        port[\"name\"] = \"%s\" % self.name\n        port[\"binding\"] = \"tns:%sBinding\" % self.name\n        soapaddress = port.add_child('soap:address')\n        soapaddress[\"location\"] = self.location\n        return wsdl.as_xml(pretty=True)\nclass SOAPHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        \"\"\"User viewable help information and wsdl\"\"\"\n        args = self.path[1:].split(\"?\")\n        if self.path != \"/\" and args[0] not in self.server.dispatcher.methods.keys():\n            self.send_error(404, \"Method not found: %s\" % args[0])\n        else:\n            if self.path == \"/\":\n                # return wsdl if no method supplied\n                response = self.server.dispatcher.wsdl()\n            else:\n                # return supplied method help (?request or ?response messages)\n                req, res, doc = self.server.dispatcher.help(args[0])\n                if len(args) == 1 or args[1] == \"request\":\n                    response = req\n                else:\n                    response = res\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.end_headers()\n            self.wfile.write(response)\n    def do_POST(self):\n        \"\"\"SOAP POST gateway\"\"\"\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/xml\")\n        self.end_headers()\n        request = self.rfile.read(int(self.headers.getheader('content-length')))\n        response = self.server.dispatcher.dispatch(request)\n        self.wfile.write(response)\nclass WSGISOAPHandler(object):\n    def __init__(self, dispatcher):\n        self.dispatcher = dispatcher\n    def __call__(self, environ, start_response):\n        return self.handler(environ, start_response)\n    def handler(self, environ, start_response):\n        if environ['REQUEST_METHOD'] == 'GET':\n            return self.do_get(environ, start_response)\n        elif environ['REQUEST_METHOD'] == 'POST':\n            return self.do_post(environ, start_response)\n        else:\n            start_response('405 Method not allowed', [('Content-Type', 'text/plain')])\n            return ['Method not allowed']\n    def do_get(self, environ, start_response):\n        path = environ.get('PATH_INFO').lstrip('/')\n        query = environ.get('QUERY_STRING')\n        if path != \"\" and path not in self.dispatcher.methods.keys():\n            start_response('404 Not Found', [('Content-Type', 'text/plain')])\n            return [\"Method not found: %s\" % path]\n        elif path == \"\":\n            # return wsdl if no method supplied\n            response = self.dispatcher.wsdl()\n        else:\n            # return supplied method help (?request or ?response messages)\n            req, res, doc = self.dispatcher.help(path)\n            if len(query) == 0 or query == \"request\":\n                response = req\n            else:\n                response = res\n        start_response('200 OK', [('Content-Type', 'text/xml'), ('Content-Length', str(len(response)))])\n        return [response]\n    def do_post(self, environ, start_response):\n", "answers": ["        length = int(environ['CONTENT_LENGTH'])"], "pred": "Next line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code", "length": 1670, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "8ae06de3dd26783213ae72552d610c4f1518647b7898d383"}
{"prompt": "Please complete the code given below. \n# -*- coding: utf-8 -*-\n# Qt widget to implement statuses column in Turpial\n#from PyQt4 import QtCore\nfrom PyQt4.QtCore import Qt\nfrom PyQt4.QtCore import QSize\nfrom PyQt4.QtCore import QRect\nfrom PyQt4.QtCore import QLine\nfrom PyQt4.QtGui import QFont\nfrom PyQt4.QtGui import QColor\nfrom PyQt4.QtGui import QLabel\nfrom PyQt4.QtGui import QPixmap\nfrom PyQt4.QtGui import QWidget\nfrom PyQt4.QtGui import QMessageBox\nfrom PyQt4.QtGui import QTextDocument\nfrom PyQt4.QtGui import QStyledItemDelegate\nfrom PyQt4.QtGui import QVBoxLayout, QHBoxLayout\nfrom turpial.ui.lang import i18n\nfrom turpial.ui.qt.widgets import ImageButton, BarLoadIndicator\nfrom turpial.ui.qt.webview import StatusesWebView\nfrom libturpial.common import get_preview_service_from_url, unescape_list_name, OS_MAC\nfrom libturpial.common.tools import get_account_id_from, get_column_slug_from, get_protocol_from,\\\n        get_username_from, detect_os\nclass StatusesColumn(QWidget):\n    NOTIFICATION_ERROR = 'error'\n    NOTIFICATION_SUCCESS = 'success'\n    NOTIFICATION_WARNING = 'warning'\n    NOTIFICATION_INFO = 'notice'\n    def __init__(self, base, column_id, include_header=True):\n        QWidget.__init__(self)\n        self.base = base\n        self.setMinimumWidth(280)\n        self.statuses = []\n        self.conversations = {}\n        self.id_ = None\n        #self.fgcolor = \"#e3e3e3\"\n        #self.fgcolor = \"#f9a231\"\n        #self.updating = False\n        self.last_id = None\n        self.loader = BarLoadIndicator()\n        self.loader.setVisible(False)\n        self.webview = StatusesWebView(self.base, self.id_)\n        self.webview.link_clicked.connect(self.__link_clicked)\n        self.webview.hashtag_clicked.connect(self.__hashtag_clicked)\n        self.webview.profile_clicked.connect(self.__profile_clicked)\n        self.webview.cmd_clicked.connect(self.__cmd_clicked)\n        layout = QVBoxLayout()\n        layout.setSpacing(0)\n        layout.setContentsMargins(0, 0, 0, 0)\n        if include_header:\n            header = self.__build_header(column_id)\n            layout.addWidget(header)\n            layout.addWidget(self.loader)\n        layout.addWidget(self.webview, 1)\n        self.setLayout(layout)\n    def __build_header(self, column_id):\n        self.set_column_id(column_id)\n        username = get_username_from(self.account_id)\n        column_slug = get_column_slug_from(column_id)\n        column_slug = unescape_list_name(column_slug)\n        column_slug = column_slug.replace('%23', '#')\n        column_slug = column_slug.replace('%40', '@')\n        #font = QFont('Titillium Web', 18, QFont.Normal, False)\n        # This is to handle the 96dpi vs 72dpi screen resolutions on Mac vs the world\n        if detect_os() == OS_MAC:\n            font = QFont('Maven Pro Light', 25, 0, False)\n            font2 = QFont('Monda', 14, 0, False)\n        else:\n            font = QFont('Maven Pro Light', 16, QFont.Light, False)\n            font2 = QFont('Monda', 10, QFont.Light, False)\n        bg_style = \"background-color: %s; color: %s;\" % (self.base.bgcolor, self.base.fgcolor)\n        caption = QLabel(username)\n        caption.setStyleSheet(\"QLabel { %s }\" % bg_style)\n        caption.setFont(font)\n        caption2 = QLabel(column_slug)\n        caption2.setStyleSheet(\"QLabel { %s }\" % bg_style)\n        caption2.setFont(font2)\n        caption2.setAlignment(Qt.AlignLeft | Qt.AlignBottom)\n        caption_box = QHBoxLayout()\n        caption_box.setSpacing(8)\n        caption_box.addWidget(caption)\n        caption_box.addWidget(caption2)\n        caption_box.addStretch(1)\n        close_button = ImageButton(self.base, 'action-delete-shadowed.png', i18n.get('delete_column'))\n        close_button.clicked.connect(self.__delete_column)\n        header_layout = QHBoxLayout()\n        header_layout.addLayout(caption_box, 1)\n        header_layout.addWidget(close_button)\n        header = QWidget()\n        header.setStyleSheet(\"QWidget { %s }\" % bg_style)\n        header.setLayout(header_layout)\n        return header\n    def __delete_column(self):\n        self.base.core.delete_column(self.id_)\n    def __link_clicked(self, url):\n        url = str(url)\n        preview_service = get_preview_service_from_url(url)\n        self.base.open_url(url)\n    def __hashtag_clicked(self, hashtag):\n        self.base.add_search_column(self.account_id, str(hashtag))\n    def __profile_clicked(self, username):\n        self.base.show_profile_dialog(self.account_id, str(username))\n    def __cmd_clicked(self, url):\n        status_id = str(url.split(':')[1])\n        cmd = url.split(':')[0]\n        status = None\n        try:\n            print 'Seeking for status in self array'\n            for status_ in self.statuses:\n                if status_.id_ == status_id:\n                    status = status_\n                    break\n            if status is None:\n                raise KeyError\n        except KeyError:\n            print 'Seeking for status in conversations array'\n            for status_root, statuses in self.conversations.iteritems():\n                for item in statuses:\n                    if item.id_ == status_id:\n                        status = item\n                        break\n                if status is not None:\n                    break\n        if status is None:\n            self.notify_error(status_id, i18n.get('try_again'))\n        if cmd == 'reply':\n            self.__reply_status(status)\n        elif cmd == 'quote':\n            self.__quote_status(status)\n        elif cmd == 'repeat':\n            self.__repeat_status(status)\n        elif cmd == 'delete':\n            self.__delete_status(status)\n        elif cmd == 'favorite':\n            self.__mark_status_as_favorite(status)\n        elif cmd == 'unfavorite':\n            self.__unmark_status_as_favorite(status)\n        elif cmd == 'delete_direct':\n            self.__delete_direct_message(status)\n        elif cmd == 'reply_direct':\n            self.__reply_direct_message(status)\n        elif cmd == 'view_conversation':\n            self.__view_conversation(status)\n        elif cmd == 'hide_conversation':\n            self.__hide_conversation(status)\n        elif cmd == 'show_avatar':\n            self.__show_avatar(status)\n    def __reply_status(self, status):\n        self.base.show_update_box_for_reply(self.account_id, status)\n    def __quote_status(self, status):\n        self.base.show_update_box_for_quote(self.account_id, status)\n    def __repeat_status(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_retweet'),\n            i18n.get('do_you_want_to_retweet_status'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.repeat_status(self.id_, self.account_id, status)\n    def __delete_status(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_delete'),\n            i18n.get('do_you_want_to_delete_status'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.delete_status(self.id_, self.account_id, status)\n    def __delete_direct_message(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_delete'),\n            i18n.get('do_you_want_to_delete_direct_message'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.delete_direct_message(self.id_, self.account_id, status)\n    def __reply_direct_message(self, status):\n        self.base.show_update_box_for_reply_direct(self.account_id, status)\n    def __mark_status_as_favorite(self, status):\n        self.lock_status(status.id_)\n        self.base.mark_status_as_favorite(self.id_, self.account_id, status)\n    def __unmark_status_as_favorite(self, status):\n        self.lock_status(status.id_)\n        self.base.unmark_status_as_favorite(self.id_, self.account_id, status)\n    def __view_conversation(self, status):\n        self.webview.view_conversation(status.id_)\n        self.base.get_conversation(self.account_id, status, self.id_, status.id_)\n    def __hide_conversation(self, status):\n        del self.conversations[status.id_]\n        self.webview.clear_conversation(status.id_)\n    def __show_avatar(self, status):\n        self.base.show_profile_image(self.account_id, status.username)\n    def __set_last_status_id(self, statuses):\n        if statuses[0].repeated_by:\n            self.last_id = statuses[0].original_status_id\n        else:\n            self.last_id = statuses[0].id_\n    def set_column_id(self, column_id):\n        self.id_ = column_id\n        self.account_id = get_account_id_from(column_id)\n        self.protocol_id = get_protocol_from(self.account_id)\n        self.webview.column_id = column_id\n    def clear(self):\n        self.webview.clear()\n    def start_updating(self):\n        self.loader.setVisible(True)\n        return self.last_id\n    def stop_updating(self):\n        self.loader.setVisible(False)\n    def update_timestamps(self):\n        self.webview.sync_timestamps(self.statuses)\n    def update_statuses(self, statuses):\n        self.__set_last_status_id(statuses)\n        self.update_timestamps()\n        self.webview.update_statuses(statuses)\n        # Filter repeated statuses\n        unique_statuses = [s1 for s1 in statuses if s1 not in self.statuses]\n        # Remove old conversations\n        to_remove = self.statuses[-(len(unique_statuses)):]\n        self.statuses = statuses + self.statuses[: -(len(unique_statuses))]\n        for status in to_remove:\n            if self.conversations.has_key(status.id_):\n                del self.conversations[status.id_]\n    def update_conversation(self, status, status_root_id):\n        status_root_id = str(status_root_id)\n        self.webview.update_conversation(status, status_root_id)\n        if status_root_id in self.conversations:\n            self.conversations[status_root_id].append(status)\n        else:\n            self.conversations[status_root_id] = [status]\n    def error_in_conversation(self, status_root_id):\n        self.webview.clear_conversation(status_root_id)\n    def mark_status_as_favorite(self, status_id):\n        mark = \"setFavorite('%s')\" % status_id\n        self.webview.execute_javascript(mark)\n    def unmark_status_as_favorite(self, status_id):\n        mark = \"unsetFavorite('%s');\" % status_id\n        self.webview.execute_javascript(mark)\n    def mark_status_as_repeated(self, status_id):\nNext line of code:\n", "input": "", "context": "# -*- coding: utf-8 -*-\n# Qt widget to implement statuses column in Turpial\n#from PyQt4 import QtCore\nfrom PyQt4.QtCore import Qt\nfrom PyQt4.QtCore import QSize\nfrom PyQt4.QtCore import QRect\nfrom PyQt4.QtCore import QLine\nfrom PyQt4.QtGui import QFont\nfrom PyQt4.QtGui import QColor\nfrom PyQt4.QtGui import QLabel\nfrom PyQt4.QtGui import QPixmap\nfrom PyQt4.QtGui import QWidget\nfrom PyQt4.QtGui import QMessageBox\nfrom PyQt4.QtGui import QTextDocument\nfrom PyQt4.QtGui import QStyledItemDelegate\nfrom PyQt4.QtGui import QVBoxLayout, QHBoxLayout\nfrom turpial.ui.lang import i18n\nfrom turpial.ui.qt.widgets import ImageButton, BarLoadIndicator\nfrom turpial.ui.qt.webview import StatusesWebView\nfrom libturpial.common import get_preview_service_from_url, unescape_list_name, OS_MAC\nfrom libturpial.common.tools import get_account_id_from, get_column_slug_from, get_protocol_from,\\\n        get_username_from, detect_os\nclass StatusesColumn(QWidget):\n    NOTIFICATION_ERROR = 'error'\n    NOTIFICATION_SUCCESS = 'success'\n    NOTIFICATION_WARNING = 'warning'\n    NOTIFICATION_INFO = 'notice'\n    def __init__(self, base, column_id, include_header=True):\n        QWidget.__init__(self)\n        self.base = base\n        self.setMinimumWidth(280)\n        self.statuses = []\n        self.conversations = {}\n        self.id_ = None\n        #self.fgcolor = \"#e3e3e3\"\n        #self.fgcolor = \"#f9a231\"\n        #self.updating = False\n        self.last_id = None\n        self.loader = BarLoadIndicator()\n        self.loader.setVisible(False)\n        self.webview = StatusesWebView(self.base, self.id_)\n        self.webview.link_clicked.connect(self.__link_clicked)\n        self.webview.hashtag_clicked.connect(self.__hashtag_clicked)\n        self.webview.profile_clicked.connect(self.__profile_clicked)\n        self.webview.cmd_clicked.connect(self.__cmd_clicked)\n        layout = QVBoxLayout()\n        layout.setSpacing(0)\n        layout.setContentsMargins(0, 0, 0, 0)\n        if include_header:\n            header = self.__build_header(column_id)\n            layout.addWidget(header)\n            layout.addWidget(self.loader)\n        layout.addWidget(self.webview, 1)\n        self.setLayout(layout)\n    def __build_header(self, column_id):\n        self.set_column_id(column_id)\n        username = get_username_from(self.account_id)\n        column_slug = get_column_slug_from(column_id)\n        column_slug = unescape_list_name(column_slug)\n        column_slug = column_slug.replace('%23', '#')\n        column_slug = column_slug.replace('%40', '@')\n        #font = QFont('Titillium Web', 18, QFont.Normal, False)\n        # This is to handle the 96dpi vs 72dpi screen resolutions on Mac vs the world\n        if detect_os() == OS_MAC:\n            font = QFont('Maven Pro Light', 25, 0, False)\n            font2 = QFont('Monda', 14, 0, False)\n        else:\n            font = QFont('Maven Pro Light', 16, QFont.Light, False)\n            font2 = QFont('Monda', 10, QFont.Light, False)\n        bg_style = \"background-color: %s; color: %s;\" % (self.base.bgcolor, self.base.fgcolor)\n        caption = QLabel(username)\n        caption.setStyleSheet(\"QLabel { %s }\" % bg_style)\n        caption.setFont(font)\n        caption2 = QLabel(column_slug)\n        caption2.setStyleSheet(\"QLabel { %s }\" % bg_style)\n        caption2.setFont(font2)\n        caption2.setAlignment(Qt.AlignLeft | Qt.AlignBottom)\n        caption_box = QHBoxLayout()\n        caption_box.setSpacing(8)\n        caption_box.addWidget(caption)\n        caption_box.addWidget(caption2)\n        caption_box.addStretch(1)\n        close_button = ImageButton(self.base, 'action-delete-shadowed.png', i18n.get('delete_column'))\n        close_button.clicked.connect(self.__delete_column)\n        header_layout = QHBoxLayout()\n        header_layout.addLayout(caption_box, 1)\n        header_layout.addWidget(close_button)\n        header = QWidget()\n        header.setStyleSheet(\"QWidget { %s }\" % bg_style)\n        header.setLayout(header_layout)\n        return header\n    def __delete_column(self):\n        self.base.core.delete_column(self.id_)\n    def __link_clicked(self, url):\n        url = str(url)\n        preview_service = get_preview_service_from_url(url)\n        self.base.open_url(url)\n    def __hashtag_clicked(self, hashtag):\n        self.base.add_search_column(self.account_id, str(hashtag))\n    def __profile_clicked(self, username):\n        self.base.show_profile_dialog(self.account_id, str(username))\n    def __cmd_clicked(self, url):\n        status_id = str(url.split(':')[1])\n        cmd = url.split(':')[0]\n        status = None\n        try:\n            print 'Seeking for status in self array'\n            for status_ in self.statuses:\n                if status_.id_ == status_id:\n                    status = status_\n                    break\n            if status is None:\n                raise KeyError\n        except KeyError:\n            print 'Seeking for status in conversations array'\n            for status_root, statuses in self.conversations.iteritems():\n                for item in statuses:\n                    if item.id_ == status_id:\n                        status = item\n                        break\n                if status is not None:\n                    break\n        if status is None:\n            self.notify_error(status_id, i18n.get('try_again'))\n        if cmd == 'reply':\n            self.__reply_status(status)\n        elif cmd == 'quote':\n            self.__quote_status(status)\n        elif cmd == 'repeat':\n            self.__repeat_status(status)\n        elif cmd == 'delete':\n            self.__delete_status(status)\n        elif cmd == 'favorite':\n            self.__mark_status_as_favorite(status)\n        elif cmd == 'unfavorite':\n            self.__unmark_status_as_favorite(status)\n        elif cmd == 'delete_direct':\n            self.__delete_direct_message(status)\n        elif cmd == 'reply_direct':\n            self.__reply_direct_message(status)\n        elif cmd == 'view_conversation':\n            self.__view_conversation(status)\n        elif cmd == 'hide_conversation':\n            self.__hide_conversation(status)\n        elif cmd == 'show_avatar':\n            self.__show_avatar(status)\n    def __reply_status(self, status):\n        self.base.show_update_box_for_reply(self.account_id, status)\n    def __quote_status(self, status):\n        self.base.show_update_box_for_quote(self.account_id, status)\n    def __repeat_status(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_retweet'),\n            i18n.get('do_you_want_to_retweet_status'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.repeat_status(self.id_, self.account_id, status)\n    def __delete_status(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_delete'),\n            i18n.get('do_you_want_to_delete_status'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.delete_status(self.id_, self.account_id, status)\n    def __delete_direct_message(self, status):\n        confirmation = self.base.show_confirmation_message(i18n.get('confirm_delete'),\n            i18n.get('do_you_want_to_delete_direct_message'))\n        if confirmation:\n            self.lock_status(status.id_)\n            self.base.delete_direct_message(self.id_, self.account_id, status)\n    def __reply_direct_message(self, status):\n        self.base.show_update_box_for_reply_direct(self.account_id, status)\n    def __mark_status_as_favorite(self, status):\n        self.lock_status(status.id_)\n        self.base.mark_status_as_favorite(self.id_, self.account_id, status)\n    def __unmark_status_as_favorite(self, status):\n        self.lock_status(status.id_)\n        self.base.unmark_status_as_favorite(self.id_, self.account_id, status)\n    def __view_conversation(self, status):\n        self.webview.view_conversation(status.id_)\n        self.base.get_conversation(self.account_id, status, self.id_, status.id_)\n    def __hide_conversation(self, status):\n        del self.conversations[status.id_]\n        self.webview.clear_conversation(status.id_)\n    def __show_avatar(self, status):\n        self.base.show_profile_image(self.account_id, status.username)\n    def __set_last_status_id(self, statuses):\n        if statuses[0].repeated_by:\n            self.last_id = statuses[0].original_status_id\n        else:\n            self.last_id = statuses[0].id_\n    def set_column_id(self, column_id):\n        self.id_ = column_id\n        self.account_id = get_account_id_from(column_id)\n        self.protocol_id = get_protocol_from(self.account_id)\n        self.webview.column_id = column_id\n    def clear(self):\n        self.webview.clear()\n    def start_updating(self):\n        self.loader.setVisible(True)\n        return self.last_id\n    def stop_updating(self):\n        self.loader.setVisible(False)\n    def update_timestamps(self):\n        self.webview.sync_timestamps(self.statuses)\n    def update_statuses(self, statuses):\n        self.__set_last_status_id(statuses)\n        self.update_timestamps()\n        self.webview.update_statuses(statuses)\n        # Filter repeated statuses\n        unique_statuses = [s1 for s1 in statuses if s1 not in self.statuses]\n        # Remove old conversations\n        to_remove = self.statuses[-(len(unique_statuses)):]\n        self.statuses = statuses + self.statuses[: -(len(unique_statuses))]\n        for status in to_remove:\n            if self.conversations.has_key(status.id_):\n                del self.conversations[status.id_]\n    def update_conversation(self, status, status_root_id):\n        status_root_id = str(status_root_id)\n        self.webview.update_conversation(status, status_root_id)\n        if status_root_id in self.conversations:\n            self.conversations[status_root_id].append(status)\n        else:\n            self.conversations[status_root_id] = [status]\n    def error_in_conversation(self, status_root_id):\n        self.webview.clear_conversation(status_root_id)\n    def mark_status_as_favorite(self, status_id):\n        mark = \"setFavorite('%s')\" % status_id\n        self.webview.execute_javascript(mark)\n    def unmark_status_as_favorite(self, status_id):\n        mark = \"unsetFavorite('%s');\" % status_id\n        self.webview.execute_javascript(mark)\n    def mark_status_as_repeated(self, status_id):\n", "answers": ["        mark = \"setRepeated('%s');\" % status_id"], "pred": "self.webview.clear_conversation(status_id):\nself.mark_status_as_repeated(self, status_id):\nself.webview.execute_javascript(mark)\n    self.webview.mark_status_as_repeated(self, status_id):\n    self.webview.mark_status_as_repeated(self, status_id):\n    self.webview.mark_status_as_re", "length": 686, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "14de6afab15eabeb4fec480f9d6b4db78e93e0493851cc35"}
{"prompt": "Please complete the code given below. \nimport pprint\nimport select\nimport traceback\nfrom multiprocessing import Pipe, Process\nfrom beget_msgpack import Controller\nfrom base.exc import Error\nfrom lib.FileManager import FM\nfrom lib.FileManager.OperationStatus import OperationStatus\nfrom lib.FileManager.workers.sftp.analyzeSize import AnalyzeSize\nfrom lib.FileManager.workers.sftp.chmodFiles import ChmodFiles\nfrom lib.FileManager.workers.sftp.copyBetweenSftp import CopyBetweenSftp\nfrom lib.FileManager.workers.sftp.copyFromSftp import CopyFromSftp\nfrom lib.FileManager.workers.sftp.copyFromSftpToFtp import CopyFromSftpToFtp\nfrom lib.FileManager.workers.sftp.copyFromSftpToWebDav import CopyFromSftpToWebDav\nfrom lib.FileManager.workers.sftp.copySftp import CopySftp\nfrom lib.FileManager.workers.sftp.createArchive import CreateArchive\nfrom lib.FileManager.workers.sftp.createConnection import CreateConnection\nfrom lib.FileManager.workers.sftp.createCopy import CreateCopy\nfrom lib.FileManager.workers.sftp.downloadFiles import DownloadFiles\nfrom lib.FileManager.workers.sftp.extractArchive import ExtractArchive\nfrom lib.FileManager.workers.sftp.findFiles import FindFiles\nfrom lib.FileManager.workers.sftp.findText import FindText\nfrom lib.FileManager.workers.sftp.listFiles import ListFiles\nfrom lib.FileManager.workers.sftp.makeDir import MakeDir\nfrom lib.FileManager.workers.sftp.moveBetweenSftp import MoveBetweenSftp\nfrom lib.FileManager.workers.sftp.moveFromSftp import MoveFromSftp\nfrom lib.FileManager.workers.sftp.moveFromSftpToFtp import MoveFromSftpToFtp\nfrom lib.FileManager.workers.sftp.moveFromSftpToWebDav import MoveFromSftpToWebDav\nfrom lib.FileManager.workers.sftp.moveSftp import MoveSftp\nfrom lib.FileManager.workers.sftp.newFile import NewFile\nfrom lib.FileManager.workers.sftp.readFile import ReadFile\nfrom lib.FileManager.workers.sftp.readImages import ReadImages\nfrom lib.FileManager.workers.sftp.removeConnection import RemoveConnection\nfrom lib.FileManager.workers.sftp.removeFiles import RemoveFiles\nfrom lib.FileManager.workers.sftp.renameFile import RenameFile\nfrom lib.FileManager.workers.sftp.updateConnection import UpdateConnection\nfrom lib.FileManager.workers.sftp.uploadFile import UploadFile\nfrom lib.FileManager.workers.sftp.writeFile import WriteFile\nfrom misc.helpers import byte_to_unicode_list, byte_to_unicode_dict\nclass SftpController(Controller):\n    def action_create_connection(self, login, password, host, port, sftp_user, sftp_password):\n        return self.get_process_data(CreateConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"host\": host.decode('UTF-8'),\n            \"port\": port,\n            \"sftp_user\": sftp_user.decode('UTF-8'),\n            \"sftp_password\": sftp_password.decode('UTF-8')\n        })\n    def action_edit_connection(self, login, password, connection_id, host, port, sftp_user, sftp_password):\n        return self.get_process_data(UpdateConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"connection_id\": connection_id,\n            \"host\": host.decode('UTF-8'),\n            \"port\": port,\n            \"sftp_user\": sftp_user.decode('UTF-8'),\n            \"sftp_password\": sftp_password.decode('UTF-8')\n        })\n    def action_remove_connection(self, login, password, connection_id):\n        return self.get_process_data(RemoveConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"connection_id\": connection_id\n        })\n    def action_list_files(self, login, password, path, session):\n        return self.get_process_data(ListFiles, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_make_dir(self, login, password, path, session):\n        return self.get_process_data(MakeDir, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_new_file(self, login, password, path, session):\n        return self.get_process_data(NewFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_read_file(self, login, password, path, encoding, session):\n        if encoding is None:\n            encoding = b''\n        return self.get_process_data(ReadFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session),\n            \"encoding\": encoding.decode('UTF-8')\n        })\n    def action_write_file(self, login, password, path, content, encoding, session):\n        return self.get_process_data(WriteFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"content\": content.decode('UTF-8'),\n            \"encoding\": encoding.decode('UTF-8'),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_rename_file(self, login, password, source_path, target_path, session):\n        return self.get_process_data(RenameFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"source_path\": source_path.decode(\"UTF-8\"),\n            \"target_path\": target_path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_download_files(self, login, password, paths, mode, session):\n        return self.get_process_data(DownloadFiles, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"paths\": byte_to_unicode_list(paths),\n            \"mode\": mode.decode('UTF-8'),\n            \"session\": byte_to_unicode_dict(session)\n        }, timeout=7200)\n    def action_read_images(self, login, password, paths, session):\n        return self.get_process_data(ReadImages, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"paths\": byte_to_unicode_list(paths),\n            \"session\": byte_to_unicode_dict(session)\n        }, timeout=7200)\n    def action_upload_file(self, login, password, path, file_path, overwrite, session):\n        params = {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode('UTF-8'),\n            \"file_path\": file_path.decode('UTF-8'),\n            \"overwrite\": overwrite,\n            \"session\": byte_to_unicode_dict(session),\n        }\n        return self.get_process_data(UploadFile, params, timeout=7200)\n    @staticmethod\n    def run_subprocess(logger, worker_object, status_id, name, params):\n        logger.info(\"FM call SFTP long action %s %s %s\" % (name, pprint.pformat(status_id), pprint.pformat(params.get(\"login\"))))\n        def async_check_operation(op_status_id):\n            operation = OperationStatus.load(op_status_id)\n            logger.info(\"Operation id='%s' status is '%s'\" % (str(status_id), operation.status))\n            if operation.status != OperationStatus.STATUS_WAIT:\n                raise Error(\"Operation status is not wait - aborting\")\n        def async_on_error(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_error()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': status_id,\n                'status': 'error',\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_success(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_success()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_SUCCESS,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_running(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_running()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_RUNNING,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_abort(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_abort()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_ABORT,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_finish(worker_process, op_status_id, pid=None, pname=None):\n            logger.info(\"Process on_finish()\")\n            logger.info(\"Process exit code %s info = %s\", str(process.exitcode), pprint.pformat(process))\n            if worker_process.exitcode < 0:\n                async_on_abort(status_id, pid=pid, pname=pname)\n            elif worker_process.exitcode > 0:\n                async_on_error(op_status_id, pid=pid, pname=pname)\n        try:\n            async_check_operation(status_id)\n            kwargs = {\n                \"name\": name,\n                \"status_id\": status_id,\n                \"logger\": logger,\n                \"on_running\": async_on_running,\n                \"on_abort\": async_on_abort,\n                \"on_error\": async_on_error,\n                \"on_success\": async_on_success\n            }\n            kwargs.update(params)\n            process = worker_object(**kwargs)\n            process.start()\n            process.join()\n            async_on_finish(process, status_id, pid=process.pid, pname=process.name)\n        except Exception as e:\n            result = {\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            async_on_error(status_id, result)\n    def action_remove_files(self, login, password, status_id, paths, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker remove_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, RemoveFiles, status_id.decode('UTF-8'), FM.Action.REMOVE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"paths\": byte_to_unicode_list(paths),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_analyze_size(self, login, password, status_id, path, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker analyze_size %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, AnalyzeSize, status_id.decode('UTF-8'), FM.Action.ANALYZE_SIZE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"path\": path.decode('UTF-8'),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_chmod_files(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker chmod_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, ChmodFiles, status_id.decode('UTF-8'), FM.Action.CHMOD, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_find_text(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker find_text %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, FindText, status_id.decode('UTF-8'), FM.Action.SEARCH_TEXT, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_find_files(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker find_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, FindFiles, status_id.decode('UTF-8'), FM.Action.SEARCH_FILES, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_create_archive(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker create_archive %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, CreateArchive, status_id.decode('UTF-8'), FM.Action.CREATE_ARCHIVE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\nNext line of code:\n", "input": "", "context": "import pprint\nimport select\nimport traceback\nfrom multiprocessing import Pipe, Process\nfrom beget_msgpack import Controller\nfrom base.exc import Error\nfrom lib.FileManager import FM\nfrom lib.FileManager.OperationStatus import OperationStatus\nfrom lib.FileManager.workers.sftp.analyzeSize import AnalyzeSize\nfrom lib.FileManager.workers.sftp.chmodFiles import ChmodFiles\nfrom lib.FileManager.workers.sftp.copyBetweenSftp import CopyBetweenSftp\nfrom lib.FileManager.workers.sftp.copyFromSftp import CopyFromSftp\nfrom lib.FileManager.workers.sftp.copyFromSftpToFtp import CopyFromSftpToFtp\nfrom lib.FileManager.workers.sftp.copyFromSftpToWebDav import CopyFromSftpToWebDav\nfrom lib.FileManager.workers.sftp.copySftp import CopySftp\nfrom lib.FileManager.workers.sftp.createArchive import CreateArchive\nfrom lib.FileManager.workers.sftp.createConnection import CreateConnection\nfrom lib.FileManager.workers.sftp.createCopy import CreateCopy\nfrom lib.FileManager.workers.sftp.downloadFiles import DownloadFiles\nfrom lib.FileManager.workers.sftp.extractArchive import ExtractArchive\nfrom lib.FileManager.workers.sftp.findFiles import FindFiles\nfrom lib.FileManager.workers.sftp.findText import FindText\nfrom lib.FileManager.workers.sftp.listFiles import ListFiles\nfrom lib.FileManager.workers.sftp.makeDir import MakeDir\nfrom lib.FileManager.workers.sftp.moveBetweenSftp import MoveBetweenSftp\nfrom lib.FileManager.workers.sftp.moveFromSftp import MoveFromSftp\nfrom lib.FileManager.workers.sftp.moveFromSftpToFtp import MoveFromSftpToFtp\nfrom lib.FileManager.workers.sftp.moveFromSftpToWebDav import MoveFromSftpToWebDav\nfrom lib.FileManager.workers.sftp.moveSftp import MoveSftp\nfrom lib.FileManager.workers.sftp.newFile import NewFile\nfrom lib.FileManager.workers.sftp.readFile import ReadFile\nfrom lib.FileManager.workers.sftp.readImages import ReadImages\nfrom lib.FileManager.workers.sftp.removeConnection import RemoveConnection\nfrom lib.FileManager.workers.sftp.removeFiles import RemoveFiles\nfrom lib.FileManager.workers.sftp.renameFile import RenameFile\nfrom lib.FileManager.workers.sftp.updateConnection import UpdateConnection\nfrom lib.FileManager.workers.sftp.uploadFile import UploadFile\nfrom lib.FileManager.workers.sftp.writeFile import WriteFile\nfrom misc.helpers import byte_to_unicode_list, byte_to_unicode_dict\nclass SftpController(Controller):\n    def action_create_connection(self, login, password, host, port, sftp_user, sftp_password):\n        return self.get_process_data(CreateConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"host\": host.decode('UTF-8'),\n            \"port\": port,\n            \"sftp_user\": sftp_user.decode('UTF-8'),\n            \"sftp_password\": sftp_password.decode('UTF-8')\n        })\n    def action_edit_connection(self, login, password, connection_id, host, port, sftp_user, sftp_password):\n        return self.get_process_data(UpdateConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"connection_id\": connection_id,\n            \"host\": host.decode('UTF-8'),\n            \"port\": port,\n            \"sftp_user\": sftp_user.decode('UTF-8'),\n            \"sftp_password\": sftp_password.decode('UTF-8')\n        })\n    def action_remove_connection(self, login, password, connection_id):\n        return self.get_process_data(RemoveConnection, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"connection_id\": connection_id\n        })\n    def action_list_files(self, login, password, path, session):\n        return self.get_process_data(ListFiles, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_make_dir(self, login, password, path, session):\n        return self.get_process_data(MakeDir, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_new_file(self, login, password, path, session):\n        return self.get_process_data(NewFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_read_file(self, login, password, path, encoding, session):\n        if encoding is None:\n            encoding = b''\n        return self.get_process_data(ReadFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session),\n            \"encoding\": encoding.decode('UTF-8')\n        })\n    def action_write_file(self, login, password, path, content, encoding, session):\n        return self.get_process_data(WriteFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode(\"UTF-8\"),\n            \"content\": content.decode('UTF-8'),\n            \"encoding\": encoding.decode('UTF-8'),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_rename_file(self, login, password, source_path, target_path, session):\n        return self.get_process_data(RenameFile, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"source_path\": source_path.decode(\"UTF-8\"),\n            \"target_path\": target_path.decode(\"UTF-8\"),\n            \"session\": byte_to_unicode_dict(session)\n        })\n    def action_download_files(self, login, password, paths, mode, session):\n        return self.get_process_data(DownloadFiles, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"paths\": byte_to_unicode_list(paths),\n            \"mode\": mode.decode('UTF-8'),\n            \"session\": byte_to_unicode_dict(session)\n        }, timeout=7200)\n    def action_read_images(self, login, password, paths, session):\n        return self.get_process_data(ReadImages, {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"paths\": byte_to_unicode_list(paths),\n            \"session\": byte_to_unicode_dict(session)\n        }, timeout=7200)\n    def action_upload_file(self, login, password, path, file_path, overwrite, session):\n        params = {\n            \"login\": login.decode('UTF-8'),\n            \"password\": password.decode('UTF-8'),\n            \"path\": path.decode('UTF-8'),\n            \"file_path\": file_path.decode('UTF-8'),\n            \"overwrite\": overwrite,\n            \"session\": byte_to_unicode_dict(session),\n        }\n        return self.get_process_data(UploadFile, params, timeout=7200)\n    @staticmethod\n    def run_subprocess(logger, worker_object, status_id, name, params):\n        logger.info(\"FM call SFTP long action %s %s %s\" % (name, pprint.pformat(status_id), pprint.pformat(params.get(\"login\"))))\n        def async_check_operation(op_status_id):\n            operation = OperationStatus.load(op_status_id)\n            logger.info(\"Operation id='%s' status is '%s'\" % (str(status_id), operation.status))\n            if operation.status != OperationStatus.STATUS_WAIT:\n                raise Error(\"Operation status is not wait - aborting\")\n        def async_on_error(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_error()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': status_id,\n                'status': 'error',\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_success(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_success()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_SUCCESS,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_running(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_running()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_RUNNING,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_abort(op_status_id, data=None, progress=None, pid=None, pname=None):\n            logger.info(\"Process on_abort()\")\n            operation = OperationStatus.load(op_status_id)\n            data = {\n                'id': op_status_id,\n                'status': OperationStatus.STATUS_ABORT,\n                'data': data,\n                'progress': progress,\n                'pid': pid,\n                'pname': pname\n            }\n            operation.set_attributes(data)\n            operation.save()\n        def async_on_finish(worker_process, op_status_id, pid=None, pname=None):\n            logger.info(\"Process on_finish()\")\n            logger.info(\"Process exit code %s info = %s\", str(process.exitcode), pprint.pformat(process))\n            if worker_process.exitcode < 0:\n                async_on_abort(status_id, pid=pid, pname=pname)\n            elif worker_process.exitcode > 0:\n                async_on_error(op_status_id, pid=pid, pname=pname)\n        try:\n            async_check_operation(status_id)\n            kwargs = {\n                \"name\": name,\n                \"status_id\": status_id,\n                \"logger\": logger,\n                \"on_running\": async_on_running,\n                \"on_abort\": async_on_abort,\n                \"on_error\": async_on_error,\n                \"on_success\": async_on_success\n            }\n            kwargs.update(params)\n            process = worker_object(**kwargs)\n            process.start()\n            process.join()\n            async_on_finish(process, status_id, pid=process.pid, pname=process.name)\n        except Exception as e:\n            result = {\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            async_on_error(status_id, result)\n    def action_remove_files(self, login, password, status_id, paths, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker remove_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, RemoveFiles, status_id.decode('UTF-8'), FM.Action.REMOVE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"paths\": byte_to_unicode_list(paths),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_analyze_size(self, login, password, status_id, path, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker analyze_size %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, AnalyzeSize, status_id.decode('UTF-8'), FM.Action.ANALYZE_SIZE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"path\": path.decode('UTF-8'),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_chmod_files(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker chmod_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, ChmodFiles, status_id.decode('UTF-8'), FM.Action.CHMOD, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_find_text(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker find_text %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, FindText, status_id.decode('UTF-8'), FM.Action.SEARCH_TEXT, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_find_files(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker find_files %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, FindFiles, status_id.decode('UTF-8'), FM.Action.SEARCH_FILES, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n            return {\"error\": False}\n        except Exception as e:\n            result = {\n                \"error\": True,\n                \"message\": str(e),\n                \"traceback\": traceback.format_exc()\n            }\n            return result\n    def action_create_archive(self, login, password, status_id, params, session):\n        try:\n            self.logger.info(\"FM starting subprocess worker create_archive %s %s\", pprint.pformat(status_id),\n                             pprint.pformat(login))\n            p = Process(target=self.run_subprocess,\n                        args=(self.logger, CreateArchive, status_id.decode('UTF-8'), FM.Action.CREATE_ARCHIVE, {\n                            \"login\": login.decode('UTF-8'),\n                            \"password\": password.decode('UTF-8'),\n                            \"params\": byte_to_unicode_dict(params),\n                            \"session\": byte_to_unicode_dict(session)\n                        }))\n            p.start()\n", "answers": ["            return {\"error\": False}"], "pred": "    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n", "length": 958, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "1712603d3736689b03586a52e0f51eedd1a2bccd03217fde"}
{"prompt": "Please complete the code given below. \n//\n// ZoneIdentityPermissionTest.cs - NUnit Test Cases for ZoneIdentityPermission\n//\n// Author:\n//\tSebastien Pouliot  <sebastien@ximian.com>\n//\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\nusing NUnit.Framework;\nusing System;\nusing System.Security;\nusing System.Security.Permissions;\nnamespace MonoTests.System.Security.Permissions {\n\t[TestFixture]\n\tpublic class ZoneIdentityPermissionTest\t{\n\t\t[Test]\n\t\tpublic void PermissionStateNone ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.None);\n\t\t\tAssert.AreEqual (SecurityZone.NoZone, zip.SecurityZone);\n\t\t}\n#if NET_2_0\n\t\t[Test]\n\t\t[Category (\"NotWorking\")]\n\t\tpublic void PermissionStateUnrestricted ()\n\t\t{\n\t\t\t// In 2.0 Unrestricted are permitted for identity permissions\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.Unrestricted);\n\t\t\tAssert.AreEqual (SecurityZone.NoZone, zip.SecurityZone);\n\t\t\tSecurityElement se = zip.ToXml ();\n\t\t\tAssert.AreEqual (5, se.Children.Count, \"Count\");\n\t\t\t// and they aren't equals to None\n\t\t\tAssert.IsFalse (zip.Equals (new ZoneIdentityPermission (PermissionState.None)));\n\t\t}\n#else\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void PermissionStateUnrestricted ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.Unrestricted);\n\t\t}\n#endif\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void PermissionStateInvalid ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission ((PermissionState)2);\n\t\t}\n\t\tprivate bool Same (ZoneIdentityPermission zip1, ZoneIdentityPermission zip2)\n\t\t{\n#if NET_2_0\n\t\t\treturn zip1.Equals (zip2);\n#else\n\t\t\treturn (zip1.SecurityZone == zip2.SecurityZone);\n#endif\n\t\t}\n\t\tprivate ZoneIdentityPermission BasicTestZone (SecurityZone zone, bool special)\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (zone);\n\t\t\tAssert.AreEqual (zone, zip.SecurityZone, \"SecurityZone\");\n\t\t\t\n\t\t\tZoneIdentityPermission copy = (ZoneIdentityPermission) zip.Copy ();\n\t\t\tAssert.IsTrue (Same (zip, copy), \"Equals-Copy\");\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (copy), \"IsSubset-1\");\n\t\t\tAssert.IsTrue (copy.IsSubsetOf (zip), \"IsSubset-2\");\n\t\t\tif (special) {\n\t\t\t\tAssert.IsFalse (zip.IsSubsetOf (null), \"IsSubset-Null\");\n\t\t\t}\n\t\t\t\n\t\t\tIPermission intersect = zip.Intersect (copy);\n\t\t\tif (special) {\n\t\t\t\tAssert.IsTrue (intersect.IsSubsetOf (zip), \"IsSubset-3\");\n\t\t\t\tAssert.IsFalse (Object.ReferenceEquals (zip, intersect), \"!ReferenceEquals1\");\n\t\t\t\tAssert.IsTrue (intersect.IsSubsetOf (copy), \"IsSubset-4\");\n\t\t\t\tAssert.IsFalse (Object.ReferenceEquals (copy, intersect), \"!ReferenceEquals2\");\n\t\t\t}\n\t\t\tAssert.IsNull (zip.Intersect (null), \"Intersect with null\");\n\t\t\tintersect = zip.Intersect (new ZoneIdentityPermission (PermissionState.None));\n\t\t\tAssert.IsNull (intersect, \"Intersect with PS.None\");\n\t\t\t// note: can't be tested with PermissionState.Unrestricted\n\t\t\t// XML roundtrip\n\t\t\tSecurityElement se = zip.ToXml ();\n\t\t\tcopy.FromXml (se);\n\t\t\tAssert.IsTrue (Same (zip, copy), \"Equals-Xml\");\n\t\t\treturn zip;\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Internet ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Internet, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Intranet ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Intranet, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_MyComputer ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.MyComputer, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_NoZone ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = BasicTestZone (SecurityZone.NoZone, false);\n\t\t\tAssert.IsNull (zip.ToXml ().Attribute (\"Zone\"), \"Zone Attribute\");\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (null), \"IsSubset-Null\");\n\t\t\tIPermission intersect = zip.Intersect (zip);\n\t\t\tAssert.IsNull (intersect, \"Intersect with No Zone\");\n\t\t\t// NoZone is special as it is a subset of all zones\n\t\t\tZoneIdentityPermission ss = new ZoneIdentityPermission (SecurityZone.Internet);\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Internet\");\n\t\t\tss.SecurityZone = SecurityZone.Intranet;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Intranet\");\n\t\t\tss.SecurityZone = SecurityZone.MyComputer;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-MyComputer\");\n\t\t\tss.SecurityZone = SecurityZone.NoZone;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-NoZone\");\n\t\t\tss.SecurityZone = SecurityZone.Trusted;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Trusted\");\n\t\t\tss.SecurityZone = SecurityZone.Untrusted;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Untrusted\");\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Trusted ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Trusted, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Untrusted ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Untrusted, true);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void SecurityZone_Invalid ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission ((SecurityZone)128);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void Intersect_DifferentPermissions ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tSecurityPermission b = new SecurityPermission (PermissionState.None);\n\t\t\ta.Intersect (b);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void IsSubsetOf_DifferentPermissions ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tSecurityPermission b = new SecurityPermission (PermissionState.None);\n\t\t\ta.IsSubsetOf (b);\n\t\t}\n\t\t[Test]\n\t\tpublic void Union () \n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tZoneIdentityPermission z = (ZoneIdentityPermission) a.Union (null);\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+null\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals1\");\n\t\t\tz = (ZoneIdentityPermission) a.Union (new ZoneIdentityPermission (PermissionState.None));\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+PS.None\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals2\");\n\t\t\t// note: can't be tested with PermissionState.Unrestricted\n\t\t\tZoneIdentityPermission n = new ZoneIdentityPermission (SecurityZone.NoZone);\n\t\t\tz = (ZoneIdentityPermission) a.Union (n);\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+NoZone\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals3\");\n\t\t\tz = (ZoneIdentityPermission) n.Union (a);\n\t\t\tAssert.IsTrue (Same (a, z), \"NoZone+Trusted\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals4\");\n\t\t}\n#if NET_2_0\n\t\t[Category (\"NotWorking\")]\n#endif\n\t\t[Test]\n\t\tpublic void Union_DifferentIdentities ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tZoneIdentityPermission b = new ZoneIdentityPermission (SecurityZone.Untrusted);\nNext line of code:\n", "input": "", "context": "//\n// ZoneIdentityPermissionTest.cs - NUnit Test Cases for ZoneIdentityPermission\n//\n// Author:\n//\tSebastien Pouliot  <sebastien@ximian.com>\n//\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\nusing NUnit.Framework;\nusing System;\nusing System.Security;\nusing System.Security.Permissions;\nnamespace MonoTests.System.Security.Permissions {\n\t[TestFixture]\n\tpublic class ZoneIdentityPermissionTest\t{\n\t\t[Test]\n\t\tpublic void PermissionStateNone ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.None);\n\t\t\tAssert.AreEqual (SecurityZone.NoZone, zip.SecurityZone);\n\t\t}\n#if NET_2_0\n\t\t[Test]\n\t\t[Category (\"NotWorking\")]\n\t\tpublic void PermissionStateUnrestricted ()\n\t\t{\n\t\t\t// In 2.0 Unrestricted are permitted for identity permissions\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.Unrestricted);\n\t\t\tAssert.AreEqual (SecurityZone.NoZone, zip.SecurityZone);\n\t\t\tSecurityElement se = zip.ToXml ();\n\t\t\tAssert.AreEqual (5, se.Children.Count, \"Count\");\n\t\t\t// and they aren't equals to None\n\t\t\tAssert.IsFalse (zip.Equals (new ZoneIdentityPermission (PermissionState.None)));\n\t\t}\n#else\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void PermissionStateUnrestricted ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (PermissionState.Unrestricted);\n\t\t}\n#endif\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void PermissionStateInvalid ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission ((PermissionState)2);\n\t\t}\n\t\tprivate bool Same (ZoneIdentityPermission zip1, ZoneIdentityPermission zip2)\n\t\t{\n#if NET_2_0\n\t\t\treturn zip1.Equals (zip2);\n#else\n\t\t\treturn (zip1.SecurityZone == zip2.SecurityZone);\n#endif\n\t\t}\n\t\tprivate ZoneIdentityPermission BasicTestZone (SecurityZone zone, bool special)\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission (zone);\n\t\t\tAssert.AreEqual (zone, zip.SecurityZone, \"SecurityZone\");\n\t\t\t\n\t\t\tZoneIdentityPermission copy = (ZoneIdentityPermission) zip.Copy ();\n\t\t\tAssert.IsTrue (Same (zip, copy), \"Equals-Copy\");\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (copy), \"IsSubset-1\");\n\t\t\tAssert.IsTrue (copy.IsSubsetOf (zip), \"IsSubset-2\");\n\t\t\tif (special) {\n\t\t\t\tAssert.IsFalse (zip.IsSubsetOf (null), \"IsSubset-Null\");\n\t\t\t}\n\t\t\t\n\t\t\tIPermission intersect = zip.Intersect (copy);\n\t\t\tif (special) {\n\t\t\t\tAssert.IsTrue (intersect.IsSubsetOf (zip), \"IsSubset-3\");\n\t\t\t\tAssert.IsFalse (Object.ReferenceEquals (zip, intersect), \"!ReferenceEquals1\");\n\t\t\t\tAssert.IsTrue (intersect.IsSubsetOf (copy), \"IsSubset-4\");\n\t\t\t\tAssert.IsFalse (Object.ReferenceEquals (copy, intersect), \"!ReferenceEquals2\");\n\t\t\t}\n\t\t\tAssert.IsNull (zip.Intersect (null), \"Intersect with null\");\n\t\t\tintersect = zip.Intersect (new ZoneIdentityPermission (PermissionState.None));\n\t\t\tAssert.IsNull (intersect, \"Intersect with PS.None\");\n\t\t\t// note: can't be tested with PermissionState.Unrestricted\n\t\t\t// XML roundtrip\n\t\t\tSecurityElement se = zip.ToXml ();\n\t\t\tcopy.FromXml (se);\n\t\t\tAssert.IsTrue (Same (zip, copy), \"Equals-Xml\");\n\t\t\treturn zip;\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Internet ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Internet, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Intranet ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Intranet, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_MyComputer ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.MyComputer, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_NoZone ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = BasicTestZone (SecurityZone.NoZone, false);\n\t\t\tAssert.IsNull (zip.ToXml ().Attribute (\"Zone\"), \"Zone Attribute\");\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (null), \"IsSubset-Null\");\n\t\t\tIPermission intersect = zip.Intersect (zip);\n\t\t\tAssert.IsNull (intersect, \"Intersect with No Zone\");\n\t\t\t// NoZone is special as it is a subset of all zones\n\t\t\tZoneIdentityPermission ss = new ZoneIdentityPermission (SecurityZone.Internet);\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Internet\");\n\t\t\tss.SecurityZone = SecurityZone.Intranet;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Intranet\");\n\t\t\tss.SecurityZone = SecurityZone.MyComputer;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-MyComputer\");\n\t\t\tss.SecurityZone = SecurityZone.NoZone;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-NoZone\");\n\t\t\tss.SecurityZone = SecurityZone.Trusted;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Trusted\");\n\t\t\tss.SecurityZone = SecurityZone.Untrusted;\n\t\t\tAssert.IsTrue (zip.IsSubsetOf (ss), \"IsSubset-Untrusted\");\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Trusted ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Trusted, true);\n\t\t}\n\t\t[Test]\n\t\tpublic void SecurityZone_Untrusted ()\n\t\t{\n\t\t\tBasicTestZone (SecurityZone.Untrusted, true);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void SecurityZone_Invalid ()\n\t\t{\n\t\t\tZoneIdentityPermission zip = new ZoneIdentityPermission ((SecurityZone)128);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void Intersect_DifferentPermissions ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tSecurityPermission b = new SecurityPermission (PermissionState.None);\n\t\t\ta.Intersect (b);\n\t\t}\n\t\t[Test]\n\t\t[ExpectedException (typeof (ArgumentException))]\n\t\tpublic void IsSubsetOf_DifferentPermissions ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tSecurityPermission b = new SecurityPermission (PermissionState.None);\n\t\t\ta.IsSubsetOf (b);\n\t\t}\n\t\t[Test]\n\t\tpublic void Union () \n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tZoneIdentityPermission z = (ZoneIdentityPermission) a.Union (null);\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+null\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals1\");\n\t\t\tz = (ZoneIdentityPermission) a.Union (new ZoneIdentityPermission (PermissionState.None));\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+PS.None\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals2\");\n\t\t\t// note: can't be tested with PermissionState.Unrestricted\n\t\t\tZoneIdentityPermission n = new ZoneIdentityPermission (SecurityZone.NoZone);\n\t\t\tz = (ZoneIdentityPermission) a.Union (n);\n\t\t\tAssert.IsTrue (Same (a, z), \"Trusted+NoZone\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals3\");\n\t\t\tz = (ZoneIdentityPermission) n.Union (a);\n\t\t\tAssert.IsTrue (Same (a, z), \"NoZone+Trusted\");\n\t\t\tAssert.IsFalse (Object.ReferenceEquals (a, z), \"!ReferenceEquals4\");\n\t\t}\n#if NET_2_0\n\t\t[Category (\"NotWorking\")]\n#endif\n\t\t[Test]\n\t\tpublic void Union_DifferentIdentities ()\n\t\t{\n\t\t\tZoneIdentityPermission a = new ZoneIdentityPermission (SecurityZone.Trusted);\n\t\t\tZoneIdentityPermission b = new ZoneIdentityPermission (SecurityZone.Untrusted);\n", "answers": ["\t\t\tIPermission result = a.Union (b);"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 778, "dataset": "lcc", "language": "csharp", "all_classes": null, "_id": "e212994f82962f98d4e1be7a5678cfd25eacb4f645df2198"}
{"prompt": "Please complete the code given below. \nimport logging\nimport sys\nimport uuid\nfrom array import array\nfrom contextlib import closing\nfrom StringIO import StringIO\nfrom java.io import BufferedInputStream, BufferedReader, FileReader, InputStreamReader, ByteArrayInputStream\nfrom java.security import KeyStore, Security\nfrom java.security.cert import CertificateException, CertificateFactory\nfrom javax.net.ssl import (\n    X509KeyManager, X509TrustManager, KeyManagerFactory, SSLContext, TrustManager, TrustManagerFactory)\ntry:\n    # jarjar-ed version\n    from org.python.bouncycastle.asn1.pkcs import PrivateKeyInfo\n    from org.python.bouncycastle.cert import X509CertificateHolder\n    from org.python.bouncycastle.cert.jcajce import JcaX509CertificateConverter\n    from org.python.bouncycastle.jce.provider import BouncyCastleProvider\n    from org.python.bouncycastle.openssl import PEMKeyPair, PEMParser\n    from org.python.bouncycastle.openssl.jcajce import JcaPEMKeyConverter\nexcept ImportError:\n    # dev version from extlibs\n    from org.bouncycastle.asn1.pkcs import PrivateKeyInfo\n    from org.bouncycastle.cert import X509CertificateHolder\n    from org.bouncycastle.cert.jcajce import JcaX509CertificateConverter\n    from org.bouncycastle.jce.provider import BouncyCastleProvider\n    from org.bouncycastle.openssl import PEMKeyPair, PEMParser\n    from org.bouncycastle.openssl.jcajce import JcaPEMKeyConverter\nlog = logging.getLogger(\"ssl\")\n# FIXME what happens if reloaded?\nSecurity.addProvider(BouncyCastleProvider())\n# build the necessary certificate with a CertificateFactory; this can take the pem format:\n# http://docs.oracle.com/javase/7/docs/api/java/security/cert/CertificateFactory.html#generateCertificate(java.io.InputStream)\n# not certain if we can include a private key in the pem file; see \n# http://stackoverflow.com/questions/7216969/getting-rsa-private-key-from-pem-base64-encoded-private-key-file\n# helpful advice for being able to manage ca_certs outside of Java's keystore\n# specifically the example ReloadableX509TrustManager\n# http://jcalcote.wordpress.com/2010/06/22/managing-a-dynamic-java-trust-store/\n# in the case of http://docs.python.org/2/library/ssl.html#ssl.CERT_REQUIRED\n# http://docs.python.org/2/library/ssl.html#ssl.CERT_NONE\n# https://github.com/rackerlabs/romper/blob/master/romper/trust.py#L15\n#\n# it looks like CERT_OPTIONAL simply validates certificates if\n# provided, probably something in checkServerTrusted - maybe a None\n# arg? need to verify as usual with a real system... :)\n# http://alesaudate.wordpress.com/2010/08/09/how-to-dynamically-select-a-certificate-alias-when-invoking-web-services/\n# is somewhat relevant for managing the keyfile, certfile\ndef _get_ca_certs_trust_manager(ca_certs):\n    trust_store = KeyStore.getInstance(KeyStore.getDefaultType())\n    trust_store.load(None, None)\n    num_certs_installed = 0\n    with open(ca_certs) as f:\n        cf = CertificateFactory.getInstance(\"X.509\")\n        for cert in cf.generateCertificates(BufferedInputStream(f)):\n            trust_store.setCertificateEntry(str(uuid.uuid4()), cert)\n            num_certs_installed += 1\n    tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())\n    tmf.init(trust_store)\n    log.debug(\"Installed %s certificates\", num_certs_installed, extra={\"sock\": \"*\"})\n    return tmf\ndef _stringio_as_reader(s):\n    return BufferedReader(InputStreamReader(ByteArrayInputStream(bytearray(s.getvalue()))))\ndef _extract_readers(cert_file):\n    private_key = StringIO()\n    certs = StringIO()\n    output = certs\n    with open(cert_file) as f:\n        for line in f:\n            if line.startswith(\"-----BEGIN PRIVATE KEY-----\"):\n                output = private_key\n            output.write(line)\n            if line.startswith(\"-----END PRIVATE KEY-----\"):\n                output = certs\n    return _stringio_as_reader(private_key), _stringio_as_reader(certs)\ndef _get_openssl_key_manager(cert_file, key_file=None):\n    paths = [key_file] if key_file else []\n    paths.append(cert_file)\n    # Go from Bouncy Castle API to Java's; a bit heavyweight for the Python dev ;)\n    key_converter = JcaPEMKeyConverter().setProvider(\"BC\")\n    cert_converter = JcaX509CertificateConverter().setProvider(\"BC\")\n    private_key = None\n    certs = []\n    for path in paths:\n        for br in _extract_readers(path):\n            while True:\n                obj = PEMParser(br).readObject()\n                if obj is None:\n                    break\n                if isinstance(obj, PEMKeyPair):\n                    private_key = key_converter.getKeyPair(obj).getPrivate()\n                elif isinstance(obj, PrivateKeyInfo):\n                    private_key = key_converter.getPrivateKey(obj)\n                elif isinstance(obj, X509CertificateHolder):\n                    certs.append(cert_converter.getCertificate(obj))\n    assert private_key, \"No private key loaded\"\n    key_store = KeyStore.getInstance(KeyStore.getDefaultType())\n    key_store.load(None, None)\n    key_store.setKeyEntry(str(uuid.uuid4()), private_key, [], certs)\n    kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())\n    kmf.init(key_store, [])\n    return kmf\ndef _get_ssl_context(keyfile, certfile, ca_certs):\n    if certfile is None and ca_certs is None:\n        log.debug(\"Using default SSL context\", extra={\"sock\": \"*\"})\n        return SSLContext.getDefault()\n    else:\n        log.debug(\"Setting up a specific SSL context for keyfile=%s, certfile=%s, ca_certs=%s\",\n                  keyfile, certfile, ca_certs, extra={\"sock\": \"*\"})\n        if ca_certs:\n            # should support composite usage below\n            trust_managers = _get_ca_certs_trust_manager(ca_certs).getTrustManagers()\n        else:\n            trust_managers = None\n        if certfile:\n            key_managers = _get_openssl_key_manager(certfile, keyfile).getKeyManagers()\n        else:\n            key_managers = None\n        # FIXME FIXME for performance, cache this lookup in the future\n        # to avoid re-reading files on every lookup\n        context = SSLContext.getInstance(\"SSL\")\n        context.init(key_managers, trust_managers, None)\n        return context\n# CompositeX509KeyManager and CompositeX509TrustManager allow for mixing together Java built-in managers\n# with new managers to support Python ssl.\n#\n# See http://tersesystems.com/2014/01/13/fixing-the-most-dangerous-code-in-the-world/\n# for a good description of this composite approach.\n#\n# Ported to Python from http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\n# which was inspired by http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\nclass CompositeX509KeyManager(X509KeyManager):\n                                                   \n    def __init__(self, key_managers):\n        self.key_managers = key_managers\n    def chooseClientAlias(self, key_type, issuers, socket):\n        for key_manager in self.key_managers:\n            alias = key_manager.chooseClientAlias(key_type, issuers, socket)\n            if alias:\n                return alias;\n        return None\n    def chooseServerAlias(self, key_type, issuers, socket):\n        for key_manager in self.key_managers:\n            alias = key_manager.chooseServerAlias(key_type, issuers, socket)\n            if alias:\n                return alias;\n        return None\n    \n    def getPrivateKey(self, alias):\n        for key_manager in self.key_managers:\n            private_key = keyManager.getPrivateKey(alias)\n            if private_key:\n                return private_key\n        return None\n    def getCertificateChain(self, alias):\n        for key_manager in self.key_managers:\n            chain = key_manager.getCertificateChain(alias)\n            if chain:\n                return chain\n        return None\n    def getClientAliases(self, key_type, issuers):\n        aliases = []\n        for key_manager in self.key_managers:\n            aliases.extend(key_manager.getClientAliases(key_type, issuers))\n        if not aliases:\n            return None\n        else:\n            return aliases\n    def getServerAliases(self, key_type, issuers):\n        aliases = []\n        for key_manager in self.key_managers:\n            aliases.extend(key_manager.getServerAliases(key_type, issuers))\n        if not aliases:\n            return None\n        else:\n            return aliases\nclass CompositeX509TrustManager(X509TrustManager):\n    def __init__(self, trust_managers):\n        self.trust_managers = trust_managers\n    def checkClientTrusted(self, chain, auth_type):\n        for trust_manager in self.trust_managers:\n            try:\n                trustManager.checkClientTrusted(chain, auth_type);\n                return\n            except CertificateException:\n                pass\n        raise CertificateException(\"None of the TrustManagers trust this certificate chain\")\n    def checkServerTrusted(self, chain, auth_type):\n        for trust_manager in self.trust_managers:\n            try:\n                trustManager.checkServerTrusted(chain, auth_type);\n                return\n            except CertificateException:\n                pass\n        raise CertificateException(\"None of the TrustManagers trust this certificate chain\")\n    def getAcceptedIssuers(self):\nNext line of code:\n", "input": "", "context": "import logging\nimport sys\nimport uuid\nfrom array import array\nfrom contextlib import closing\nfrom StringIO import StringIO\nfrom java.io import BufferedInputStream, BufferedReader, FileReader, InputStreamReader, ByteArrayInputStream\nfrom java.security import KeyStore, Security\nfrom java.security.cert import CertificateException, CertificateFactory\nfrom javax.net.ssl import (\n    X509KeyManager, X509TrustManager, KeyManagerFactory, SSLContext, TrustManager, TrustManagerFactory)\ntry:\n    # jarjar-ed version\n    from org.python.bouncycastle.asn1.pkcs import PrivateKeyInfo\n    from org.python.bouncycastle.cert import X509CertificateHolder\n    from org.python.bouncycastle.cert.jcajce import JcaX509CertificateConverter\n    from org.python.bouncycastle.jce.provider import BouncyCastleProvider\n    from org.python.bouncycastle.openssl import PEMKeyPair, PEMParser\n    from org.python.bouncycastle.openssl.jcajce import JcaPEMKeyConverter\nexcept ImportError:\n    # dev version from extlibs\n    from org.bouncycastle.asn1.pkcs import PrivateKeyInfo\n    from org.bouncycastle.cert import X509CertificateHolder\n    from org.bouncycastle.cert.jcajce import JcaX509CertificateConverter\n    from org.bouncycastle.jce.provider import BouncyCastleProvider\n    from org.bouncycastle.openssl import PEMKeyPair, PEMParser\n    from org.bouncycastle.openssl.jcajce import JcaPEMKeyConverter\nlog = logging.getLogger(\"ssl\")\n# FIXME what happens if reloaded?\nSecurity.addProvider(BouncyCastleProvider())\n# build the necessary certificate with a CertificateFactory; this can take the pem format:\n# http://docs.oracle.com/javase/7/docs/api/java/security/cert/CertificateFactory.html#generateCertificate(java.io.InputStream)\n# not certain if we can include a private key in the pem file; see \n# http://stackoverflow.com/questions/7216969/getting-rsa-private-key-from-pem-base64-encoded-private-key-file\n# helpful advice for being able to manage ca_certs outside of Java's keystore\n# specifically the example ReloadableX509TrustManager\n# http://jcalcote.wordpress.com/2010/06/22/managing-a-dynamic-java-trust-store/\n# in the case of http://docs.python.org/2/library/ssl.html#ssl.CERT_REQUIRED\n# http://docs.python.org/2/library/ssl.html#ssl.CERT_NONE\n# https://github.com/rackerlabs/romper/blob/master/romper/trust.py#L15\n#\n# it looks like CERT_OPTIONAL simply validates certificates if\n# provided, probably something in checkServerTrusted - maybe a None\n# arg? need to verify as usual with a real system... :)\n# http://alesaudate.wordpress.com/2010/08/09/how-to-dynamically-select-a-certificate-alias-when-invoking-web-services/\n# is somewhat relevant for managing the keyfile, certfile\ndef _get_ca_certs_trust_manager(ca_certs):\n    trust_store = KeyStore.getInstance(KeyStore.getDefaultType())\n    trust_store.load(None, None)\n    num_certs_installed = 0\n    with open(ca_certs) as f:\n        cf = CertificateFactory.getInstance(\"X.509\")\n        for cert in cf.generateCertificates(BufferedInputStream(f)):\n            trust_store.setCertificateEntry(str(uuid.uuid4()), cert)\n            num_certs_installed += 1\n    tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())\n    tmf.init(trust_store)\n    log.debug(\"Installed %s certificates\", num_certs_installed, extra={\"sock\": \"*\"})\n    return tmf\ndef _stringio_as_reader(s):\n    return BufferedReader(InputStreamReader(ByteArrayInputStream(bytearray(s.getvalue()))))\ndef _extract_readers(cert_file):\n    private_key = StringIO()\n    certs = StringIO()\n    output = certs\n    with open(cert_file) as f:\n        for line in f:\n            if line.startswith(\"-----BEGIN PRIVATE KEY-----\"):\n                output = private_key\n            output.write(line)\n            if line.startswith(\"-----END PRIVATE KEY-----\"):\n                output = certs\n    return _stringio_as_reader(private_key), _stringio_as_reader(certs)\ndef _get_openssl_key_manager(cert_file, key_file=None):\n    paths = [key_file] if key_file else []\n    paths.append(cert_file)\n    # Go from Bouncy Castle API to Java's; a bit heavyweight for the Python dev ;)\n    key_converter = JcaPEMKeyConverter().setProvider(\"BC\")\n    cert_converter = JcaX509CertificateConverter().setProvider(\"BC\")\n    private_key = None\n    certs = []\n    for path in paths:\n        for br in _extract_readers(path):\n            while True:\n                obj = PEMParser(br).readObject()\n                if obj is None:\n                    break\n                if isinstance(obj, PEMKeyPair):\n                    private_key = key_converter.getKeyPair(obj).getPrivate()\n                elif isinstance(obj, PrivateKeyInfo):\n                    private_key = key_converter.getPrivateKey(obj)\n                elif isinstance(obj, X509CertificateHolder):\n                    certs.append(cert_converter.getCertificate(obj))\n    assert private_key, \"No private key loaded\"\n    key_store = KeyStore.getInstance(KeyStore.getDefaultType())\n    key_store.load(None, None)\n    key_store.setKeyEntry(str(uuid.uuid4()), private_key, [], certs)\n    kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())\n    kmf.init(key_store, [])\n    return kmf\ndef _get_ssl_context(keyfile, certfile, ca_certs):\n    if certfile is None and ca_certs is None:\n        log.debug(\"Using default SSL context\", extra={\"sock\": \"*\"})\n        return SSLContext.getDefault()\n    else:\n        log.debug(\"Setting up a specific SSL context for keyfile=%s, certfile=%s, ca_certs=%s\",\n                  keyfile, certfile, ca_certs, extra={\"sock\": \"*\"})\n        if ca_certs:\n            # should support composite usage below\n            trust_managers = _get_ca_certs_trust_manager(ca_certs).getTrustManagers()\n        else:\n            trust_managers = None\n        if certfile:\n            key_managers = _get_openssl_key_manager(certfile, keyfile).getKeyManagers()\n        else:\n            key_managers = None\n        # FIXME FIXME for performance, cache this lookup in the future\n        # to avoid re-reading files on every lookup\n        context = SSLContext.getInstance(\"SSL\")\n        context.init(key_managers, trust_managers, None)\n        return context\n# CompositeX509KeyManager and CompositeX509TrustManager allow for mixing together Java built-in managers\n# with new managers to support Python ssl.\n#\n# See http://tersesystems.com/2014/01/13/fixing-the-most-dangerous-code-in-the-world/\n# for a good description of this composite approach.\n#\n# Ported to Python from http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\n# which was inspired by http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\nclass CompositeX509KeyManager(X509KeyManager):\n                                                   \n    def __init__(self, key_managers):\n        self.key_managers = key_managers\n    def chooseClientAlias(self, key_type, issuers, socket):\n        for key_manager in self.key_managers:\n            alias = key_manager.chooseClientAlias(key_type, issuers, socket)\n            if alias:\n                return alias;\n        return None\n    def chooseServerAlias(self, key_type, issuers, socket):\n        for key_manager in self.key_managers:\n            alias = key_manager.chooseServerAlias(key_type, issuers, socket)\n            if alias:\n                return alias;\n        return None\n    \n    def getPrivateKey(self, alias):\n        for key_manager in self.key_managers:\n            private_key = keyManager.getPrivateKey(alias)\n            if private_key:\n                return private_key\n        return None\n    def getCertificateChain(self, alias):\n        for key_manager in self.key_managers:\n            chain = key_manager.getCertificateChain(alias)\n            if chain:\n                return chain\n        return None\n    def getClientAliases(self, key_type, issuers):\n        aliases = []\n        for key_manager in self.key_managers:\n            aliases.extend(key_manager.getClientAliases(key_type, issuers))\n        if not aliases:\n            return None\n        else:\n            return aliases\n    def getServerAliases(self, key_type, issuers):\n        aliases = []\n        for key_manager in self.key_managers:\n            aliases.extend(key_manager.getServerAliases(key_type, issuers))\n        if not aliases:\n            return None\n        else:\n            return aliases\nclass CompositeX509TrustManager(X509TrustManager):\n    def __init__(self, trust_managers):\n        self.trust_managers = trust_managers\n    def checkClientTrusted(self, chain, auth_type):\n        for trust_manager in self.trust_managers:\n            try:\n                trustManager.checkClientTrusted(chain, auth_type);\n                return\n            except CertificateException:\n                pass\n        raise CertificateException(\"None of the TrustManagers trust this certificate chain\")\n    def checkServerTrusted(self, chain, auth_type):\n        for trust_manager in self.trust_managers:\n            try:\n                trustManager.checkServerTrusted(chain, auth_type);\n                return\n            except CertificateException:\n                pass\n        raise CertificateException(\"None of the TrustManagers trust this certificate chain\")\n    def getAcceptedIssuers(self):\n", "answers": ["        certs = []"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 713, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "e6dca363f4644795057dce35d57cdbc53e1e84bea1699bbf"}
{"prompt": "Please complete the code given below. \n/*\n * Jamm\n * Copyright (C) 2002 Dave Dribin and Keith Garner\n *  \n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage jamm.webapp;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.struts.action.ActionMapping;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionError;\nimport org.apache.struts.action.ActionErrors;\nimport jamm.backend.MailManager;\nimport jamm.backend.MailManagerException;\nimport jamm.backend.AccountInfo;\nimport jamm.backend.AliasInfo;\nimport jamm.backend.MailAddress;\nimport jamm.backend.DomainInfo;\n/**\n * Loads data via Mail Manager needed for the domain administration\n * page.  It puts the following into the request's attributes after\n * seeding them from the MailManager: domain, accounts,\n * domainAccountForm (a DomainConfigForm), aliases, and\n * domainAliasForm (a DomainConfigForm).  It then forwards to the\n * domain_admin page.\n *\n * @see jamm.backend.MailManager\n * @see jamm.webapp.DomainConfigForm\n * \n * @struts.action validate=\"false\" path=\"/private/domain_admin\"\n *                roles=\"Site Administrator, Domain Administrator\"\n * @struts.action-forward name=\"view\" path=\"/private/domain_admin.jsp\"\n */\npublic class DomainAdminAction extends JammAction\n{\n    /**\n     * Performs the action.\n     *\n     * @param mapping The action mapping with possible destinations.\n     * @param actionForm Not used in this action.  Is ignored.\n     * @param request the http request that caused this action.\n     * @param response the http response\n     *\n     * @return an <code>ActionForward</code>\n     *\n     * @exception Exception if an error occurs\n     */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm actionForm,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response)\n        throws Exception\n    {\n        ActionErrors errors = new ActionErrors();\n        User user  = getUser(request);\n        MailManager manager = getMailManager(user);\n        \n        String domain = request.getParameter(\"domain\");\n        if (domain == null)\n        {\n            domain = MailAddress.hostFromAddress(user.getUsername());\n        }\n        if (domain == null)\n        {\n            errors.add(ActionErrors.GLOBAL_ERROR,\n                       new ActionError(\"general.error.domain.is.null\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"general_error\");\n        }\n        request.setAttribute(\"domain\", domain);\n        Map postmasterPasswordParameters = new HashMap();\n        postmasterPasswordParameters.put(\n            \"mail\", MailAddress.addressFromParts(\"postmaster\", domain));\n        postmasterPasswordParameters.put(\"done\", \"domain_admin\");\n        request.setAttribute(\"postmasterPasswordParameters\",\n                             postmasterPasswordParameters);\n        // Create the bread crumbs\n        List breadCrumbs = new ArrayList();\n        BreadCrumb breadCrumb;\n        if (user.isUserInRole(User.SITE_ADMIN_ROLE))\n        {\n            breadCrumb = new BreadCrumb(\n                findForward(mapping, \"site_admin\", request).getPath(),\n                \"Site Admin\");\n            breadCrumbs.add(breadCrumb);\n        }\n        breadCrumb = new BreadCrumb(\n            getDomainAdminForward(mapping, domain).getPath(), \"Domain Admin\");\n        breadCrumbs.add(breadCrumb);\n        request.setAttribute(\"breadCrumbs\", breadCrumbs);\n        doAccounts(request, manager, domain);\n        doAliases(request, manager, domain);\n        doCatchAll(request, manager, domain);\n        doDomainInfo(request, manager, domain);\n        return (mapping.findForward(\"view\"));\n    }\n    /**\n     * Prepares the account information and adds it to the web page.\n     *\n     * @param request The request we're servicing\n     * @param manager a mail manager instance to use\n     * @param domain The domain we're manipulating\n     * @exception MailManagerException if an error occurs\n     */\n    private void doAccounts(HttpServletRequest request, MailManager manager,\n                            String domain)\n        throws MailManagerException\n    {\n        List accounts;\n        String startsWith = request.getParameter(\"startsWith\");\n        if (StringUtils.isAlphanumeric(startsWith) &&\n            StringUtils.isNotEmpty(startsWith))\n        {\n            accounts = manager.getAccountsStartingWith(startsWith, domain);\n        }\n        else\n        {\n            accounts = manager.getAccounts(domain);\n        }\n         \n        \n        request.setAttribute(\"accounts\", accounts);\n        List activeAccounts = new ArrayList();\n        List adminAccounts = new ArrayList();\n        List deleteAccounts = new ArrayList();\n        Iterator i = accounts.iterator();\n        while (i.hasNext())\n        {\n            AccountInfo account = (AccountInfo) i.next();\n            String name = account.getName();\n            if (account.isActive())\n            {\n                activeAccounts.add(name);\n            }\n            if (account.isAdministrator())\n            {\n                adminAccounts.add(name);\n            }\n            if (account.getDelete())\n            {\n                deleteAccounts.add(name);\n            }\n        }\n        String[] activeAccountsArray =\n            (String []) activeAccounts.toArray(new String[0]);\n        String[] adminAccountsArray =\n            (String []) adminAccounts.toArray(new String[0]);\n        String[] deleteAccountsArray =\n            (String []) deleteAccounts.toArray(new String[0]);\n        DomainConfigForm dcf = new DomainConfigForm();\n        dcf.setOriginalActiveItems(activeAccountsArray);\n        dcf.setActiveItems(activeAccountsArray);\n        dcf.setOriginalAdminItems(adminAccountsArray);\n        dcf.setAdminItems(adminAccountsArray);\n        dcf.setOriginalItemsToDelete(deleteAccountsArray);\n        dcf.setItemsToDelete(deleteAccountsArray);\n        dcf.setDomain(domain);\n        request.setAttribute(\"domainAccountForm\", dcf);\n    }\n    /**\n     * Prepares the aliases for the page.\n     *\n     * @param request the request being serviced\n     * @param manager The mail manager to use\n     * @param domain which domain are we manipulating\n     * @exception MailManagerException if an error occurs\n     */\n    private void doAliases(HttpServletRequest request, MailManager manager,\n                           String domain)\n        throws MailManagerException\n    {\n        List aliases;\n        String startsWith = request.getParameter(\"startsWith\");\n        if (StringUtils.isAlphanumeric(startsWith) &&\n            StringUtils.isNotEmpty(startsWith))\n        {\n            aliases = manager.getAliasesStartingWith(startsWith, domain);\n        }\n        else\n        {\n            aliases = manager.getAliases(domain);\n        }\n        request.setAttribute(\"aliases\", aliases);\n            \n        List activeAliases = new ArrayList();\n        List adminAliases = new ArrayList();\n        Iterator i = aliases.iterator();\n        while (i.hasNext())\n        {\n            AliasInfo alias = (AliasInfo) i.next();\n            if (alias.isActive())\n            {\n                activeAliases.add(alias.getName());\n            }\n            if (alias.isAdministrator())\n            {\n                adminAliases.add(alias.getName());\n            }\n        }\n        String[] activeAliasesArray =\n            (String []) activeAliases.toArray(new String[0]);\n        String[] adminAliasesArray =\n            (String []) adminAliases.toArray(new String[0]);\n        DomainConfigForm dcf = new DomainConfigForm();\n        dcf.setOriginalActiveItems(activeAliasesArray);\n        dcf.setActiveItems(activeAliasesArray);\n        dcf.setOriginalAdminItems(adminAliasesArray);\n        dcf.setAdminItems(adminAliasesArray);\n        dcf.setDomain(domain);\n        request.setAttribute(\"domainAliasForm\", dcf);\n    }\n    /**\n     * Prepares the info for the CatchAll.\n     *\n     * @param request the request being serviced\n     * @param manager the mail manager\n     * @param domain the domain\n     * @exception MailManagerException if an error occurs\n     */\n    private void doCatchAll(HttpServletRequest request, MailManager manager,\n                            String domain)\n        throws MailManagerException\n    {\n        AliasInfo catchAllAlias = manager.getAlias(\"@\" + domain);\n        if (catchAllAlias != null)\n        {\n            List destinations = catchAllAlias.getMailDestinations();\n            request.setAttribute(\"catchAllAlias\", destinations.get(0));\n        }\n        else\n        {\n            request.setAttribute(\"catchAllAlias\", \"\");\n        }\n    }\n    /**\n     * Prepares the domain info\n     *\n     * @param request the request being serviced\n     * @param manager the mail manager\n     * @param domain the domain\n     * @exception MailManagerException if an error occurs\n     */\n    private void doDomainInfo(HttpServletRequest request, MailManager manager,\n                              String domain)\n        throws MailManagerException\n    {\nNext line of code:\n", "input": "", "context": "/*\n * Jamm\n * Copyright (C) 2002 Dave Dribin and Keith Garner\n *  \n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\npackage jamm.webapp;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.struts.action.ActionMapping;\nimport org.apache.struts.action.ActionForm;\nimport org.apache.struts.action.ActionForward;\nimport org.apache.struts.action.ActionError;\nimport org.apache.struts.action.ActionErrors;\nimport jamm.backend.MailManager;\nimport jamm.backend.MailManagerException;\nimport jamm.backend.AccountInfo;\nimport jamm.backend.AliasInfo;\nimport jamm.backend.MailAddress;\nimport jamm.backend.DomainInfo;\n/**\n * Loads data via Mail Manager needed for the domain administration\n * page.  It puts the following into the request's attributes after\n * seeding them from the MailManager: domain, accounts,\n * domainAccountForm (a DomainConfigForm), aliases, and\n * domainAliasForm (a DomainConfigForm).  It then forwards to the\n * domain_admin page.\n *\n * @see jamm.backend.MailManager\n * @see jamm.webapp.DomainConfigForm\n * \n * @struts.action validate=\"false\" path=\"/private/domain_admin\"\n *                roles=\"Site Administrator, Domain Administrator\"\n * @struts.action-forward name=\"view\" path=\"/private/domain_admin.jsp\"\n */\npublic class DomainAdminAction extends JammAction\n{\n    /**\n     * Performs the action.\n     *\n     * @param mapping The action mapping with possible destinations.\n     * @param actionForm Not used in this action.  Is ignored.\n     * @param request the http request that caused this action.\n     * @param response the http response\n     *\n     * @return an <code>ActionForward</code>\n     *\n     * @exception Exception if an error occurs\n     */\n    public ActionForward execute(ActionMapping mapping,\n                                 ActionForm actionForm,\n                                 HttpServletRequest request,\n                                 HttpServletResponse response)\n        throws Exception\n    {\n        ActionErrors errors = new ActionErrors();\n        User user  = getUser(request);\n        MailManager manager = getMailManager(user);\n        \n        String domain = request.getParameter(\"domain\");\n        if (domain == null)\n        {\n            domain = MailAddress.hostFromAddress(user.getUsername());\n        }\n        if (domain == null)\n        {\n            errors.add(ActionErrors.GLOBAL_ERROR,\n                       new ActionError(\"general.error.domain.is.null\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"general_error\");\n        }\n        request.setAttribute(\"domain\", domain);\n        Map postmasterPasswordParameters = new HashMap();\n        postmasterPasswordParameters.put(\n            \"mail\", MailAddress.addressFromParts(\"postmaster\", domain));\n        postmasterPasswordParameters.put(\"done\", \"domain_admin\");\n        request.setAttribute(\"postmasterPasswordParameters\",\n                             postmasterPasswordParameters);\n        // Create the bread crumbs\n        List breadCrumbs = new ArrayList();\n        BreadCrumb breadCrumb;\n        if (user.isUserInRole(User.SITE_ADMIN_ROLE))\n        {\n            breadCrumb = new BreadCrumb(\n                findForward(mapping, \"site_admin\", request).getPath(),\n                \"Site Admin\");\n            breadCrumbs.add(breadCrumb);\n        }\n        breadCrumb = new BreadCrumb(\n            getDomainAdminForward(mapping, domain).getPath(), \"Domain Admin\");\n        breadCrumbs.add(breadCrumb);\n        request.setAttribute(\"breadCrumbs\", breadCrumbs);\n        doAccounts(request, manager, domain);\n        doAliases(request, manager, domain);\n        doCatchAll(request, manager, domain);\n        doDomainInfo(request, manager, domain);\n        return (mapping.findForward(\"view\"));\n    }\n    /**\n     * Prepares the account information and adds it to the web page.\n     *\n     * @param request The request we're servicing\n     * @param manager a mail manager instance to use\n     * @param domain The domain we're manipulating\n     * @exception MailManagerException if an error occurs\n     */\n    private void doAccounts(HttpServletRequest request, MailManager manager,\n                            String domain)\n        throws MailManagerException\n    {\n        List accounts;\n        String startsWith = request.getParameter(\"startsWith\");\n        if (StringUtils.isAlphanumeric(startsWith) &&\n            StringUtils.isNotEmpty(startsWith))\n        {\n            accounts = manager.getAccountsStartingWith(startsWith, domain);\n        }\n        else\n        {\n            accounts = manager.getAccounts(domain);\n        }\n         \n        \n        request.setAttribute(\"accounts\", accounts);\n        List activeAccounts = new ArrayList();\n        List adminAccounts = new ArrayList();\n        List deleteAccounts = new ArrayList();\n        Iterator i = accounts.iterator();\n        while (i.hasNext())\n        {\n            AccountInfo account = (AccountInfo) i.next();\n            String name = account.getName();\n            if (account.isActive())\n            {\n                activeAccounts.add(name);\n            }\n            if (account.isAdministrator())\n            {\n                adminAccounts.add(name);\n            }\n            if (account.getDelete())\n            {\n                deleteAccounts.add(name);\n            }\n        }\n        String[] activeAccountsArray =\n            (String []) activeAccounts.toArray(new String[0]);\n        String[] adminAccountsArray =\n            (String []) adminAccounts.toArray(new String[0]);\n        String[] deleteAccountsArray =\n            (String []) deleteAccounts.toArray(new String[0]);\n        DomainConfigForm dcf = new DomainConfigForm();\n        dcf.setOriginalActiveItems(activeAccountsArray);\n        dcf.setActiveItems(activeAccountsArray);\n        dcf.setOriginalAdminItems(adminAccountsArray);\n        dcf.setAdminItems(adminAccountsArray);\n        dcf.setOriginalItemsToDelete(deleteAccountsArray);\n        dcf.setItemsToDelete(deleteAccountsArray);\n        dcf.setDomain(domain);\n        request.setAttribute(\"domainAccountForm\", dcf);\n    }\n    /**\n     * Prepares the aliases for the page.\n     *\n     * @param request the request being serviced\n     * @param manager The mail manager to use\n     * @param domain which domain are we manipulating\n     * @exception MailManagerException if an error occurs\n     */\n    private void doAliases(HttpServletRequest request, MailManager manager,\n                           String domain)\n        throws MailManagerException\n    {\n        List aliases;\n        String startsWith = request.getParameter(\"startsWith\");\n        if (StringUtils.isAlphanumeric(startsWith) &&\n            StringUtils.isNotEmpty(startsWith))\n        {\n            aliases = manager.getAliasesStartingWith(startsWith, domain);\n        }\n        else\n        {\n            aliases = manager.getAliases(domain);\n        }\n        request.setAttribute(\"aliases\", aliases);\n            \n        List activeAliases = new ArrayList();\n        List adminAliases = new ArrayList();\n        Iterator i = aliases.iterator();\n        while (i.hasNext())\n        {\n            AliasInfo alias = (AliasInfo) i.next();\n            if (alias.isActive())\n            {\n                activeAliases.add(alias.getName());\n            }\n            if (alias.isAdministrator())\n            {\n                adminAliases.add(alias.getName());\n            }\n        }\n        String[] activeAliasesArray =\n            (String []) activeAliases.toArray(new String[0]);\n        String[] adminAliasesArray =\n            (String []) adminAliases.toArray(new String[0]);\n        DomainConfigForm dcf = new DomainConfigForm();\n        dcf.setOriginalActiveItems(activeAliasesArray);\n        dcf.setActiveItems(activeAliasesArray);\n        dcf.setOriginalAdminItems(adminAliasesArray);\n        dcf.setAdminItems(adminAliasesArray);\n        dcf.setDomain(domain);\n        request.setAttribute(\"domainAliasForm\", dcf);\n    }\n    /**\n     * Prepares the info for the CatchAll.\n     *\n     * @param request the request being serviced\n     * @param manager the mail manager\n     * @param domain the domain\n     * @exception MailManagerException if an error occurs\n     */\n    private void doCatchAll(HttpServletRequest request, MailManager manager,\n                            String domain)\n        throws MailManagerException\n    {\n        AliasInfo catchAllAlias = manager.getAlias(\"@\" + domain);\n        if (catchAllAlias != null)\n        {\n            List destinations = catchAllAlias.getMailDestinations();\n            request.setAttribute(\"catchAllAlias\", destinations.get(0));\n        }\n        else\n        {\n            request.setAttribute(\"catchAllAlias\", \"\");\n        }\n    }\n    /**\n     * Prepares the domain info\n     *\n     * @param request the request being serviced\n     * @param manager the mail manager\n     * @param domain the domain\n     * @exception MailManagerException if an error occurs\n     */\n    private void doDomainInfo(HttpServletRequest request, MailManager manager,\n                              String domain)\n        throws MailManagerException\n    {\n", "answers": ["        User user = getUser(request);"], "pred": "  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n", "length": 847, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "45be6133b10843a59b2ff2272116e322f7dd795025749020"}
{"prompt": "Please complete the code given below. \n#!/usr/bin/python3\n# @begin:license\n#\n# Copyright (c) 2015-2019, Benjamin Niemann <pink@odahoda.de>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# @end:license\nimport asyncio\nimport errno\nimport functools\nimport fractions\nimport logging\nimport os\nimport os.path\nimport time\nimport uuid\nfrom typing import cast, Any, Union, Callable, Awaitable, List, Tuple, Text\nfrom noisicaa.core.typing_extra import down_cast\nfrom noisicaa.core import ipc\nfrom noisicaa import audioproc\nfrom noisicaa import lv2\nfrom noisicaa import editor_main_pb2\nfrom . import player\nfrom . import render_pb2\nfrom . import project as project_lib\nfrom . import session_value_store\nlogger = logging.getLogger(__name__)\nclass RendererFailed(Exception):\n    pass\nclass DataStreamProtocol(asyncio.Protocol):\n    def __init__(\n            self, stream: asyncio.StreamWriter, event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        super().__init__()\n        self.__stream = stream\n        self.__closed = asyncio.Event(loop=event_loop)\n    async def wait(self) -> None:\n        await self.__closed.wait()\n    def data_received(self, data: bytes) -> None:\n        if not self.__stream.transport.is_closing():\n            logger.debug(\"Forward %d bytes to encoder\", len(data))\n            self.__stream.write(data)\n    def eof_received(self) -> None:\n        if not self.__stream.transport.is_closing():\n            self.__stream.write_eof()\n        self.__closed.set()\nclass EncoderProtocol(asyncio.streams.FlowControlMixin, asyncio.SubprocessProtocol):\n    def __init__(\n            self, *,\n            data_handler: Callable[[bytes], None],\n            stderr_handler: Callable[[str], None],\n            failure_handler: Callable[[int], None],\n            event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        # mypy does know about the loop argument\n        super().__init__(loop=event_loop)  # type: ignore[call-arg]\n        self.__closed = asyncio.Event(loop=event_loop)\n        self.__data_handler = data_handler\n        self.__stderr_handler = stderr_handler\n        self.__failure_handler = failure_handler\n        self.__stderr_buf = bytearray()\n        self.__transport = None  # type: asyncio.SubprocessTransport\n    async def wait(self) -> None:\n        await self.__closed.wait()\n    def connection_made(self, transport: asyncio.BaseTransport) -> None:\n        self.__transport = down_cast(asyncio.SubprocessTransport, transport)\n    def pipe_data_received(self, fd: int, data: Union[bytes, Text]) -> None:\n        data = down_cast(bytes, data)\n        if fd == 1:\n            logger.debug(\"Writing %d encoded bytes\", len(data))\n            self.__data_handler(data)\n        else:\n            assert fd == 2\n            self.__stderr_buf.extend(data)\n            while True:\n                eol = self.__stderr_buf.find(b'\\n')\n                if eol < 0:\n                    break\n                line = self.__stderr_buf[:eol].decode('utf-8')\n                del self.__stderr_buf[:eol+1]\n                self.__stderr_handler(line)\n    def process_exited(self) -> None:\n        if self.__stderr_buf:\n            line = self.__stderr_buf.decode('utf-8')\n            del self.__stderr_buf[:]\n            self.__stderr_handler(line)\n        rc = self.__transport.get_returncode()\n        assert rc is not None\n        if rc != 0:\n            self.__failure_handler(rc)\n        self.__closed.set()\nclass Encoder(object):\n    def __init__(\n            self, *,\n            data_handler: Callable[[bytes], None],\n            error_handler: Callable[[str], None],\n            event_loop: asyncio.AbstractEventLoop,\n            settings: render_pb2.RenderSettings\n    ) -> None:\n        self.event_loop = event_loop\n        self.data_handler = data_handler\n        self.error_handler = error_handler\n        self.settings = settings\n    @classmethod\n    def create(cls, *, settings: render_pb2.RenderSettings, **kwargs: Any) -> 'Encoder':\n        cls_map = {\n            render_pb2.RenderSettings.FLAC: FlacEncoder,\n            render_pb2.RenderSettings.OGG: OggEncoder,\n            render_pb2.RenderSettings.WAVE: WaveEncoder,\n            render_pb2.RenderSettings.MP3: Mp3Encoder,\n            render_pb2.RenderSettings.FAIL__TEST_ONLY__: FailingEncoder,\n        }\n        encoder_cls = cls_map[settings.output_format]\n        return encoder_cls(settings=settings, **kwargs)\n    def get_writer(self) -> asyncio.StreamWriter:\n        raise NotImplementedError\n    async def setup(self) -> None:\n        logger.info(\"Setting up %s...\", type(self).__name__)\n    async def cleanup(self) -> None:\n        logger.info(\"%s cleaned up.\", type(self).__name__)\n    async def wait(self) -> None:\n        raise NotImplementedError\nclass SubprocessEncoder(Encoder):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.__cmdline = None  # type: List[str]\n        self.__transport = None  # type: asyncio.SubprocessTransport\n        self.__protocol = None  # type: EncoderProtocol\n        self.__stdin = None  # type: asyncio.StreamWriter\n        self.__stderr = None  # type: List[str]\n        self.__returncode = None  # type: int\n    def get_writer(self) -> asyncio.StreamWriter:\n        return self.__stdin\n    def get_cmd_line(self) -> List[str]:\n        raise NotImplementedError\n    def __fail(self, rc: int) -> None:\n        assert rc\n        self.error_handler(\n            \"%s failed with returncode %d:\\n%s\" % (\n                ' '.join(self.__cmdline), rc, '\\n'.join(self.__stderr)))\n    async def setup(self) -> None:\n        await super().setup()\n        self.__cmdline = self.get_cmd_line()\n        logger.info(\"Starting encoder process: %s\", ' '.join(self.__cmdline))\n        self.__stderr = []\n        transport, protocol = await self.event_loop.subprocess_exec(\n            functools.partial(\n                EncoderProtocol,\n                data_handler=self.data_handler,\n                stderr_handler=self.__stderr.append,\n                failure_handler=self.__fail,\n                event_loop=self.event_loop),\n            *self.__cmdline,\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE)\n        self.__transport = down_cast(asyncio.SubprocessTransport, transport)\n        self.__protocol = down_cast(EncoderProtocol, protocol)\n        self.__stdin = asyncio.StreamWriter(\n            transport=self.__transport.get_pipe_transport(0),\n            protocol=self.__protocol,\n            reader=None,\n            loop=self.event_loop)\n    async def cleanup(self) -> None:\n        if self.__transport is not None:\n            self.__transport.close()\n            await self.__protocol.wait()\n            self.__transport = None\n            self.__protocol = None\n        await super().cleanup()\n    async def wait(self) -> None:\n        if not self.__stdin.transport.is_closing():\n            await self.__stdin.drain()\n            logger.info(\"All bytes written to encoder process.\")\n        logger.info(\"Waiting for encoder process to complete...\")\n        await self.__protocol.wait()\nclass FfmpegEncoder(SubprocessEncoder):\n    def get_cmd_line(self) -> List[str]:\n        global_flags = [\n            '-nostdin',\n        ]\n        input_flags = [\n            '-f', 'f32le',\n            '-ar', '%d' % self.settings.sample_rate,\n            '-ac', '2',\n            '-i', 'pipe:0',\n        ]\n        output_flags = [\n            'pipe:1',\n        ]\n        return (\n            ['/usr/bin/ffmpeg']\n            + global_flags\n            + input_flags\n            + self.get_encoder_flags()\n            + output_flags)\n    def get_encoder_flags(self) -> List[str]:\n        raise NotImplementedError\nclass FlacEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        compression_level = self.settings.flac_settings.compression_level\n        if not 0 <= compression_level <= 12:\n            raise ValueError(\"Invalid flac_settings.compression_level %d\" % compression_level)\n        bits_per_sample = self.settings.flac_settings.bits_per_sample\n        if bits_per_sample not in (16, 24):\n            raise ValueError(\"Invalid flac_settings.bits_per_sample %d\" % bits_per_sample)\n        sample_fmt = {\n            16: 's16',\n            24: 's32',\n        }[bits_per_sample]\n        return [\n            '-f', 'flac',\n            '-compression_level', str(compression_level),\n            '-sample_fmt', sample_fmt,\n        ]\nclass OggEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        flags = [\n            '-f', 'ogg',\n        ]\n        encode_mode = self.settings.ogg_settings.encode_mode\n        if encode_mode == render_pb2.RenderSettings.OggSettings.VBR:\n            quality = self.settings.ogg_settings.quality\n            if not -1.0 <= quality <= 10.0:\n                raise ValueError(\"Invalid ogg_settings.quality %f\" % quality)\n            flags += ['-q', '%.1f' % quality]\n        elif encode_mode == render_pb2.RenderSettings.OggSettings.CBR:\n            bitrate = self.settings.ogg_settings.bitrate\n            if not 45 <= bitrate <= 500:\n                raise ValueError(\"Invalid ogg_settings.bitrate %d\" % bitrate)\n            flags += ['-b:a', '%dk' % bitrate]\n        return flags\nclass WaveEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        bits_per_sample = self.settings.wave_settings.bits_per_sample\n        if bits_per_sample not in (16, 24, 32):\n            raise ValueError(\"Invalid wave_settings.bits_per_sample %d\" % bits_per_sample)\n        codec = {\n            16: 'pcm_s16le',\n            24: 'pcm_s24le',\n            32: 'pcm_s32le',\n        }[bits_per_sample]\n        return [\n            '-f', 'wav',\n            '-c:a', codec,\n        ]\nclass Mp3Encoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        flags = [\n            '-f', 'mp3',\n            '-c:a', 'libmp3lame',\n        ]\n        encode_mode = self.settings.mp3_settings.encode_mode\n        if encode_mode == render_pb2.RenderSettings.Mp3Settings.VBR:\n            compression_level = self.settings.mp3_settings.compression_level\n            if not 0 <= compression_level <= 9:\n                raise ValueError(\"Invalid mp3_settings.compression_level %d\" % compression_level)\n            flags += ['-compression_level', '%d' % compression_level]\n        elif encode_mode == render_pb2.RenderSettings.Mp3Settings.CBR:\n            bitrate = self.settings.mp3_settings.bitrate\n            if not 32 <= bitrate <= 320:\n                raise ValueError(\"Invalid mp3_settings.bitrate %d\" % bitrate)\n            flags += ['-b:a', '%dk' % bitrate]\n        return flags\nclass FailingEncoder(SubprocessEncoder):\n    def get_cmd_line(self) -> List[str]:\n        return [\n            '/bin/false',\n        ]\nclass Renderer(object):\n    def __init__(\n            self, *,\n            project: project_lib.BaseProject,\n            callback_address: str,\n            render_settings: render_pb2.RenderSettings,\n            tmp_dir: str,\n            server: ipc.Server,\n            manager: ipc.Stub,\n            urid_mapper: lv2.URIDMapper,\n            event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        self.__project = project\n        self.__callback_address = callback_address\n        self.__render_settings = render_settings\n        self.__tmp_dir = tmp_dir\n        self.__server = server\n        self.__manager = manager\n        self.__urid_mapper = urid_mapper\n        self.__event_loop = event_loop\n        self.__failed = asyncio.Event(loop=self.__event_loop)\n        self.__callback = None  # type: ipc.Stub\n        self.__data_queue = None  # type: asyncio.Queue\n        self.__data_pump_task = None  # type: asyncio.Task\n        self.__datastream_address = None  # type: str\n        self.__datastream_transport = None  # type: asyncio.BaseTransport\n        self.__datastream_protocol = None  # type: DataStreamProtocol\n        self.__datastream_fd = None  # type: int\n        self.__encoder = None  # type: Encoder\n        self.__player_state_changed = None  # type: asyncio.Event\n        self.__player_started = None  # type: asyncio.Event\n        self.__player_finished = None  # type: asyncio.Event\n        self.__playing = None  # type: bool\n        self.__current_time = None  # type: audioproc.MusicalTime\n        self.__duration = self.__project.duration\n        self.__audioproc_address = None  # type: str\n        self.__audioproc_client = None  # type: audioproc.AbstractAudioProcClient\n        self.__player = None  # type: player.Player\n        self.__next_progress_update = None  # type: Tuple[fractions.Fraction, float]\n        self.__progress_pump_task = None  # type: asyncio.Task\n        self.__session_values = None  # type: session_value_store.SessionValueStore\n    def __fail(self, msg: str) -> None:\n        logger.error(\"Encoding failed: %s\", msg)\n        self.__failed.set()\n    async def __wait_for_some(self, *futures: Awaitable) -> None:\n        \"\"\"Wait until at least one of the futures completed and cancel all uncompleted.\"\"\"\n        done, pending = await asyncio.wait(\n            futures,\n            loop=self.__event_loop,\n            return_when=asyncio.FIRST_COMPLETED)\n        for f in pending:\n            f.cancel()\n        for f in done:\n            f.result()\n    async def __setup_callback_stub(self) -> None:\n        self.__callback = ipc.Stub(self.__event_loop, self.__callback_address)\n        await self.__callback.connect()\n    async def __data_pump_main(self) -> None:\n        while True:\n            get = asyncio.ensure_future(self.__data_queue.get(), loop=self.__event_loop)\n            await self.__wait_for_some(get, self.__failed.wait())\n            if self.__failed.is_set():\n                logger.info(\"Stopping data pump, because encoder failed.\")\n                break\n            if get.done():\n                data = get.result()\n                if data is None:\n                    logger.info(\"Shutting down data pump.\")\n                    break\n                response = render_pb2.RenderDataResponse()\n                await self.__callback.call(\n                    'DATA', render_pb2.RenderDataRequest(data=data), response)\n                if not response.status:\n                    self.__fail(response.msg)\n    async def __setup_data_pump(self) -> None:\n        self.__data_queue = asyncio.Queue(loop=self.__event_loop)\n        self.__data_pump_task = self.__event_loop.create_task(self.__data_pump_main())\n    async def __setup_encoder_process(self) -> None:\n        self.__encoder = Encoder.create(\n            data_handler=self.__data_queue.put_nowait,\n            error_handler=self.__fail,\n            event_loop=self.__event_loop,\n            settings=self.__render_settings)\n        await self.__encoder.setup()\n    async def __setup_datastream_pipe(self) -> None:\n        self.__datastream_address = os.path.join(\nNext line of code:\n", "input": "", "context": "#!/usr/bin/python3\n# @begin:license\n#\n# Copyright (c) 2015-2019, Benjamin Niemann <pink@odahoda.de>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# @end:license\nimport asyncio\nimport errno\nimport functools\nimport fractions\nimport logging\nimport os\nimport os.path\nimport time\nimport uuid\nfrom typing import cast, Any, Union, Callable, Awaitable, List, Tuple, Text\nfrom noisicaa.core.typing_extra import down_cast\nfrom noisicaa.core import ipc\nfrom noisicaa import audioproc\nfrom noisicaa import lv2\nfrom noisicaa import editor_main_pb2\nfrom . import player\nfrom . import render_pb2\nfrom . import project as project_lib\nfrom . import session_value_store\nlogger = logging.getLogger(__name__)\nclass RendererFailed(Exception):\n    pass\nclass DataStreamProtocol(asyncio.Protocol):\n    def __init__(\n            self, stream: asyncio.StreamWriter, event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        super().__init__()\n        self.__stream = stream\n        self.__closed = asyncio.Event(loop=event_loop)\n    async def wait(self) -> None:\n        await self.__closed.wait()\n    def data_received(self, data: bytes) -> None:\n        if not self.__stream.transport.is_closing():\n            logger.debug(\"Forward %d bytes to encoder\", len(data))\n            self.__stream.write(data)\n    def eof_received(self) -> None:\n        if not self.__stream.transport.is_closing():\n            self.__stream.write_eof()\n        self.__closed.set()\nclass EncoderProtocol(asyncio.streams.FlowControlMixin, asyncio.SubprocessProtocol):\n    def __init__(\n            self, *,\n            data_handler: Callable[[bytes], None],\n            stderr_handler: Callable[[str], None],\n            failure_handler: Callable[[int], None],\n            event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        # mypy does know about the loop argument\n        super().__init__(loop=event_loop)  # type: ignore[call-arg]\n        self.__closed = asyncio.Event(loop=event_loop)\n        self.__data_handler = data_handler\n        self.__stderr_handler = stderr_handler\n        self.__failure_handler = failure_handler\n        self.__stderr_buf = bytearray()\n        self.__transport = None  # type: asyncio.SubprocessTransport\n    async def wait(self) -> None:\n        await self.__closed.wait()\n    def connection_made(self, transport: asyncio.BaseTransport) -> None:\n        self.__transport = down_cast(asyncio.SubprocessTransport, transport)\n    def pipe_data_received(self, fd: int, data: Union[bytes, Text]) -> None:\n        data = down_cast(bytes, data)\n        if fd == 1:\n            logger.debug(\"Writing %d encoded bytes\", len(data))\n            self.__data_handler(data)\n        else:\n            assert fd == 2\n            self.__stderr_buf.extend(data)\n            while True:\n                eol = self.__stderr_buf.find(b'\\n')\n                if eol < 0:\n                    break\n                line = self.__stderr_buf[:eol].decode('utf-8')\n                del self.__stderr_buf[:eol+1]\n                self.__stderr_handler(line)\n    def process_exited(self) -> None:\n        if self.__stderr_buf:\n            line = self.__stderr_buf.decode('utf-8')\n            del self.__stderr_buf[:]\n            self.__stderr_handler(line)\n        rc = self.__transport.get_returncode()\n        assert rc is not None\n        if rc != 0:\n            self.__failure_handler(rc)\n        self.__closed.set()\nclass Encoder(object):\n    def __init__(\n            self, *,\n            data_handler: Callable[[bytes], None],\n            error_handler: Callable[[str], None],\n            event_loop: asyncio.AbstractEventLoop,\n            settings: render_pb2.RenderSettings\n    ) -> None:\n        self.event_loop = event_loop\n        self.data_handler = data_handler\n        self.error_handler = error_handler\n        self.settings = settings\n    @classmethod\n    def create(cls, *, settings: render_pb2.RenderSettings, **kwargs: Any) -> 'Encoder':\n        cls_map = {\n            render_pb2.RenderSettings.FLAC: FlacEncoder,\n            render_pb2.RenderSettings.OGG: OggEncoder,\n            render_pb2.RenderSettings.WAVE: WaveEncoder,\n            render_pb2.RenderSettings.MP3: Mp3Encoder,\n            render_pb2.RenderSettings.FAIL__TEST_ONLY__: FailingEncoder,\n        }\n        encoder_cls = cls_map[settings.output_format]\n        return encoder_cls(settings=settings, **kwargs)\n    def get_writer(self) -> asyncio.StreamWriter:\n        raise NotImplementedError\n    async def setup(self) -> None:\n        logger.info(\"Setting up %s...\", type(self).__name__)\n    async def cleanup(self) -> None:\n        logger.info(\"%s cleaned up.\", type(self).__name__)\n    async def wait(self) -> None:\n        raise NotImplementedError\nclass SubprocessEncoder(Encoder):\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.__cmdline = None  # type: List[str]\n        self.__transport = None  # type: asyncio.SubprocessTransport\n        self.__protocol = None  # type: EncoderProtocol\n        self.__stdin = None  # type: asyncio.StreamWriter\n        self.__stderr = None  # type: List[str]\n        self.__returncode = None  # type: int\n    def get_writer(self) -> asyncio.StreamWriter:\n        return self.__stdin\n    def get_cmd_line(self) -> List[str]:\n        raise NotImplementedError\n    def __fail(self, rc: int) -> None:\n        assert rc\n        self.error_handler(\n            \"%s failed with returncode %d:\\n%s\" % (\n                ' '.join(self.__cmdline), rc, '\\n'.join(self.__stderr)))\n    async def setup(self) -> None:\n        await super().setup()\n        self.__cmdline = self.get_cmd_line()\n        logger.info(\"Starting encoder process: %s\", ' '.join(self.__cmdline))\n        self.__stderr = []\n        transport, protocol = await self.event_loop.subprocess_exec(\n            functools.partial(\n                EncoderProtocol,\n                data_handler=self.data_handler,\n                stderr_handler=self.__stderr.append,\n                failure_handler=self.__fail,\n                event_loop=self.event_loop),\n            *self.__cmdline,\n            stdin=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE)\n        self.__transport = down_cast(asyncio.SubprocessTransport, transport)\n        self.__protocol = down_cast(EncoderProtocol, protocol)\n        self.__stdin = asyncio.StreamWriter(\n            transport=self.__transport.get_pipe_transport(0),\n            protocol=self.__protocol,\n            reader=None,\n            loop=self.event_loop)\n    async def cleanup(self) -> None:\n        if self.__transport is not None:\n            self.__transport.close()\n            await self.__protocol.wait()\n            self.__transport = None\n            self.__protocol = None\n        await super().cleanup()\n    async def wait(self) -> None:\n        if not self.__stdin.transport.is_closing():\n            await self.__stdin.drain()\n            logger.info(\"All bytes written to encoder process.\")\n        logger.info(\"Waiting for encoder process to complete...\")\n        await self.__protocol.wait()\nclass FfmpegEncoder(SubprocessEncoder):\n    def get_cmd_line(self) -> List[str]:\n        global_flags = [\n            '-nostdin',\n        ]\n        input_flags = [\n            '-f', 'f32le',\n            '-ar', '%d' % self.settings.sample_rate,\n            '-ac', '2',\n            '-i', 'pipe:0',\n        ]\n        output_flags = [\n            'pipe:1',\n        ]\n        return (\n            ['/usr/bin/ffmpeg']\n            + global_flags\n            + input_flags\n            + self.get_encoder_flags()\n            + output_flags)\n    def get_encoder_flags(self) -> List[str]:\n        raise NotImplementedError\nclass FlacEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        compression_level = self.settings.flac_settings.compression_level\n        if not 0 <= compression_level <= 12:\n            raise ValueError(\"Invalid flac_settings.compression_level %d\" % compression_level)\n        bits_per_sample = self.settings.flac_settings.bits_per_sample\n        if bits_per_sample not in (16, 24):\n            raise ValueError(\"Invalid flac_settings.bits_per_sample %d\" % bits_per_sample)\n        sample_fmt = {\n            16: 's16',\n            24: 's32',\n        }[bits_per_sample]\n        return [\n            '-f', 'flac',\n            '-compression_level', str(compression_level),\n            '-sample_fmt', sample_fmt,\n        ]\nclass OggEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        flags = [\n            '-f', 'ogg',\n        ]\n        encode_mode = self.settings.ogg_settings.encode_mode\n        if encode_mode == render_pb2.RenderSettings.OggSettings.VBR:\n            quality = self.settings.ogg_settings.quality\n            if not -1.0 <= quality <= 10.0:\n                raise ValueError(\"Invalid ogg_settings.quality %f\" % quality)\n            flags += ['-q', '%.1f' % quality]\n        elif encode_mode == render_pb2.RenderSettings.OggSettings.CBR:\n            bitrate = self.settings.ogg_settings.bitrate\n            if not 45 <= bitrate <= 500:\n                raise ValueError(\"Invalid ogg_settings.bitrate %d\" % bitrate)\n            flags += ['-b:a', '%dk' % bitrate]\n        return flags\nclass WaveEncoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        bits_per_sample = self.settings.wave_settings.bits_per_sample\n        if bits_per_sample not in (16, 24, 32):\n            raise ValueError(\"Invalid wave_settings.bits_per_sample %d\" % bits_per_sample)\n        codec = {\n            16: 'pcm_s16le',\n            24: 'pcm_s24le',\n            32: 'pcm_s32le',\n        }[bits_per_sample]\n        return [\n            '-f', 'wav',\n            '-c:a', codec,\n        ]\nclass Mp3Encoder(FfmpegEncoder):\n    def get_encoder_flags(self) -> List[str]:\n        flags = [\n            '-f', 'mp3',\n            '-c:a', 'libmp3lame',\n        ]\n        encode_mode = self.settings.mp3_settings.encode_mode\n        if encode_mode == render_pb2.RenderSettings.Mp3Settings.VBR:\n            compression_level = self.settings.mp3_settings.compression_level\n            if not 0 <= compression_level <= 9:\n                raise ValueError(\"Invalid mp3_settings.compression_level %d\" % compression_level)\n            flags += ['-compression_level', '%d' % compression_level]\n        elif encode_mode == render_pb2.RenderSettings.Mp3Settings.CBR:\n            bitrate = self.settings.mp3_settings.bitrate\n            if not 32 <= bitrate <= 320:\n                raise ValueError(\"Invalid mp3_settings.bitrate %d\" % bitrate)\n            flags += ['-b:a', '%dk' % bitrate]\n        return flags\nclass FailingEncoder(SubprocessEncoder):\n    def get_cmd_line(self) -> List[str]:\n        return [\n            '/bin/false',\n        ]\nclass Renderer(object):\n    def __init__(\n            self, *,\n            project: project_lib.BaseProject,\n            callback_address: str,\n            render_settings: render_pb2.RenderSettings,\n            tmp_dir: str,\n            server: ipc.Server,\n            manager: ipc.Stub,\n            urid_mapper: lv2.URIDMapper,\n            event_loop: asyncio.AbstractEventLoop\n    ) -> None:\n        self.__project = project\n        self.__callback_address = callback_address\n        self.__render_settings = render_settings\n        self.__tmp_dir = tmp_dir\n        self.__server = server\n        self.__manager = manager\n        self.__urid_mapper = urid_mapper\n        self.__event_loop = event_loop\n        self.__failed = asyncio.Event(loop=self.__event_loop)\n        self.__callback = None  # type: ipc.Stub\n        self.__data_queue = None  # type: asyncio.Queue\n        self.__data_pump_task = None  # type: asyncio.Task\n        self.__datastream_address = None  # type: str\n        self.__datastream_transport = None  # type: asyncio.BaseTransport\n        self.__datastream_protocol = None  # type: DataStreamProtocol\n        self.__datastream_fd = None  # type: int\n        self.__encoder = None  # type: Encoder\n        self.__player_state_changed = None  # type: asyncio.Event\n        self.__player_started = None  # type: asyncio.Event\n        self.__player_finished = None  # type: asyncio.Event\n        self.__playing = None  # type: bool\n        self.__current_time = None  # type: audioproc.MusicalTime\n        self.__duration = self.__project.duration\n        self.__audioproc_address = None  # type: str\n        self.__audioproc_client = None  # type: audioproc.AbstractAudioProcClient\n        self.__player = None  # type: player.Player\n        self.__next_progress_update = None  # type: Tuple[fractions.Fraction, float]\n        self.__progress_pump_task = None  # type: asyncio.Task\n        self.__session_values = None  # type: session_value_store.SessionValueStore\n    def __fail(self, msg: str) -> None:\n        logger.error(\"Encoding failed: %s\", msg)\n        self.__failed.set()\n    async def __wait_for_some(self, *futures: Awaitable) -> None:\n        \"\"\"Wait until at least one of the futures completed and cancel all uncompleted.\"\"\"\n        done, pending = await asyncio.wait(\n            futures,\n            loop=self.__event_loop,\n            return_when=asyncio.FIRST_COMPLETED)\n        for f in pending:\n            f.cancel()\n        for f in done:\n            f.result()\n    async def __setup_callback_stub(self) -> None:\n        self.__callback = ipc.Stub(self.__event_loop, self.__callback_address)\n        await self.__callback.connect()\n    async def __data_pump_main(self) -> None:\n        while True:\n            get = asyncio.ensure_future(self.__data_queue.get(), loop=self.__event_loop)\n            await self.__wait_for_some(get, self.__failed.wait())\n            if self.__failed.is_set():\n                logger.info(\"Stopping data pump, because encoder failed.\")\n                break\n            if get.done():\n                data = get.result()\n                if data is None:\n                    logger.info(\"Shutting down data pump.\")\n                    break\n                response = render_pb2.RenderDataResponse()\n                await self.__callback.call(\n                    'DATA', render_pb2.RenderDataRequest(data=data), response)\n                if not response.status:\n                    self.__fail(response.msg)\n    async def __setup_data_pump(self) -> None:\n        self.__data_queue = asyncio.Queue(loop=self.__event_loop)\n        self.__data_pump_task = self.__event_loop.create_task(self.__data_pump_main())\n    async def __setup_encoder_process(self) -> None:\n        self.__encoder = Encoder.create(\n            data_handler=self.__data_queue.put_nowait,\n            error_handler=self.__fail,\n            event_loop=self.__event_loop,\n            settings=self.__render_settings)\n        await self.__encoder.setup()\n    async def __setup_datastream_pipe(self) -> None:\n        self.__datastream_address = os.path.join(\n", "answers": ["            self.__tmp_dir, 'datastream.%s.pipe' % uuid.uuid4().hex)"], "pred": "  self.__datastream_address = os.path.join(\n  self.__datastream_address = os.path.join(\n  self.__datastream_address = os.path.join(\n  self.__datastream_address = os.path.join(\n  self.__datastream_address = os.path.join(\n  self.__datastream_address = os.path", "length": 1276, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "4b93f91719b36d7aee8a2f7f39b3991d464913e3bc3e77b4"}
{"prompt": "Please complete the code given below. \n/*\n * This file is part of ChronoJump\n *\n * ChronoJump is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or   \n *    (at your option) any later version.\n *    \n * ChronoJump is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n *    GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Copyright (C) 2004-2017   Xavier de Blas <xaviblas@gmail.com> \n */\nusing System;\nusing Gtk;\nusing Glade;\nusing GLib; //for Value\nusing System.Text; //StringBuilder\nusing System.Collections; //ArrayList\nusing Mono.Unix;\npublic class ConvertWeightWindow \n{\n\t[Widget] Gtk.Window convert_weight;\n\tstatic ConvertWeightWindow ConvertWeightWindowBox;\n\t[Widget] Gtk.TreeView treeview1;\n\t[Widget] Gtk.Label label_old_weight_value;\n\t[Widget] Gtk.Label label_new_weight_value;\n\t[Widget] Gtk.Button button_accept;\n\t[Widget] Gtk.Button button_cancel;\n\tTreeStore store;\n\tdouble oldPersonWeight;\n\tdouble newPersonWeight;\n\tstring [] jumpsNormal;\n\tstring [] jumpsReactive;\n\tint columnBool1 = 6;\n\tint columnBool2 = 8;\n\tstring simpleString;\n\tstring reactiveString;\n\t\n\tConvertWeightWindow (double oldPersonWeight, double newPersonWeight, string [] jumpsNormal, string [] jumpsReactive) {\n\t\tGlade.XML gladeXML;\n\t\tgladeXML = Glade.XML.FromAssembly (Util.GetGladePath() + \"convert_weight.glade\", \"convert_weight\", null);\n\t\tgladeXML.Autoconnect(this);\n\t\t\n\t\t//put an icon to window\n\t\tUtilGtk.IconWindow(convert_weight);\n\t\tthis.oldPersonWeight = oldPersonWeight;\n\t\tthis.newPersonWeight = newPersonWeight;\n\t\tthis.jumpsNormal = jumpsNormal;\n\t\tthis.jumpsReactive = jumpsReactive;\n\t\t\t\t\t\n\t\tsimpleString = Catalog.GetString(\"Simple\");\n\t\treactiveString = Catalog.GetString(\"Reactive\");\n\t\n\t\tcreateTreeViewWithCheckboxes(treeview1);\n\t\t\n\t\tstore = new TreeStore( \n\t\t\t\ttypeof (string), //uniqueID\n\t\t\t\ttypeof (string), //simple or reactive\n\t\t\t\ttypeof (string), //jumpType\n\t\t\t\ttypeof (string), //tf \n\t\t\t\ttypeof (string), //tc \n\t\t\t\t/* following eg of a subject of 70Kg \n\t\t\t\t * that has done a jump with an extra of 70Kg\n\t\t\t\t * and after (in same session) changes person weight to 80\n\t\t\t\t */\n\t\t\t\ttypeof (string), //weight % + weight kg (old) (eg: 100%-70Kg)\n\t\t\t\ttypeof (bool), //mark new option 1\n\t\t\t\ttypeof (string), //weight % + weight kg (new option1) (eg: 100%-80Kg)\n\t\t\t\ttypeof (bool), //mark new option 2\n\t\t\t\ttypeof (string) //weight % + weight kg (new option2) (eg: 87%-70Kg)\n\t\t\t\t);\n\t\ttreeview1.Model = store;\n\t\t\n\t\tfillTreeView( treeview1, store );\n\t}\n\tstatic public ConvertWeightWindow Show (\n\t\t\tdouble oldPersonWeight, double newPersonWeight, string [] jumpsNormal, string [] jumpsReactive)\n\t{\n\t\tif (ConvertWeightWindowBox == null) {\n\t\t\tConvertWeightWindowBox = \n\t\t\t\tnew ConvertWeightWindow (oldPersonWeight, newPersonWeight, jumpsNormal, jumpsReactive);\n\t\t}\n\t\n\t\tConvertWeightWindowBox.label_old_weight_value.Text = oldPersonWeight.ToString() + \" Kg\";\n\t\tConvertWeightWindowBox.label_new_weight_value.Text = newPersonWeight.ToString() + \" Kg\";\n\t\tConvertWeightWindowBox.convert_weight.Show ();\n\t\t\n\t\treturn ConvertWeightWindowBox;\n\t}\n\tprotected void createTreeViewWithCheckboxes (Gtk.TreeView tv) {\n\t\ttv.HeadersVisible=true;\n\t\tint count = 0;\n\t\ttv.AppendColumn ( Catalog.GetString(\"ID\"), new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"Simple\") + \" \" +\n\t\t\t\tCatalog.GetString(\"or\") + \" \" +\n\t\t\t\tCatalog.GetString(\"Reactive\")\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"Type\"), new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"TF\") \n\t\t\t\t/*\n\t\t\t\t+ \"\\n\" + \n\t\t\t\tCatalog.GetString(\"TF\") + \"(\" + \n\t\t\t\tCatalog.GetString(\"AVG\") + \")\"\n\t\t\t\t*/\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"TC\") \n\t\t\t\t/*\n\t\t\t\t+ \"\\n\" + \n\t\t\t\tCatalog.GetString(\"TC\") + \"(\" + \n\t\t\t\tCatalog.GetString(\"AVG\") + \")\"\n\t\t\t\t*/\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"Old weight\"), new CellRendererText(), \"text\", count++);\n\t\tCellRendererToggle crt = new CellRendererToggle();\n\t\tcrt.Visible = true;\n\t\tcrt.Activatable = true;\n\t\tcrt.Active = true;\n\t\tcrt.Toggled += ItemToggled1;\n\t\tTreeViewColumn column = new TreeViewColumn (\"\", crt, \"active\", count);\n\t\tcolumn.Clickable = true;\n\t\ttv.InsertColumn (column, count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"New weight\\noption 1\"), new CellRendererText(), \"text\", count++);\n\t\tCellRendererToggle crt2 = new CellRendererToggle();\n\t\tcrt2.Visible = true;\n\t\tcrt2.Activatable = true;\n\t\tcrt2.Active = true;\n\t\tcrt2.Toggled += ItemToggled2;\n\t\tcolumn = new TreeViewColumn (\"\", crt2, \"active\", count);\n\t\tcolumn.Clickable = true;\n\t\ttv.InsertColumn (column, count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"New weight\\noption 2\"), new CellRendererText(), \"text\", count++);\n\t}\n\t\n\tvoid ItemToggled1(object o, ToggledArgs args) {\n\t\tItemToggled(columnBool1, columnBool2, o, args);\n\t}\n\tvoid ItemToggled2(object o, ToggledArgs args) {\n\t\tItemToggled(columnBool2, columnBool1, o, args);\n\t}\n\t\n\tvoid ItemToggled(int columnThis, int columnOther, object o, ToggledArgs args) {\n\t\tTreeIter iter;\n\t\tif (store.GetIter (out iter, new TreePath(args.Path))) \n\t\t{\n\t\t\tbool val = (bool) store.GetValue (iter, columnThis);\n\t\t\tLogB.Information (string.Format(\"toggled {0} with value {1}\", args.Path, !val));\n\t\t\tif(args.Path == \"0\") {\n\t\t\t\tif (store.GetIterFirst(out iter)) {\n\t\t\t\t\tval = (bool) store.GetValue (iter, columnThis);\n\t\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t\twhile ( store.IterNext(ref iter) ){\n\t\t\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t//usnelect \"all\" checkboxes\n\t\t\t\tstore.GetIterFirst(out iter);\n\t\t\t\tstore.SetValue (iter, columnThis, false);\n\t\t\t\tstore.SetValue (iter, columnOther, false);\n\t\t\t}\n\t\t}\n\t}\n\tprivate string createStringCalculatingKgs (double personWeightKg, double jumpWeightPercent) {\n\t\treturn jumpWeightPercent + \"% \" + \n\t\t\tConvert.ToDouble(Util.WeightFromPercentToKg(jumpWeightPercent, personWeightKg)).ToString()\n\t\t\t+ \"Kg\";\n\t}\n\tprivate string createStringCalculatingPercent (double oldPersonWeightKg, double newPersonWeightKg, double jumpWeightPercent) {\n\t\tdouble jumpInKg = Util.WeightFromPercentToKg(jumpWeightPercent, oldPersonWeightKg);\n\t\tdouble jumpPercentToNewPersonWeight = Convert.ToDouble(Util.WeightFromKgToPercent(jumpInKg, newPersonWeightKg));\n\t\treturn jumpPercentToNewPersonWeight + \"% \" + jumpInKg + \"Kg\";\n\t}\n\tprotected void fillTreeView (Gtk.TreeView tv, TreeStore store) \n\t{\n\t\t//add a string for first row (for checking or unchecking all)\n\t\tstore.AppendValues ( \"\", \"\", \"\", \"\", \"\", \"\", true, \"\", false, \"\");\n\t\t\n\t\tforeach (string jump in jumpsNormal) {\n\t\t\tstring [] myStringFull = jump.Split(new char[] {':'});\n\t\t\tstore.AppendValues (\n\t\t\t\t\tmyStringFull[1], //uniqueID\n\t\t\t\t\tsimpleString,\n\t\t\t\t\tmyStringFull[4], //type\n\t\t\t\t\tmyStringFull[5], //tf\n\t\t\t\t\tmyStringFull[6], //tf\n\t\t\t\t\tcreateStringCalculatingKgs(oldPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //old weight\n\t\t\t\t\ttrue,\n\t\t\t\t\tcreateStringCalculatingKgs(newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //new weight 1\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreateStringCalculatingPercent(oldPersonWeight, newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))) //new weight 2\n\t\t\t\t\t);\n\t\t}\n\t\tforeach (string jump in jumpsReactive) {\n\t\t\tstring [] myStringFull = jump.Split(new char[] {':'});\n\t\t\tstore.AppendValues (\n\t\t\t\t\tmyStringFull[1], //uniqueID\n\t\t\t\t\treactiveString,\n\t\t\t\t\tmyStringFull[4], //type\n\t\t\t\t\tmyStringFull[10], //tf (AVG)\n\t\t\t\t\tmyStringFull[11], //tf (AVG)\n\t\t\t\t\tcreateStringCalculatingKgs(oldPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //old weight\n\t\t\t\t\ttrue,\n\t\t\t\t\tcreateStringCalculatingKgs(newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //new weight 1\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreateStringCalculatingPercent(oldPersonWeight, newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))) //new weight 2\n\t\t\t\t\t);\n\t\t}\n\t\t \n\t}\n\tprotected void on_button_cancel_clicked (object o, EventArgs args)\n\t{\n\t\tConvertWeightWindowBox.convert_weight.Hide();\n\t\tConvertWeightWindowBox = null;\n\t}\n\t\n\tprotected void on_delete_event (object o, DeleteEventArgs args)\n\t{\n\t\tConvertWeightWindowBox.convert_weight.Hide();\n\t\tConvertWeightWindowBox = null;\n\t}\n\t\n\tprotected void on_button_accept_clicked (object o, EventArgs args)\n\t{\n\t\tGtk.TreeIter iter;\n\t\t\n\t\tint jumpID;\n\t\tbool option1;\n\t\tif (store.GetIterFirst(out iter)) {\n\t\t\t//don't catch 0 value\n\t\t\twhile ( store.IterNext(ref iter) ){\n\t\t\t\toption1 = (bool) store.GetValue (iter, columnBool1);\n\t\t\t\t//only change in database if option is 2\n\t\t\t\t//because option 1 leaves the same percent and changes Kg (and database is in %)\nNext line of code:\n", "input": "", "context": "/*\n * This file is part of ChronoJump\n *\n * ChronoJump is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or   \n *    (at your option) any later version.\n *    \n * ChronoJump is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n *    GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Copyright (C) 2004-2017   Xavier de Blas <xaviblas@gmail.com> \n */\nusing System;\nusing Gtk;\nusing Glade;\nusing GLib; //for Value\nusing System.Text; //StringBuilder\nusing System.Collections; //ArrayList\nusing Mono.Unix;\npublic class ConvertWeightWindow \n{\n\t[Widget] Gtk.Window convert_weight;\n\tstatic ConvertWeightWindow ConvertWeightWindowBox;\n\t[Widget] Gtk.TreeView treeview1;\n\t[Widget] Gtk.Label label_old_weight_value;\n\t[Widget] Gtk.Label label_new_weight_value;\n\t[Widget] Gtk.Button button_accept;\n\t[Widget] Gtk.Button button_cancel;\n\tTreeStore store;\n\tdouble oldPersonWeight;\n\tdouble newPersonWeight;\n\tstring [] jumpsNormal;\n\tstring [] jumpsReactive;\n\tint columnBool1 = 6;\n\tint columnBool2 = 8;\n\tstring simpleString;\n\tstring reactiveString;\n\t\n\tConvertWeightWindow (double oldPersonWeight, double newPersonWeight, string [] jumpsNormal, string [] jumpsReactive) {\n\t\tGlade.XML gladeXML;\n\t\tgladeXML = Glade.XML.FromAssembly (Util.GetGladePath() + \"convert_weight.glade\", \"convert_weight\", null);\n\t\tgladeXML.Autoconnect(this);\n\t\t\n\t\t//put an icon to window\n\t\tUtilGtk.IconWindow(convert_weight);\n\t\tthis.oldPersonWeight = oldPersonWeight;\n\t\tthis.newPersonWeight = newPersonWeight;\n\t\tthis.jumpsNormal = jumpsNormal;\n\t\tthis.jumpsReactive = jumpsReactive;\n\t\t\t\t\t\n\t\tsimpleString = Catalog.GetString(\"Simple\");\n\t\treactiveString = Catalog.GetString(\"Reactive\");\n\t\n\t\tcreateTreeViewWithCheckboxes(treeview1);\n\t\t\n\t\tstore = new TreeStore( \n\t\t\t\ttypeof (string), //uniqueID\n\t\t\t\ttypeof (string), //simple or reactive\n\t\t\t\ttypeof (string), //jumpType\n\t\t\t\ttypeof (string), //tf \n\t\t\t\ttypeof (string), //tc \n\t\t\t\t/* following eg of a subject of 70Kg \n\t\t\t\t * that has done a jump with an extra of 70Kg\n\t\t\t\t * and after (in same session) changes person weight to 80\n\t\t\t\t */\n\t\t\t\ttypeof (string), //weight % + weight kg (old) (eg: 100%-70Kg)\n\t\t\t\ttypeof (bool), //mark new option 1\n\t\t\t\ttypeof (string), //weight % + weight kg (new option1) (eg: 100%-80Kg)\n\t\t\t\ttypeof (bool), //mark new option 2\n\t\t\t\ttypeof (string) //weight % + weight kg (new option2) (eg: 87%-70Kg)\n\t\t\t\t);\n\t\ttreeview1.Model = store;\n\t\t\n\t\tfillTreeView( treeview1, store );\n\t}\n\tstatic public ConvertWeightWindow Show (\n\t\t\tdouble oldPersonWeight, double newPersonWeight, string [] jumpsNormal, string [] jumpsReactive)\n\t{\n\t\tif (ConvertWeightWindowBox == null) {\n\t\t\tConvertWeightWindowBox = \n\t\t\t\tnew ConvertWeightWindow (oldPersonWeight, newPersonWeight, jumpsNormal, jumpsReactive);\n\t\t}\n\t\n\t\tConvertWeightWindowBox.label_old_weight_value.Text = oldPersonWeight.ToString() + \" Kg\";\n\t\tConvertWeightWindowBox.label_new_weight_value.Text = newPersonWeight.ToString() + \" Kg\";\n\t\tConvertWeightWindowBox.convert_weight.Show ();\n\t\t\n\t\treturn ConvertWeightWindowBox;\n\t}\n\tprotected void createTreeViewWithCheckboxes (Gtk.TreeView tv) {\n\t\ttv.HeadersVisible=true;\n\t\tint count = 0;\n\t\ttv.AppendColumn ( Catalog.GetString(\"ID\"), new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"Simple\") + \" \" +\n\t\t\t\tCatalog.GetString(\"or\") + \" \" +\n\t\t\t\tCatalog.GetString(\"Reactive\")\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"Type\"), new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"TF\") \n\t\t\t\t/*\n\t\t\t\t+ \"\\n\" + \n\t\t\t\tCatalog.GetString(\"TF\") + \"(\" + \n\t\t\t\tCatalog.GetString(\"AVG\") + \")\"\n\t\t\t\t*/\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( \n\t\t\t\tCatalog.GetString(\"TC\") \n\t\t\t\t/*\n\t\t\t\t+ \"\\n\" + \n\t\t\t\tCatalog.GetString(\"TC\") + \"(\" + \n\t\t\t\tCatalog.GetString(\"AVG\") + \")\"\n\t\t\t\t*/\n\t\t\t\t, new CellRendererText(), \"text\", count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"Old weight\"), new CellRendererText(), \"text\", count++);\n\t\tCellRendererToggle crt = new CellRendererToggle();\n\t\tcrt.Visible = true;\n\t\tcrt.Activatable = true;\n\t\tcrt.Active = true;\n\t\tcrt.Toggled += ItemToggled1;\n\t\tTreeViewColumn column = new TreeViewColumn (\"\", crt, \"active\", count);\n\t\tcolumn.Clickable = true;\n\t\ttv.InsertColumn (column, count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"New weight\\noption 1\"), new CellRendererText(), \"text\", count++);\n\t\tCellRendererToggle crt2 = new CellRendererToggle();\n\t\tcrt2.Visible = true;\n\t\tcrt2.Activatable = true;\n\t\tcrt2.Active = true;\n\t\tcrt2.Toggled += ItemToggled2;\n\t\tcolumn = new TreeViewColumn (\"\", crt2, \"active\", count);\n\t\tcolumn.Clickable = true;\n\t\ttv.InsertColumn (column, count++);\n\t\ttv.AppendColumn ( Catalog.GetString(\"New weight\\noption 2\"), new CellRendererText(), \"text\", count++);\n\t}\n\t\n\tvoid ItemToggled1(object o, ToggledArgs args) {\n\t\tItemToggled(columnBool1, columnBool2, o, args);\n\t}\n\tvoid ItemToggled2(object o, ToggledArgs args) {\n\t\tItemToggled(columnBool2, columnBool1, o, args);\n\t}\n\t\n\tvoid ItemToggled(int columnThis, int columnOther, object o, ToggledArgs args) {\n\t\tTreeIter iter;\n\t\tif (store.GetIter (out iter, new TreePath(args.Path))) \n\t\t{\n\t\t\tbool val = (bool) store.GetValue (iter, columnThis);\n\t\t\tLogB.Information (string.Format(\"toggled {0} with value {1}\", args.Path, !val));\n\t\t\tif(args.Path == \"0\") {\n\t\t\t\tif (store.GetIterFirst(out iter)) {\n\t\t\t\t\tval = (bool) store.GetValue (iter, columnThis);\n\t\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t\twhile ( store.IterNext(ref iter) ){\n\t\t\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstore.SetValue (iter, columnThis, !val);\n\t\t\t\tstore.SetValue (iter, columnOther, val);\n\t\t\t\t//usnelect \"all\" checkboxes\n\t\t\t\tstore.GetIterFirst(out iter);\n\t\t\t\tstore.SetValue (iter, columnThis, false);\n\t\t\t\tstore.SetValue (iter, columnOther, false);\n\t\t\t}\n\t\t}\n\t}\n\tprivate string createStringCalculatingKgs (double personWeightKg, double jumpWeightPercent) {\n\t\treturn jumpWeightPercent + \"% \" + \n\t\t\tConvert.ToDouble(Util.WeightFromPercentToKg(jumpWeightPercent, personWeightKg)).ToString()\n\t\t\t+ \"Kg\";\n\t}\n\tprivate string createStringCalculatingPercent (double oldPersonWeightKg, double newPersonWeightKg, double jumpWeightPercent) {\n\t\tdouble jumpInKg = Util.WeightFromPercentToKg(jumpWeightPercent, oldPersonWeightKg);\n\t\tdouble jumpPercentToNewPersonWeight = Convert.ToDouble(Util.WeightFromKgToPercent(jumpInKg, newPersonWeightKg));\n\t\treturn jumpPercentToNewPersonWeight + \"% \" + jumpInKg + \"Kg\";\n\t}\n\tprotected void fillTreeView (Gtk.TreeView tv, TreeStore store) \n\t{\n\t\t//add a string for first row (for checking or unchecking all)\n\t\tstore.AppendValues ( \"\", \"\", \"\", \"\", \"\", \"\", true, \"\", false, \"\");\n\t\t\n\t\tforeach (string jump in jumpsNormal) {\n\t\t\tstring [] myStringFull = jump.Split(new char[] {':'});\n\t\t\tstore.AppendValues (\n\t\t\t\t\tmyStringFull[1], //uniqueID\n\t\t\t\t\tsimpleString,\n\t\t\t\t\tmyStringFull[4], //type\n\t\t\t\t\tmyStringFull[5], //tf\n\t\t\t\t\tmyStringFull[6], //tf\n\t\t\t\t\tcreateStringCalculatingKgs(oldPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //old weight\n\t\t\t\t\ttrue,\n\t\t\t\t\tcreateStringCalculatingKgs(newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //new weight 1\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreateStringCalculatingPercent(oldPersonWeight, newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))) //new weight 2\n\t\t\t\t\t);\n\t\t}\n\t\tforeach (string jump in jumpsReactive) {\n\t\t\tstring [] myStringFull = jump.Split(new char[] {':'});\n\t\t\tstore.AppendValues (\n\t\t\t\t\tmyStringFull[1], //uniqueID\n\t\t\t\t\treactiveString,\n\t\t\t\t\tmyStringFull[4], //type\n\t\t\t\t\tmyStringFull[10], //tf (AVG)\n\t\t\t\t\tmyStringFull[11], //tf (AVG)\n\t\t\t\t\tcreateStringCalculatingKgs(oldPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //old weight\n\t\t\t\t\ttrue,\n\t\t\t\t\tcreateStringCalculatingKgs(newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))), //new weight 1\n\t\t\t\t\tfalse,\n\t\t\t\t\tcreateStringCalculatingPercent(oldPersonWeight, newPersonWeight, Convert.ToDouble(Util.ChangeDecimalSeparator(myStringFull[8]))) //new weight 2\n\t\t\t\t\t);\n\t\t}\n\t\t \n\t}\n\tprotected void on_button_cancel_clicked (object o, EventArgs args)\n\t{\n\t\tConvertWeightWindowBox.convert_weight.Hide();\n\t\tConvertWeightWindowBox = null;\n\t}\n\t\n\tprotected void on_delete_event (object o, DeleteEventArgs args)\n\t{\n\t\tConvertWeightWindowBox.convert_weight.Hide();\n\t\tConvertWeightWindowBox = null;\n\t}\n\t\n\tprotected void on_button_accept_clicked (object o, EventArgs args)\n\t{\n\t\tGtk.TreeIter iter;\n\t\t\n\t\tint jumpID;\n\t\tbool option1;\n\t\tif (store.GetIterFirst(out iter)) {\n\t\t\t//don't catch 0 value\n\t\t\twhile ( store.IterNext(ref iter) ){\n\t\t\t\toption1 = (bool) store.GetValue (iter, columnBool1);\n\t\t\t\t//only change in database if option is 2\n\t\t\t\t//because option 1 leaves the same percent and changes Kg (and database is in %)\n", "answers": ["\t\t\t\tif(! option1) {"], "pred": "  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //  //", "length": 957, "dataset": "lcc", "language": "csharp", "all_classes": null, "_id": "54df7435e6cdeb9cf80f52a45f4c173229b57b7dfcc77ad7"}
{"prompt": "Please complete the code given below. \n/*\n * $Id: Resources.java 476419 2006-11-18 02:28:07Z niallp $\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts.validator;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.commons.validator.Arg;\nimport org.apache.commons.validator.Field;\nimport org.apache.commons.validator.Msg;\nimport org.apache.commons.validator.Validator;\nimport org.apache.commons.validator.ValidatorAction;\nimport org.apache.commons.validator.ValidatorResources;\nimport org.apache.commons.validator.Var;\nimport org.apache.struts.Globals;\nimport org.apache.struts.action.ActionMessage;\nimport org.apache.struts.action.ActionMessages;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.util.MessageResources;\nimport org.apache.struts.util.ModuleUtils;\nimport org.apache.struts.util.RequestUtils;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Locale;\n/**\n * This class helps provides some useful methods for retrieving objects from\n * different scopes of the application.\n *\n * @version $Rev: 476419 $ $Date: 2005-09-16 23:34:41 -0400 (Fri, 16 Sep 2005)\n *          $\n * @since Struts 1.1\n */\npublic class Resources {\n    /**\n     * The message resources for this package.\n     */\n    private static MessageResources sysmsgs =\n        MessageResources.getMessageResources(\n            \"org.apache.struts.validator.LocalStrings\");\n    /**\n     * <p>Commons Logging instance.</p>\n     */\n    private static Log log = LogFactory.getLog(Resources.class);\n    /**\n     * Resources key the <code>ServletContext</code> is stored under.\n     */\n    private static String SERVLET_CONTEXT_PARAM =\n        \"javax.servlet.ServletContext\";\n    /**\n     * Resources key the <code>HttpServletRequest</code> is stored under.\n     */\n    private static String HTTP_SERVLET_REQUEST_PARAM =\n        \"javax.servlet.http.HttpServletRequest\";\n    /**\n     * Resources key the <code>ActionMessages</code> is stored under.\n     */\n    private static String ACTION_MESSAGES_PARAM =\n        \"org.apache.struts.action.ActionMessages\";\n    /**\n     * Retrieve <code>ValidatorResources</code> for the current module.\n     *\n     * @param application Application Context\n     * @param request     The ServletRequest\n     */\n    public static ValidatorResources getValidatorResources(\n        ServletContext application, HttpServletRequest request) {\n        String prefix =\n            ModuleUtils.getInstance().getModuleConfig(request, application)\n                       .getPrefix();\n        return (ValidatorResources) application.getAttribute(ValidatorPlugIn.VALIDATOR_KEY\n            + prefix);\n    }\n    /**\n     * Retrieve <code>MessageResources</code> for the module.\n     *\n     * @param request the servlet request\n     */\n    public static MessageResources getMessageResources(\n        HttpServletRequest request) {\n        return (MessageResources) request.getAttribute(Globals.MESSAGES_KEY);\n    }\n    /**\n     * Retrieve <code>MessageResources</code> for the module and bundle.\n     *\n     * @param application the servlet context\n     * @param request     the servlet request\n     * @param bundle      the bundle key\n     */\n    public static MessageResources getMessageResources(\n        ServletContext application, HttpServletRequest request, String bundle) {\n        if (bundle == null) {\n            bundle = Globals.MESSAGES_KEY;\n        }\n        MessageResources resources =\n            (MessageResources) request.getAttribute(bundle);\n        if (resources == null) {\n            ModuleConfig moduleConfig =\n                ModuleUtils.getInstance().getModuleConfig(request, application);\n            resources =\n                (MessageResources) application.getAttribute(bundle\n                    + moduleConfig.getPrefix());\n        }\n        if (resources == null) {\n            resources = (MessageResources) application.getAttribute(bundle);\n        }\n        if (resources == null) {\n            throw new NullPointerException(\n                \"No message resources found for bundle: \" + bundle);\n        }\n        return resources;\n    }\n    /**\n     * Get the value of a variable.\n     *\n     * @param varName   The variable name\n     * @param field     the validator Field\n     * @param validator The Validator\n     * @param request   the servlet request\n     * @param required  Whether the variable is mandatory\n     * @return The variable's value\n     */\n    public static String getVarValue(String varName, Field field,\n        Validator validator, HttpServletRequest request, boolean required) {\n        Var var = field.getVar(varName);\n        if (var == null) {\n            String msg = sysmsgs.getMessage(\"variable.missing\", varName);\n            if (required) {\n                throw new IllegalArgumentException(msg);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(field.getProperty() + \": \" + msg);\n            }\n            return null;\n        }\n        ServletContext application =\n            (ServletContext) validator.getParameterValue(SERVLET_CONTEXT_PARAM);\n        return getVarValue(var, application, request, required);\n    }\n    /**\n     * Get the value of a variable.\n     *\n     * @param var         the validator variable\n     * @param application The ServletContext\n     * @param request     the servlet request\n     * @param required    Whether the variable is mandatory\n     * @return The variables values\n     */\n    public static String getVarValue(Var var, ServletContext application,\n        HttpServletRequest request, boolean required) {\n        String varName = var.getName();\n        String varValue = var.getValue();\n        // Non-resource variable\n        if (!var.isResource()) {\n            return varValue;\n        }\n        // Get the message resources\n        String bundle = var.getBundle();\n        MessageResources messages =\n            getMessageResources(application, request, bundle);\n        // Retrieve variable's value from message resources\n        Locale locale = RequestUtils.getUserLocale(request, null);\n        String value = messages.getMessage(locale, varValue, null);\n        // Not found in message resources\n        if ((value == null) && required) {\n            throw new IllegalArgumentException(sysmsgs.getMessage(\n                    \"variable.resource.notfound\", varName, varValue, bundle));\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Var=[\" + varName + \"], \" + \"bundle=[\" + bundle + \"], \"\n                + \"key=[\" + varValue + \"], \" + \"value=[\" + value + \"]\");\n        }\n        return value;\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param messages The Message resources\n     * @param locale   The locale.\n     * @param key      Key used to lookup the message\n     */\n    public static String getMessage(MessageResources messages, Locale locale,\n        String key) {\n        String message = null;\n        if (messages != null) {\n            message = messages.getMessage(locale, key);\n        }\n        return (message == null) ? \"\" : message;\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param request servlet request\n     * @param key     the request key\n     */\n    public static String getMessage(HttpServletRequest request, String key) {\n        MessageResources messages = getMessageResources(request);\n        return getMessage(messages, RequestUtils.getUserLocale(request, null),\n            key);\n    }\n    /**\n     * Gets the locale sensitive message based on the <code>ValidatorAction</code>\n     * message and the <code>Field</code>'s arg objects.\n     *\n     * @param messages The Message resources\n     * @param locale   The locale\n     * @param va       The Validator Action\n     * @param field    The Validator Field\n     */\n    public static String getMessage(MessageResources messages, Locale locale,\n        ValidatorAction va, Field field) {\n        String[] args = getArgs(va.getName(), messages, locale, field);\n        String msg =\n            (field.getMsg(va.getName()) != null) ? field.getMsg(va.getName())\n                                                 : va.getMsg();\n        return messages.getMessage(locale, msg, args);\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param application     the servlet context\n     * @param request         the servlet request\n     * @param defaultMessages The default Message resources\n     * @param locale          The locale\n     * @param va              The Validator Action\n     * @param field           The Validator Field\n     */\n    public static String getMessage(ServletContext application,\n        HttpServletRequest request, MessageResources defaultMessages,\n        Locale locale, ValidatorAction va, Field field) {\n        Msg msg = field.getMessage(va.getName());\n        if ((msg != null) && !msg.isResource()) {\n            return msg.getKey();\n        }\n        String msgKey = null;\n        String msgBundle = null;\n        MessageResources messages = defaultMessages;\n        if (msg == null) {\n            msgKey = va.getMsg();\n        } else {\n            msgKey = msg.getKey();\n            msgBundle = msg.getBundle();\n            if (msg.getBundle() != null) {\n                messages =\n                    getMessageResources(application, request, msg.getBundle());\n            }\n        }\n        if ((msgKey == null) || (msgKey.length() == 0)) {\n            return \"??? \" + va.getName() + \".\" + field.getProperty() + \" ???\";\n        }\n        // Get the arguments\n        Arg[] args = field.getArgs(va.getName());\n        String[] argValues =\n            getArgValues(application, request, messages, locale, args);\n        // Return the message\n        return messages.getMessage(locale, msgKey, argValues);\n    }\n    /**\n     * Gets the <code>ActionMessage</code> based on the\n     * <code>ValidatorAction</code> message and the <code>Field</code>'s arg\n     * objects.\n     * <p>\n     * <strong>Note:</strong> this method does not respect bundle information\n     * stored with the field's &lt;msg&gt; or &lt;arg&gt; elements, and localization\n     * will not work for alternative resource bundles. This method is\n     * deprecated for this reason, and you should use\n     * {@link #getActionMessage(Validator,HttpServletRequest,ValidatorAction,Field)}\n     * instead. \n     *\n     * @param request the servlet request\n     * @param va      Validator action\n     * @param field   the validator Field\n     * @deprecated Use getActionMessage(Validator, HttpServletRequest,\n     *    ValidatorAction, Field) method instead\n     */\n    public static ActionMessage getActionMessage(HttpServletRequest request,\n        ValidatorAction va, Field field) {\n        String[] args =\n            getArgs(va.getName(), getMessageResources(request),\n                RequestUtils.getUserLocale(request, null), field);\n        String msg =\n            (field.getMsg(va.getName()) != null) ? field.getMsg(va.getName())\n                                                 : va.getMsg();\n        return new ActionMessage(msg, args);\n    }\n    /**\n     * Gets the <code>ActionMessage</code> based on the\n     * <code>ValidatorAction</code> message and the <code>Field</code>'s arg\n     * objects.\n     *\n     * @param validator the Validator\n     * @param request   the servlet request\n     * @param va        Validator action\n     * @param field     the validator Field\n     */\n    public static ActionMessage getActionMessage(Validator validator,\n        HttpServletRequest request, ValidatorAction va, Field field) {\n        Msg msg = field.getMessage(va.getName());\n        if ((msg != null) && !msg.isResource()) {\n            return new ActionMessage(msg.getKey(), false);\n        }\n        String msgKey = null;\n        String msgBundle = null;\n        if (msg == null) {\n            msgKey = va.getMsg();\n        } else {\n            msgKey = msg.getKey();\n            msgBundle = msg.getBundle();\n        }\n        if ((msgKey == null) || (msgKey.length() == 0)) {\n            return new ActionMessage(\"??? \" + va.getName() + \".\"\n                + field.getProperty() + \" ???\", false);\n        }\n        ServletContext application =\n            (ServletContext) validator.getParameterValue(SERVLET_CONTEXT_PARAM);\n        MessageResources messages =\n            getMessageResources(application, request, msgBundle);\n        Locale locale = RequestUtils.getUserLocale(request, null);\n        Arg[] args = field.getArgs(va.getName());\n        String[] argValues =\n            getArgValues(application, request, messages, locale, args);\n        ActionMessage actionMessage = null;\n        if (msgBundle == null) {\n            actionMessage = new ActionMessage(msgKey, argValues);\n        } else {\n            String message = messages.getMessage(locale, msgKey, argValues);\n            actionMessage = new ActionMessage(message, false);\n        }\n        return actionMessage;\n    }\n    /**\n     * Gets the message arguments based on the current <code>ValidatorAction</code>\n     * and <code>Field</code>.\n     *\n     * @param actionName action name\n     * @param messages   message resources\n     * @param locale     the locale\n     * @param field      the validator field\n     */\n    public static String[] getArgs(String actionName,\n        MessageResources messages, Locale locale, Field field) {\n        String[] argMessages = new String[4];\n        Arg[] args =\n            new Arg[] {\n                field.getArg(actionName, 0), field.getArg(actionName, 1),\n                field.getArg(actionName, 2), field.getArg(actionName, 3)\n            };\n        for (int i = 0; i < args.length; i++) {\n            if (args[i] == null) {\n                continue;\n            }\n            if (args[i].isResource()) {\n                argMessages[i] = getMessage(messages, locale, args[i].getKey());\n            } else {\n                argMessages[i] = args[i].getKey();\n            }\n        }\n        return argMessages;\n    }\n    /**\n     * Gets the message arguments based on the current <code>ValidatorAction</code>\n     * and <code>Field</code>.\n     *\n     * @param application     the servlet context\n     * @param request         the servlet request\n     * @param defaultMessages Default message resources\n     * @param locale          the locale\n     * @param args            The arguments for the message\n     */\n    private static String[] getArgValues(ServletContext application,\n        HttpServletRequest request, MessageResources defaultMessages,\n        Locale locale, Arg[] args) {\nNext line of code:\n", "input": "", "context": "/*\n * $Id: Resources.java 476419 2006-11-18 02:28:07Z niallp $\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts.validator;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.commons.validator.Arg;\nimport org.apache.commons.validator.Field;\nimport org.apache.commons.validator.Msg;\nimport org.apache.commons.validator.Validator;\nimport org.apache.commons.validator.ValidatorAction;\nimport org.apache.commons.validator.ValidatorResources;\nimport org.apache.commons.validator.Var;\nimport org.apache.struts.Globals;\nimport org.apache.struts.action.ActionMessage;\nimport org.apache.struts.action.ActionMessages;\nimport org.apache.struts.config.ModuleConfig;\nimport org.apache.struts.util.MessageResources;\nimport org.apache.struts.util.ModuleUtils;\nimport org.apache.struts.util.RequestUtils;\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Locale;\n/**\n * This class helps provides some useful methods for retrieving objects from\n * different scopes of the application.\n *\n * @version $Rev: 476419 $ $Date: 2005-09-16 23:34:41 -0400 (Fri, 16 Sep 2005)\n *          $\n * @since Struts 1.1\n */\npublic class Resources {\n    /**\n     * The message resources for this package.\n     */\n    private static MessageResources sysmsgs =\n        MessageResources.getMessageResources(\n            \"org.apache.struts.validator.LocalStrings\");\n    /**\n     * <p>Commons Logging instance.</p>\n     */\n    private static Log log = LogFactory.getLog(Resources.class);\n    /**\n     * Resources key the <code>ServletContext</code> is stored under.\n     */\n    private static String SERVLET_CONTEXT_PARAM =\n        \"javax.servlet.ServletContext\";\n    /**\n     * Resources key the <code>HttpServletRequest</code> is stored under.\n     */\n    private static String HTTP_SERVLET_REQUEST_PARAM =\n        \"javax.servlet.http.HttpServletRequest\";\n    /**\n     * Resources key the <code>ActionMessages</code> is stored under.\n     */\n    private static String ACTION_MESSAGES_PARAM =\n        \"org.apache.struts.action.ActionMessages\";\n    /**\n     * Retrieve <code>ValidatorResources</code> for the current module.\n     *\n     * @param application Application Context\n     * @param request     The ServletRequest\n     */\n    public static ValidatorResources getValidatorResources(\n        ServletContext application, HttpServletRequest request) {\n        String prefix =\n            ModuleUtils.getInstance().getModuleConfig(request, application)\n                       .getPrefix();\n        return (ValidatorResources) application.getAttribute(ValidatorPlugIn.VALIDATOR_KEY\n            + prefix);\n    }\n    /**\n     * Retrieve <code>MessageResources</code> for the module.\n     *\n     * @param request the servlet request\n     */\n    public static MessageResources getMessageResources(\n        HttpServletRequest request) {\n        return (MessageResources) request.getAttribute(Globals.MESSAGES_KEY);\n    }\n    /**\n     * Retrieve <code>MessageResources</code> for the module and bundle.\n     *\n     * @param application the servlet context\n     * @param request     the servlet request\n     * @param bundle      the bundle key\n     */\n    public static MessageResources getMessageResources(\n        ServletContext application, HttpServletRequest request, String bundle) {\n        if (bundle == null) {\n            bundle = Globals.MESSAGES_KEY;\n        }\n        MessageResources resources =\n            (MessageResources) request.getAttribute(bundle);\n        if (resources == null) {\n            ModuleConfig moduleConfig =\n                ModuleUtils.getInstance().getModuleConfig(request, application);\n            resources =\n                (MessageResources) application.getAttribute(bundle\n                    + moduleConfig.getPrefix());\n        }\n        if (resources == null) {\n            resources = (MessageResources) application.getAttribute(bundle);\n        }\n        if (resources == null) {\n            throw new NullPointerException(\n                \"No message resources found for bundle: \" + bundle);\n        }\n        return resources;\n    }\n    /**\n     * Get the value of a variable.\n     *\n     * @param varName   The variable name\n     * @param field     the validator Field\n     * @param validator The Validator\n     * @param request   the servlet request\n     * @param required  Whether the variable is mandatory\n     * @return The variable's value\n     */\n    public static String getVarValue(String varName, Field field,\n        Validator validator, HttpServletRequest request, boolean required) {\n        Var var = field.getVar(varName);\n        if (var == null) {\n            String msg = sysmsgs.getMessage(\"variable.missing\", varName);\n            if (required) {\n                throw new IllegalArgumentException(msg);\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(field.getProperty() + \": \" + msg);\n            }\n            return null;\n        }\n        ServletContext application =\n            (ServletContext) validator.getParameterValue(SERVLET_CONTEXT_PARAM);\n        return getVarValue(var, application, request, required);\n    }\n    /**\n     * Get the value of a variable.\n     *\n     * @param var         the validator variable\n     * @param application The ServletContext\n     * @param request     the servlet request\n     * @param required    Whether the variable is mandatory\n     * @return The variables values\n     */\n    public static String getVarValue(Var var, ServletContext application,\n        HttpServletRequest request, boolean required) {\n        String varName = var.getName();\n        String varValue = var.getValue();\n        // Non-resource variable\n        if (!var.isResource()) {\n            return varValue;\n        }\n        // Get the message resources\n        String bundle = var.getBundle();\n        MessageResources messages =\n            getMessageResources(application, request, bundle);\n        // Retrieve variable's value from message resources\n        Locale locale = RequestUtils.getUserLocale(request, null);\n        String value = messages.getMessage(locale, varValue, null);\n        // Not found in message resources\n        if ((value == null) && required) {\n            throw new IllegalArgumentException(sysmsgs.getMessage(\n                    \"variable.resource.notfound\", varName, varValue, bundle));\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"Var=[\" + varName + \"], \" + \"bundle=[\" + bundle + \"], \"\n                + \"key=[\" + varValue + \"], \" + \"value=[\" + value + \"]\");\n        }\n        return value;\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param messages The Message resources\n     * @param locale   The locale.\n     * @param key      Key used to lookup the message\n     */\n    public static String getMessage(MessageResources messages, Locale locale,\n        String key) {\n        String message = null;\n        if (messages != null) {\n            message = messages.getMessage(locale, key);\n        }\n        return (message == null) ? \"\" : message;\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param request servlet request\n     * @param key     the request key\n     */\n    public static String getMessage(HttpServletRequest request, String key) {\n        MessageResources messages = getMessageResources(request);\n        return getMessage(messages, RequestUtils.getUserLocale(request, null),\n            key);\n    }\n    /**\n     * Gets the locale sensitive message based on the <code>ValidatorAction</code>\n     * message and the <code>Field</code>'s arg objects.\n     *\n     * @param messages The Message resources\n     * @param locale   The locale\n     * @param va       The Validator Action\n     * @param field    The Validator Field\n     */\n    public static String getMessage(MessageResources messages, Locale locale,\n        ValidatorAction va, Field field) {\n        String[] args = getArgs(va.getName(), messages, locale, field);\n        String msg =\n            (field.getMsg(va.getName()) != null) ? field.getMsg(va.getName())\n                                                 : va.getMsg();\n        return messages.getMessage(locale, msg, args);\n    }\n    /**\n     * Gets the <code>Locale</code> sensitive value based on the key passed\n     * in.\n     *\n     * @param application     the servlet context\n     * @param request         the servlet request\n     * @param defaultMessages The default Message resources\n     * @param locale          The locale\n     * @param va              The Validator Action\n     * @param field           The Validator Field\n     */\n    public static String getMessage(ServletContext application,\n        HttpServletRequest request, MessageResources defaultMessages,\n        Locale locale, ValidatorAction va, Field field) {\n        Msg msg = field.getMessage(va.getName());\n        if ((msg != null) && !msg.isResource()) {\n            return msg.getKey();\n        }\n        String msgKey = null;\n        String msgBundle = null;\n        MessageResources messages = defaultMessages;\n        if (msg == null) {\n            msgKey = va.getMsg();\n        } else {\n            msgKey = msg.getKey();\n            msgBundle = msg.getBundle();\n            if (msg.getBundle() != null) {\n                messages =\n                    getMessageResources(application, request, msg.getBundle());\n            }\n        }\n        if ((msgKey == null) || (msgKey.length() == 0)) {\n            return \"??? \" + va.getName() + \".\" + field.getProperty() + \" ???\";\n        }\n        // Get the arguments\n        Arg[] args = field.getArgs(va.getName());\n        String[] argValues =\n            getArgValues(application, request, messages, locale, args);\n        // Return the message\n        return messages.getMessage(locale, msgKey, argValues);\n    }\n    /**\n     * Gets the <code>ActionMessage</code> based on the\n     * <code>ValidatorAction</code> message and the <code>Field</code>'s arg\n     * objects.\n     * <p>\n     * <strong>Note:</strong> this method does not respect bundle information\n     * stored with the field's &lt;msg&gt; or &lt;arg&gt; elements, and localization\n     * will not work for alternative resource bundles. This method is\n     * deprecated for this reason, and you should use\n     * {@link #getActionMessage(Validator,HttpServletRequest,ValidatorAction,Field)}\n     * instead. \n     *\n     * @param request the servlet request\n     * @param va      Validator action\n     * @param field   the validator Field\n     * @deprecated Use getActionMessage(Validator, HttpServletRequest,\n     *    ValidatorAction, Field) method instead\n     */\n    public static ActionMessage getActionMessage(HttpServletRequest request,\n        ValidatorAction va, Field field) {\n        String[] args =\n            getArgs(va.getName(), getMessageResources(request),\n                RequestUtils.getUserLocale(request, null), field);\n        String msg =\n            (field.getMsg(va.getName()) != null) ? field.getMsg(va.getName())\n                                                 : va.getMsg();\n        return new ActionMessage(msg, args);\n    }\n    /**\n     * Gets the <code>ActionMessage</code> based on the\n     * <code>ValidatorAction</code> message and the <code>Field</code>'s arg\n     * objects.\n     *\n     * @param validator the Validator\n     * @param request   the servlet request\n     * @param va        Validator action\n     * @param field     the validator Field\n     */\n    public static ActionMessage getActionMessage(Validator validator,\n        HttpServletRequest request, ValidatorAction va, Field field) {\n        Msg msg = field.getMessage(va.getName());\n        if ((msg != null) && !msg.isResource()) {\n            return new ActionMessage(msg.getKey(), false);\n        }\n        String msgKey = null;\n        String msgBundle = null;\n        if (msg == null) {\n            msgKey = va.getMsg();\n        } else {\n            msgKey = msg.getKey();\n            msgBundle = msg.getBundle();\n        }\n        if ((msgKey == null) || (msgKey.length() == 0)) {\n            return new ActionMessage(\"??? \" + va.getName() + \".\"\n                + field.getProperty() + \" ???\", false);\n        }\n        ServletContext application =\n            (ServletContext) validator.getParameterValue(SERVLET_CONTEXT_PARAM);\n        MessageResources messages =\n            getMessageResources(application, request, msgBundle);\n        Locale locale = RequestUtils.getUserLocale(request, null);\n        Arg[] args = field.getArgs(va.getName());\n        String[] argValues =\n            getArgValues(application, request, messages, locale, args);\n        ActionMessage actionMessage = null;\n        if (msgBundle == null) {\n            actionMessage = new ActionMessage(msgKey, argValues);\n        } else {\n            String message = messages.getMessage(locale, msgKey, argValues);\n            actionMessage = new ActionMessage(message, false);\n        }\n        return actionMessage;\n    }\n    /**\n     * Gets the message arguments based on the current <code>ValidatorAction</code>\n     * and <code>Field</code>.\n     *\n     * @param actionName action name\n     * @param messages   message resources\n     * @param locale     the locale\n     * @param field      the validator field\n     */\n    public static String[] getArgs(String actionName,\n        MessageResources messages, Locale locale, Field field) {\n        String[] argMessages = new String[4];\n        Arg[] args =\n            new Arg[] {\n                field.getArg(actionName, 0), field.getArg(actionName, 1),\n                field.getArg(actionName, 2), field.getArg(actionName, 3)\n            };\n        for (int i = 0; i < args.length; i++) {\n            if (args[i] == null) {\n                continue;\n            }\n            if (args[i].isResource()) {\n                argMessages[i] = getMessage(messages, locale, args[i].getKey());\n            } else {\n                argMessages[i] = args[i].getKey();\n            }\n        }\n        return argMessages;\n    }\n    /**\n     * Gets the message arguments based on the current <code>ValidatorAction</code>\n     * and <code>Field</code>.\n     *\n     * @param application     the servlet context\n     * @param request         the servlet request\n     * @param defaultMessages Default message resources\n     * @param locale          the locale\n     * @param args            The arguments for the message\n     */\n    private static String[] getArgValues(ServletContext application,\n        HttpServletRequest request, MessageResources defaultMessages,\n        Locale locale, Arg[] args) {\n", "answers": ["        if ((args == null) || (args.length == 0)) {"], "pred": "}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n", "length": 1570, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "e42bb143aca03ffdde352e012ca3991013aa4f1018e60c8f"}
{"prompt": "Please complete the code given below. \npackage com.censoredsoftware.capitalism.data;\nimport com.censoredsoftware.capitalism.Capitalism;\nimport com.censoredsoftware.capitalism.data.util.ServerDatas;\nimport com.censoredsoftware.capitalism.data.util.TimedDatas;\nimport com.censoredsoftware.capitalism.entity.Firm;\nimport com.censoredsoftware.capitalism.entity.Person;\nimport com.censoredsoftware.censoredlib.data.ServerData;\nimport com.censoredsoftware.censoredlib.data.TimedData;\nimport com.censoredsoftware.censoredlib.helper.ConfigFile;\nimport com.google.common.collect.Maps;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.entity.Player;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentMap;\npublic class DataManager\n{\n\t// Data\n\tpublic static ConcurrentMap<String, Person> persons;\n\tpublic static ConcurrentMap<UUID, Firm> firms;\n\tpublic static ConcurrentMap<UUID, TimedData> timedData;\n\tpublic static ConcurrentMap<UUID, ServerData> serverData;\n\tprivate static ConcurrentMap<String, HashMap<String, Object>> tempData;\n\tstatic\n\t{\n\t\tfor(File file : File.values())\n\t\t\tfile.getConfigFile().loadToData();\n\t\ttempData = Maps.newConcurrentMap();\n\t}\n\tpublic static void save()\n\t{\n\t\tfor(File file : File.values())\n\t\t\tfile.getConfigFile().saveToFile();\n\t}\n\tpublic static void flushData()\n\t{\n\t\t// Kick everyone\n\t\tfor(Player player : Bukkit.getOnlinePlayers())\n\t\t\tplayer.kickPlayer(ChatColor.GREEN + \"Data has been reset, you can rejoin now.\");\n\t\t// Clear the data\n\t\tpersons.clear();\n\t\tfirms.clear();\n\t\ttimedData.clear();\n\t\ttempData.clear();\n\t\tserverData.clear();\n\t\tsave();\n\t\t// Reload the PLUGIN\n\t\tBukkit.getServer().getPluginManager().disablePlugin(Capitalism.PLUGIN);\n\t\tBukkit.getServer().getPluginManager().enablePlugin(Capitalism.PLUGIN);\n\t}\n\t/*\n\t * Temporary data\n\t */\n\tpublic static boolean hasKeyTemp(String key, String subKey)\n\t{\n\t\treturn tempData.containsKey(key) && tempData.get(key).containsKey(subKey);\n\t}\n\tpublic static Object getValueTemp(String key, String subKey)\n\t{\n\t\tif(tempData.containsKey(key)) return tempData.get(key).get(subKey);\n\t\telse return null;\n\t}\n\tpublic static void saveTemp(String key, String subKey, Object value)\n\t{\n\t\tif(!tempData.containsKey(key)) tempData.put(key, new HashMap<String, Object>());\n\t\ttempData.get(key).put(subKey, value);\n\t}\n\tpublic static void removeTemp(String key, String subKey)\n\t{\n\t\tif(tempData.containsKey(key) && tempData.get(key).containsKey(subKey)) tempData.get(key).remove(subKey);\n\t}\n\t/*\n\t * Timed data\n\t */\n\tpublic static void saveTimed(String key, String subKey, Object data, Integer seconds)\n\t{\n\t\t// Remove the data if it exists already\n\t\tTimedDatas.remove(key, subKey);\n\t\t// Create and save the timed data\n\t\tTimedData timedData = new TimedData();\n\t\ttimedData.generateId();\n\t\ttimedData.setKey(key);\n\t\ttimedData.setSubKey(subKey);\n\t\ttimedData.setData(data.toString());\n\t\ttimedData.setSeconds(seconds);\n\t\tDataManager.timedData.put(timedData.getId(), timedData);\n\t}\n\tpublic static void removeTimed(String key, String subKey)\n\t{\n\t\tTimedDatas.remove(key, subKey);\n\t}\n\tpublic static boolean hasTimed(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey) != null;\n\t}\n\tpublic static Object getTimedValue(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey).getData();\n\t}\n\tpublic static long getTimedExpiration(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey).getExpiration();\n\t}\n\t/*\n\t * Server data\n\t */\n\tpublic static void saveServerData(String key, String subKey, Object data)\n\t{\n\t\t// Remove the data if it exists already\n\t\tServerDatas.remove(key, subKey);\n\t\t// Create and save the timed data\n\t\tServerData serverData = new ServerData();\n\t\tserverData.generateId();\n\t\tserverData.setKey(key);\n\t\tserverData.setSubKey(subKey);\n\t\tserverData.setData(data.toString());\n\t\tDataManager.serverData.put(serverData.getId(), serverData);\n\t}\n\tpublic static void removeServerData(String key, String subKey)\n\t{\n\t\tServerDatas.remove(key, subKey);\n\t}\n\tpublic static boolean hasServerData(String key, String subKey)\n\t{\n\t\treturn ServerDatas.find(key, subKey) != null;\n\t}\n\tpublic static Object getServerDataValue(String key, String subKey)\n\t{\n\t\treturn ServerDatas.find(key, subKey).getData();\n\t}\n\tpublic static enum File\n\t{\n\t\tPLAYER(new ConfigFile<String, Person>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Person create(String string, ConfigurationSection conf)\n\t\t\t{\n\t\t\t\treturn new Person(string, conf);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ConcurrentMap<String, Person> getLoadedData()\n\t\t\t{\n\t\t\t\treturn DataManager.persons;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSavePath()\n\t\t\t{\n\t\t\t\treturn Capitalism.SAVE_PATH;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSaveFile()\n\t\t\t{\n\t\t\t\treturn \"persons.yml\";\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> serialize(String string)\n\t\t\t{\n\t\t\t\treturn getLoadedData().get(string).serialize();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String convertFromString(String stringId)\n\t\t\t{\n\t\t\t\treturn stringId;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void loadToData()\n\t\t\t{\n\t\t\t\tpersons = loadFromFile();\n\t\t\t}\n\t\t}), FIRM(new ConfigFile<UUID, Firm>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Firm create(UUID id, ConfigurationSection conf)\n\t\t\t{\n\t\t\t\treturn new Firm(id, conf);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ConcurrentMap<UUID, Firm> getLoadedData()\n\t\t\t{\n\t\t\t\treturn DataManager.firms;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSavePath()\n\t\t\t{\n\t\t\t\treturn Capitalism.SAVE_PATH;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSaveFile()\n\t\t\t{\n\t\t\t\treturn \"firms.yml\";\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> serialize(UUID id)\n\t\t\t{\n\t\t\t\treturn getLoadedData().get(id).serialize();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic UUID convertFromString(String stringId)\n\t\t\t{\n\t\t\t\treturn UUID.fromString(stringId);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void loadToData()\n\t\t\t{\nNext line of code:\n", "input": "", "context": "package com.censoredsoftware.capitalism.data;\nimport com.censoredsoftware.capitalism.Capitalism;\nimport com.censoredsoftware.capitalism.data.util.ServerDatas;\nimport com.censoredsoftware.capitalism.data.util.TimedDatas;\nimport com.censoredsoftware.capitalism.entity.Firm;\nimport com.censoredsoftware.capitalism.entity.Person;\nimport com.censoredsoftware.censoredlib.data.ServerData;\nimport com.censoredsoftware.censoredlib.data.TimedData;\nimport com.censoredsoftware.censoredlib.helper.ConfigFile;\nimport com.google.common.collect.Maps;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.ConfigurationSection;\nimport org.bukkit.entity.Player;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentMap;\npublic class DataManager\n{\n\t// Data\n\tpublic static ConcurrentMap<String, Person> persons;\n\tpublic static ConcurrentMap<UUID, Firm> firms;\n\tpublic static ConcurrentMap<UUID, TimedData> timedData;\n\tpublic static ConcurrentMap<UUID, ServerData> serverData;\n\tprivate static ConcurrentMap<String, HashMap<String, Object>> tempData;\n\tstatic\n\t{\n\t\tfor(File file : File.values())\n\t\t\tfile.getConfigFile().loadToData();\n\t\ttempData = Maps.newConcurrentMap();\n\t}\n\tpublic static void save()\n\t{\n\t\tfor(File file : File.values())\n\t\t\tfile.getConfigFile().saveToFile();\n\t}\n\tpublic static void flushData()\n\t{\n\t\t// Kick everyone\n\t\tfor(Player player : Bukkit.getOnlinePlayers())\n\t\t\tplayer.kickPlayer(ChatColor.GREEN + \"Data has been reset, you can rejoin now.\");\n\t\t// Clear the data\n\t\tpersons.clear();\n\t\tfirms.clear();\n\t\ttimedData.clear();\n\t\ttempData.clear();\n\t\tserverData.clear();\n\t\tsave();\n\t\t// Reload the PLUGIN\n\t\tBukkit.getServer().getPluginManager().disablePlugin(Capitalism.PLUGIN);\n\t\tBukkit.getServer().getPluginManager().enablePlugin(Capitalism.PLUGIN);\n\t}\n\t/*\n\t * Temporary data\n\t */\n\tpublic static boolean hasKeyTemp(String key, String subKey)\n\t{\n\t\treturn tempData.containsKey(key) && tempData.get(key).containsKey(subKey);\n\t}\n\tpublic static Object getValueTemp(String key, String subKey)\n\t{\n\t\tif(tempData.containsKey(key)) return tempData.get(key).get(subKey);\n\t\telse return null;\n\t}\n\tpublic static void saveTemp(String key, String subKey, Object value)\n\t{\n\t\tif(!tempData.containsKey(key)) tempData.put(key, new HashMap<String, Object>());\n\t\ttempData.get(key).put(subKey, value);\n\t}\n\tpublic static void removeTemp(String key, String subKey)\n\t{\n\t\tif(tempData.containsKey(key) && tempData.get(key).containsKey(subKey)) tempData.get(key).remove(subKey);\n\t}\n\t/*\n\t * Timed data\n\t */\n\tpublic static void saveTimed(String key, String subKey, Object data, Integer seconds)\n\t{\n\t\t// Remove the data if it exists already\n\t\tTimedDatas.remove(key, subKey);\n\t\t// Create and save the timed data\n\t\tTimedData timedData = new TimedData();\n\t\ttimedData.generateId();\n\t\ttimedData.setKey(key);\n\t\ttimedData.setSubKey(subKey);\n\t\ttimedData.setData(data.toString());\n\t\ttimedData.setSeconds(seconds);\n\t\tDataManager.timedData.put(timedData.getId(), timedData);\n\t}\n\tpublic static void removeTimed(String key, String subKey)\n\t{\n\t\tTimedDatas.remove(key, subKey);\n\t}\n\tpublic static boolean hasTimed(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey) != null;\n\t}\n\tpublic static Object getTimedValue(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey).getData();\n\t}\n\tpublic static long getTimedExpiration(String key, String subKey)\n\t{\n\t\treturn TimedDatas.find(key, subKey).getExpiration();\n\t}\n\t/*\n\t * Server data\n\t */\n\tpublic static void saveServerData(String key, String subKey, Object data)\n\t{\n\t\t// Remove the data if it exists already\n\t\tServerDatas.remove(key, subKey);\n\t\t// Create and save the timed data\n\t\tServerData serverData = new ServerData();\n\t\tserverData.generateId();\n\t\tserverData.setKey(key);\n\t\tserverData.setSubKey(subKey);\n\t\tserverData.setData(data.toString());\n\t\tDataManager.serverData.put(serverData.getId(), serverData);\n\t}\n\tpublic static void removeServerData(String key, String subKey)\n\t{\n\t\tServerDatas.remove(key, subKey);\n\t}\n\tpublic static boolean hasServerData(String key, String subKey)\n\t{\n\t\treturn ServerDatas.find(key, subKey) != null;\n\t}\n\tpublic static Object getServerDataValue(String key, String subKey)\n\t{\n\t\treturn ServerDatas.find(key, subKey).getData();\n\t}\n\tpublic static enum File\n\t{\n\t\tPLAYER(new ConfigFile<String, Person>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Person create(String string, ConfigurationSection conf)\n\t\t\t{\n\t\t\t\treturn new Person(string, conf);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ConcurrentMap<String, Person> getLoadedData()\n\t\t\t{\n\t\t\t\treturn DataManager.persons;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSavePath()\n\t\t\t{\n\t\t\t\treturn Capitalism.SAVE_PATH;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSaveFile()\n\t\t\t{\n\t\t\t\treturn \"persons.yml\";\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> serialize(String string)\n\t\t\t{\n\t\t\t\treturn getLoadedData().get(string).serialize();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String convertFromString(String stringId)\n\t\t\t{\n\t\t\t\treturn stringId;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void loadToData()\n\t\t\t{\n\t\t\t\tpersons = loadFromFile();\n\t\t\t}\n\t\t}), FIRM(new ConfigFile<UUID, Firm>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Firm create(UUID id, ConfigurationSection conf)\n\t\t\t{\n\t\t\t\treturn new Firm(id, conf);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ConcurrentMap<UUID, Firm> getLoadedData()\n\t\t\t{\n\t\t\t\treturn DataManager.firms;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSavePath()\n\t\t\t{\n\t\t\t\treturn Capitalism.SAVE_PATH;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic String getSaveFile()\n\t\t\t{\n\t\t\t\treturn \"firms.yml\";\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic Map<String, Object> serialize(UUID id)\n\t\t\t{\n\t\t\t\treturn getLoadedData().get(id).serialize();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic UUID convertFromString(String stringId)\n\t\t\t{\n\t\t\t\treturn UUID.fromString(stringId);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void loadToData()\n\t\t\t{\n", "answers": ["\t\t\t\tfirms = loadFromFile();"], "pred": "} // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //", "length": 515, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "04233bb10cad37ee372ddcc1ca95b3e2a853d217fa90929e"}
{"prompt": "Please complete the code given below. \npackage gui;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.preference.BooleanFieldEditor;\nimport org.eclipse.jface.preference.FieldEditor;\nimport org.eclipse.jface.preference.FieldEditorPreferencePage;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.IntegerFieldEditor;\nimport org.eclipse.jface.preference.PreferenceDialog;\nimport org.eclipse.jface.preference.PreferenceManager;\nimport org.eclipse.jface.preference.PreferenceNode;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.preference.PreferenceStore;\nimport org.eclipse.jface.util.IPropertyChangeListener;\nimport org.eclipse.jface.util.PropertyChangeEvent;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.graphics.Color;\nimport org.eclipse.swt.graphics.FontMetrics;\nimport org.eclipse.swt.graphics.GC;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.graphics.RGB;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport util.PmTransException;\npublic class Config extends PreferenceStore {\n\tprivate static Config instance = null;\n\t/**\n\t * Non-configurable stuff\n\t */\n\t// Config file path\n\tprivate static String CONFIG_PATH = \"./config.properties\";\n\t// State file path\n\tpublic static String STATE_PATH = \"./state.transcriber\";\n\t// Icon paths\n\tpublic static String ICON_PATH_PLAY = \"/icon/start.png\";\n\tpublic static String ICON_PATH_PAUSE = \"/icon/pause.png\";\n\tpublic static String ICON_PATH_RESTART = \"/icon/restart.png\";\n\tpublic static String ICON_PATH_OPEN_TRANSCRIPTION = \"/icon/open.png\";\n\tpublic static String ICON_PATH_OPEN_AUDIO = \"/icon/openAudio.png\";\n\tpublic static String ICON_PATH_SAVE_TRANSCRIPTION = \"/icon/save.png\";\n\tpublic static String ICON_PATH_LOOP = \"/icon/loop.png\";\n\tpublic static String ICON_PATH_ZOOM_IN = \"/icon/zoom_in.png\";\n\tpublic static String ICON_PATH_ZOOM_OUT = \"/icon/zoom_out.png\";\n\tpublic static String ICON_PATH_COPY = \"/icon/copy.png\";\n\tpublic static String ICON_PATH_CUT = \"/icon/cut.png\";\n\tpublic static String ICON_PATH_PASTE = \"/icon/paste.png\";\n\tpublic static String ICON_PATH_CROSS = \"/icon/cross.png\";\n\tpublic static String ICON_PATH_ADVANCED_SEARCH = \"/icon/advancedSearch.png\";\n\tpublic static String ICON_PATH_CHANGE_BACKGROUND_COLOR = \"/icon/changeBackgroundColor.png\";\n\tpublic static String ICON_PATH_CHANGE_FONT_COLOR = \"/icon/changeFontColor.png\";\n\tpublic static String ICON_PATH_SETTINGS = \"/icon/settings.png\";\n\tpublic static String ICON_PATH_CONTRIBUTE = \"/icon/contribute.png\";\n\tpublic static String DEFAULT_ACCELERATORS = \"cxvfosa\";\n\t// Main shell initial dimensions\n\tprivate int SHELL_HEIGHT_DEFAULT = 600;\n\tprivate int SHELL_LENGHT_DEFAULT = 600;\n\tpublic static String SHELL_HEIGHT = \"window.height\";\n\tpublic static String SHELL_LENGHT = \"window.lenght\";\n\t// Last directory paths for file dialogs\n\tprivate String LAST_OPEN_AUDIO_PATH_DEFAULT = \"\";\n\tpublic static String LAST_OPEN_AUDIO_PATH = \"last.open.audio.path\";\n\tprivate String LAST_OPEN_TEXT_PATH_DEFAULT = \"\";\n\tpublic static String LAST_OPEN_TEXT_PATH = \"last.open.text.path\";\n\t// Last directory path for the export dialog\n\tprivate String LAST_EXPORT_TRANSCRIPTION_PATH_DEFALUT = \"\";\n\tpublic static String LAST_EXPORT_TRANSCRIPTION_PATH = \"last.export.transcription.path\";\n\t// URLs\n\tpublic static String CONTRIBUTE_URL = \"https://github.com/juanerasmoe/pmTrans/wiki/Contribute-to-pmTrans\";\n\t\n\t/**\n\t * Configurable stuff\n\t */\n\t// Duration of the short rewind in seconds\n\tprivate int SHORT_REWIND_DEFAULT = 5;\n\tpublic static String SHORT_REWIND = \"short.rewind.duration\";\n\t// Duration of the long rewind in seconds\n\tprivate int LONG_REWIND_DEFAULT = 10;\n\tpublic static String LONG_REWIND = \"long.rewind.duration\";\n\t// Duration of the rewind-and-play\n\tprivate static int REWIND_AND_PLAY_DEFAULT = 2;\n\tpublic static String REWIND_AND_PLAY = \"rewind.and.play.duration\";\n\t// Max size of the previous-files list\n\tprivate static int AUDIO_FILE_CACHE_LENGHT_DEFAULT = 7;\n\tpublic static String AUDIO_FILE_CACHE_LENGHT = \"audio.file.cache.lenght\";\n\tprivate static int TEXT_FILE_CACHE_LENGHT_DEFAULT = 7;\n\tpublic static String TEXT_FILE_CACHE_LENGHT = \"text.file.cache.lenght\";\n\tprivate static int SLOW_DOWN_PLAYBACK_DEFAULT = -5;\n\tpublic static String SLOW_DOWN_PLAYBACK = \"slow.down.playback\";\n\tprivate static int SPEED_UP_PLAYBACK_DEFAULT = 5;\n\tpublic static String SPEED_UP_PLAYBACK = \"speed.up.plaback\";\n\t// Auto save\n\tprivate static boolean AUTO_SAVE_DEFAULT = true;\n\tpublic static String AUTO_SAVE = \"auto.save\";\n\tprivate static int AUTO_SAVE_TIME_DEFAULT = 2;\n\tpublic static String AUTO_SAVE_TIME = \"auto.save.time\";\n\t// Mini-mode dialog\n\tprivate static boolean SHOW_MINI_MODE_DIALOG_DEFAULT = true;\n\tpublic static String SHOW_MINI_MODE_DIALOG = \"show.mini.mode.dialog\";\n\t// Font and size\n\tprivate static String FONT_DEFAULT = \"Courier New\";\n\tpublic static String FONT = \"font\";\n\tprivate static int FONT_SIZE_DEFAULT = 10;\n\tpublic static String FONT_SIZE = \"font.size\";\n\tprivate static Color FONT_COLOR_DEFAULT = Display.getCurrent()\n\t\t\t.getSystemColor(SWT.COLOR_BLACK);\n\tpublic static String FONT_COLOR = \"font.color\";\n\tprivate static Color BACKGROUND_COLOR_DEFAULT = Display.getCurrent()\n\t\t\t.getSystemColor(SWT.COLOR_WHITE);\n\tpublic static String BACKGROUND_COLOR = \"background.color\";\n\t// CONFIGURABLE ACCELERATORS\n\tprivate String accelerators;\n\t// Pause\n\tprivate static String PAUSE_KEY_DEFAULT = \" \";\n\tpublic static String PAUSE_KEY = \"pause.key\";\n\t// Short rewind\n\tprivate static String SHORT_REWIND_KEY_DEFAULT = \"7\";\n\tpublic static String SHORT_REWIND_KEY = \"short.rewind.key\";\n\t// Long rewind\n\tprivate static String LONG_REWIND_KEY_DEFAULT = \"8\";\n\tpublic static String LONG_REWIND_KEY = \"long.rewind.key\";\n\t// Speed up\n\tprivate static String SPEED_UP_KEY_DEFAULT = \"4\";\n\tpublic static String SPEED_UP_KEY = \"speed.up.key\";\n\t// Slow down\n\tprivate static String SLOW_DOWN_KEY_DEFAULT = \"3\";\n\tpublic static String SLOW_DOWN_KEY = \"slow.down.key\";\n\t// Audio loops\n\tprivate static String AUDIO_LOOPS_KEY_DEFAULT = \"9\";\n\tpublic static String AUDIO_LOOPS_KEY = \"audio.loops.key\";\n\tpublic static String LOOP_FRECUENCY = \"loop.frecuency\";\n\tprivate static int LOOP_FRECUENCY_DEFAULT = 5;\n\tpublic static String LOOP_LENGHT = \"loop.lenght\";\n\tprivate static int LOOP_LENGHT_DEFAULT = 2;\n\t// Timestamps\n\tprivate static String TIMESTAMP_KEY_DEFAULT = \"t\";\n\tpublic static String TIMESTAMP_KEY = \"timestamp.key\";\n\tprivate Config() {\n\t\tsuper(CONFIG_PATH);\n\t\t// Set up the defaults\n\t\tsetDefault(SHORT_REWIND, SHORT_REWIND_DEFAULT);\n\t\tsetDefault(LONG_REWIND, LONG_REWIND_DEFAULT);\n\t\tsetDefault(REWIND_AND_PLAY, REWIND_AND_PLAY_DEFAULT);\n\t\tsetDefault(SHELL_HEIGHT, SHELL_HEIGHT_DEFAULT);\n\t\tsetDefault(SHELL_LENGHT, SHELL_LENGHT_DEFAULT);\n\t\tsetDefault(TEXT_FILE_CACHE_LENGHT, TEXT_FILE_CACHE_LENGHT_DEFAULT);\n\t\tsetDefault(AUDIO_FILE_CACHE_LENGHT, AUDIO_FILE_CACHE_LENGHT_DEFAULT);\n\t\tsetDefault(SLOW_DOWN_PLAYBACK, SLOW_DOWN_PLAYBACK_DEFAULT);\n\t\tsetDefault(SPEED_UP_PLAYBACK, SPEED_UP_PLAYBACK_DEFAULT);\n\t\tsetDefault(AUTO_SAVE, AUTO_SAVE_DEFAULT);\n\t\tsetDefault(AUTO_SAVE_TIME, AUTO_SAVE_TIME_DEFAULT);\n\t\tsetDefault(SHOW_MINI_MODE_DIALOG, SHOW_MINI_MODE_DIALOG_DEFAULT);\n\t\tsetDefault(FONT, FONT_DEFAULT);\n\t\tsetDefault(FONT_SIZE, FONT_SIZE_DEFAULT);\n\t\tsetDefault(FONT_COLOR, FONT_COLOR_DEFAULT);\n\t\tsetDefault(BACKGROUND_COLOR, BACKGROUND_COLOR_DEFAULT);\n\t\t// Pause\n\t\tsetDefault(PAUSE_KEY, PAUSE_KEY_DEFAULT);\n\t\t// Short rewind\n\t\tsetDefault(SHORT_REWIND_KEY, SHORT_REWIND_KEY_DEFAULT);\n\t\t// Long rewind\n\t\tsetDefault(LONG_REWIND_KEY, LONG_REWIND_KEY_DEFAULT);\n\t\t// Playback speed\n\t\tsetDefault(SPEED_UP_KEY, SPEED_UP_KEY_DEFAULT);\n\t\tsetDefault(SLOW_DOWN_KEY, SLOW_DOWN_KEY_DEFAULT);\n\t\t// Audio loops\n\t\tsetDefault(AUDIO_LOOPS_KEY, AUDIO_LOOPS_KEY_DEFAULT);\n\t\tsetDefault(LOOP_FRECUENCY, LOOP_FRECUENCY_DEFAULT);\n\t\tsetDefault(LOOP_LENGHT, LOOP_LENGHT_DEFAULT);\n\t\t// Timestamp\n\t\tsetDefault(TIMESTAMP_KEY, TIMESTAMP_KEY_DEFAULT);\n\t\t// Cache\n\t\tsetDefault(LAST_OPEN_AUDIO_PATH, LAST_OPEN_AUDIO_PATH_DEFAULT);\n\t\tsetDefault(LAST_OPEN_TEXT_PATH, LAST_OPEN_TEXT_PATH_DEFAULT);\n\t\tsetDefault(LAST_EXPORT_TRANSCRIPTION_PATH,\n\t\t\t\tLAST_EXPORT_TRANSCRIPTION_PATH_DEFALUT);\n\t\ttry {\n\t\t\tload();\n\t\t} catch (Exception e) {\n\t\t\t// The properties will start as default values\n\t\t}\n\t\tupdateAccelerators();\n\t\t// Add the listeners\n\t\taddPropertyChangeListener(new IPropertyChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void propertyChange(PropertyChangeEvent event) {\n\t\t\t\ttry {\n\t\t\t\t\tupdateAccelerators();\n\t\t\t\t\tsave();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tpublic void showConfigurationDialog(Shell parent) throws PmTransException {\n\t\t// Create the preference manager\n\t\tPreferenceManager mgr = new PreferenceManager();\n\t\t// Create the nodes\n\t\tPreferenceNode playbackNode = new PreferenceNode(\"playbackPreferences\");\n\t\tPreferencePage playbackPage = new FieldEditorPreferencePage() {\n\t\t\t@Override\n\t\t\tprotected void createFieldEditors() {\n\t\t\t\taddField(new IntegerFieldEditor(SHORT_REWIND,\n\t\t\t\t\t\t\"Short rewind duration (in sec)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LONG_REWIND,\n\t\t\t\t\t\t\"Long rewind duration (in sec)\", getFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(REWIND_AND_PLAY,\n\t\t\t\t\t\t\"Rewind-and-resume duartion duration (in sec)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LOOP_FRECUENCY,\n\t\t\t\t\t\t\"Loops frecuency (in seconds)\", getFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LOOP_LENGHT,\n\t\t\t\t\t\t\"Loop rewind lenght (in seconds)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t}\n\t\t};\n\t\tplaybackPage.setTitle(\"Playback preferences\");\n\t\tplaybackNode.setPage(playbackPage);\n\t\tPreferenceNode shortcutsNode = new PreferenceNode(\n\t\t\t\t\"shortcutsPreferences\");\n\t\tPreferencePage shortcutsPage = new FieldEditorPreferencePage() {\n\t\t\t@Override\n\t\t\tprotected void createFieldEditors() {\n\t\t\t\taddField(new ShortcutFieldEditor(SHORT_REWIND_KEY,\n\t\t\t\t\t\t\"Short rewind\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(LONG_REWIND_KEY,\n\t\t\t\t\t\t\"Long rewind\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(PAUSE_KEY, \"Pause and resume\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(AUDIO_LOOPS_KEY,\n\t\t\t\t\t\t\"Enable audio loops\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(SLOW_DOWN_KEY,\n\t\t\t\t\t\t\"Slow down audio playback\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(SPEED_UP_KEY,\n\t\t\t\t\t\t\"Speed up audio playback\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(TIMESTAMP_KEY,\n\t\t\t\t\t\t\"Insert timestamp\", getFieldEditorParent()));\n\t\t\t}\n\t\t};\n\t\tshortcutsPage.setTitle(\"Shortcuts preferences\");\n\t\tshortcutsNode.setPage(shortcutsPage);\n\t\tPreferenceNode generalNode = new PreferenceNode(\"generalPreferences\");\nNext line of code:\n", "input": "", "context": "package gui;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.preference.BooleanFieldEditor;\nimport org.eclipse.jface.preference.FieldEditor;\nimport org.eclipse.jface.preference.FieldEditorPreferencePage;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.IntegerFieldEditor;\nimport org.eclipse.jface.preference.PreferenceDialog;\nimport org.eclipse.jface.preference.PreferenceManager;\nimport org.eclipse.jface.preference.PreferenceNode;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.preference.PreferenceStore;\nimport org.eclipse.jface.util.IPropertyChangeListener;\nimport org.eclipse.jface.util.PropertyChangeEvent;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.graphics.Color;\nimport org.eclipse.swt.graphics.FontMetrics;\nimport org.eclipse.swt.graphics.GC;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.graphics.RGB;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport util.PmTransException;\npublic class Config extends PreferenceStore {\n\tprivate static Config instance = null;\n\t/**\n\t * Non-configurable stuff\n\t */\n\t// Config file path\n\tprivate static String CONFIG_PATH = \"./config.properties\";\n\t// State file path\n\tpublic static String STATE_PATH = \"./state.transcriber\";\n\t// Icon paths\n\tpublic static String ICON_PATH_PLAY = \"/icon/start.png\";\n\tpublic static String ICON_PATH_PAUSE = \"/icon/pause.png\";\n\tpublic static String ICON_PATH_RESTART = \"/icon/restart.png\";\n\tpublic static String ICON_PATH_OPEN_TRANSCRIPTION = \"/icon/open.png\";\n\tpublic static String ICON_PATH_OPEN_AUDIO = \"/icon/openAudio.png\";\n\tpublic static String ICON_PATH_SAVE_TRANSCRIPTION = \"/icon/save.png\";\n\tpublic static String ICON_PATH_LOOP = \"/icon/loop.png\";\n\tpublic static String ICON_PATH_ZOOM_IN = \"/icon/zoom_in.png\";\n\tpublic static String ICON_PATH_ZOOM_OUT = \"/icon/zoom_out.png\";\n\tpublic static String ICON_PATH_COPY = \"/icon/copy.png\";\n\tpublic static String ICON_PATH_CUT = \"/icon/cut.png\";\n\tpublic static String ICON_PATH_PASTE = \"/icon/paste.png\";\n\tpublic static String ICON_PATH_CROSS = \"/icon/cross.png\";\n\tpublic static String ICON_PATH_ADVANCED_SEARCH = \"/icon/advancedSearch.png\";\n\tpublic static String ICON_PATH_CHANGE_BACKGROUND_COLOR = \"/icon/changeBackgroundColor.png\";\n\tpublic static String ICON_PATH_CHANGE_FONT_COLOR = \"/icon/changeFontColor.png\";\n\tpublic static String ICON_PATH_SETTINGS = \"/icon/settings.png\";\n\tpublic static String ICON_PATH_CONTRIBUTE = \"/icon/contribute.png\";\n\tpublic static String DEFAULT_ACCELERATORS = \"cxvfosa\";\n\t// Main shell initial dimensions\n\tprivate int SHELL_HEIGHT_DEFAULT = 600;\n\tprivate int SHELL_LENGHT_DEFAULT = 600;\n\tpublic static String SHELL_HEIGHT = \"window.height\";\n\tpublic static String SHELL_LENGHT = \"window.lenght\";\n\t// Last directory paths for file dialogs\n\tprivate String LAST_OPEN_AUDIO_PATH_DEFAULT = \"\";\n\tpublic static String LAST_OPEN_AUDIO_PATH = \"last.open.audio.path\";\n\tprivate String LAST_OPEN_TEXT_PATH_DEFAULT = \"\";\n\tpublic static String LAST_OPEN_TEXT_PATH = \"last.open.text.path\";\n\t// Last directory path for the export dialog\n\tprivate String LAST_EXPORT_TRANSCRIPTION_PATH_DEFALUT = \"\";\n\tpublic static String LAST_EXPORT_TRANSCRIPTION_PATH = \"last.export.transcription.path\";\n\t// URLs\n\tpublic static String CONTRIBUTE_URL = \"https://github.com/juanerasmoe/pmTrans/wiki/Contribute-to-pmTrans\";\n\t\n\t/**\n\t * Configurable stuff\n\t */\n\t// Duration of the short rewind in seconds\n\tprivate int SHORT_REWIND_DEFAULT = 5;\n\tpublic static String SHORT_REWIND = \"short.rewind.duration\";\n\t// Duration of the long rewind in seconds\n\tprivate int LONG_REWIND_DEFAULT = 10;\n\tpublic static String LONG_REWIND = \"long.rewind.duration\";\n\t// Duration of the rewind-and-play\n\tprivate static int REWIND_AND_PLAY_DEFAULT = 2;\n\tpublic static String REWIND_AND_PLAY = \"rewind.and.play.duration\";\n\t// Max size of the previous-files list\n\tprivate static int AUDIO_FILE_CACHE_LENGHT_DEFAULT = 7;\n\tpublic static String AUDIO_FILE_CACHE_LENGHT = \"audio.file.cache.lenght\";\n\tprivate static int TEXT_FILE_CACHE_LENGHT_DEFAULT = 7;\n\tpublic static String TEXT_FILE_CACHE_LENGHT = \"text.file.cache.lenght\";\n\tprivate static int SLOW_DOWN_PLAYBACK_DEFAULT = -5;\n\tpublic static String SLOW_DOWN_PLAYBACK = \"slow.down.playback\";\n\tprivate static int SPEED_UP_PLAYBACK_DEFAULT = 5;\n\tpublic static String SPEED_UP_PLAYBACK = \"speed.up.plaback\";\n\t// Auto save\n\tprivate static boolean AUTO_SAVE_DEFAULT = true;\n\tpublic static String AUTO_SAVE = \"auto.save\";\n\tprivate static int AUTO_SAVE_TIME_DEFAULT = 2;\n\tpublic static String AUTO_SAVE_TIME = \"auto.save.time\";\n\t// Mini-mode dialog\n\tprivate static boolean SHOW_MINI_MODE_DIALOG_DEFAULT = true;\n\tpublic static String SHOW_MINI_MODE_DIALOG = \"show.mini.mode.dialog\";\n\t// Font and size\n\tprivate static String FONT_DEFAULT = \"Courier New\";\n\tpublic static String FONT = \"font\";\n\tprivate static int FONT_SIZE_DEFAULT = 10;\n\tpublic static String FONT_SIZE = \"font.size\";\n\tprivate static Color FONT_COLOR_DEFAULT = Display.getCurrent()\n\t\t\t.getSystemColor(SWT.COLOR_BLACK);\n\tpublic static String FONT_COLOR = \"font.color\";\n\tprivate static Color BACKGROUND_COLOR_DEFAULT = Display.getCurrent()\n\t\t\t.getSystemColor(SWT.COLOR_WHITE);\n\tpublic static String BACKGROUND_COLOR = \"background.color\";\n\t// CONFIGURABLE ACCELERATORS\n\tprivate String accelerators;\n\t// Pause\n\tprivate static String PAUSE_KEY_DEFAULT = \" \";\n\tpublic static String PAUSE_KEY = \"pause.key\";\n\t// Short rewind\n\tprivate static String SHORT_REWIND_KEY_DEFAULT = \"7\";\n\tpublic static String SHORT_REWIND_KEY = \"short.rewind.key\";\n\t// Long rewind\n\tprivate static String LONG_REWIND_KEY_DEFAULT = \"8\";\n\tpublic static String LONG_REWIND_KEY = \"long.rewind.key\";\n\t// Speed up\n\tprivate static String SPEED_UP_KEY_DEFAULT = \"4\";\n\tpublic static String SPEED_UP_KEY = \"speed.up.key\";\n\t// Slow down\n\tprivate static String SLOW_DOWN_KEY_DEFAULT = \"3\";\n\tpublic static String SLOW_DOWN_KEY = \"slow.down.key\";\n\t// Audio loops\n\tprivate static String AUDIO_LOOPS_KEY_DEFAULT = \"9\";\n\tpublic static String AUDIO_LOOPS_KEY = \"audio.loops.key\";\n\tpublic static String LOOP_FRECUENCY = \"loop.frecuency\";\n\tprivate static int LOOP_FRECUENCY_DEFAULT = 5;\n\tpublic static String LOOP_LENGHT = \"loop.lenght\";\n\tprivate static int LOOP_LENGHT_DEFAULT = 2;\n\t// Timestamps\n\tprivate static String TIMESTAMP_KEY_DEFAULT = \"t\";\n\tpublic static String TIMESTAMP_KEY = \"timestamp.key\";\n\tprivate Config() {\n\t\tsuper(CONFIG_PATH);\n\t\t// Set up the defaults\n\t\tsetDefault(SHORT_REWIND, SHORT_REWIND_DEFAULT);\n\t\tsetDefault(LONG_REWIND, LONG_REWIND_DEFAULT);\n\t\tsetDefault(REWIND_AND_PLAY, REWIND_AND_PLAY_DEFAULT);\n\t\tsetDefault(SHELL_HEIGHT, SHELL_HEIGHT_DEFAULT);\n\t\tsetDefault(SHELL_LENGHT, SHELL_LENGHT_DEFAULT);\n\t\tsetDefault(TEXT_FILE_CACHE_LENGHT, TEXT_FILE_CACHE_LENGHT_DEFAULT);\n\t\tsetDefault(AUDIO_FILE_CACHE_LENGHT, AUDIO_FILE_CACHE_LENGHT_DEFAULT);\n\t\tsetDefault(SLOW_DOWN_PLAYBACK, SLOW_DOWN_PLAYBACK_DEFAULT);\n\t\tsetDefault(SPEED_UP_PLAYBACK, SPEED_UP_PLAYBACK_DEFAULT);\n\t\tsetDefault(AUTO_SAVE, AUTO_SAVE_DEFAULT);\n\t\tsetDefault(AUTO_SAVE_TIME, AUTO_SAVE_TIME_DEFAULT);\n\t\tsetDefault(SHOW_MINI_MODE_DIALOG, SHOW_MINI_MODE_DIALOG_DEFAULT);\n\t\tsetDefault(FONT, FONT_DEFAULT);\n\t\tsetDefault(FONT_SIZE, FONT_SIZE_DEFAULT);\n\t\tsetDefault(FONT_COLOR, FONT_COLOR_DEFAULT);\n\t\tsetDefault(BACKGROUND_COLOR, BACKGROUND_COLOR_DEFAULT);\n\t\t// Pause\n\t\tsetDefault(PAUSE_KEY, PAUSE_KEY_DEFAULT);\n\t\t// Short rewind\n\t\tsetDefault(SHORT_REWIND_KEY, SHORT_REWIND_KEY_DEFAULT);\n\t\t// Long rewind\n\t\tsetDefault(LONG_REWIND_KEY, LONG_REWIND_KEY_DEFAULT);\n\t\t// Playback speed\n\t\tsetDefault(SPEED_UP_KEY, SPEED_UP_KEY_DEFAULT);\n\t\tsetDefault(SLOW_DOWN_KEY, SLOW_DOWN_KEY_DEFAULT);\n\t\t// Audio loops\n\t\tsetDefault(AUDIO_LOOPS_KEY, AUDIO_LOOPS_KEY_DEFAULT);\n\t\tsetDefault(LOOP_FRECUENCY, LOOP_FRECUENCY_DEFAULT);\n\t\tsetDefault(LOOP_LENGHT, LOOP_LENGHT_DEFAULT);\n\t\t// Timestamp\n\t\tsetDefault(TIMESTAMP_KEY, TIMESTAMP_KEY_DEFAULT);\n\t\t// Cache\n\t\tsetDefault(LAST_OPEN_AUDIO_PATH, LAST_OPEN_AUDIO_PATH_DEFAULT);\n\t\tsetDefault(LAST_OPEN_TEXT_PATH, LAST_OPEN_TEXT_PATH_DEFAULT);\n\t\tsetDefault(LAST_EXPORT_TRANSCRIPTION_PATH,\n\t\t\t\tLAST_EXPORT_TRANSCRIPTION_PATH_DEFALUT);\n\t\ttry {\n\t\t\tload();\n\t\t} catch (Exception e) {\n\t\t\t// The properties will start as default values\n\t\t}\n\t\tupdateAccelerators();\n\t\t// Add the listeners\n\t\taddPropertyChangeListener(new IPropertyChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void propertyChange(PropertyChangeEvent event) {\n\t\t\t\ttry {\n\t\t\t\t\tupdateAccelerators();\n\t\t\t\t\tsave();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tpublic void showConfigurationDialog(Shell parent) throws PmTransException {\n\t\t// Create the preference manager\n\t\tPreferenceManager mgr = new PreferenceManager();\n\t\t// Create the nodes\n\t\tPreferenceNode playbackNode = new PreferenceNode(\"playbackPreferences\");\n\t\tPreferencePage playbackPage = new FieldEditorPreferencePage() {\n\t\t\t@Override\n\t\t\tprotected void createFieldEditors() {\n\t\t\t\taddField(new IntegerFieldEditor(SHORT_REWIND,\n\t\t\t\t\t\t\"Short rewind duration (in sec)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LONG_REWIND,\n\t\t\t\t\t\t\"Long rewind duration (in sec)\", getFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(REWIND_AND_PLAY,\n\t\t\t\t\t\t\"Rewind-and-resume duartion duration (in sec)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LOOP_FRECUENCY,\n\t\t\t\t\t\t\"Loops frecuency (in seconds)\", getFieldEditorParent()));\n\t\t\t\taddField(new IntegerFieldEditor(LOOP_LENGHT,\n\t\t\t\t\t\t\"Loop rewind lenght (in seconds)\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t}\n\t\t};\n\t\tplaybackPage.setTitle(\"Playback preferences\");\n\t\tplaybackNode.setPage(playbackPage);\n\t\tPreferenceNode shortcutsNode = new PreferenceNode(\n\t\t\t\t\"shortcutsPreferences\");\n\t\tPreferencePage shortcutsPage = new FieldEditorPreferencePage() {\n\t\t\t@Override\n\t\t\tprotected void createFieldEditors() {\n\t\t\t\taddField(new ShortcutFieldEditor(SHORT_REWIND_KEY,\n\t\t\t\t\t\t\"Short rewind\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(LONG_REWIND_KEY,\n\t\t\t\t\t\t\"Long rewind\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(PAUSE_KEY, \"Pause and resume\",\n\t\t\t\t\t\tgetFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(AUDIO_LOOPS_KEY,\n\t\t\t\t\t\t\"Enable audio loops\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(SLOW_DOWN_KEY,\n\t\t\t\t\t\t\"Slow down audio playback\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(SPEED_UP_KEY,\n\t\t\t\t\t\t\"Speed up audio playback\", getFieldEditorParent()));\n\t\t\t\taddField(new ShortcutFieldEditor(TIMESTAMP_KEY,\n\t\t\t\t\t\t\"Insert timestamp\", getFieldEditorParent()));\n\t\t\t}\n\t\t};\n\t\tshortcutsPage.setTitle(\"Shortcuts preferences\");\n\t\tshortcutsNode.setPage(shortcutsPage);\n\t\tPreferenceNode generalNode = new PreferenceNode(\"generalPreferences\");\n", "answers": ["\t\tPreferencePage generalPage = new FieldEditorPreferencePage() {"], "pred": " \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\" : \"Shorts\"", "length": 925, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "36799d0d8e06fa5c217eccd67db779ab9866845eb0713e74"}
{"prompt": "Please complete the code given below. \nusing System;\nusing System.Collections.Generic;\nusing Server.Network;\nusing Server.Items;\nusing Server.Targeting;\nusing Server.Engines.PartySystem;\nnamespace Server.Spells.Fourth\n{\n\tpublic class ArchProtectionSpell : MagerySpell\n\t{\n\t\tprivate static SpellInfo m_Info = new SpellInfo(\n\t\t\t\t\"Arch Protection\", \"Vas Uus Sanct\",\n\t\t\t\tCore.AOS ? 239 : 215,\n\t\t\t\t9011,\n\t\t\t\tReagent.Garlic,\n\t\t\t\tReagent.Ginseng,\n\t\t\t\tReagent.MandrakeRoot,\n\t\t\t\tReagent.SulfurousAsh\n\t\t\t);\n\t\tpublic override SpellCircle Circle { get { return SpellCircle.Fourth; } }\n        public override void SelectTarget()\n        {\n            Caster.Target = new InternalSphereTarget(this);\n        }\n        public override void OnSphereCast()\n        {\n            if (SpellTarget != null)\n            {\n                if (SpellTarget is IPoint3D)\n                {\n                    Target((IPoint3D)SpellTarget);\n                }\n                else\n                {\n                    Caster.SendAsciiMessage(\"Invalid target\");\n                }\n            }\n            FinishSequence();\n        }\n\t    public ArchProtectionSpell( Mobile caster, Item scroll ) : base( caster, scroll, m_Info )\n\t\t{\n\t\t}\n\t\tpublic override void OnCast()\n\t\t{\n\t\t\tCaster.Target = new InternalTarget( this );\n\t\t}\n\t\tpublic void Target( IPoint3D p )\n\t\t{\n\t\t\tif ( !Caster.CanSee( p ) )\n\t\t\t{\n\t\t\t\tCaster.SendLocalizedMessage( 500237 ); // Target can not be seen.\n\t\t\t}\n            else if (!CheckLineOfSight(p))\n            {\n                this.DoFizzle();\n                Caster.SendAsciiMessage(\"Target is not in line of sight\");\n            }\n\t\t\telse if ( CheckSequence() )\n\t\t\t{\n\t\t\t\tSpellHelper.Turn( Caster, p );\n\t\t\t\tSpellHelper.GetSurfaceTop( ref p );\n\t\t\t\tList<Mobile> targets = new List<Mobile>();\n\t\t\t\tMap map = Caster.Map;\n\t\t\t\tif ( map != null )\n\t\t\t\t{\n\t\t\t\t\tIPooledEnumerable eable = map.GetMobilesInRange( new Point3D( p ), Core.AOS ? 2 : 3 );\n\t\t\t\t\tforeach ( Mobile m in eable )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( Caster.CanBeBeneficial( m, false ) )\n\t\t\t\t\t\t\ttargets.Add( m );\n\t\t\t\t\t}\n\t\t\t\t\teable.Free();\n\t\t\t\t}\n\t\t\t\tif ( Core.AOS )\n\t\t\t\t{\n\t\t\t\t\tParty party = Party.Get( Caster );\n\t\t\t\t\tfor ( int i = 0; i < targets.Count; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tMobile m = targets[i];\n\t\t\t\t\t\tif ( m == Caster || ( party != null && party.Contains( m ) ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCaster.DoBeneficial( m );\n\t\t\t\t\t\t\tSpells.Second.ProtectionSpell.Toggle( Caster, m );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEffects.PlaySound( p, Caster.Map, 0x299 );\n\t\t\t\t\tint val = (int)(Caster.Skills[SkillName.Magery].Value/10.0 + 1);\n\t\t\t\t\tif ( targets.Count > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( int i = 0; i < targets.Count; ++i )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMobile m = targets[i];\n\t\t\t\t\t\t\tif ( m.BeginAction( typeof( ArchProtectionSpell ) ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCaster.DoBeneficial( m );\n\t\t\t\t\t\t\t\tm.VirtualArmorMod += val;\n\t\t\t\t\t\t\t\tnew InternalTimer( m, Caster, val ).Start();\n\t\t\t\t\t\t\t\tm.FixedParticles( 0x375A, 9, 20, 5027, EffectLayer.Waist );\n\t\t\t\t\t\t\t\tm.PlaySound( 0x1F7 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFinishSequence();\n\t\t}\n\t\tprivate class InternalTimer : Timer\n\t\t{\n\t\t\tprivate Mobile m_Owner;\n\t\t\tprivate int m_Val;\n\t\t\tpublic InternalTimer( Mobile target, Mobile caster, int val ) : base( TimeSpan.FromSeconds( 0 ) )\n\t\t\t{\n\t\t\t\tdouble time = caster.Skills[SkillName.Magery].Value * 1.2;\n\t\t\t\tif ( time > 144 )\n\t\t\t\t\ttime = 144;\n\t\t\t\tDelay = TimeSpan.FromSeconds( time );\n\t\t\t\tPriority = TimerPriority.OneSecond;\n\t\t\t\tm_Owner = target;\n\t\t\t\tm_Val = val;\n\t\t\t}\n\t\t\tprotected override void OnTick()\n\t\t\t{\n\t\t\t\tm_Owner.EndAction( typeof( ArchProtectionSpell ) );\n\t\t\t\tm_Owner.VirtualArmorMod -= m_Val;\n\t\t\t\tif ( m_Owner.VirtualArmorMod < 0 )\n\t\t\t\t\tm_Owner.VirtualArmorMod = 0;\n\t\t\t}\n\t\t}\n        private static Dictionary<Mobile, Int32> _Table = new Dictionary<Mobile, Int32>();\n        private static void AddEntry(Mobile m, Int32 v)\n        {\n            _Table[m] = v;\n        }\n        public static void RemoveEntry(Mobile m)\n        {\n            if (_Table.ContainsKey(m))\n            {\n                int v = _Table[m];\n                _Table.Remove(m);\n                m.EndAction(typeof(ArchProtectionSpell));\n                m.VirtualArmorMod -= v;\n                if (m.VirtualArmorMod < 0)\n                    m.VirtualArmorMod = 0;\n            }\n        }\n        private class InternalSphereTarget : Target\n        {\n            private ArchProtectionSpell m_Owner;\n            public InternalSphereTarget(ArchProtectionSpell owner)\n                : base(Core.ML ? 10 : 12, true, TargetFlags.Beneficial)\n            {\n                m_Owner = owner;\n                m_Owner.Caster.SendAsciiMessage(\"Select target...\");\n            }\n            protected override void OnTarget(Mobile from, object o)\n            {\n                if (o is IPoint3D)\n                {\n                    m_Owner.SpellTarget = o;\n                    m_Owner.CastSpell();\n                }\n                else\n                {\n                    m_Owner.Caster.SendAsciiMessage(\"Invalid target\");\n                }\n            }\n            protected override void OnTargetFinish(Mobile from)\n            {\nNext line of code:\n", "input": "", "context": "using System;\nusing System.Collections.Generic;\nusing Server.Network;\nusing Server.Items;\nusing Server.Targeting;\nusing Server.Engines.PartySystem;\nnamespace Server.Spells.Fourth\n{\n\tpublic class ArchProtectionSpell : MagerySpell\n\t{\n\t\tprivate static SpellInfo m_Info = new SpellInfo(\n\t\t\t\t\"Arch Protection\", \"Vas Uus Sanct\",\n\t\t\t\tCore.AOS ? 239 : 215,\n\t\t\t\t9011,\n\t\t\t\tReagent.Garlic,\n\t\t\t\tReagent.Ginseng,\n\t\t\t\tReagent.MandrakeRoot,\n\t\t\t\tReagent.SulfurousAsh\n\t\t\t);\n\t\tpublic override SpellCircle Circle { get { return SpellCircle.Fourth; } }\n        public override void SelectTarget()\n        {\n            Caster.Target = new InternalSphereTarget(this);\n        }\n        public override void OnSphereCast()\n        {\n            if (SpellTarget != null)\n            {\n                if (SpellTarget is IPoint3D)\n                {\n                    Target((IPoint3D)SpellTarget);\n                }\n                else\n                {\n                    Caster.SendAsciiMessage(\"Invalid target\");\n                }\n            }\n            FinishSequence();\n        }\n\t    public ArchProtectionSpell( Mobile caster, Item scroll ) : base( caster, scroll, m_Info )\n\t\t{\n\t\t}\n\t\tpublic override void OnCast()\n\t\t{\n\t\t\tCaster.Target = new InternalTarget( this );\n\t\t}\n\t\tpublic void Target( IPoint3D p )\n\t\t{\n\t\t\tif ( !Caster.CanSee( p ) )\n\t\t\t{\n\t\t\t\tCaster.SendLocalizedMessage( 500237 ); // Target can not be seen.\n\t\t\t}\n            else if (!CheckLineOfSight(p))\n            {\n                this.DoFizzle();\n                Caster.SendAsciiMessage(\"Target is not in line of sight\");\n            }\n\t\t\telse if ( CheckSequence() )\n\t\t\t{\n\t\t\t\tSpellHelper.Turn( Caster, p );\n\t\t\t\tSpellHelper.GetSurfaceTop( ref p );\n\t\t\t\tList<Mobile> targets = new List<Mobile>();\n\t\t\t\tMap map = Caster.Map;\n\t\t\t\tif ( map != null )\n\t\t\t\t{\n\t\t\t\t\tIPooledEnumerable eable = map.GetMobilesInRange( new Point3D( p ), Core.AOS ? 2 : 3 );\n\t\t\t\t\tforeach ( Mobile m in eable )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( Caster.CanBeBeneficial( m, false ) )\n\t\t\t\t\t\t\ttargets.Add( m );\n\t\t\t\t\t}\n\t\t\t\t\teable.Free();\n\t\t\t\t}\n\t\t\t\tif ( Core.AOS )\n\t\t\t\t{\n\t\t\t\t\tParty party = Party.Get( Caster );\n\t\t\t\t\tfor ( int i = 0; i < targets.Count; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tMobile m = targets[i];\n\t\t\t\t\t\tif ( m == Caster || ( party != null && party.Contains( m ) ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCaster.DoBeneficial( m );\n\t\t\t\t\t\t\tSpells.Second.ProtectionSpell.Toggle( Caster, m );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEffects.PlaySound( p, Caster.Map, 0x299 );\n\t\t\t\t\tint val = (int)(Caster.Skills[SkillName.Magery].Value/10.0 + 1);\n\t\t\t\t\tif ( targets.Count > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( int i = 0; i < targets.Count; ++i )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMobile m = targets[i];\n\t\t\t\t\t\t\tif ( m.BeginAction( typeof( ArchProtectionSpell ) ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCaster.DoBeneficial( m );\n\t\t\t\t\t\t\t\tm.VirtualArmorMod += val;\n\t\t\t\t\t\t\t\tnew InternalTimer( m, Caster, val ).Start();\n\t\t\t\t\t\t\t\tm.FixedParticles( 0x375A, 9, 20, 5027, EffectLayer.Waist );\n\t\t\t\t\t\t\t\tm.PlaySound( 0x1F7 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFinishSequence();\n\t\t}\n\t\tprivate class InternalTimer : Timer\n\t\t{\n\t\t\tprivate Mobile m_Owner;\n\t\t\tprivate int m_Val;\n\t\t\tpublic InternalTimer( Mobile target, Mobile caster, int val ) : base( TimeSpan.FromSeconds( 0 ) )\n\t\t\t{\n\t\t\t\tdouble time = caster.Skills[SkillName.Magery].Value * 1.2;\n\t\t\t\tif ( time > 144 )\n\t\t\t\t\ttime = 144;\n\t\t\t\tDelay = TimeSpan.FromSeconds( time );\n\t\t\t\tPriority = TimerPriority.OneSecond;\n\t\t\t\tm_Owner = target;\n\t\t\t\tm_Val = val;\n\t\t\t}\n\t\t\tprotected override void OnTick()\n\t\t\t{\n\t\t\t\tm_Owner.EndAction( typeof( ArchProtectionSpell ) );\n\t\t\t\tm_Owner.VirtualArmorMod -= m_Val;\n\t\t\t\tif ( m_Owner.VirtualArmorMod < 0 )\n\t\t\t\t\tm_Owner.VirtualArmorMod = 0;\n\t\t\t}\n\t\t}\n        private static Dictionary<Mobile, Int32> _Table = new Dictionary<Mobile, Int32>();\n        private static void AddEntry(Mobile m, Int32 v)\n        {\n            _Table[m] = v;\n        }\n        public static void RemoveEntry(Mobile m)\n        {\n            if (_Table.ContainsKey(m))\n            {\n                int v = _Table[m];\n                _Table.Remove(m);\n                m.EndAction(typeof(ArchProtectionSpell));\n                m.VirtualArmorMod -= v;\n                if (m.VirtualArmorMod < 0)\n                    m.VirtualArmorMod = 0;\n            }\n        }\n        private class InternalSphereTarget : Target\n        {\n            private ArchProtectionSpell m_Owner;\n            public InternalSphereTarget(ArchProtectionSpell owner)\n                : base(Core.ML ? 10 : 12, true, TargetFlags.Beneficial)\n            {\n                m_Owner = owner;\n                m_Owner.Caster.SendAsciiMessage(\"Select target...\");\n            }\n            protected override void OnTarget(Mobile from, object o)\n            {\n                if (o is IPoint3D)\n                {\n                    m_Owner.SpellTarget = o;\n                    m_Owner.CastSpell();\n                }\n                else\n                {\n                    m_Owner.Caster.SendAsciiMessage(\"Invalid target\");\n                }\n            }\n            protected override void OnTargetFinish(Mobile from)\n            {\n", "answers": ["                if (m_Owner.SpellTarget == null)"], "pred": " }\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell();\n  m_Owner.CastSpell", "length": 538, "dataset": "lcc", "language": "csharp", "all_classes": null, "_id": "82560c22f3648e5086523b10f22179edb1aebdc379fdfaa5"}
{"prompt": "Please complete the code given below. \n# orm/session.py\n# Copyright (C) 2005-2013 the SQLAlchemy authors and contributors <see AUTHORS file>\n#\n# This module is part of SQLAlchemy and is released under\n# the MIT License: http://www.opensource.org/licenses/mit-license.php\n\"\"\"Provides the Session class and related utilities.\"\"\"\nimport weakref\nfrom itertools import chain\nfrom sqlalchemy import util, sql, engine, log, exc as sa_exc\nfrom sqlalchemy.sql import util as sql_util, expression\nfrom sqlalchemy.orm import (\n    SessionExtension, attributes, exc, query, unitofwork, util as mapperutil, state\n    )\nfrom sqlalchemy.orm.util import object_mapper as _object_mapper\nfrom sqlalchemy.orm.util import class_mapper as _class_mapper\nfrom sqlalchemy.orm.util import (\n    _class_to_mapper, _state_mapper,\n    )\nfrom sqlalchemy.orm.mapper import Mapper, _none_set\nfrom sqlalchemy.orm.unitofwork import UOWTransaction\nfrom sqlalchemy.orm import identity\nfrom sqlalchemy import event\nfrom sqlalchemy.orm.events import SessionEvents\nimport sys\n__all__ = ['Session', 'SessionTransaction', 'SessionExtension']\ndef sessionmaker(bind=None, class_=None, autoflush=True, autocommit=False,\n                 expire_on_commit=True, **kwargs):\n    \"\"\"Generate a custom-configured :class:`.Session` class.\n    The returned object is a subclass of :class:`.Session`, which, when instantiated\n    with no arguments, uses the keyword arguments configured here as its\n    constructor arguments.\n    It is intended that the :func:`.sessionmaker()` function be called within the\n    global scope of an application, and the returned class be made available\n    to the rest of the application as the single class used to instantiate\n    sessions.\n    e.g.::\n        # global scope\n        Session = sessionmaker(autoflush=False)\n        # later, in a local scope, create and use a session:\n        sess = Session()\n    Any keyword arguments sent to the constructor itself will override the\n    \"configured\" keywords::\n        Session = sessionmaker()\n        # bind an individual session to a connection\n        sess = Session(bind=connection)\n    The class also includes a special classmethod ``configure()``, which\n    allows additional configurational options to take place after the custom\n    ``Session`` class has been generated.  This is useful particularly for\n    defining the specific ``Engine`` (or engines) to which new instances of\n    ``Session`` should be bound::\n        Session = sessionmaker()\n        Session.configure(bind=create_engine('sqlite:///foo.db'))\n        sess = Session()\n    For options, see the constructor options for :class:`.Session`.\n    \"\"\"\n    kwargs['bind'] = bind\n    kwargs['autoflush'] = autoflush\n    kwargs['autocommit'] = autocommit\n    kwargs['expire_on_commit'] = expire_on_commit\n    if class_ is None:\n        class_ = Session\n    class Sess(object):\n        def __init__(self, **local_kwargs):\n            for k in kwargs:\n                local_kwargs.setdefault(k, kwargs[k])\n            super(Sess, self).__init__(**local_kwargs)\n        @classmethod\n        def configure(self, **new_kwargs):\n            \"\"\"(Re)configure the arguments for this sessionmaker.\n            e.g.::\n                Session = sessionmaker()\n                Session.configure(bind=create_engine('sqlite://'))\n            \"\"\"\n            kwargs.update(new_kwargs)\n    return type(\"SessionMaker\", (Sess, class_), {})\nclass SessionTransaction(object):\n    \"\"\"A :class:`.Session`-level transaction.\n    :class:`.SessionTransaction` is a mostly behind-the-scenes object\n    not normally referenced directly by application code.   It coordinates\n    among multiple :class:`.Connection` objects, maintaining a database\n    transaction for each one individually, committing or rolling them\n    back all at once.   It also provides optional two-phase commit behavior\n    which can augment this coordination operation.\n    The :attr:`.Session.transaction` attribute of :class:`.Session` refers to the\n    current :class:`.SessionTransaction` object in use, if any.\n    A :class:`.SessionTransaction` is associated with a :class:`.Session`\n    in its default mode of ``autocommit=False`` immediately, associated\n    with no database connections.  As the :class:`.Session` is called upon\n    to emit SQL on behalf of various :class:`.Engine` or :class:`.Connection`\n    objects, a corresponding :class:`.Connection` and associated :class:`.Transaction`\n    is added to a collection within the :class:`.SessionTransaction` object,\n    becoming one of the connection/transaction pairs maintained by the\n    :class:`.SessionTransaction`.\n    The lifespan of the :class:`.SessionTransaction` ends when the\n    :meth:`.Session.commit`, :meth:`.Session.rollback` or :meth:`.Session.close`\n    methods are called.  At this point, the :class:`.SessionTransaction` removes\n    its association with its parent :class:`.Session`.   A :class:`.Session`\n    that is in ``autocommit=False`` mode will create a new\n    :class:`.SessionTransaction` to replace it immediately, whereas a\n    :class:`.Session` that's in ``autocommit=True``\n    mode will remain without a :class:`.SessionTransaction` until the\n    :meth:`.Session.begin` method is called.\n    Another detail of :class:`.SessionTransaction` behavior is that it is\n    capable of \"nesting\".  This means that the :meth:`.begin` method can\n    be called while an existing :class:`.SessionTransaction` is already present,\n    producing a new :class:`.SessionTransaction` that temporarily replaces\n    the parent :class:`.SessionTransaction`.   When a :class:`.SessionTransaction`\n    is produced as nested, it assigns itself to the :attr:`.Session.transaction`\n    attribute.  When it is ended via :meth:`.Session.commit` or :meth:`.Session.rollback`,\n    it restores its parent :class:`.SessionTransaction` back onto the\n    :attr:`.Session.transaction` attribute.  The\n    behavior is effectively a stack, where :attr:`.Session.transaction` refers\n    to the current head of the stack.\n    The purpose of this stack is to allow nesting of :meth:`.rollback` or\n    :meth:`.commit` calls in context with various flavors of :meth:`.begin`.\n    This nesting behavior applies to when :meth:`.Session.begin_nested`\n    is used to emit a SAVEPOINT transaction, and is also used to produce\n    a so-called \"subtransaction\" which allows a block of code to use a\n    begin/rollback/commit sequence regardless of whether or not its enclosing\n    code block has begun a transaction.  The :meth:`.flush` method, whether called\n    explicitly or via autoflush, is the primary consumer of the \"subtransaction\"\n    feature, in that it wishes to guarantee that it works within in a transaction block\n    regardless of whether or not the :class:`.Session` is in transactional mode\n    when the method is called.\n    See also:\n    :meth:`.Session.rollback`\n    :meth:`.Session.commit`\n    :meth:`.Session.begin`\n    :meth:`.Session.begin_nested`\n    :attr:`.Session.is_active`\n    :meth:`.SessionEvents.after_commit`\n    :meth:`.SessionEvents.after_rollback`\n    :meth:`.SessionEvents.after_soft_rollback`\n    \"\"\"\n    _rollback_exception = None\n    def __init__(self, session, parent=None, nested=False):\n        self.session = session\n        self._connections = {}\n        self._parent = parent\n        self.nested = nested\n        self._active = True\n        self._prepared = False\n        if not parent and nested:\n            raise sa_exc.InvalidRequestError(\n                \"Can't start a SAVEPOINT transaction when no existing \"\n                \"transaction is in progress\")\n        if self.session._enable_transaction_accounting:\n            self._take_snapshot()\n    @property\n    def is_active(self):\n        return self.session is not None and self._active\n    def _assert_is_active(self):\n        self._assert_is_open()\n        if not self._active:\n            if self._rollback_exception:\n                raise sa_exc.InvalidRequestError(\n                    \"This Session's transaction has been rolled back \"\n                    \"due to a previous exception during flush.\"\n                    \" To begin a new transaction with this Session, \"\n                    \"first issue Session.rollback().\"\n                    \" Original exception was: %s\"\n                    % self._rollback_exception\n                )\n            else:\n                raise sa_exc.InvalidRequestError(\n                    \"This Session's transaction has been rolled back \"\n                    \"by a nested rollback() call.  To begin a new \"\n                    \"transaction, issue Session.rollback() first.\"\n                    )\n    def _assert_is_open(self, error_msg=\"The transaction is closed\"):\n        if self.session is None:\n            raise sa_exc.ResourceClosedError(error_msg)\n    @property\n    def _is_transaction_boundary(self):\n        return self.nested or not self._parent\n    def connection(self, bindkey, **kwargs):\n        self._assert_is_active()\n        engine = self.session.get_bind(bindkey, **kwargs)\n        return self._connection_for_bind(engine)\n    def _begin(self, nested=False):\n        self._assert_is_active()\n        return SessionTransaction(\n            self.session, self, nested=nested)\n    def _iterate_parents(self, upto=None):\n        if self._parent is upto:\n            return (self,)\n        else:\n            if self._parent is None:\n                raise sa_exc.InvalidRequestError(\n                    \"Transaction %s is not on the active transaction list\" % (\n                    upto))\n            return (self,) + self._parent._iterate_parents(upto)\n    def _take_snapshot(self):\n        if not self._is_transaction_boundary:\n            self._new = self._parent._new\n            self._deleted = self._parent._deleted\n            self._key_switches = self._parent._key_switches\n            return\n        if not self.session._flushing:\n            self.session.flush()\n        self._new = weakref.WeakKeyDictionary()\n        self._deleted = weakref.WeakKeyDictionary()\n        self._key_switches = weakref.WeakKeyDictionary()\n    def _restore_snapshot(self):\n        assert self._is_transaction_boundary\n        for s in set(self._new).union(self.session._new):\n            self.session._expunge_state(s)\n            if s.key:\n                del s.key\n        for s, (oldkey, newkey) in self._key_switches.items():\n            self.session.identity_map.discard(s)\n            s.key = oldkey\n            self.session.identity_map.replace(s)\n        for s in set(self._deleted).union(self.session._deleted):\n            if s.deleted:\n                #assert s in self._deleted\n                del s.deleted\n            self.session._update_impl(s, discard_existing=True)\n        assert not self.session._deleted\n        for s in self.session.identity_map.all_states():\n            s.expire(s.dict, self.session.identity_map._modified)\n    def _remove_snapshot(self):\n        assert self._is_transaction_boundary\n        if not self.nested and self.session.expire_on_commit:\n            for s in self.session.identity_map.all_states():\n                s.expire(s.dict, self.session.identity_map._modified)\n    def _connection_for_bind(self, bind):\n        self._assert_is_active()\n        if bind in self._connections:\n            return self._connections[bind][0]\n        if self._parent:\n            conn = self._parent._connection_for_bind(bind)\n            if not self.nested:\n                return conn\n        else:\n            if isinstance(bind, engine.Connection):\n                conn = bind\n                if conn.engine in self._connections:\n                    raise sa_exc.InvalidRequestError(\n                        \"Session already has a Connection associated for the \"\n                        \"given Connection's Engine\")\n            else:\n                conn = bind.contextual_connect()\n        if self.session.twophase and self._parent is None:\n            transaction = conn.begin_twophase()\n        elif self.nested:\n            transaction = conn.begin_nested()\n        else:\n            transaction = conn.begin()\n        self._connections[conn] = self._connections[conn.engine] = \\\n          (conn, transaction, conn is not bind)\n        self.session.dispatch.after_begin(self.session, self, conn)\n        return conn\n    def prepare(self):\n        if self._parent is not None or not self.session.twophase:\n            raise sa_exc.InvalidRequestError(\n                \"Only root two phase transactions of can be prepared\")\n        self._prepare_impl()\n    def _prepare_impl(self):\n        self._assert_is_active()\n        if self._parent is None or self.nested:\n            self.session.dispatch.before_commit(self.session)\n        stx = self.session.transaction\n        if stx is not self:\n            for subtransaction in stx._iterate_parents(upto=self):\n                subtransaction.commit()\n        if not self.session._flushing:\n            for _flush_guard in xrange(100):\n                if self.session._is_clean():\n                    break\n                self.session.flush()\n            else:\n                raise exc.FlushError(\n                        \"Over 100 subsequent flushes have occurred within \"\n                        \"session.commit() - is an after_flush() hook \"\n                        \"creating new objects?\")\n        if self._parent is None and self.session.twophase:\n            try:\n                for t in set(self._connections.values()):\n                    t[1].prepare()\n            except:\n                self.rollback()\n                raise\n        self._deactivate()\n        self._prepared = True\n    def commit(self):\n        self._assert_is_open()\n        if not self._prepared:\n            self._prepare_impl()\n        if self._parent is None or self.nested:\n            for t in set(self._connections.values()):\n                t[1].commit()\n            self.session.dispatch.after_commit(self.session)\n            if self.session._enable_transaction_accounting:\n                self._remove_snapshot()\n        self.close()\n        return self._parent\n    def rollback(self, _capture_exception=False):\n        self._assert_is_open()\n        stx = self.session.transaction\n        if stx is not self:\n            for subtransaction in stx._iterate_parents(upto=self):\n                subtransaction.close()\n        if self.is_active or self._prepared:\n            for transaction in self._iterate_parents():\n                if transaction._parent is None or transaction.nested:\n                    transaction._rollback_impl()\n                    transaction._deactivate()\n                    break\n                else:\n                    transaction._deactivate()\n        sess = self.session\n        if self.session._enable_transaction_accounting and \\\n            not sess._is_clean():\n            # if items were added, deleted, or mutated\n            # here, we need to re-restore the snapshot\n            util.warn(\n                    \"Session's state has been changed on \"\n                    \"a non-active transaction - this state \"\n                    \"will be discarded.\")\n            self._restore_snapshot()\n        self.close()\n        if self._parent and _capture_exception:\n            self._parent._rollback_exception = sys.exc_info()[1]\n        sess.dispatch.after_soft_rollback(sess, self)\n        return self._parent\n    def _rollback_impl(self):\n        for t in set(self._connections.values()):\n            t[1].rollback()\n        if self.session._enable_transaction_accounting:\n            self._restore_snapshot()\n        self.session.dispatch.after_rollback(self.session)\n    def _deactivate(self):\n        self._active = False\n    def close(self):\n        self.session.transaction = self._parent\n        if self._parent is None:\n            for connection, transaction, autoclose in \\\n                set(self._connections.values()):\n                if autoclose:\n                    connection.close()\n                else:\n                    transaction.close()\n            if not self.session.autocommit:\n                self.session.begin()\n        self._deactivate()\n        self.session = None\n        self._connections = None\n    def __enter__(self):\n        return self\n    def __exit__(self, type, value, traceback):\n        self._assert_is_open(\"Cannot end transaction context. The transaction \"\n                                    \"was closed from within the context\")\n        if self.session.transaction is None:\n            return\n        if type is None:\n            try:\n                self.commit()\n            except:\n                self.rollback()\n                raise\n        else:\n            self.rollback()\nclass Session(object):\n    \"\"\"Manages persistence operations for ORM-mapped objects.\n    The Session's usage paradigm is described at :ref:`session_toplevel`.\n    \"\"\"\n    public_methods = (\n        '__contains__', '__iter__', 'add', 'add_all', 'begin', 'begin_nested',\n        'close', 'commit', 'connection', 'delete', 'execute', 'expire',\n        'expire_all', 'expunge', 'expunge_all', 'flush', 'get_bind',\n        'is_modified',\n        'merge', 'query', 'refresh', 'rollback',\n        'scalar')\n    def __init__(self, bind=None, autoflush=True, expire_on_commit=True,\n                _enable_transaction_accounting=True,\n                 autocommit=False, twophase=False,\n                 weak_identity_map=True, binds=None, extension=None,\n                 query_cls=query.Query):\n        \"\"\"Construct a new Session.\n        See also the :func:`.sessionmaker` function which is used to\n        generate a :class:`.Session`-producing callable with a given\n        set of arguments.\n        :param autocommit: Defaults to ``False``. When ``True``, the ``Session``\n          does not keep a persistent transaction running, and will acquire\n          connections from the engine on an as-needed basis, returning them\n          immediately after their use. Flushes will begin and commit (or possibly\n          rollback) their own transaction if no transaction is present. When using\n          this mode, the `session.begin()` method may be used to begin a\n          transaction explicitly.\n          Leaving it on its default value of ``False`` means that the ``Session``\n          will acquire a connection and begin a transaction the first time it is\n          used, which it will maintain persistently until ``rollback()``,\n          ``commit()``, or ``close()`` is called. When the transaction is released\n          by any of these methods, the ``Session`` is ready for the next usage,\n          which will again acquire and maintain a new connection/transaction.\n        :param autoflush: When ``True``, all query operations will issue a\n           ``flush()`` call to this ``Session`` before proceeding. This is a\n           convenience feature so that ``flush()`` need not be called repeatedly\n           in order for database queries to retrieve results. It's typical that\n           ``autoflush`` is used in conjunction with ``autocommit=False``. In this\n           scenario, explicit calls to ``flush()`` are rarely needed; you usually\n           only need to call ``commit()`` (which flushes) to finalize changes.\n        :param bind: An optional ``Engine`` or ``Connection`` to which this\n           ``Session`` should be bound. When specified, all SQL operations\n           performed by this session will execute via this connectable.\n        :param binds: An optional dictionary which contains more granular \"bind\"\n           information than the ``bind`` parameter provides. This dictionary can\n           map individual ``Table`` instances as well as ``Mapper`` instances to\n           individual ``Engine`` or ``Connection`` objects. Operations which\n           proceed relative to a particular ``Mapper`` will consult this\n           dictionary for the direct ``Mapper`` instance as well as the mapper's\n           ``mapped_table`` attribute in order to locate an connectable to use.\n           The full resolution is described in the ``get_bind()`` method of\n           ``Session``. Usage looks like::\n            Session = sessionmaker(binds={\n                SomeMappedClass: create_engine('postgresql://engine1'),\n                somemapper: create_engine('postgresql://engine2'),\n                some_table: create_engine('postgresql://engine3'),\n                })\n          Also see the :meth:`.Session.bind_mapper` and :meth:`.Session.bind_table` methods.\n        :param \\class_: Specify an alternate class other than\n           ``sqlalchemy.orm.session.Session`` which should be used by the returned\n           class. This is the only argument that is local to the\n           ``sessionmaker()`` function, and is not sent directly to the\n           constructor for ``Session``.\n        :param _enable_transaction_accounting:  Defaults to ``True``.  A\n           legacy-only flag which when ``False`` disables *all* 0.5-style object\n           accounting on transaction boundaries, including auto-expiry of\n           instances on rollback and commit, maintenance of the \"new\" and\n           \"deleted\" lists upon rollback, and autoflush of pending changes upon\n           begin(), all of which are interdependent.\n        :param expire_on_commit:  Defaults to ``True``. When ``True``, all\n           instances will be fully expired after each ``commit()``, so that all\n           attribute/object access subsequent to a completed transaction will load\n           from the most recent database state.\n        :param extension: An optional\n           :class:`~.SessionExtension` instance, or a list\n           of such instances, which will receive pre- and post- commit and flush\n           events, as well as a post-rollback event. **Deprecated.**\n           Please see :class:`.SessionEvents`.\n        :param query_cls:  Class which should be used to create new Query objects,\n           as returned by the ``query()`` method. Defaults to\n           :class:`~sqlalchemy.orm.query.Query`.\n        :param twophase:  When ``True``, all transactions will be started as\n            a \"two phase\" transaction, i.e. using the \"two phase\" semantics\n            of the database in use along with an XID.  During a ``commit()``,\n            after ``flush()`` has been issued for all attached databases, the\n            ``prepare()`` method on each database's ``TwoPhaseTransaction`` will\n            be called. This allows each database to roll back the entire\n            transaction, before each transaction is committed.\n        :param weak_identity_map:  Defaults to ``True`` - when set to\n           ``False``, objects placed in the :class:`.Session` will be\n           strongly referenced until explicitly removed or the\n           :class:`.Session` is closed.  **Deprecated** - this option\n           is obsolete.\n        \"\"\"\n        if weak_identity_map:\n            self._identity_cls = identity.WeakInstanceDict\n        else:\n            util.warn_deprecated(\"weak_identity_map=False is deprecated.  \"\n                                    \"This feature is not needed.\")\n            self._identity_cls = identity.StrongInstanceDict\n        self.identity_map = self._identity_cls()\n        self._new = {}   # InstanceState->object, strong refs object\n        self._deleted = {}  # same\n        self.bind = bind\n        self.__binds = {}\n        self._flushing = False\n        self.transaction = None\n        self.hash_key = _new_sessionid()\n        self.autoflush = autoflush\n        self.autocommit = autocommit\n        self.expire_on_commit = expire_on_commit\n        self._enable_transaction_accounting = _enable_transaction_accounting\n        self.twophase = twophase\n        self._query_cls = query_cls\n        if extension:\n            for ext in util.to_list(extension):\n                SessionExtension._adapt_listener(self, ext)\n        if binds is not None:\n            for mapperortable, bind in binds.iteritems():\n                if isinstance(mapperortable, (type, Mapper)):\n                    self.bind_mapper(mapperortable, bind)\n                else:\n                    self.bind_table(mapperortable, bind)\n        if not self.autocommit:\n            self.begin()\n        _sessions[self.hash_key] = self\n    dispatch = event.dispatcher(SessionEvents)\n    connection_callable = None\n    transaction = None\n    \"\"\"The current active or inactive :class:`.SessionTransaction`.\"\"\"\n    def begin(self, subtransactions=False, nested=False):\n        \"\"\"Begin a transaction on this Session.\n        If this Session is already within a transaction, either a plain\n        transaction or nested transaction, an error is raised, unless\n        ``subtransactions=True`` or ``nested=True`` is specified.\n        The ``subtransactions=True`` flag indicates that this :meth:`~.Session.begin`\n        can create a subtransaction if a transaction is already in progress.\n        For documentation on subtransactions, please see :ref:`session_subtransactions`.\n        The ``nested`` flag begins a SAVEPOINT transaction and is equivalent\n        to calling :meth:`~.Session.begin_nested`. For documentation on SAVEPOINT\n        transactions, please see :ref:`session_begin_nested`.\n        \"\"\"\n        if self.transaction is not None:\n            if subtransactions or nested:\n                self.transaction = self.transaction._begin(\n                                        nested=nested)\n            else:\n                raise sa_exc.InvalidRequestError(\n                    \"A transaction is already begun.  Use subtransactions=True \"\n                    \"to allow subtransactions.\")\n        else:\n            self.transaction = SessionTransaction(\n                self, nested=nested)\n        return self.transaction  # needed for __enter__/__exit__ hook\n    def begin_nested(self):\n        \"\"\"Begin a `nested` transaction on this Session.\n        The target database(s) must support SQL SAVEPOINTs or a\n        SQLAlchemy-supported vendor implementation of the idea.\n        For documentation on SAVEPOINT\n        transactions, please see :ref:`session_begin_nested`.\n        \"\"\"\n        return self.begin(nested=True)\n    def rollback(self):\n        \"\"\"Rollback the current transaction in progress.\n        If no transaction is in progress, this method is a pass-through.\n        This method rolls back the current transaction or nested transaction\n        regardless of subtransactions being in effect.  All subtransactions up\n        to the first real transaction are closed.  Subtransactions occur when\n        begin() is called multiple times.\n        \"\"\"\n        if self.transaction is None:\n            pass\n        else:\n            self.transaction.rollback()\n    def commit(self):\n        \"\"\"Flush pending changes and commit the current transaction.\n        If no transaction is in progress, this method raises an\n        InvalidRequestError.\n        By default, the :class:`.Session` also expires all database\n        loaded state on all ORM-managed attributes after transaction commit.\n        This so that subsequent operations load the most recent\n        data from the database.   This behavior can be disabled using\n        the ``expire_on_commit=False`` option to :func:`.sessionmaker` or\n        the :class:`.Session` constructor.\n        If a subtransaction is in effect (which occurs when begin() is called\n        multiple times), the subtransaction will be closed, and the next call\n        to ``commit()`` will operate on the enclosing transaction.\n        For a session configured with autocommit=False, a new transaction will\n        be begun immediately after the commit, but note that the newly begun\n        transaction does *not* use any connection resources until the first\n        SQL is actually emitted.\n        \"\"\"\n        if self.transaction is None:\n            if not self.autocommit:\n                self.begin()\n            else:\n                raise sa_exc.InvalidRequestError(\"No transaction is begun.\")\n        self.transaction.commit()\n    def prepare(self):\n        \"\"\"Prepare the current transaction in progress for two phase commit.\n        If no transaction is in progress, this method raises an\n        InvalidRequestError.\n        Only root transactions of two phase sessions can be prepared. If the\n        current transaction is not such, an InvalidRequestError is raised.\n        \"\"\"\n        if self.transaction is None:\n            if not self.autocommit:\n                self.begin()\n            else:\n                raise sa_exc.InvalidRequestError(\"No transaction is begun.\")\n        self.transaction.prepare()\n    def connection(self, mapper=None, clause=None,\n                        bind=None,\n                        close_with_result=False,\n                        **kw):\n        \"\"\"Return a :class:`.Connection` object corresponding to this\n        :class:`.Session` object's transactional state.\n        If this :class:`.Session` is configured with ``autocommit=False``,\n        either the :class:`.Connection` corresponding to the current transaction\n        is returned, or if no transaction is in progress, a new one is begun\n        and the :class:`.Connection` returned (note that no transactional state\n        is established with the DBAPI until the first SQL statement is emitted).\n        Alternatively, if this :class:`.Session` is configured with ``autocommit=True``,\n        an ad-hoc :class:`.Connection` is returned using :meth:`.Engine.contextual_connect`\n        on the underlying :class:`.Engine`.\n        Ambiguity in multi-bind or unbound :class:`.Session` objects can be resolved through\n        any of the optional keyword arguments.   This ultimately makes usage of the\n        :meth:`.get_bind` method for resolution.\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes precedence\n          over ``mapper``, ``clause``.\n        :param mapper:\n          Optional :func:`.mapper` mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause``.\n        :param clause:\n            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,\n            :func:`~.sql.expression.text`,\n            etc.) which will be used to locate a bind, if a bind\n            cannot otherwise be identified.\n        :param close_with_result: Passed to :meth:`Engine.connect`, indicating\n          the :class:`.Connection` should be considered \"single use\", automatically\n          closing when the first result set is closed.  This flag only has\n          an effect if this :class:`.Session` is configured with ``autocommit=True``\n          and does not already have a  transaction in progress.\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`get_bind()`,\n          allowing additional arguments to be passed to custom\n          implementations of :meth:`get_bind`.\n        \"\"\"\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n        return self._connection_for_bind(bind,\n                                        close_with_result=close_with_result)\n    def _connection_for_bind(self, engine, **kwargs):\n        if self.transaction is not None:\n            return self.transaction._connection_for_bind(engine)\n        else:\n            return engine.contextual_connect(**kwargs)\n    def execute(self, clause, params=None, mapper=None, bind=None, **kw):\n        \"\"\"Execute a SQL expression construct or string statement within\n        the current transaction.\n        Returns a :class:`.ResultProxy` representing\n        results of the statement execution, in the same manner as that of an\n        :class:`.Engine` or\n        :class:`.Connection`.\n        E.g.::\n            result = session.execute(\n                        user_table.select().where(user_table.c.id == 5)\n                    )\n        :meth:`~.Session.execute` accepts any executable clause construct, such\n        as :func:`~.sql.expression.select`,\n        :func:`~.sql.expression.insert`,\n        :func:`~.sql.expression.update`,\n        :func:`~.sql.expression.delete`, and\n        :func:`~.sql.expression.text`.  Plain SQL strings can be passed\n        as well, which in the case of :meth:`.Session.execute` only\n        will be interpreted the same as if it were passed via a :func:`~.expression.text`\n        construct.  That is, the following usage::\n            result = session.execute(\n                        \"SELECT * FROM user WHERE id=:param\",\n                        {\"param\":5}\n                    )\n        is equivalent to::\n            from sqlalchemy import text\n            result = session.execute(\n                        text(\"SELECT * FROM user WHERE id=:param\"),\n                        {\"param\":5}\n                    )\n        The second positional argument to :meth:`.Session.execute` is an\n        optional parameter set.  Similar to that of :meth:`.Connection.execute`, whether this\n        is passed as a single dictionary, or a list of dictionaries, determines\n        whether the DBAPI cursor's ``execute()`` or ``executemany()`` is used to execute the\n        statement.   An INSERT construct may be invoked for a single row::\n            result = session.execute(users.insert(), {\"id\": 7, \"name\": \"somename\"})\n        or for multiple rows::\n            result = session.execute(users.insert(), [\n                                    {\"id\": 7, \"name\": \"somename7\"},\n                                    {\"id\": 8, \"name\": \"somename8\"},\n                                    {\"id\": 9, \"name\": \"somename9\"}\n                                ])\n        The statement is executed within the current transactional context of\n        this :class:`.Session`.   The :class:`.Connection` which is used\n        to execute the statement can also be acquired directly by\n        calling the :meth:`.Session.connection` method.  Both methods use\n        a rule-based resolution scheme in order to determine the\n        :class:`.Connection`, which in the average case is derived directly\n        from the \"bind\" of the :class:`.Session` itself, and in other cases\n        can be based on the :func:`.mapper`\n        and :class:`.Table` objects passed to the method; see the documentation\n        for :meth:`.Session.get_bind` for a full description of this scheme.\n        The :meth:`.Session.execute` method does *not* invoke autoflush.\n        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`\n        method is returned with the \"close_with_result\" flag set to true;\n        the significance of this flag is that if this :class:`.Session` is\n        autocommitting and does not have a transaction-dedicated :class:`.Connection`\n        available, a temporary :class:`.Connection` is established for the\n        statement execution, which is closed (meaning, returned to the connection\n        pool) when the :class:`.ResultProxy` has consumed all available data.\n        This applies *only* when the :class:`.Session` is configured with\n        autocommit=True and no transaction has been started.\n        :param clause:\n            An executable statement (i.e. an :class:`.Executable` expression\n            such as :func:`.expression.select`) or string SQL statement\n            to be executed.\n        :param params:\n            Optional dictionary, or list of dictionaries, containing\n            bound parameter values.   If a single dictionary, single-row\n            execution occurs; if a list of dictionaries, an\n            \"executemany\" will be invoked.  The keys in each dictionary\n            must correspond to parameter names present in the statement.\n        :param mapper:\n          Optional :func:`.mapper` or mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`\n          for more details.\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes\n          precedence over ``mapper`` and ``clause`` when locating\n          a bind.\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`.Session.get_bind()`\n          to allow extensibility of \"bind\" schemes.\n        .. seealso::\n            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL\n            constructs.\n            :ref:`connections_toplevel` - Further information on direct\n            statement execution.\n            :meth:`.Connection.execute` - core level statement execution\n            method, which is :meth:`.Session.execute` ultimately uses\n            in order to execute the statement.\n        \"\"\"\n        clause = expression._literal_as_text(clause)\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n        return self._connection_for_bind(bind, close_with_result=True).execute(\n            clause, params or {})\n    def scalar(self, clause, params=None, mapper=None, bind=None, **kw):\n        \"\"\"Like :meth:`~.Session.execute` but return a scalar result.\"\"\"\n        return self.execute(clause, params=params, mapper=mapper, bind=bind, **kw).scalar()\n    def close(self):\n        \"\"\"Close this Session.\n        This clears all items and ends any transaction in progress.\n        If this session were created with ``autocommit=False``, a new\n        transaction is immediately begun.  Note that this new transaction does\n        not use any connection resources until they are first needed.\n        \"\"\"\n        self.expunge_all()\n        if self.transaction is not None:\n            for transaction in self.transaction._iterate_parents():\n                transaction.close()\n    @classmethod\n    def close_all(cls):\n        \"\"\"Close *all* sessions in memory.\"\"\"\n        for sess in _sessions.values():\n            sess.close()\n    def expunge_all(self):\n        \"\"\"Remove all object instances from this ``Session``.\n        This is equivalent to calling ``expunge(obj)`` on all objects in this\n        ``Session``.\n        \"\"\"\n        for state in self.identity_map.all_states() + list(self._new):\n            state.detach()\n        self.identity_map = self._identity_cls()\n        self._new = {}\n        self._deleted = {}\n    # TODO: need much more test coverage for bind_mapper() and similar !\n    # TODO: + crystalize + document resolution order vis. bind_mapper/bind_table\n    def bind_mapper(self, mapper, bind):\n        \"\"\"Bind operations for a mapper to a Connectable.\n        mapper\n          A mapper instance or mapped class\n        bind\n          Any Connectable: a ``Engine`` or ``Connection``.\n        All subsequent operations involving this mapper will use the given\n        `bind`.\n        \"\"\"\n        if isinstance(mapper, type):\n            mapper = _class_mapper(mapper)\n        self.__binds[mapper.base_mapper] = bind\n        for t in mapper._all_tables:\n            self.__binds[t] = bind\n    def bind_table(self, table, bind):\n        \"\"\"Bind operations on a Table to a Connectable.\n        table\n          A ``Table`` instance\n        bind\n          Any Connectable: a ``Engine`` or ``Connection``.\n        All subsequent operations involving this ``Table`` will use the\n        given `bind`.\n        \"\"\"\n        self.__binds[table] = bind\n    def get_bind(self, mapper=None, clause=None):\n        \"\"\"Return a \"bind\" to which this :class:`.Session` is bound.\n        The \"bind\" is usually an instance of :class:`.Engine`,\n        except in the case where the :class:`.Session` has been\n        explicitly bound directly to a :class:`.Connection`.\n        For a multiply-bound or unbound :class:`.Session`, the\n        ``mapper`` or ``clause`` arguments are used to determine the\n        appropriate bind to return.\n        Note that the \"mapper\" argument is usually present\n        when :meth:`.Session.get_bind` is called via an ORM\n        operation such as a :meth:`.Session.query`, each\n        individual INSERT/UPDATE/DELETE operation within a\n        :meth:`.Session.flush`, call, etc.\n        The order of resolution is:\n        1. if mapper given and session.binds is present,\n           locate a bind based on mapper.\n        2. if clause given and session.binds is present,\n           locate a bind based on :class:`.Table` objects\n           found in the given clause present in session.binds.\n        3. if session.bind is present, return that.\n        4. if clause given, attempt to return a bind\n           linked to the :class:`.MetaData` ultimately\n           associated with the clause.\n        5. if mapper given, attempt to return a bind\n           linked to the :class:`.MetaData` ultimately\n           associated with the :class:`.Table` or other\n           selectable to which the mapper is mapped.\n        6. No bind can be found, :class:`.UnboundExecutionError`\n           is raised.\n        :param mapper:\n          Optional :func:`.mapper` mapped class or instance of\n          :class:`.Mapper`.   The bind can be derived from a :class:`.Mapper`\n          first by consulting the \"binds\" map associated with this\n          :class:`.Session`, and secondly by consulting the :class:`.MetaData`\n          associated with the :class:`.Table` to which the :class:`.Mapper`\n          is mapped for a bind.\n        :param clause:\n            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,\n            :func:`~.sql.expression.text`,\n            etc.).  If the ``mapper`` argument is not present or could not produce\n            a bind, the given expression construct will be searched for a bound\n            element, typically a :class:`.Table` associated with bound\n            :class:`.MetaData`.\n        \"\"\"\n        if mapper is clause is None:\n            if self.bind:\n                return self.bind\n            else:\n                raise sa_exc.UnboundExecutionError(\n                    \"This session is not bound to a single Engine or \"\n                    \"Connection, and no context was provided to locate \"\n                    \"a binding.\")\n        c_mapper = mapper is not None and _class_to_mapper(mapper) or None\n        # manually bound?\n        if self.__binds:\n            if c_mapper:\n                if c_mapper.base_mapper in self.__binds:\n                    return self.__binds[c_mapper.base_mapper]\n                elif c_mapper.mapped_table in self.__binds:\n                    return self.__binds[c_mapper.mapped_table]\n            if clause is not None:\n                for t in sql_util.find_tables(clause, include_crud=True):\n                    if t in self.__binds:\n                        return self.__binds[t]\n        if self.bind:\n            return self.bind\n        if isinstance(clause, sql.expression.ClauseElement) and clause.bind:\n            return clause.bind\n        if c_mapper and c_mapper.mapped_table.bind:\n            return c_mapper.mapped_table.bind\n        context = []\n        if mapper is not None:\n            context.append('mapper %s' % c_mapper)\n        if clause is not None:\n            context.append('SQL expression')\n        raise sa_exc.UnboundExecutionError(\n            \"Could not locate a bind configured on %s or this Session\" % (\n            ', '.join(context)))\n    def query(self, *entities, **kwargs):\n        \"\"\"Return a new ``Query`` object corresponding to this ``Session``.\"\"\"\n        return self._query_cls(entities, self, **kwargs)\n    @property\n    @util.contextmanager\n    def no_autoflush(self):\n        \"\"\"Return a context manager that disables autoflush.\n        e.g.::\n            with session.no_autoflush:\n                some_object = SomeClass()\n                session.add(some_object)\n                # won't autoflush\n                some_object.related_thing = session.query(SomeRelated).first()\n        Operations that proceed within the ``with:`` block\n        will not be subject to flushes occurring upon query\n        access.  This is useful when initializing a series\n        of objects which involve existing database queries,\n        where the uncompleted object should not yet be flushed.\n        .. versionadded:: 0.7.6\n        \"\"\"\n        autoflush = self.autoflush\n        self.autoflush = False\n        yield self\n        self.autoflush = autoflush\n    def _autoflush(self):\n        if self.autoflush and not self._flushing:\n            self.flush()\n    def _finalize_loaded(self, states):\nNext line of code:\n", "input": "", "context": "# orm/session.py\n# Copyright (C) 2005-2013 the SQLAlchemy authors and contributors <see AUTHORS file>\n#\n# This module is part of SQLAlchemy and is released under\n# the MIT License: http://www.opensource.org/licenses/mit-license.php\n\"\"\"Provides the Session class and related utilities.\"\"\"\nimport weakref\nfrom itertools import chain\nfrom sqlalchemy import util, sql, engine, log, exc as sa_exc\nfrom sqlalchemy.sql import util as sql_util, expression\nfrom sqlalchemy.orm import (\n    SessionExtension, attributes, exc, query, unitofwork, util as mapperutil, state\n    )\nfrom sqlalchemy.orm.util import object_mapper as _object_mapper\nfrom sqlalchemy.orm.util import class_mapper as _class_mapper\nfrom sqlalchemy.orm.util import (\n    _class_to_mapper, _state_mapper,\n    )\nfrom sqlalchemy.orm.mapper import Mapper, _none_set\nfrom sqlalchemy.orm.unitofwork import UOWTransaction\nfrom sqlalchemy.orm import identity\nfrom sqlalchemy import event\nfrom sqlalchemy.orm.events import SessionEvents\nimport sys\n__all__ = ['Session', 'SessionTransaction', 'SessionExtension']\ndef sessionmaker(bind=None, class_=None, autoflush=True, autocommit=False,\n                 expire_on_commit=True, **kwargs):\n    \"\"\"Generate a custom-configured :class:`.Session` class.\n    The returned object is a subclass of :class:`.Session`, which, when instantiated\n    with no arguments, uses the keyword arguments configured here as its\n    constructor arguments.\n    It is intended that the :func:`.sessionmaker()` function be called within the\n    global scope of an application, and the returned class be made available\n    to the rest of the application as the single class used to instantiate\n    sessions.\n    e.g.::\n        # global scope\n        Session = sessionmaker(autoflush=False)\n        # later, in a local scope, create and use a session:\n        sess = Session()\n    Any keyword arguments sent to the constructor itself will override the\n    \"configured\" keywords::\n        Session = sessionmaker()\n        # bind an individual session to a connection\n        sess = Session(bind=connection)\n    The class also includes a special classmethod ``configure()``, which\n    allows additional configurational options to take place after the custom\n    ``Session`` class has been generated.  This is useful particularly for\n    defining the specific ``Engine`` (or engines) to which new instances of\n    ``Session`` should be bound::\n        Session = sessionmaker()\n        Session.configure(bind=create_engine('sqlite:///foo.db'))\n        sess = Session()\n    For options, see the constructor options for :class:`.Session`.\n    \"\"\"\n    kwargs['bind'] = bind\n    kwargs['autoflush'] = autoflush\n    kwargs['autocommit'] = autocommit\n    kwargs['expire_on_commit'] = expire_on_commit\n    if class_ is None:\n        class_ = Session\n    class Sess(object):\n        def __init__(self, **local_kwargs):\n            for k in kwargs:\n                local_kwargs.setdefault(k, kwargs[k])\n            super(Sess, self).__init__(**local_kwargs)\n        @classmethod\n        def configure(self, **new_kwargs):\n            \"\"\"(Re)configure the arguments for this sessionmaker.\n            e.g.::\n                Session = sessionmaker()\n                Session.configure(bind=create_engine('sqlite://'))\n            \"\"\"\n            kwargs.update(new_kwargs)\n    return type(\"SessionMaker\", (Sess, class_), {})\nclass SessionTransaction(object):\n    \"\"\"A :class:`.Session`-level transaction.\n    :class:`.SessionTransaction` is a mostly behind-the-scenes object\n    not normally referenced directly by application code.   It coordinates\n    among multiple :class:`.Connection` objects, maintaining a database\n    transaction for each one individually, committing or rolling them\n    back all at once.   It also provides optional two-phase commit behavior\n    which can augment this coordination operation.\n    The :attr:`.Session.transaction` attribute of :class:`.Session` refers to the\n    current :class:`.SessionTransaction` object in use, if any.\n    A :class:`.SessionTransaction` is associated with a :class:`.Session`\n    in its default mode of ``autocommit=False`` immediately, associated\n    with no database connections.  As the :class:`.Session` is called upon\n    to emit SQL on behalf of various :class:`.Engine` or :class:`.Connection`\n    objects, a corresponding :class:`.Connection` and associated :class:`.Transaction`\n    is added to a collection within the :class:`.SessionTransaction` object,\n    becoming one of the connection/transaction pairs maintained by the\n    :class:`.SessionTransaction`.\n    The lifespan of the :class:`.SessionTransaction` ends when the\n    :meth:`.Session.commit`, :meth:`.Session.rollback` or :meth:`.Session.close`\n    methods are called.  At this point, the :class:`.SessionTransaction` removes\n    its association with its parent :class:`.Session`.   A :class:`.Session`\n    that is in ``autocommit=False`` mode will create a new\n    :class:`.SessionTransaction` to replace it immediately, whereas a\n    :class:`.Session` that's in ``autocommit=True``\n    mode will remain without a :class:`.SessionTransaction` until the\n    :meth:`.Session.begin` method is called.\n    Another detail of :class:`.SessionTransaction` behavior is that it is\n    capable of \"nesting\".  This means that the :meth:`.begin` method can\n    be called while an existing :class:`.SessionTransaction` is already present,\n    producing a new :class:`.SessionTransaction` that temporarily replaces\n    the parent :class:`.SessionTransaction`.   When a :class:`.SessionTransaction`\n    is produced as nested, it assigns itself to the :attr:`.Session.transaction`\n    attribute.  When it is ended via :meth:`.Session.commit` or :meth:`.Session.rollback`,\n    it restores its parent :class:`.SessionTransaction` back onto the\n    :attr:`.Session.transaction` attribute.  The\n    behavior is effectively a stack, where :attr:`.Session.transaction` refers\n    to the current head of the stack.\n    The purpose of this stack is to allow nesting of :meth:`.rollback` or\n    :meth:`.commit` calls in context with various flavors of :meth:`.begin`.\n    This nesting behavior applies to when :meth:`.Session.begin_nested`\n    is used to emit a SAVEPOINT transaction, and is also used to produce\n    a so-called \"subtransaction\" which allows a block of code to use a\n    begin/rollback/commit sequence regardless of whether or not its enclosing\n    code block has begun a transaction.  The :meth:`.flush` method, whether called\n    explicitly or via autoflush, is the primary consumer of the \"subtransaction\"\n    feature, in that it wishes to guarantee that it works within in a transaction block\n    regardless of whether or not the :class:`.Session` is in transactional mode\n    when the method is called.\n    See also:\n    :meth:`.Session.rollback`\n    :meth:`.Session.commit`\n    :meth:`.Session.begin`\n    :meth:`.Session.begin_nested`\n    :attr:`.Session.is_active`\n    :meth:`.SessionEvents.after_commit`\n    :meth:`.SessionEvents.after_rollback`\n    :meth:`.SessionEvents.after_soft_rollback`\n    \"\"\"\n    _rollback_exception = None\n    def __init__(self, session, parent=None, nested=False):\n        self.session = session\n        self._connections = {}\n        self._parent = parent\n        self.nested = nested\n        self._active = True\n        self._prepared = False\n        if not parent and nested:\n            raise sa_exc.InvalidRequestError(\n                \"Can't start a SAVEPOINT transaction when no existing \"\n                \"transaction is in progress\")\n        if self.session._enable_transaction_accounting:\n            self._take_snapshot()\n    @property\n    def is_active(self):\n        return self.session is not None and self._active\n    def _assert_is_active(self):\n        self._assert_is_open()\n        if not self._active:\n            if self._rollback_exception:\n                raise sa_exc.InvalidRequestError(\n                    \"This Session's transaction has been rolled back \"\n                    \"due to a previous exception during flush.\"\n                    \" To begin a new transaction with this Session, \"\n                    \"first issue Session.rollback().\"\n                    \" Original exception was: %s\"\n                    % self._rollback_exception\n                )\n            else:\n                raise sa_exc.InvalidRequestError(\n                    \"This Session's transaction has been rolled back \"\n                    \"by a nested rollback() call.  To begin a new \"\n                    \"transaction, issue Session.rollback() first.\"\n                    )\n    def _assert_is_open(self, error_msg=\"The transaction is closed\"):\n        if self.session is None:\n            raise sa_exc.ResourceClosedError(error_msg)\n    @property\n    def _is_transaction_boundary(self):\n        return self.nested or not self._parent\n    def connection(self, bindkey, **kwargs):\n        self._assert_is_active()\n        engine = self.session.get_bind(bindkey, **kwargs)\n        return self._connection_for_bind(engine)\n    def _begin(self, nested=False):\n        self._assert_is_active()\n        return SessionTransaction(\n            self.session, self, nested=nested)\n    def _iterate_parents(self, upto=None):\n        if self._parent is upto:\n            return (self,)\n        else:\n            if self._parent is None:\n                raise sa_exc.InvalidRequestError(\n                    \"Transaction %s is not on the active transaction list\" % (\n                    upto))\n            return (self,) + self._parent._iterate_parents(upto)\n    def _take_snapshot(self):\n        if not self._is_transaction_boundary:\n            self._new = self._parent._new\n            self._deleted = self._parent._deleted\n            self._key_switches = self._parent._key_switches\n            return\n        if not self.session._flushing:\n            self.session.flush()\n        self._new = weakref.WeakKeyDictionary()\n        self._deleted = weakref.WeakKeyDictionary()\n        self._key_switches = weakref.WeakKeyDictionary()\n    def _restore_snapshot(self):\n        assert self._is_transaction_boundary\n        for s in set(self._new).union(self.session._new):\n            self.session._expunge_state(s)\n            if s.key:\n                del s.key\n        for s, (oldkey, newkey) in self._key_switches.items():\n            self.session.identity_map.discard(s)\n            s.key = oldkey\n            self.session.identity_map.replace(s)\n        for s in set(self._deleted).union(self.session._deleted):\n            if s.deleted:\n                #assert s in self._deleted\n                del s.deleted\n            self.session._update_impl(s, discard_existing=True)\n        assert not self.session._deleted\n        for s in self.session.identity_map.all_states():\n            s.expire(s.dict, self.session.identity_map._modified)\n    def _remove_snapshot(self):\n        assert self._is_transaction_boundary\n        if not self.nested and self.session.expire_on_commit:\n            for s in self.session.identity_map.all_states():\n                s.expire(s.dict, self.session.identity_map._modified)\n    def _connection_for_bind(self, bind):\n        self._assert_is_active()\n        if bind in self._connections:\n            return self._connections[bind][0]\n        if self._parent:\n            conn = self._parent._connection_for_bind(bind)\n            if not self.nested:\n                return conn\n        else:\n            if isinstance(bind, engine.Connection):\n                conn = bind\n                if conn.engine in self._connections:\n                    raise sa_exc.InvalidRequestError(\n                        \"Session already has a Connection associated for the \"\n                        \"given Connection's Engine\")\n            else:\n                conn = bind.contextual_connect()\n        if self.session.twophase and self._parent is None:\n            transaction = conn.begin_twophase()\n        elif self.nested:\n            transaction = conn.begin_nested()\n        else:\n            transaction = conn.begin()\n        self._connections[conn] = self._connections[conn.engine] = \\\n          (conn, transaction, conn is not bind)\n        self.session.dispatch.after_begin(self.session, self, conn)\n        return conn\n    def prepare(self):\n        if self._parent is not None or not self.session.twophase:\n            raise sa_exc.InvalidRequestError(\n                \"Only root two phase transactions of can be prepared\")\n        self._prepare_impl()\n    def _prepare_impl(self):\n        self._assert_is_active()\n        if self._parent is None or self.nested:\n            self.session.dispatch.before_commit(self.session)\n        stx = self.session.transaction\n        if stx is not self:\n            for subtransaction in stx._iterate_parents(upto=self):\n                subtransaction.commit()\n        if not self.session._flushing:\n            for _flush_guard in xrange(100):\n                if self.session._is_clean():\n                    break\n                self.session.flush()\n            else:\n                raise exc.FlushError(\n                        \"Over 100 subsequent flushes have occurred within \"\n                        \"session.commit() - is an after_flush() hook \"\n                        \"creating new objects?\")\n        if self._parent is None and self.session.twophase:\n            try:\n                for t in set(self._connections.values()):\n                    t[1].prepare()\n            except:\n                self.rollback()\n                raise\n        self._deactivate()\n        self._prepared = True\n    def commit(self):\n        self._assert_is_open()\n        if not self._prepared:\n            self._prepare_impl()\n        if self._parent is None or self.nested:\n            for t in set(self._connections.values()):\n                t[1].commit()\n            self.session.dispatch.after_commit(self.session)\n            if self.session._enable_transaction_accounting:\n                self._remove_snapshot()\n        self.close()\n        return self._parent\n    def rollback(self, _capture_exception=False):\n        self._assert_is_open()\n        stx = self.session.transaction\n        if stx is not self:\n            for subtransaction in stx._iterate_parents(upto=self):\n                subtransaction.close()\n        if self.is_active or self._prepared:\n            for transaction in self._iterate_parents():\n                if transaction._parent is None or transaction.nested:\n                    transaction._rollback_impl()\n                    transaction._deactivate()\n                    break\n                else:\n                    transaction._deactivate()\n        sess = self.session\n        if self.session._enable_transaction_accounting and \\\n            not sess._is_clean():\n            # if items were added, deleted, or mutated\n            # here, we need to re-restore the snapshot\n            util.warn(\n                    \"Session's state has been changed on \"\n                    \"a non-active transaction - this state \"\n                    \"will be discarded.\")\n            self._restore_snapshot()\n        self.close()\n        if self._parent and _capture_exception:\n            self._parent._rollback_exception = sys.exc_info()[1]\n        sess.dispatch.after_soft_rollback(sess, self)\n        return self._parent\n    def _rollback_impl(self):\n        for t in set(self._connections.values()):\n            t[1].rollback()\n        if self.session._enable_transaction_accounting:\n            self._restore_snapshot()\n        self.session.dispatch.after_rollback(self.session)\n    def _deactivate(self):\n        self._active = False\n    def close(self):\n        self.session.transaction = self._parent\n        if self._parent is None:\n            for connection, transaction, autoclose in \\\n                set(self._connections.values()):\n                if autoclose:\n                    connection.close()\n                else:\n                    transaction.close()\n            if not self.session.autocommit:\n                self.session.begin()\n        self._deactivate()\n        self.session = None\n        self._connections = None\n    def __enter__(self):\n        return self\n    def __exit__(self, type, value, traceback):\n        self._assert_is_open(\"Cannot end transaction context. The transaction \"\n                                    \"was closed from within the context\")\n        if self.session.transaction is None:\n            return\n        if type is None:\n            try:\n                self.commit()\n            except:\n                self.rollback()\n                raise\n        else:\n            self.rollback()\nclass Session(object):\n    \"\"\"Manages persistence operations for ORM-mapped objects.\n    The Session's usage paradigm is described at :ref:`session_toplevel`.\n    \"\"\"\n    public_methods = (\n        '__contains__', '__iter__', 'add', 'add_all', 'begin', 'begin_nested',\n        'close', 'commit', 'connection', 'delete', 'execute', 'expire',\n        'expire_all', 'expunge', 'expunge_all', 'flush', 'get_bind',\n        'is_modified',\n        'merge', 'query', 'refresh', 'rollback',\n        'scalar')\n    def __init__(self, bind=None, autoflush=True, expire_on_commit=True,\n                _enable_transaction_accounting=True,\n                 autocommit=False, twophase=False,\n                 weak_identity_map=True, binds=None, extension=None,\n                 query_cls=query.Query):\n        \"\"\"Construct a new Session.\n        See also the :func:`.sessionmaker` function which is used to\n        generate a :class:`.Session`-producing callable with a given\n        set of arguments.\n        :param autocommit: Defaults to ``False``. When ``True``, the ``Session``\n          does not keep a persistent transaction running, and will acquire\n          connections from the engine on an as-needed basis, returning them\n          immediately after their use. Flushes will begin and commit (or possibly\n          rollback) their own transaction if no transaction is present. When using\n          this mode, the `session.begin()` method may be used to begin a\n          transaction explicitly.\n          Leaving it on its default value of ``False`` means that the ``Session``\n          will acquire a connection and begin a transaction the first time it is\n          used, which it will maintain persistently until ``rollback()``,\n          ``commit()``, or ``close()`` is called. When the transaction is released\n          by any of these methods, the ``Session`` is ready for the next usage,\n          which will again acquire and maintain a new connection/transaction.\n        :param autoflush: When ``True``, all query operations will issue a\n           ``flush()`` call to this ``Session`` before proceeding. This is a\n           convenience feature so that ``flush()`` need not be called repeatedly\n           in order for database queries to retrieve results. It's typical that\n           ``autoflush`` is used in conjunction with ``autocommit=False``. In this\n           scenario, explicit calls to ``flush()`` are rarely needed; you usually\n           only need to call ``commit()`` (which flushes) to finalize changes.\n        :param bind: An optional ``Engine`` or ``Connection`` to which this\n           ``Session`` should be bound. When specified, all SQL operations\n           performed by this session will execute via this connectable.\n        :param binds: An optional dictionary which contains more granular \"bind\"\n           information than the ``bind`` parameter provides. This dictionary can\n           map individual ``Table`` instances as well as ``Mapper`` instances to\n           individual ``Engine`` or ``Connection`` objects. Operations which\n           proceed relative to a particular ``Mapper`` will consult this\n           dictionary for the direct ``Mapper`` instance as well as the mapper's\n           ``mapped_table`` attribute in order to locate an connectable to use.\n           The full resolution is described in the ``get_bind()`` method of\n           ``Session``. Usage looks like::\n            Session = sessionmaker(binds={\n                SomeMappedClass: create_engine('postgresql://engine1'),\n                somemapper: create_engine('postgresql://engine2'),\n                some_table: create_engine('postgresql://engine3'),\n                })\n          Also see the :meth:`.Session.bind_mapper` and :meth:`.Session.bind_table` methods.\n        :param \\class_: Specify an alternate class other than\n           ``sqlalchemy.orm.session.Session`` which should be used by the returned\n           class. This is the only argument that is local to the\n           ``sessionmaker()`` function, and is not sent directly to the\n           constructor for ``Session``.\n        :param _enable_transaction_accounting:  Defaults to ``True``.  A\n           legacy-only flag which when ``False`` disables *all* 0.5-style object\n           accounting on transaction boundaries, including auto-expiry of\n           instances on rollback and commit, maintenance of the \"new\" and\n           \"deleted\" lists upon rollback, and autoflush of pending changes upon\n           begin(), all of which are interdependent.\n        :param expire_on_commit:  Defaults to ``True``. When ``True``, all\n           instances will be fully expired after each ``commit()``, so that all\n           attribute/object access subsequent to a completed transaction will load\n           from the most recent database state.\n        :param extension: An optional\n           :class:`~.SessionExtension` instance, or a list\n           of such instances, which will receive pre- and post- commit and flush\n           events, as well as a post-rollback event. **Deprecated.**\n           Please see :class:`.SessionEvents`.\n        :param query_cls:  Class which should be used to create new Query objects,\n           as returned by the ``query()`` method. Defaults to\n           :class:`~sqlalchemy.orm.query.Query`.\n        :param twophase:  When ``True``, all transactions will be started as\n            a \"two phase\" transaction, i.e. using the \"two phase\" semantics\n            of the database in use along with an XID.  During a ``commit()``,\n            after ``flush()`` has been issued for all attached databases, the\n            ``prepare()`` method on each database's ``TwoPhaseTransaction`` will\n            be called. This allows each database to roll back the entire\n            transaction, before each transaction is committed.\n        :param weak_identity_map:  Defaults to ``True`` - when set to\n           ``False``, objects placed in the :class:`.Session` will be\n           strongly referenced until explicitly removed or the\n           :class:`.Session` is closed.  **Deprecated** - this option\n           is obsolete.\n        \"\"\"\n        if weak_identity_map:\n            self._identity_cls = identity.WeakInstanceDict\n        else:\n            util.warn_deprecated(\"weak_identity_map=False is deprecated.  \"\n                                    \"This feature is not needed.\")\n            self._identity_cls = identity.StrongInstanceDict\n        self.identity_map = self._identity_cls()\n        self._new = {}   # InstanceState->object, strong refs object\n        self._deleted = {}  # same\n        self.bind = bind\n        self.__binds = {}\n        self._flushing = False\n        self.transaction = None\n        self.hash_key = _new_sessionid()\n        self.autoflush = autoflush\n        self.autocommit = autocommit\n        self.expire_on_commit = expire_on_commit\n        self._enable_transaction_accounting = _enable_transaction_accounting\n        self.twophase = twophase\n        self._query_cls = query_cls\n        if extension:\n            for ext in util.to_list(extension):\n                SessionExtension._adapt_listener(self, ext)\n        if binds is not None:\n            for mapperortable, bind in binds.iteritems():\n                if isinstance(mapperortable, (type, Mapper)):\n                    self.bind_mapper(mapperortable, bind)\n                else:\n                    self.bind_table(mapperortable, bind)\n        if not self.autocommit:\n            self.begin()\n        _sessions[self.hash_key] = self\n    dispatch = event.dispatcher(SessionEvents)\n    connection_callable = None\n    transaction = None\n    \"\"\"The current active or inactive :class:`.SessionTransaction`.\"\"\"\n    def begin(self, subtransactions=False, nested=False):\n        \"\"\"Begin a transaction on this Session.\n        If this Session is already within a transaction, either a plain\n        transaction or nested transaction, an error is raised, unless\n        ``subtransactions=True`` or ``nested=True`` is specified.\n        The ``subtransactions=True`` flag indicates that this :meth:`~.Session.begin`\n        can create a subtransaction if a transaction is already in progress.\n        For documentation on subtransactions, please see :ref:`session_subtransactions`.\n        The ``nested`` flag begins a SAVEPOINT transaction and is equivalent\n        to calling :meth:`~.Session.begin_nested`. For documentation on SAVEPOINT\n        transactions, please see :ref:`session_begin_nested`.\n        \"\"\"\n        if self.transaction is not None:\n            if subtransactions or nested:\n                self.transaction = self.transaction._begin(\n                                        nested=nested)\n            else:\n                raise sa_exc.InvalidRequestError(\n                    \"A transaction is already begun.  Use subtransactions=True \"\n                    \"to allow subtransactions.\")\n        else:\n            self.transaction = SessionTransaction(\n                self, nested=nested)\n        return self.transaction  # needed for __enter__/__exit__ hook\n    def begin_nested(self):\n        \"\"\"Begin a `nested` transaction on this Session.\n        The target database(s) must support SQL SAVEPOINTs or a\n        SQLAlchemy-supported vendor implementation of the idea.\n        For documentation on SAVEPOINT\n        transactions, please see :ref:`session_begin_nested`.\n        \"\"\"\n        return self.begin(nested=True)\n    def rollback(self):\n        \"\"\"Rollback the current transaction in progress.\n        If no transaction is in progress, this method is a pass-through.\n        This method rolls back the current transaction or nested transaction\n        regardless of subtransactions being in effect.  All subtransactions up\n        to the first real transaction are closed.  Subtransactions occur when\n        begin() is called multiple times.\n        \"\"\"\n        if self.transaction is None:\n            pass\n        else:\n            self.transaction.rollback()\n    def commit(self):\n        \"\"\"Flush pending changes and commit the current transaction.\n        If no transaction is in progress, this method raises an\n        InvalidRequestError.\n        By default, the :class:`.Session` also expires all database\n        loaded state on all ORM-managed attributes after transaction commit.\n        This so that subsequent operations load the most recent\n        data from the database.   This behavior can be disabled using\n        the ``expire_on_commit=False`` option to :func:`.sessionmaker` or\n        the :class:`.Session` constructor.\n        If a subtransaction is in effect (which occurs when begin() is called\n        multiple times), the subtransaction will be closed, and the next call\n        to ``commit()`` will operate on the enclosing transaction.\n        For a session configured with autocommit=False, a new transaction will\n        be begun immediately after the commit, but note that the newly begun\n        transaction does *not* use any connection resources until the first\n        SQL is actually emitted.\n        \"\"\"\n        if self.transaction is None:\n            if not self.autocommit:\n                self.begin()\n            else:\n                raise sa_exc.InvalidRequestError(\"No transaction is begun.\")\n        self.transaction.commit()\n    def prepare(self):\n        \"\"\"Prepare the current transaction in progress for two phase commit.\n        If no transaction is in progress, this method raises an\n        InvalidRequestError.\n        Only root transactions of two phase sessions can be prepared. If the\n        current transaction is not such, an InvalidRequestError is raised.\n        \"\"\"\n        if self.transaction is None:\n            if not self.autocommit:\n                self.begin()\n            else:\n                raise sa_exc.InvalidRequestError(\"No transaction is begun.\")\n        self.transaction.prepare()\n    def connection(self, mapper=None, clause=None,\n                        bind=None,\n                        close_with_result=False,\n                        **kw):\n        \"\"\"Return a :class:`.Connection` object corresponding to this\n        :class:`.Session` object's transactional state.\n        If this :class:`.Session` is configured with ``autocommit=False``,\n        either the :class:`.Connection` corresponding to the current transaction\n        is returned, or if no transaction is in progress, a new one is begun\n        and the :class:`.Connection` returned (note that no transactional state\n        is established with the DBAPI until the first SQL statement is emitted).\n        Alternatively, if this :class:`.Session` is configured with ``autocommit=True``,\n        an ad-hoc :class:`.Connection` is returned using :meth:`.Engine.contextual_connect`\n        on the underlying :class:`.Engine`.\n        Ambiguity in multi-bind or unbound :class:`.Session` objects can be resolved through\n        any of the optional keyword arguments.   This ultimately makes usage of the\n        :meth:`.get_bind` method for resolution.\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes precedence\n          over ``mapper``, ``clause``.\n        :param mapper:\n          Optional :func:`.mapper` mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause``.\n        :param clause:\n            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,\n            :func:`~.sql.expression.text`,\n            etc.) which will be used to locate a bind, if a bind\n            cannot otherwise be identified.\n        :param close_with_result: Passed to :meth:`Engine.connect`, indicating\n          the :class:`.Connection` should be considered \"single use\", automatically\n          closing when the first result set is closed.  This flag only has\n          an effect if this :class:`.Session` is configured with ``autocommit=True``\n          and does not already have a  transaction in progress.\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`get_bind()`,\n          allowing additional arguments to be passed to custom\n          implementations of :meth:`get_bind`.\n        \"\"\"\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n        return self._connection_for_bind(bind,\n                                        close_with_result=close_with_result)\n    def _connection_for_bind(self, engine, **kwargs):\n        if self.transaction is not None:\n            return self.transaction._connection_for_bind(engine)\n        else:\n            return engine.contextual_connect(**kwargs)\n    def execute(self, clause, params=None, mapper=None, bind=None, **kw):\n        \"\"\"Execute a SQL expression construct or string statement within\n        the current transaction.\n        Returns a :class:`.ResultProxy` representing\n        results of the statement execution, in the same manner as that of an\n        :class:`.Engine` or\n        :class:`.Connection`.\n        E.g.::\n            result = session.execute(\n                        user_table.select().where(user_table.c.id == 5)\n                    )\n        :meth:`~.Session.execute` accepts any executable clause construct, such\n        as :func:`~.sql.expression.select`,\n        :func:`~.sql.expression.insert`,\n        :func:`~.sql.expression.update`,\n        :func:`~.sql.expression.delete`, and\n        :func:`~.sql.expression.text`.  Plain SQL strings can be passed\n        as well, which in the case of :meth:`.Session.execute` only\n        will be interpreted the same as if it were passed via a :func:`~.expression.text`\n        construct.  That is, the following usage::\n            result = session.execute(\n                        \"SELECT * FROM user WHERE id=:param\",\n                        {\"param\":5}\n                    )\n        is equivalent to::\n            from sqlalchemy import text\n            result = session.execute(\n                        text(\"SELECT * FROM user WHERE id=:param\"),\n                        {\"param\":5}\n                    )\n        The second positional argument to :meth:`.Session.execute` is an\n        optional parameter set.  Similar to that of :meth:`.Connection.execute`, whether this\n        is passed as a single dictionary, or a list of dictionaries, determines\n        whether the DBAPI cursor's ``execute()`` or ``executemany()`` is used to execute the\n        statement.   An INSERT construct may be invoked for a single row::\n            result = session.execute(users.insert(), {\"id\": 7, \"name\": \"somename\"})\n        or for multiple rows::\n            result = session.execute(users.insert(), [\n                                    {\"id\": 7, \"name\": \"somename7\"},\n                                    {\"id\": 8, \"name\": \"somename8\"},\n                                    {\"id\": 9, \"name\": \"somename9\"}\n                                ])\n        The statement is executed within the current transactional context of\n        this :class:`.Session`.   The :class:`.Connection` which is used\n        to execute the statement can also be acquired directly by\n        calling the :meth:`.Session.connection` method.  Both methods use\n        a rule-based resolution scheme in order to determine the\n        :class:`.Connection`, which in the average case is derived directly\n        from the \"bind\" of the :class:`.Session` itself, and in other cases\n        can be based on the :func:`.mapper`\n        and :class:`.Table` objects passed to the method; see the documentation\n        for :meth:`.Session.get_bind` for a full description of this scheme.\n        The :meth:`.Session.execute` method does *not* invoke autoflush.\n        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`\n        method is returned with the \"close_with_result\" flag set to true;\n        the significance of this flag is that if this :class:`.Session` is\n        autocommitting and does not have a transaction-dedicated :class:`.Connection`\n        available, a temporary :class:`.Connection` is established for the\n        statement execution, which is closed (meaning, returned to the connection\n        pool) when the :class:`.ResultProxy` has consumed all available data.\n        This applies *only* when the :class:`.Session` is configured with\n        autocommit=True and no transaction has been started.\n        :param clause:\n            An executable statement (i.e. an :class:`.Executable` expression\n            such as :func:`.expression.select`) or string SQL statement\n            to be executed.\n        :param params:\n            Optional dictionary, or list of dictionaries, containing\n            bound parameter values.   If a single dictionary, single-row\n            execution occurs; if a list of dictionaries, an\n            \"executemany\" will be invoked.  The keys in each dictionary\n            must correspond to parameter names present in the statement.\n        :param mapper:\n          Optional :func:`.mapper` or mapped class, used to identify\n          the appropriate bind.  This argument takes precedence over\n          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`\n          for more details.\n        :param bind:\n          Optional :class:`.Engine` to be used as the bind.  If\n          this engine is already involved in an ongoing transaction,\n          that connection will be used.  This argument takes\n          precedence over ``mapper`` and ``clause`` when locating\n          a bind.\n        :param \\**kw:\n          Additional keyword arguments are sent to :meth:`.Session.get_bind()`\n          to allow extensibility of \"bind\" schemes.\n        .. seealso::\n            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL\n            constructs.\n            :ref:`connections_toplevel` - Further information on direct\n            statement execution.\n            :meth:`.Connection.execute` - core level statement execution\n            method, which is :meth:`.Session.execute` ultimately uses\n            in order to execute the statement.\n        \"\"\"\n        clause = expression._literal_as_text(clause)\n        if bind is None:\n            bind = self.get_bind(mapper, clause=clause, **kw)\n        return self._connection_for_bind(bind, close_with_result=True).execute(\n            clause, params or {})\n    def scalar(self, clause, params=None, mapper=None, bind=None, **kw):\n        \"\"\"Like :meth:`~.Session.execute` but return a scalar result.\"\"\"\n        return self.execute(clause, params=params, mapper=mapper, bind=bind, **kw).scalar()\n    def close(self):\n        \"\"\"Close this Session.\n        This clears all items and ends any transaction in progress.\n        If this session were created with ``autocommit=False``, a new\n        transaction is immediately begun.  Note that this new transaction does\n        not use any connection resources until they are first needed.\n        \"\"\"\n        self.expunge_all()\n        if self.transaction is not None:\n            for transaction in self.transaction._iterate_parents():\n                transaction.close()\n    @classmethod\n    def close_all(cls):\n        \"\"\"Close *all* sessions in memory.\"\"\"\n        for sess in _sessions.values():\n            sess.close()\n    def expunge_all(self):\n        \"\"\"Remove all object instances from this ``Session``.\n        This is equivalent to calling ``expunge(obj)`` on all objects in this\n        ``Session``.\n        \"\"\"\n        for state in self.identity_map.all_states() + list(self._new):\n            state.detach()\n        self.identity_map = self._identity_cls()\n        self._new = {}\n        self._deleted = {}\n    # TODO: need much more test coverage for bind_mapper() and similar !\n    # TODO: + crystalize + document resolution order vis. bind_mapper/bind_table\n    def bind_mapper(self, mapper, bind):\n        \"\"\"Bind operations for a mapper to a Connectable.\n        mapper\n          A mapper instance or mapped class\n        bind\n          Any Connectable: a ``Engine`` or ``Connection``.\n        All subsequent operations involving this mapper will use the given\n        `bind`.\n        \"\"\"\n        if isinstance(mapper, type):\n            mapper = _class_mapper(mapper)\n        self.__binds[mapper.base_mapper] = bind\n        for t in mapper._all_tables:\n            self.__binds[t] = bind\n    def bind_table(self, table, bind):\n        \"\"\"Bind operations on a Table to a Connectable.\n        table\n          A ``Table`` instance\n        bind\n          Any Connectable: a ``Engine`` or ``Connection``.\n        All subsequent operations involving this ``Table`` will use the\n        given `bind`.\n        \"\"\"\n        self.__binds[table] = bind\n    def get_bind(self, mapper=None, clause=None):\n        \"\"\"Return a \"bind\" to which this :class:`.Session` is bound.\n        The \"bind\" is usually an instance of :class:`.Engine`,\n        except in the case where the :class:`.Session` has been\n        explicitly bound directly to a :class:`.Connection`.\n        For a multiply-bound or unbound :class:`.Session`, the\n        ``mapper`` or ``clause`` arguments are used to determine the\n        appropriate bind to return.\n        Note that the \"mapper\" argument is usually present\n        when :meth:`.Session.get_bind` is called via an ORM\n        operation such as a :meth:`.Session.query`, each\n        individual INSERT/UPDATE/DELETE operation within a\n        :meth:`.Session.flush`, call, etc.\n        The order of resolution is:\n        1. if mapper given and session.binds is present,\n           locate a bind based on mapper.\n        2. if clause given and session.binds is present,\n           locate a bind based on :class:`.Table` objects\n           found in the given clause present in session.binds.\n        3. if session.bind is present, return that.\n        4. if clause given, attempt to return a bind\n           linked to the :class:`.MetaData` ultimately\n           associated with the clause.\n        5. if mapper given, attempt to return a bind\n           linked to the :class:`.MetaData` ultimately\n           associated with the :class:`.Table` or other\n           selectable to which the mapper is mapped.\n        6. No bind can be found, :class:`.UnboundExecutionError`\n           is raised.\n        :param mapper:\n          Optional :func:`.mapper` mapped class or instance of\n          :class:`.Mapper`.   The bind can be derived from a :class:`.Mapper`\n          first by consulting the \"binds\" map associated with this\n          :class:`.Session`, and secondly by consulting the :class:`.MetaData`\n          associated with the :class:`.Table` to which the :class:`.Mapper`\n          is mapped for a bind.\n        :param clause:\n            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,\n            :func:`~.sql.expression.text`,\n            etc.).  If the ``mapper`` argument is not present or could not produce\n            a bind, the given expression construct will be searched for a bound\n            element, typically a :class:`.Table` associated with bound\n            :class:`.MetaData`.\n        \"\"\"\n        if mapper is clause is None:\n            if self.bind:\n                return self.bind\n            else:\n                raise sa_exc.UnboundExecutionError(\n                    \"This session is not bound to a single Engine or \"\n                    \"Connection, and no context was provided to locate \"\n                    \"a binding.\")\n        c_mapper = mapper is not None and _class_to_mapper(mapper) or None\n        # manually bound?\n        if self.__binds:\n            if c_mapper:\n                if c_mapper.base_mapper in self.__binds:\n                    return self.__binds[c_mapper.base_mapper]\n                elif c_mapper.mapped_table in self.__binds:\n                    return self.__binds[c_mapper.mapped_table]\n            if clause is not None:\n                for t in sql_util.find_tables(clause, include_crud=True):\n                    if t in self.__binds:\n                        return self.__binds[t]\n        if self.bind:\n            return self.bind\n        if isinstance(clause, sql.expression.ClauseElement) and clause.bind:\n            return clause.bind\n        if c_mapper and c_mapper.mapped_table.bind:\n            return c_mapper.mapped_table.bind\n        context = []\n        if mapper is not None:\n            context.append('mapper %s' % c_mapper)\n        if clause is not None:\n            context.append('SQL expression')\n        raise sa_exc.UnboundExecutionError(\n            \"Could not locate a bind configured on %s or this Session\" % (\n            ', '.join(context)))\n    def query(self, *entities, **kwargs):\n        \"\"\"Return a new ``Query`` object corresponding to this ``Session``.\"\"\"\n        return self._query_cls(entities, self, **kwargs)\n    @property\n    @util.contextmanager\n    def no_autoflush(self):\n        \"\"\"Return a context manager that disables autoflush.\n        e.g.::\n            with session.no_autoflush:\n                some_object = SomeClass()\n                session.add(some_object)\n                # won't autoflush\n                some_object.related_thing = session.query(SomeRelated).first()\n        Operations that proceed within the ``with:`` block\n        will not be subject to flushes occurring upon query\n        access.  This is useful when initializing a series\n        of objects which involve existing database queries,\n        where the uncompleted object should not yet be flushed.\n        .. versionadded:: 0.7.6\n        \"\"\"\n        autoflush = self.autoflush\n        self.autoflush = False\n        yield self\n        self.autoflush = autoflush\n    def _autoflush(self):\n        if self.autoflush and not self._flushing:\n            self.flush()\n    def _finalize_loaded(self, states):\n", "answers": ["        for state, dict_ in states.items():"], "pred": "  Code: 0.7.6\n  Code: 0.7.6\n  Code: 0.7.6\n  Code: 0.7.6\n  Code: 0.7.6\n  Code: 0.7.6\n  Code: ", "length": 4268, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "52b05f3e84a4fe67c9a1b15719fbecb75dda4932f22567e9"}
{"prompt": "Please complete the code given below. \n/******************************************************************************\n * Copyright (c) 2009 - 2015 IBM Corporation.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n/**\n * \n */\npackage com.ibm.wala.memsat.util;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport com.ibm.wala.cast.java.ipa.callgraph.AstJavaSSAPropagationCallGraphBuilder.EnclosingObjectReferenceKey;\nimport com.ibm.wala.cast.loader.AstMethod;\nimport com.ibm.wala.cast.tree.CAstSourcePositionMap.Position;\nimport com.ibm.wala.classLoader.IField;\nimport com.ibm.wala.classLoader.IMethod;\nimport com.ibm.wala.classLoader.ShrikeBTMethod;\nimport com.ibm.wala.ipa.callgraph.CGNode;\nimport com.ibm.wala.ipa.callgraph.propagation.ArrayContentsKey;\nimport com.ibm.wala.ipa.callgraph.propagation.InstanceFieldKey;\nimport com.ibm.wala.ipa.callgraph.propagation.InstanceKey;\nimport com.ibm.wala.ipa.callgraph.propagation.PointerKey;\nimport com.ibm.wala.ipa.callgraph.propagation.StaticFieldKey;\nimport com.ibm.wala.ipa.callgraph.propagation.rta.CallSite;\nimport com.ibm.wala.ipa.modref.ArrayLengthKey;\nimport com.ibm.wala.memsat.frontEnd.InlinedInstruction;\nimport com.ibm.wala.shrikeCT.InvalidClassFileException;\nimport com.ibm.wala.ssa.IR;\nimport com.ibm.wala.types.TypeName;\nimport com.ibm.wala.util.collections.Pair;\nimport com.ibm.wala.util.graph.Graph;\nimport kodkod.ast.Node;\n/**\n * A set of utility functions for string manipulation and pretty printing of Kodkod nodes,\n * IRs, etc.\n * \n * @author Emina Torlak\n */\npublic final class Strings {\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given nodes, with each line offset with at least the given\n\t * number of whitespaces.  The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given nodes\n\t */\n\tpublic static String prettyPrint(Collection<Node> nodes, int offset, int line, Map<String,String> display) { \n\t\treturn PrettyPrinter.print(nodes, offset, 80, display);\n\t}\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset, Map<String, String> display) { \n\t\treturn prettyPrint(node, offset, 80, display);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The line parameter determines the\n\t * length of each pretty-printed line, including the offset.\n\t * The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset, int line, final Map<String, String> display) { \n\t\treturn prettyPrint(Collections.singleton(node), offset, line, display);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The line parameter determines the\n\t * length of each pretty-printed line, including the offset.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String prettyPrint(Node node, int offset, int line) { \n\t\tassert offset >= 0 && offset < line && line > 0;\n\t\treturn prettyPrint(node, offset, line, Collections.EMPTY_MAP);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  \n\t * @requires 0 <= offset < 80\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset) { \n\t\treturn prettyPrint(node,offset,80);\n\t}\n\t\n\t/**\n\t * Returns a string that consists of the given number of repetitions\n\t * of the specified string.\n\t * @return str^reps\n\t */\n\tpublic static String repeat(String str, int reps) {\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfor(int i = 0; i < reps; i++) { \n\t\t\tresult.append(str);\n\t\t}\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns the given string, with all new lines replaced with new lines indented \n\t * by the given number of spaces.\n\t * @return given string, with all new lines replaced with new lines indented \n\t * by the given number of spaces.\n\t */\n\tpublic static String indent(String str, int offset) { \n\t\tassert offset >= 0;\n\t\tfinal String indent = repeat(\" \", offset);\n\t\treturn indent + str.replaceAll(\"\\\\n\", \"\\n\"+indent);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given graph.\n\t * @return pretty-print String representation\n\t * of the given graph\n\t */\n\tpublic static String prettyPrint(Graph<?> graph) { \n\t\treturn prettyPrint(graph,0);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given graph, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given graph\n\t */\n\tpublic static <T> String prettyPrint(Graph<T> graph, int offset) { \n\t\tassert offset>=0;\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfinal String indent = repeat(\" \", offset);\n\t\tfor(T o : graph) {\n\t\t\tresult.append(\"\\n\");\n\t\t\tresult.append(indent);\n\t\t\tresult.append(o);\n\t\t\tfor(Iterator<?> itr = graph.getSuccNodes(o); itr.hasNext(); ) { \n\t\t\t\tresult.append(\"\\n\" + indent + \" --> \" + itr.next());\n\t\t\t}\n\t\t\tresult.append(\",\\n\");\n\t\t}\n\t\tresult.delete(result.length()-2, result.length());\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given IR, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given IR\n\t */\n\tpublic static String prettyPrint(IR ir, int offset) { \n\t\treturn indent(ir.toString(), offset);\n\t\t/*\n\t    final StringBuffer result = new StringBuffer();\n\t    result.append(\"\\n\"+indent+\"CFG:\\n\");\n\t    final SSACFG cfg = ir.getControlFlowGraph();\n\t    for (int i = 0; i <= cfg.getNumber(cfg.exit()); i++) {\n\t        BasicBlock bb = cfg.getNode(i);\n\t        result.append(indent+\"BB\").append(i).append(\"[\").append(bb.getFirstInstructionIndex()).append(\"..\").append(bb.getLastInstructionIndex())\n\t            .append(\"]\\n\");\n\t        Iterator<ISSABasicBlock> succNodes = cfg.getSuccNodes(bb);\n\t        while (succNodes.hasNext()) {\n\t          result.append(indent+\"    -> BB\").append(((BasicBlock) succNodes.next()).getNumber()).append(\"\\n\");\n\t        }\n\t      }\n\t    result.append(indent+\"Instructions:\\n\");\n\t    for (int i = 0; i <= cfg.getMaxNumber(); i++) {\n\t      BasicBlock bb = cfg.getNode(i);\n\t      int start = bb.getFirstInstructionIndex();\n\t      int end = bb.getLastInstructionIndex();\n\t      result.append(indent+\"BB\").append(bb.getNumber());\n\t      if (bb instanceof ExceptionHandlerBasicBlock) {\n\t        result.append(indent+\"<Handler>\");\n\t      }\n\t      result.append(\"\\n\");\n\t      final SymbolTable symbolTable = ir.getSymbolTable();\n\t      for (Iterator<SSAPhiInstruction> it = bb.iteratePhis(); it.hasNext();) {\n\t        SSAPhiInstruction phi = it.next();\n\t        if (phi != null) {\n\t          result.append(indent+\"           \" + phi.toString(symbolTable)).append(\"\\n\");\n\t        }\n\t      }\n\t      if (bb instanceof ExceptionHandlerBasicBlock) {\n\t        ExceptionHandlerBasicBlock ebb = (ExceptionHandlerBasicBlock) bb;\n\t        SSAGetCaughtExceptionInstruction s = ebb.getCatchInstruction();\n\t        if (s != null) {\n\t          result.append(indent+\"           \" + s.toString(symbolTable)).append(\"\\n\");\n\t        } else {\n\t          result.append(indent+\"           \" + \" No catch instruction. Unreachable?\\n\");\n\t        }\n\t      }\n\t      final SSAInstruction[] instructions = ir.getInstructions();\n\t      for (int j = start; j <= end; j++) {\n\t        if (instructions[j] != null) {\n\t          StringBuffer x = new StringBuffer(indent+j + \"   \" + instructions[j].toString(symbolTable));\n\t          StringStuff.padWithSpaces(x, 45);\n\t          result.append(indent+x);\n\t          result.append(\"\\n\");\n\t        }\n\t      }\n\t      for (Iterator<SSAPiInstruction> it = bb.iteratePis(); it.hasNext();) {\n\t        SSAPiInstruction pi = it.next();\n\t        if (pi != null) {\n\t          result.append(indent+\"           \" + pi.toString(symbolTable)).append(\"\\n\");\n\t        }\n\t      }\n\t    }\n\t    return result.toString();\n\t    */\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given IR.\n\t * @return pretty-print String representation\n\t * of the given IR\n\t */\n\tpublic static String prettyPrint(IR ir) { return prettyPrint(ir,0); }\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given collection.\n\t * @return pretty-print String representation\n\t * of the given collection\n\t */\n\tpublic static String prettyPrint(Collection<?> c) { \n\t\treturn prettyPrint(c,0);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given collection, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given collection\n\t */\n\tpublic static String prettyPrint(Collection<?> c, int offset) { \n\t\tassert offset>=0;\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfinal String indent = repeat(\" \", offset);\n\t\tfor(Object o : c) { \n\t\t\tresult.append(indent);\n\t\t\tresult.append(o);\n\t\t\tresult.append(\"\\n\");\n\t\t}\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns a String representation of the position in the source of the given method corresponding\n\t * to the instruction at the specified index, or the empty string if the line is unknown.\n\t * @return a String representation of the position in the source of the given method corresponding\n\t * to the instruction at the specified index, or the empty string if the line is unknown.\n\t */\n\tpublic static final String line(IMethod method, int instructionIndex) { \n\t\tif (instructionIndex>=0) {\n\t\t\tif (method instanceof ShrikeBTMethod) { \n\t\t\t\ttry {\n\t\t\t\t\treturn String.valueOf(method.getLineNumber(((ShrikeBTMethod)method).getBytecodeIndex(instructionIndex)));\n\t\t\t\t} catch (InvalidClassFileException e) {  } // ignore\n\t\t\t} else if (method instanceof AstMethod) { \n\t\t\t\tfinal Position pos = ((AstMethod)method).getSourcePosition(instructionIndex);\n\t\t\t\tif (pos!=null)\n\t\t\t\t\treturn String.valueOf(pos.getFirstLine());\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * Returns a map from each InlinedInstruction in the given set to a unique name.\n\t * The names are constructed from the names of the concrete instructions wrapped\n\t * in each inlined instruction. Short type names are used whenever possible.\n\t * @return a map from each InlinedInstruction in the given set to a unique name.\n\t */\n\tpublic static Map<InlinedInstruction, String> instructionNames(Set<InlinedInstruction> insts) { \n\t\tfinal Map<CGNode,String> methodNames = nodeNames(Programs.relevantMethods(insts));\n\t\tfinal Map<String, List<InlinedInstruction>> name2Inst = new LinkedHashMap<String, List<InlinedInstruction>>();\n\t\tfinal Map<InlinedInstruction, String> inst2Name = new LinkedHashMap<InlinedInstruction, String>();\n\t\t\n\t\tfor(InlinedInstruction inst : insts) { \n\t\t\tfinal String m = methodNames.get(inst.cgNode());\n\t\t\tfinal String infix;\n\t\t\tfinal int idx = inst.instructionIndex();\n\t\t\tif (idx==Integer.MIN_VALUE) { \n\t\t\t\tinfix = \"start\";\n\t\t\t} else if (idx==Integer.MAX_VALUE) { \n\t\t\t\tinfix = \"end\";\n\t\t\t} else { \n\t\t\t\tfinal String cname = \"\";//inst.instruction().getClass().getSimpleName().replaceAll(\"SSA\", \"\").replaceAll(\"Instruction\", \"\");\n\t\t\t\tinfix = cname+idx;\n\t\t\t} \n\t\t\tfinal String name = m + \"[\" + infix + \"]\"; // m+\"_\"+infix;\n\t\t\tList<InlinedInstruction> named = name2Inst.get(name);\n\t\t\tif (named==null) { \n\t\t\t\tnamed = new ArrayList<InlinedInstruction>(3);\n\t\t\t\tname2Inst.put(name, named);\n\t\t\t}\n\t\t\tnamed.add(inst);\n\t\t}\n\t\t\n\t\tfor(Map.Entry<String, List<InlinedInstruction>> entry : name2Inst.entrySet()) { \n\t\t\tfinal List<InlinedInstruction> named = entry.getValue();\n\t\t\tif (named.size()==1) { \n\t\t\t\tinst2Name.put(named.get(0), entry.getKey());\n\t\t\t} else {\n\t\t\t\tfor(InlinedInstruction inst : named) { \n\t\t\t\t\tfinal StringBuilder b = new StringBuilder();\n\t\t\t\t\tassert !inst.callStack().empty();\n\t\t\t\t\tfinal Iterator<CallSite> itr = inst.callStack().iterator();\n\t\t\t\t\tb.append(methodNames.get(itr.next().getNode()));\n\t\t\t\t\twhile(itr.hasNext()) { \n\t\t\t\t\t\tb.append(\"_\" + methodNames.get(itr.next().getNode()));\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"_\" + entry.getKey());\n\t\t\t\t\tinst2Name.put(inst, b.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inst2Name;\n\t}\n\t\n\t/**\n\t * Returns a map from each CGNode in the given set to a unique name derived\n\t * from the signature of that node. Short type names are used whenever possible.\n\t * @return a map from each CGNode in the given set to a unique name derived\n\t * from the signature of that node. \n\t */\n\tpublic static Map<CGNode, String> nodeNames(Set<CGNode> nodes) { \n\t\tfinal Map<String, List<CGNode>> name2Node = new LinkedHashMap<String, List<CGNode>>();\n\t\tfinal Map<CGNode,String> node2Name = new LinkedHashMap<CGNode, String>();\n\t\t\n\t\tfor(CGNode ref : nodes) { \n\t\t\tfinal String name = ref.getMethod().getName().toString();\n\t\t\tList<CGNode> named = name2Node.get(name);\n\t\t\tif (named==null) { \n\t\t\t\tnamed = new ArrayList<CGNode>(3);\n\t\t\t\tname2Node.put(name, named);\n\t\t\t}\n\t\t\tnamed.add(ref);\n\t\t}\n\t\tfor(Map.Entry<String,List<CGNode>> entry: name2Node.entrySet()) { \n\t\t\tfinal List<CGNode> named = entry.getValue();\n\t\t\tif (named.size()==1) { \n\t\t\t\tnode2Name.put(named.get(0), entry.getKey());\n\t\t\t} else {\n\t\t\t\tfor(CGNode ref : named) { \n\t\t\t\t\tnode2Name.put(ref, ref.getMethod().getSignature());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node2Name;\n\t}\n\t\n\t/**\n\t * Returns a map from each InstanceKey in the given set to a unique name.\n\t * The names are constructed from the names of the concrete types represented\n\t * by each instance key.  If there is more than one instance key for the same \n\t * type, unique suffixes are appended to make the names unique.  Short type names\n\t * are used whenever possible.\n\t * @return a map from each InstanceKey in the given set to a unique name.\n\t */\n\tpublic static Map<InstanceKey, String> instanceNames(Set<InstanceKey> instances) { \n\t\tfinal Map<TypeName, List<InstanceKey>> nameToKey = new LinkedHashMap<TypeName,List<InstanceKey>>();\n\t\tfinal Map<String, Boolean> uniqueShort = new HashMap<String,Boolean>();\n\t\tfinal Map<InstanceKey, String> keyToName = new LinkedHashMap<InstanceKey,String>();\n\t\t\n\t\tfor(InstanceKey key : instances) {\n\t\t\tfinal TypeName fullName = key.getConcreteType().getName();\n\t\t\tList<InstanceKey> named = nameToKey.get(fullName);\n\t\t\tif (named==null) {\n\t\t\t\tnamed = new ArrayList<InstanceKey>(3);\n\t\t\t\tnameToKey.put(fullName, named);\n\t\t\t}\n\t\t\tnamed.add(key);\n\t\t}\n\t\t\n\t\tfor(TypeName fullName : nameToKey.keySet()) { \n\t\t\tfinal String shortName = fullName.getClassName().toString();\n\t\t\tfinal Boolean unique = uniqueShort.get(shortName);\n\t\t\tif (unique==null)\t{ uniqueShort.put(shortName, Boolean.TRUE); }\n\t\t\telse \t\t\t\t{ uniqueShort.put(shortName, Boolean.FALSE); }\n\t\t}\n\t\t\n\t\tfor(Map.Entry<TypeName, List<InstanceKey>> entry : nameToKey.entrySet()) {\n\t\t\tfinal TypeName fullName = entry.getKey();\n\t\t\tfinal List<InstanceKey> named = entry.getValue();\n\t\t\tfinal String shortName = fullName.getClassName().toString();\n\t\t\tfinal String name = uniqueShort.get(shortName) ? shortName : fullName.toString();\n\t\t\tfinal int size = named.size();\n\t\t\tif (size==1) { \n\t\t\t\tkeyToName.put(named.get(0), name);\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\t\tkeyToName.put(named.get(i), name + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert keyToName.size() == instances.size();\n\t\treturn keyToName;\n\t}\n\t\n\t/**\n\t * Returns a map from each IField in the given set to a unique name.\n\t * The names are constructed from the names of the  fields represented\n\t * by IField.  Short field names are used whenever possible.\n\t * @return a map from each IField in the given set to a unique name.\n\t */\n\tpublic static Map<IField, String> fieldNames(Set<IField> fields) { \n\t\tfinal Map<String, List<IField>> name2Field = new LinkedHashMap<String, List<IField>>();\n\t\tfinal Map<IField,String> field2Name = new LinkedHashMap<IField, String>();\n\t\t\nNext line of code:\n", "input": "", "context": "/******************************************************************************\n * Copyright (c) 2009 - 2015 IBM Corporation.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *****************************************************************************/\n/**\n * \n */\npackage com.ibm.wala.memsat.util;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport com.ibm.wala.cast.java.ipa.callgraph.AstJavaSSAPropagationCallGraphBuilder.EnclosingObjectReferenceKey;\nimport com.ibm.wala.cast.loader.AstMethod;\nimport com.ibm.wala.cast.tree.CAstSourcePositionMap.Position;\nimport com.ibm.wala.classLoader.IField;\nimport com.ibm.wala.classLoader.IMethod;\nimport com.ibm.wala.classLoader.ShrikeBTMethod;\nimport com.ibm.wala.ipa.callgraph.CGNode;\nimport com.ibm.wala.ipa.callgraph.propagation.ArrayContentsKey;\nimport com.ibm.wala.ipa.callgraph.propagation.InstanceFieldKey;\nimport com.ibm.wala.ipa.callgraph.propagation.InstanceKey;\nimport com.ibm.wala.ipa.callgraph.propagation.PointerKey;\nimport com.ibm.wala.ipa.callgraph.propagation.StaticFieldKey;\nimport com.ibm.wala.ipa.callgraph.propagation.rta.CallSite;\nimport com.ibm.wala.ipa.modref.ArrayLengthKey;\nimport com.ibm.wala.memsat.frontEnd.InlinedInstruction;\nimport com.ibm.wala.shrikeCT.InvalidClassFileException;\nimport com.ibm.wala.ssa.IR;\nimport com.ibm.wala.types.TypeName;\nimport com.ibm.wala.util.collections.Pair;\nimport com.ibm.wala.util.graph.Graph;\nimport kodkod.ast.Node;\n/**\n * A set of utility functions for string manipulation and pretty printing of Kodkod nodes,\n * IRs, etc.\n * \n * @author Emina Torlak\n */\npublic final class Strings {\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given nodes, with each line offset with at least the given\n\t * number of whitespaces.  The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given nodes\n\t */\n\tpublic static String prettyPrint(Collection<Node> nodes, int offset, int line, Map<String,String> display) { \n\t\treturn PrettyPrinter.print(nodes, offset, 80, display);\n\t}\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset, Map<String, String> display) { \n\t\treturn prettyPrint(node, offset, 80, display);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The line parameter determines the\n\t * length of each pretty-printed line, including the offset.\n\t * The display parameter determines how \n\t * the mapped nodes are displayed; that is, a descendant d of the\n\t * given node is displayed as display.get(d.toString()) if \n\t * display.containsKey(d.toString()) is true.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset, int line, final Map<String, String> display) { \n\t\treturn prettyPrint(Collections.singleton(node), offset, line, display);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  The line parameter determines the\n\t * length of each pretty-printed line, including the offset.\n\t * @requires 0 <= offset < line\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String prettyPrint(Node node, int offset, int line) { \n\t\tassert offset >= 0 && offset < line && line > 0;\n\t\treturn prettyPrint(node, offset, line, Collections.EMPTY_MAP);\n\t}\n\t\n\t/**\n\t * Returns a pretty-printed string representation of the \n\t * given node, with each line offset with at least the given\n\t * number of whitespaces.  \n\t * @requires 0 <= offset < 80\n\t * @return a pretty-printed string representation of the \n\t * given node\n\t */\n\tpublic static String prettyPrint(Node node, int offset) { \n\t\treturn prettyPrint(node,offset,80);\n\t}\n\t\n\t/**\n\t * Returns a string that consists of the given number of repetitions\n\t * of the specified string.\n\t * @return str^reps\n\t */\n\tpublic static String repeat(String str, int reps) {\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfor(int i = 0; i < reps; i++) { \n\t\t\tresult.append(str);\n\t\t}\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns the given string, with all new lines replaced with new lines indented \n\t * by the given number of spaces.\n\t * @return given string, with all new lines replaced with new lines indented \n\t * by the given number of spaces.\n\t */\n\tpublic static String indent(String str, int offset) { \n\t\tassert offset >= 0;\n\t\tfinal String indent = repeat(\" \", offset);\n\t\treturn indent + str.replaceAll(\"\\\\n\", \"\\n\"+indent);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given graph.\n\t * @return pretty-print String representation\n\t * of the given graph\n\t */\n\tpublic static String prettyPrint(Graph<?> graph) { \n\t\treturn prettyPrint(graph,0);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given graph, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given graph\n\t */\n\tpublic static <T> String prettyPrint(Graph<T> graph, int offset) { \n\t\tassert offset>=0;\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfinal String indent = repeat(\" \", offset);\n\t\tfor(T o : graph) {\n\t\t\tresult.append(\"\\n\");\n\t\t\tresult.append(indent);\n\t\t\tresult.append(o);\n\t\t\tfor(Iterator<?> itr = graph.getSuccNodes(o); itr.hasNext(); ) { \n\t\t\t\tresult.append(\"\\n\" + indent + \" --> \" + itr.next());\n\t\t\t}\n\t\t\tresult.append(\",\\n\");\n\t\t}\n\t\tresult.delete(result.length()-2, result.length());\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given IR, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given IR\n\t */\n\tpublic static String prettyPrint(IR ir, int offset) { \n\t\treturn indent(ir.toString(), offset);\n\t\t/*\n\t    final StringBuffer result = new StringBuffer();\n\t    result.append(\"\\n\"+indent+\"CFG:\\n\");\n\t    final SSACFG cfg = ir.getControlFlowGraph();\n\t    for (int i = 0; i <= cfg.getNumber(cfg.exit()); i++) {\n\t        BasicBlock bb = cfg.getNode(i);\n\t        result.append(indent+\"BB\").append(i).append(\"[\").append(bb.getFirstInstructionIndex()).append(\"..\").append(bb.getLastInstructionIndex())\n\t            .append(\"]\\n\");\n\t        Iterator<ISSABasicBlock> succNodes = cfg.getSuccNodes(bb);\n\t        while (succNodes.hasNext()) {\n\t          result.append(indent+\"    -> BB\").append(((BasicBlock) succNodes.next()).getNumber()).append(\"\\n\");\n\t        }\n\t      }\n\t    result.append(indent+\"Instructions:\\n\");\n\t    for (int i = 0; i <= cfg.getMaxNumber(); i++) {\n\t      BasicBlock bb = cfg.getNode(i);\n\t      int start = bb.getFirstInstructionIndex();\n\t      int end = bb.getLastInstructionIndex();\n\t      result.append(indent+\"BB\").append(bb.getNumber());\n\t      if (bb instanceof ExceptionHandlerBasicBlock) {\n\t        result.append(indent+\"<Handler>\");\n\t      }\n\t      result.append(\"\\n\");\n\t      final SymbolTable symbolTable = ir.getSymbolTable();\n\t      for (Iterator<SSAPhiInstruction> it = bb.iteratePhis(); it.hasNext();) {\n\t        SSAPhiInstruction phi = it.next();\n\t        if (phi != null) {\n\t          result.append(indent+\"           \" + phi.toString(symbolTable)).append(\"\\n\");\n\t        }\n\t      }\n\t      if (bb instanceof ExceptionHandlerBasicBlock) {\n\t        ExceptionHandlerBasicBlock ebb = (ExceptionHandlerBasicBlock) bb;\n\t        SSAGetCaughtExceptionInstruction s = ebb.getCatchInstruction();\n\t        if (s != null) {\n\t          result.append(indent+\"           \" + s.toString(symbolTable)).append(\"\\n\");\n\t        } else {\n\t          result.append(indent+\"           \" + \" No catch instruction. Unreachable?\\n\");\n\t        }\n\t      }\n\t      final SSAInstruction[] instructions = ir.getInstructions();\n\t      for (int j = start; j <= end; j++) {\n\t        if (instructions[j] != null) {\n\t          StringBuffer x = new StringBuffer(indent+j + \"   \" + instructions[j].toString(symbolTable));\n\t          StringStuff.padWithSpaces(x, 45);\n\t          result.append(indent+x);\n\t          result.append(\"\\n\");\n\t        }\n\t      }\n\t      for (Iterator<SSAPiInstruction> it = bb.iteratePis(); it.hasNext();) {\n\t        SSAPiInstruction pi = it.next();\n\t        if (pi != null) {\n\t          result.append(indent+\"           \" + pi.toString(symbolTable)).append(\"\\n\");\n\t        }\n\t      }\n\t    }\n\t    return result.toString();\n\t    */\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given IR.\n\t * @return pretty-print String representation\n\t * of the given IR\n\t */\n\tpublic static String prettyPrint(IR ir) { return prettyPrint(ir,0); }\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given collection.\n\t * @return pretty-print String representation\n\t * of the given collection\n\t */\n\tpublic static String prettyPrint(Collection<?> c) { \n\t\treturn prettyPrint(c,0);\n\t}\n\t\n\t/**\n\t * Returns a pretty-print String representation\n\t * of the given collection, with each new line starting\n\t * indented at least the given number of spaces.\n\t * @return pretty-print String representation\n\t * of the given collection\n\t */\n\tpublic static String prettyPrint(Collection<?> c, int offset) { \n\t\tassert offset>=0;\n\t\tfinal StringBuffer result = new StringBuffer();\n\t\tfinal String indent = repeat(\" \", offset);\n\t\tfor(Object o : c) { \n\t\t\tresult.append(indent);\n\t\t\tresult.append(o);\n\t\t\tresult.append(\"\\n\");\n\t\t}\n\t\treturn result.toString();\n\t}\n\t/**\n\t * Returns a String representation of the position in the source of the given method corresponding\n\t * to the instruction at the specified index, or the empty string if the line is unknown.\n\t * @return a String representation of the position in the source of the given method corresponding\n\t * to the instruction at the specified index, or the empty string if the line is unknown.\n\t */\n\tpublic static final String line(IMethod method, int instructionIndex) { \n\t\tif (instructionIndex>=0) {\n\t\t\tif (method instanceof ShrikeBTMethod) { \n\t\t\t\ttry {\n\t\t\t\t\treturn String.valueOf(method.getLineNumber(((ShrikeBTMethod)method).getBytecodeIndex(instructionIndex)));\n\t\t\t\t} catch (InvalidClassFileException e) {  } // ignore\n\t\t\t} else if (method instanceof AstMethod) { \n\t\t\t\tfinal Position pos = ((AstMethod)method).getSourcePosition(instructionIndex);\n\t\t\t\tif (pos!=null)\n\t\t\t\t\treturn String.valueOf(pos.getFirstLine());\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\t/**\n\t * Returns a map from each InlinedInstruction in the given set to a unique name.\n\t * The names are constructed from the names of the concrete instructions wrapped\n\t * in each inlined instruction. Short type names are used whenever possible.\n\t * @return a map from each InlinedInstruction in the given set to a unique name.\n\t */\n\tpublic static Map<InlinedInstruction, String> instructionNames(Set<InlinedInstruction> insts) { \n\t\tfinal Map<CGNode,String> methodNames = nodeNames(Programs.relevantMethods(insts));\n\t\tfinal Map<String, List<InlinedInstruction>> name2Inst = new LinkedHashMap<String, List<InlinedInstruction>>();\n\t\tfinal Map<InlinedInstruction, String> inst2Name = new LinkedHashMap<InlinedInstruction, String>();\n\t\t\n\t\tfor(InlinedInstruction inst : insts) { \n\t\t\tfinal String m = methodNames.get(inst.cgNode());\n\t\t\tfinal String infix;\n\t\t\tfinal int idx = inst.instructionIndex();\n\t\t\tif (idx==Integer.MIN_VALUE) { \n\t\t\t\tinfix = \"start\";\n\t\t\t} else if (idx==Integer.MAX_VALUE) { \n\t\t\t\tinfix = \"end\";\n\t\t\t} else { \n\t\t\t\tfinal String cname = \"\";//inst.instruction().getClass().getSimpleName().replaceAll(\"SSA\", \"\").replaceAll(\"Instruction\", \"\");\n\t\t\t\tinfix = cname+idx;\n\t\t\t} \n\t\t\tfinal String name = m + \"[\" + infix + \"]\"; // m+\"_\"+infix;\n\t\t\tList<InlinedInstruction> named = name2Inst.get(name);\n\t\t\tif (named==null) { \n\t\t\t\tnamed = new ArrayList<InlinedInstruction>(3);\n\t\t\t\tname2Inst.put(name, named);\n\t\t\t}\n\t\t\tnamed.add(inst);\n\t\t}\n\t\t\n\t\tfor(Map.Entry<String, List<InlinedInstruction>> entry : name2Inst.entrySet()) { \n\t\t\tfinal List<InlinedInstruction> named = entry.getValue();\n\t\t\tif (named.size()==1) { \n\t\t\t\tinst2Name.put(named.get(0), entry.getKey());\n\t\t\t} else {\n\t\t\t\tfor(InlinedInstruction inst : named) { \n\t\t\t\t\tfinal StringBuilder b = new StringBuilder();\n\t\t\t\t\tassert !inst.callStack().empty();\n\t\t\t\t\tfinal Iterator<CallSite> itr = inst.callStack().iterator();\n\t\t\t\t\tb.append(methodNames.get(itr.next().getNode()));\n\t\t\t\t\twhile(itr.hasNext()) { \n\t\t\t\t\t\tb.append(\"_\" + methodNames.get(itr.next().getNode()));\n\t\t\t\t\t}\n\t\t\t\t\tb.append(\"_\" + entry.getKey());\n\t\t\t\t\tinst2Name.put(inst, b.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn inst2Name;\n\t}\n\t\n\t/**\n\t * Returns a map from each CGNode in the given set to a unique name derived\n\t * from the signature of that node. Short type names are used whenever possible.\n\t * @return a map from each CGNode in the given set to a unique name derived\n\t * from the signature of that node. \n\t */\n\tpublic static Map<CGNode, String> nodeNames(Set<CGNode> nodes) { \n\t\tfinal Map<String, List<CGNode>> name2Node = new LinkedHashMap<String, List<CGNode>>();\n\t\tfinal Map<CGNode,String> node2Name = new LinkedHashMap<CGNode, String>();\n\t\t\n\t\tfor(CGNode ref : nodes) { \n\t\t\tfinal String name = ref.getMethod().getName().toString();\n\t\t\tList<CGNode> named = name2Node.get(name);\n\t\t\tif (named==null) { \n\t\t\t\tnamed = new ArrayList<CGNode>(3);\n\t\t\t\tname2Node.put(name, named);\n\t\t\t}\n\t\t\tnamed.add(ref);\n\t\t}\n\t\tfor(Map.Entry<String,List<CGNode>> entry: name2Node.entrySet()) { \n\t\t\tfinal List<CGNode> named = entry.getValue();\n\t\t\tif (named.size()==1) { \n\t\t\t\tnode2Name.put(named.get(0), entry.getKey());\n\t\t\t} else {\n\t\t\t\tfor(CGNode ref : named) { \n\t\t\t\t\tnode2Name.put(ref, ref.getMethod().getSignature());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node2Name;\n\t}\n\t\n\t/**\n\t * Returns a map from each InstanceKey in the given set to a unique name.\n\t * The names are constructed from the names of the concrete types represented\n\t * by each instance key.  If there is more than one instance key for the same \n\t * type, unique suffixes are appended to make the names unique.  Short type names\n\t * are used whenever possible.\n\t * @return a map from each InstanceKey in the given set to a unique name.\n\t */\n\tpublic static Map<InstanceKey, String> instanceNames(Set<InstanceKey> instances) { \n\t\tfinal Map<TypeName, List<InstanceKey>> nameToKey = new LinkedHashMap<TypeName,List<InstanceKey>>();\n\t\tfinal Map<String, Boolean> uniqueShort = new HashMap<String,Boolean>();\n\t\tfinal Map<InstanceKey, String> keyToName = new LinkedHashMap<InstanceKey,String>();\n\t\t\n\t\tfor(InstanceKey key : instances) {\n\t\t\tfinal TypeName fullName = key.getConcreteType().getName();\n\t\t\tList<InstanceKey> named = nameToKey.get(fullName);\n\t\t\tif (named==null) {\n\t\t\t\tnamed = new ArrayList<InstanceKey>(3);\n\t\t\t\tnameToKey.put(fullName, named);\n\t\t\t}\n\t\t\tnamed.add(key);\n\t\t}\n\t\t\n\t\tfor(TypeName fullName : nameToKey.keySet()) { \n\t\t\tfinal String shortName = fullName.getClassName().toString();\n\t\t\tfinal Boolean unique = uniqueShort.get(shortName);\n\t\t\tif (unique==null)\t{ uniqueShort.put(shortName, Boolean.TRUE); }\n\t\t\telse \t\t\t\t{ uniqueShort.put(shortName, Boolean.FALSE); }\n\t\t}\n\t\t\n\t\tfor(Map.Entry<TypeName, List<InstanceKey>> entry : nameToKey.entrySet()) {\n\t\t\tfinal TypeName fullName = entry.getKey();\n\t\t\tfinal List<InstanceKey> named = entry.getValue();\n\t\t\tfinal String shortName = fullName.getClassName().toString();\n\t\t\tfinal String name = uniqueShort.get(shortName) ? shortName : fullName.toString();\n\t\t\tfinal int size = named.size();\n\t\t\tif (size==1) { \n\t\t\t\tkeyToName.put(named.get(0), name);\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < size; i++) {\n\t\t\t\t\tkeyToName.put(named.get(i), name + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert keyToName.size() == instances.size();\n\t\treturn keyToName;\n\t}\n\t\n\t/**\n\t * Returns a map from each IField in the given set to a unique name.\n\t * The names are constructed from the names of the  fields represented\n\t * by IField.  Short field names are used whenever possible.\n\t * @return a map from each IField in the given set to a unique name.\n\t */\n\tpublic static Map<IField, String> fieldNames(Set<IField> fields) { \n\t\tfinal Map<String, List<IField>> name2Field = new LinkedHashMap<String, List<IField>>();\n\t\tfinal Map<IField,String> field2Name = new LinkedHashMap<IField, String>();\n\t\t\n", "answers": ["\t\tfor(IField field : fields) { "], "pred": " \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n  Next line of code:\n \n", "length": 1985, "dataset": "lcc", "language": "java", "all_classes": null, "_id": "1e32291c11bc48e0917860b1de8446dde3fedecd450ef073"}
{"prompt": "Please complete the code given below. \n#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\"\"\"``tornado.web`` provides a simple web framework with asynchronous\nfeatures that allow it to scale to large numbers of open connections,\nmaking it ideal for `long polling\n<http://en.wikipedia.org/wiki/Push_technology#Long_polling>`_.\nHere is a simple \"Hello, world\" example app:\n.. testcode::\n    import tornado.ioloop\n    import tornado.web\n    class MainHandler(tornado.web.RequestHandler):\n        def get(self):\n            self.write(\"Hello, world\")\n    if __name__ == \"__main__\":\n        application = tornado.web.Application([\n            (r\"/\", MainHandler),\n        ])\n        application.listen(8888)\n        tornado.ioloop.IOLoop.current().start()\n.. testoutput::\n   :hide:\nSee the :doc:`guide` for additional information.\nThread-safety notes\n-------------------\nIn general, methods on `RequestHandler` and elsewhere in Tornado are\nnot thread-safe.  In particular, methods such as\n`~RequestHandler.write()`, `~RequestHandler.finish()`, and\n`~RequestHandler.flush()` must only be called from the main thread.  If\nyou use multiple threads it is important to use `.IOLoop.add_callback`\nto transfer control back to the main thread before finishing the\nrequest.\n\"\"\"\nfrom __future__ import (absolute_import, division,\n                        print_function, with_statement)\nimport base64\nimport binascii\nimport datetime\nimport email.utils\nimport functools\nimport gzip\nimport hashlib\nimport hmac\nimport mimetypes\nimport numbers\nimport os.path\nimport re\nimport stat\nimport sys\nimport threading\nimport time\nimport tornado\nimport traceback\nimport types\nfrom io import BytesIO\nfrom tornado.concurrent import Future, is_future\nfrom tornado import escape\nfrom tornado import gen\nfrom tornado import httputil\nfrom tornado import iostream\nfrom tornado import locale\nfrom tornado.log import access_log, app_log, gen_log\nfrom tornado import stack_context\nfrom tornado import template\nfrom tornado.escape import utf8, _unicode\nfrom tornado.util import (import_object, ObjectDict, raise_exc_info,\n                          unicode_type, _websocket_mask)\nfrom tornado.httputil import split_host_and_port\ntry:\n    import Cookie  # py2\nexcept ImportError:\n    import http.cookies as Cookie  # py3\ntry:\n    import urlparse  # py2\nexcept ImportError:\n    import urllib.parse as urlparse  # py3\ntry:\n    from urllib import urlencode  # py2\nexcept ImportError:\n    from urllib.parse import urlencode  # py3\nMIN_SUPPORTED_SIGNED_VALUE_VERSION = 1\n\"\"\"The oldest signed value version supported by this version of Tornado.\nSigned values older than this version cannot be decoded.\n.. versionadded:: 3.2.1\n\"\"\"\nMAX_SUPPORTED_SIGNED_VALUE_VERSION = 2\n\"\"\"The newest signed value version supported by this version of Tornado.\nSigned values newer than this version cannot be decoded.\n.. versionadded:: 3.2.1\n\"\"\"\nDEFAULT_SIGNED_VALUE_VERSION = 2\n\"\"\"The signed value version produced by `.RequestHandler.create_signed_value`.\nMay be overridden by passing a ``version`` keyword argument.\n.. versionadded:: 3.2.1\n\"\"\"\nDEFAULT_SIGNED_VALUE_MIN_VERSION = 1\n\"\"\"The oldest signed value accepted by `.RequestHandler.get_secure_cookie`.\nMay be overridden by passing a ``min_version`` keyword argument.\n.. versionadded:: 3.2.1\n\"\"\"\nclass RequestHandler(object):\n    \"\"\"Base class for HTTP request handlers.\n    Subclasses must define at least one of the methods defined in the\n    \"Entry points\" section below.\n    \"\"\"\n    SUPPORTED_METHODS = (\"GET\", \"HEAD\", \"POST\", \"DELETE\", \"PATCH\", \"PUT\",\n                         \"OPTIONS\")\n    _template_loaders = {}  # {path: template.BaseLoader}\n    _template_loader_lock = threading.Lock()\n    _remove_control_chars_regex = re.compile(r\"[\\x00-\\x08\\x0e-\\x1f]\")\n    def __init__(self, application, request, **kwargs):\n        super(RequestHandler, self).__init__()\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._transforms = None  # will be set in _execute\n        self._prepared_future = None\n        self.path_args = None\n        self.path_kwargs = None\n        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in\n                             application.ui_methods.items())\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self,\n                                                    application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        self.request.connection.set_close_callback(self.on_connection_close)\n        self.initialize(**kwargs)\n    def initialize(self):\n        \"\"\"Hook for subclass initialization.\n        A dictionary passed as the third argument of a url spec will be\n        supplied as keyword arguments to initialize().\n        Example::\n            class ProfileHandler(RequestHandler):\n                def initialize(self, database):\n                    self.database = database\n                def get(self, username):\n                    ...\n            app = Application([\n                (r'/user/(.*)', ProfileHandler, dict(database=database)),\n                ])\n        \"\"\"\n        pass\n    @property\n    def settings(self):\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings\n    def head(self, *args, **kwargs):\n        raise HTTPError(405)\n    def get(self, *args, **kwargs):\n        raise HTTPError(405)\n    def post(self, *args, **kwargs):\n        raise HTTPError(405)\n    def delete(self, *args, **kwargs):\n        raise HTTPError(405)\n    def patch(self, *args, **kwargs):\n        raise HTTPError(405)\n    def put(self, *args, **kwargs):\n        raise HTTPError(405)\n    def options(self, *args, **kwargs):\n        raise HTTPError(405)\n    def prepare(self):\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n        Override this method to perform common initialization regardless\n        of the request method.\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or `.return_future` to make it asynchronous (the\n        `asynchronous` decorator cannot be used on `prepare`).\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass\n    def on_finish(self):\n        \"\"\"Called after the end of a request.\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass\n    def on_connection_close(self):\n        \"\"\"Called in async handlers if the client closed the connection.\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        if _has_stream_request_body(self.__class__):\n            if not self.request.body.done():\n                self.request.body.set_exception(iostream.StreamClosedError())\n                self.request.body.exception()\n    def clear(self):\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders({\n            \"Server\": \"TornadoServer/%s\" % tornado.version,\n            \"Content-Type\": \"text/html; charset=UTF-8\",\n            \"Date\": httputil.format_timestamp(time.time()),\n        })\n        self.set_default_headers()\n        self._write_buffer = []\n        self._status_code = 200\n        self._reason = httputil.responses[200]\n    def set_default_headers(self):\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass\n    def set_status(self, status_code, reason=None):\n        \"\"\"Sets the status code for our response.\n        :arg int status_code: Response status code. If ``reason`` is ``None``,\n            it must be present in `httplib.responses <http.client.responses>`.\n        :arg string reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `httplib.responses <http.client.responses>`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            try:\n                self._reason = httputil.responses[status_code]\n            except KeyError:\n                raise ValueError(\"unknown status code %d\", status_code)\n    def get_status(self):\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code\n    def set_header(self, name, value):\n        \"\"\"Sets the given response header name and value.\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)\n    def add_header(self, name, value):\n        \"\"\"Adds the given response header and value.\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))\n    def clear_header(self, name):\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]\n    _INVALID_HEADER_CHAR_RE = re.compile(br\"[\\x00-\\x1f]\")\n    def _convert_header_value(self, value):\n        if isinstance(value, bytes):\n            pass\n        elif isinstance(value, unicode_type):\n            value = value.encode('utf-8')\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request.\n        if RequestHandler._INVALID_HEADER_CHAR_RE.search(value):\n            raise ValueError(\"Unsafe header value %r\", value)\n        return value\n    _ARG_DEFAULT = []\n    def get_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)\n    def get_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        \"\"\"\n        # Make sure `get_arguments` isn't accidentally being called with a\n        # positional argument that's assumed to be a default (like in\n        # `get_argument`.)\n        assert isinstance(strip, bool)\n        return self._get_arguments(name, self.request.arguments, strip)\n    def get_body_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments,\n                                  strip)\n    def get_body_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the body arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)\n    def get_query_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default,\n                                  self.request.query_arguments, strip)\n    def get_query_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the query arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)\n    def _get_argument(self, name, default, source, strip=True):\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if default is self._ARG_DEFAULT:\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]\n    def _get_arguments(self, name, source, strip=True):\n        values = []\n        for v in source.get(name, []):\n            v = self.decode_argument(v, name=name)\n            if isinstance(v, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                v = RequestHandler._remove_control_chars_regex.sub(\" \", v)\n            if strip:\n                v = v.strip()\n            values.append(v)\n        return values\n    def decode_argument(self, value, name=None):\n        \"\"\"Decodes an argument from the request.\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(400, \"Invalid unicode in %s: %r\" %\n                            (name or \"url\", value[:40]))\n    @property\n    def cookies(self):\n        \"\"\"An alias for\n        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`.\"\"\"\n        return self.request.cookies\n    def get_cookie(self, name, default=None):\n        \"\"\"Gets the value of the cookie with the given name, else default.\"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default\n    def set_cookie(self, name, value, domain=None, expires=None, path=\"/\",\n                   expires_days=None, **kwargs):\n        \"\"\"Sets the given cookie name/value with the given options.\n        Additional keyword arguments are set on the Cookie.Morsel\n        directly.\n        See http://docs.python.org/library/cookie.html#morsel-objects\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = Cookie.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(\n                days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == 'max_age':\n                k = 'max-age'\n            # skip falsy values for httponly and secure flags because\n            # SimpleCookie sets them regardless\n            if k in ['httponly', 'secure'] and not v:\n                continue\n            morsel[k] = v\n    def clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires,\n                        domain=domain)\n    def clear_all_cookies(self, path=\"/\", domain=None):\n        \"\"\"Deletes all the cookies the user sent with this request.\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n        .. versionchanged:: 3.2\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)\n    def set_secure_cookie(self, name, value, expires_days=30, version=None,\n                          **kwargs):\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n        To read a cookie set with this method, use `get_secure_cookie()`.\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n        .. versionchanged:: 3.2.1\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(name, self.create_signed_value(name, value,\n                                                       version=version),\n                        expires_days=expires_days, **kwargs)\n    def create_signed_value(self, name, value, version=None):\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n        .. versionchanged:: 3.2.1\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        secret = self.application.settings[\"cookie_secret\"]\n        key_version = None\n        if isinstance(secret, dict):\n            if self.application.settings.get(\"key_version\") is None:\n                raise Exception(\"key_version setting must be used for secret_key dicts\")\n            key_version = self.application.settings[\"key_version\"]\n        return create_signed_value(secret, name, value, version=version,\n                                   key_version=key_version)\n    def get_secure_cookie(self, name, value=None, max_age_days=31,\n                          min_version=None):\n        \"\"\"Returns the given signed cookie if it validates, or None.\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n        .. versionchanged:: 3.2.1\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, max_age_days=max_age_days,\n                                   min_version=min_version)\n    def get_secure_cookie_key_version(self, name, value=None):\n        \"\"\"Returns the signing key version of the secure cookie.\n        The version is returned as int.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return get_signature_key_version(value)\n    def redirect(self, url, permanent=False, status=None):\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", utf8(url))\n        self.finish()\n    def write(self, chunk):\n        \"\"\"Writes the given chunk to the output buffer.\n        To write the output to the network, use the flush() method below.\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and\n        https://github.com/facebook/tornado/issues/1009\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish()\")\n        if not isinstance(chunk, (bytes, unicode_type, dict)):\n            message = \"write() only accepts bytes, unicode, and dict objects\"\n            if isinstance(chunk, list):\n                message += \". Lists not accepted for security reasons; see http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write\"\n            raise TypeError(message)\n        if isinstance(chunk, dict):\n            if 'unwrap_json' in chunk:\n                chunk = chunk['unwrap_json']\n            else:\n                chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)\n    def render(self, template_name, **kwargs):\n        \"\"\"Renders the template with the given arguments as the response.\"\"\"\n        html = self.render_string(template_name, **kwargs)\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    js_files.append(file_part)\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    css_files.append(file_part)\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n        def is_absolute(path):\n            return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            paths = []\n            unique_paths = set()\n            for path in js_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            js = ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                         '\" type=\"text/javascript\"></script>'\n                         for p in paths)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        if js_embed:\n            js = b'<script type=\"text/javascript\">\\n//<![CDATA[\\n' + \\\n                b'\\n'.join(js_embed) + b'\\n//]]>\\n</script>'\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + js + b'\\n' + html[sloc:]\n        if css_files:\n            paths = []\n            unique_paths = set()\n            for path in css_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            css = ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                          'type=\"text/css\" rel=\"stylesheet\"/>'\n                          for p in paths)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + utf8(css) + b'\\n' + html[hloc:]\n        if css_embed:\n            css = b'<style type=\"text/css\">\\n' + b'\\n'.join(css_embed) + \\\n                b'\\n</style>'\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + css + b'\\n' + html[hloc:]\n        if html_heads:\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + b''.join(html_heads) + b'\\n' + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b'</body>')\n            html = html[:hloc] + b''.join(html_bodies) + b'\\n' + html[hloc:]\n        self.finish(html)\n    def render_string(self, template_name, **kwargs):\n        \"\"\"Generate the given template with the given arguments.\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)\n    def get_template_namespace(self):\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n        May be overridden by subclasses to add or modify values.\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            pgettext=self.locale.pgettext,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        namespace.update(self.ui)\n        return namespace\n    def create_template_loader(self, template_path):\n        \"\"\"Returns a new template loader for the given path.\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` and ``template_whitespace`` application\n        settings.  If a ``template_loader`` application setting is\n        supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        if \"template_whitespace\" in settings:\n            kwargs[\"whitespace\"] = settings[\"template_whitespace\"]\n        return template.Loader(template_path, **kwargs)\n    def flush(self, include_footers=False, callback=None):\n        \"\"\"Flushes the current output buffer to the network.\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n        .. versionchanged:: 4.0\n           Now returns a `.Future` if no callback is given.\n        \"\"\"\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                self._status_code, self._headers, chunk = \\\n                    transform.transform_first_chunk(\n                        self._status_code, self._headers,\n                        chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method == \"HEAD\":\n                chunk = None\n            # Finalize the cookie headers (which have been stored in a side\n            # object so an outgoing cookie could be overwritten before it\n            # is sent).\n            if hasattr(self, \"_new_cookie\"):\n                for cookie in self._new_cookie.values():\n                    self.add_header(\"Set-Cookie\", cookie.OutputString(None))\n            start_line = httputil.ResponseStartLine('',\n                                                    self._status_code,\n                                                    self._reason)\n            return self.request.connection.write_headers(\n                start_line, self._headers, chunk, callback=callback)\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method != \"HEAD\":\n                return self.request.connection.write(chunk, callback=callback)\n            else:\n                future = Future()\n                future.set_result(None)\n                return future\n    def finish(self, chunk=None):\n        \"\"\"Finishes this response, ending the HTTP request.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice\")\n        if chunk is not None:\n            self.write(chunk)\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (self._status_code == 200 and\n                self.request.method in (\"GET\", \"HEAD\") and\n                    \"Etag\" not in self._headers):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if self._status_code == 304:\n                assert not self._write_buffer, \"Cannot send body with 304\"\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n        if hasattr(self.request, \"connection\"):\n            # Now that the request is finished, clear the callback we\n            # set on the HTTPConnection (which would otherwise prevent the\n            # garbage collection of the RequestHandler when there\n            # are keepalive connections)\n            self.request.connection.set_close_callback(None)\n        self.flush(include_footers=True)\n        self.request.finish()\n        self._log()\n        self._finished = True\n        self.on_finish()\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None\n    def send_error(self, status_code=500, **kwargs):\n        \"\"\"Sends the given HTTP error code to the browser.\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                # If we get an error between writing headers and finishing,\n                # we are unlikely to be able to finish due to a\n                # Content-Length mismatch. Try anyway to release the\n                # socket.\n                try:\n                    self.finish()\n                except Exception:\n                    gen_log.error(\"Failed to flush partial response\",\n                                  exc_info=True)\n            return\n        self.clear()\n        reason = kwargs.get('reason')\n        if 'exc_info' in kwargs:\n            exception = kwargs['exc_info'][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()\n    def write_error(self, status_code, **kwargs):\n        \"\"\"Override to implement custom error pages.\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n        \"\"\"\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                        \"<body>%(code)d: %(message)s</body></html>\" % {\n                            \"code\": status_code,\n                            \"message\": self._reason,\n                        })\n    @property\n    def locale(self):\n        \"\"\"The locale for the current session.\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n        .. versionchanged: 4.1\n           Added a property setter.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            self._locale = self.get_user_locale()\n            if not self._locale:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale\n    @locale.setter\n    def locale(self, value):\n        self._locale = value\n    def get_user_locale(self):\n        \"\"\"Override to determine the locale from the authenticated user.\n        If None is returned, we fall back to `get_browser_locale()`.\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None\n    def get_browser_locale(self, default=\"en_US\"):\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)\n    @property\n    def current_user(self):\n        \"\"\"The authenticated user for this request.\n        This is a cached version of `get_current_user`, which you can\n        override to set the user based on, e.g., a cookie. If that\n        method is not overridden, this method always returns None.\n        We lazy-load the current user the first time this method is called\n        and cache the result after that.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user\n    @current_user.setter\n    def current_user(self, value):\n        self._current_user = value\n    def get_current_user(self):\n        \"\"\"Override to determine the current user from, e.g., a cookie.\"\"\"\n        return None\n    def get_login_url(self):\n        \"\"\"Override to customize the login URL based on the request.\n        By default, we use the ``login_url`` application setting.\n        \"\"\"\n        self.require_setting(\"login_url\", \"@tornado.web.authenticated\")\n        return self.application.settings[\"login_url\"]\n    def get_template_path(self):\n        \"\"\"Override to customize template path for each handler.\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")\n    @property\n    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            version, token, timestamp = self._get_raw_xsrf_token()\n            output_version = self.settings.get(\"xsrf_cookie_version\", 2)\n            if output_version == 1:\n                self._xsrf_token = binascii.b2a_hex(token)\n            elif output_version == 2:\n                mask = os.urandom(4)\n                self._xsrf_token = b\"|\".join([\n                    b\"2\",\n                    binascii.b2a_hex(mask),\n                    binascii.b2a_hex(_websocket_mask(mask, token)),\n                    utf8(str(int(timestamp)))])\n            else:\n                raise ValueError(\"unknown xsrf cookie version %d\",\n                                 output_version)\n            if version is None:\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", self._xsrf_token,\n                                expires_days=expires_days)\n        return self._xsrf_token\n    def _get_raw_xsrf_token(self):\n        \"\"\"Read or generate the xsrf token in its raw form.\n        The raw_xsrf_token is a tuple containing:\n        * version: the version of the cookie from which this token was read,\n          or None if we generated a new token in this request.\n        * token: the raw token data; random (non-ascii) bytes.\n        * timestamp: the time this token was generated (will not be accurate\n          for version 1 cookies)\n        \"\"\"\n        if not hasattr(self, '_raw_xsrf_token'):\n            cookie = self.get_cookie(\"_xsrf\")\n            if cookie:\n                version, token, timestamp = self._decode_xsrf_token(cookie)\n            else:\n                version, token, timestamp = None, None, None\n            if token is None:\n                version = None\n                token = os.urandom(16)\n                timestamp = time.time()\n            self._raw_xsrf_token = (version, token, timestamp)\n        return self._raw_xsrf_token\n    def _decode_xsrf_token(self, cookie):\n        \"\"\"Convert a cookie string into a the tuple form returned by\n        _get_raw_xsrf_token.\n        \"\"\"\n        try:\n            m = _signed_value_version_re.match(utf8(cookie))\n            if m:\n                version = int(m.group(1))\n                if version == 2:\n                    _, mask, masked_token, timestamp = cookie.split(\"|\")\n                    mask = binascii.a2b_hex(utf8(mask))\n                    token = _websocket_mask(\n                        mask, binascii.a2b_hex(utf8(masked_token)))\n                    timestamp = int(timestamp)\n                    return version, token, timestamp\n                else:\n                    # Treat unknown versions as not present instead of failing.\n                    raise Exception(\"Unknown xsrf cookie version\")\n            else:\n                version = 1\n                try:\n                    token = binascii.a2b_hex(utf8(cookie))\n                except (binascii.Error, TypeError):\n                    token = utf8(cookie)\n                # We don't have a usable timestamp in older versions.\n                timestamp = int(time.time())\n                return (version, token, timestamp)\n        except Exception:\n            # Catch exceptions and return nothing instead of failing.\n            gen_log.debug(\"Uncaught exception in _decode_xsrf_token\",\n                          exc_info=True)\n            return None, None, None\n    def check_xsrf_cookie(self):\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n        .. versionchanged:: 3.2.2\n           Added support for cookie version 2.  Both versions 1 and 2 are\n           supported.\n        \"\"\"\n        token = (self.get_argument(\"_xsrf\", None) or\n                 self.request.headers.get(\"X-Xsrftoken\") or\n                 self.request.headers.get(\"X-Csrftoken\"))\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        _, token, _ = self._decode_xsrf_token(token)\n        _, expected_token, _ = self._get_raw_xsrf_token()\n        if not _time_independent_equals(utf8(token), utf8(expected_token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")\n    def xsrf_form_html(self):\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return '<input type=\"hidden\" name=\"_xsrf\" value=\"' + \\\n            escape.xhtml_escape(self.xsrf_token) + '\"/>'\n    def static_url(self, path, include_host=None, **kwargs):\n        \"\"\"Returns a static URL for the given relative static file path.\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\"static_handler_class\",\n                                    StaticFileHandler).make_static_url\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n        return base + get_url(self.settings, path, **kwargs)\n    def require_setting(self, name, feature=\"this feature\"):\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\"You must define the '%s' setting in your \"\n                            \"application to use %s\" % (name, feature))\n    def reverse_url(self, name, *args):\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)\n    def compute_etag(self):\n        \"\"\"Computes the etag header to be used for this request.\n        By default uses a hash of the content written so far.\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()\n    def set_etag_header(self):\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)\n    def check_etag_header(self):\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        computed_etag = utf8(self._headers.get(\"Etag\", \"\"))\n        # Find all weak and strong etag values from If-None-Match header\n        # because RFC 7232 allows multiple etag values in a single header.\n        etags = re.findall(\n            br'\\*|(?:W/)?\"[^\"]*\"',\n            utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        )\n        if not computed_etag or not etags:\n            return False\n        match = False\n        if etags[0] == b'*':\n            match = True\n        else:\n            # Use a weak comparison when comparing entity-tags.\n            val = lambda x: x[2:] if x.startswith(b'W/') else x\n            for etag in etags:\n                if val(etag) == val(computed_etag):\n                    match = True\n                    break\n        return match\n    def _stack_context_handle_exception(self, type, value, traceback):\n        try:\n            # For historical reasons _handle_request_exception only takes\n            # the exception value instead of the full triple,\n            # so re-raise the exception to ensure that it's in\n            # sys.exc_info()\n            raise_exc_info((type, value, traceback))\n        except Exception:\n            self._handle_request_exception(value)\n        return True\n    @gen.coroutine\n    def _execute(self, transforms, *args, **kwargs):\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                    for (k, v) in kwargs.items())\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                    self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n            result = self.prepare()\n            if result is not None:\n                result = yield result\n            if self._prepared_future is not None:\n                # Tell the Application we've finished with prepare()\n                # and are ready for the body to arrive.\n                self._prepared_future.set_result(None)\n            if self._finished:\n                return\n            if _has_stream_request_body(self.__class__):\n                # In streaming mode request.body is a Future that signals\n                # the body has been completely received.  The Future has no\n                # result; the data has been passed to self.data_received\n                # instead.\n                try:\n                    yield self.request.body\n                except iostream.StreamClosedError:\n                    return\n            method = getattr(self, self.request.method.lower())\n            result = method(*self.path_args, **self.path_kwargs)\n            if result is not None:\n                result = yield result\n            if self._auto_finish and not self._finished:\n                self.finish()\n        except Exception as e:\n            try:\n                self._handle_request_exception(e)\n            except Exception:\n                app_log.error(\"Exception in exception handler\", exc_info=True)\n            if (self._prepared_future is not None and\n                    not self._prepared_future.done()):\n                # In case we failed before setting _prepared_future, do it\n                # now (to unblock the HTTP server).  Note that this is not\n                # in a finally block to avoid GC issues prior to Python 3.4.\n                self._prepared_future.set_result(None)\n    def data_received(self, chunk):\n        \"\"\"Implement this method to handle streamed request data.\n        Requires the `.stream_request_body` decorator.\n        \"\"\"\n        raise NotImplementedError()\n    def _log(self):\n        \"\"\"Logs the current request.\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)\n    def _request_summary(self):\n        return \"%s %s (%s)\" % (self.request.method, self.request.uri,\n                               self.request.remote_ip)\n    def _handle_request_exception(self, e):\n        if isinstance(e, Finish):\n            # Not an error; just finish the request without logging.\n            if not self._finished:\n                self.finish()\n            return\n        try:\n            self.log_exception(*sys.exc_info())\n        except Exception:\n            # An error here should still get a best-effort send_error()\n            # to avoid leaking the connection.\n            app_log.error(\"Error in exception logger\", exc_info=True)\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            if e.status_code not in httputil.responses and not e.reason:\n                gen_log.error(\"Bad HTTP status code: %d\", e.status_code)\n                self.send_error(500, exc_info=sys.exc_info())\n            else:\n                self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())\n    def log_exception(self, typ, value, tb):\n        \"\"\"Override to customize logging of uncaught exceptions.\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = ([value.status_code, self._request_summary()] +\n                        list(value.args))\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(\"Uncaught exception %s\\n%r\", self._request_summary(),\n                          self.request, exc_info=(typ, value, tb))\n    def _ui_module(self, name, module):\n        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n        return render\n    def _ui_method(self, method):\n        return lambda *args, **kwargs: method(self, *args, **kwargs)\n    def _clear_headers_for_304(self):\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\"Allow\", \"Content-Encoding\", \"Content-Language\",\n                   \"Content-Length\", \"Content-MD5\", \"Content-Range\",\n                   \"Content-Type\", \"Last-Modified\"]\n        for h in headers:\n            self.clear_header(h)\ndef asynchronous(method):\n    \"\"\"Wrap request handler methods with this if they are asynchronous.\n    This decorator is for callback-style asynchronous methods; for\n    coroutines, use the ``@gen.coroutine`` decorator without\n    ``@asynchronous``. (It is legal for legacy reasons to use the two\n    decorators together provided ``@asynchronous`` is first, but\n    ``@asynchronous`` will be ignored in this case)\n    This decorator should only be applied to the :ref:`HTTP verb\n    methods <verbs>`; its behavior is undefined for any other method.\n    This decorator does not *make* a method asynchronous; it tells\n    the framework that the method *is* asynchronous.  For this decorator\n    to be useful the method must (at least sometimes) do something\n    asynchronous.\n    If this decorator is given, the response is not finished when the\n    method returns. It is up to the request handler to call\n    `self.finish() <RequestHandler.finish>` to finish the HTTP\n    request. Without this decorator, the request is automatically\n    finished when the ``get()`` or ``post()`` method returns. Example:\n    .. testcode::\n       class MyRequestHandler(RequestHandler):\n           @asynchronous\n           def get(self):\n              http = httpclient.AsyncHTTPClient()\n              http.fetch(\"http://friendfeed.com/\", self._on_download)\n           def _on_download(self, response):\n              self.write(\"Downloaded!\")\n              self.finish()\n    .. testoutput::\n       :hide:\n    .. versionadded:: 3.1\n       The ability to use ``@gen.coroutine`` without ``@asynchronous``.\n    \"\"\"\n    # Delay the IOLoop import because it's not available on app engine.\n    from tornado.ioloop import IOLoop\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if is_future(result):\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result\n    return wrapper\ndef stream_request_body(cls):\n    \"\"\"Apply to `RequestHandler` subclasses to enable streaming body support.\n    This decorator implies the following changes:\n    * `.HTTPServerRequest.body` is undefined, and body arguments will not\n      be included in `RequestHandler.get_argument`.\n    * `RequestHandler.prepare` is called when the request headers have been\n      read instead of after the entire body has been read.\n    * The subclass must define a method ``data_received(self, data):``, which\n      will be called zero or more times as data is available.  Note that\n      if the request has an empty body, ``data_received`` may not be called.\n    * ``prepare`` and ``data_received`` may return Futures (such as via\n      ``@gen.coroutine``, in which case the next method will not be called\n      until those futures have completed.\n    * The regular HTTP method (``post``, ``put``, etc) will be called after\n      the entire body has been read.\n    There is a subtle interaction between ``data_received`` and asynchronous\n    ``prepare``: The first call to ``data_received`` may occur at any point\n    after the call to ``prepare`` has returned *or yielded*.\n    \"\"\"\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    cls._stream_request_body = True\n    return cls\ndef _has_stream_request_body(cls):\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return getattr(cls, '_stream_request_body', False)\ndef removeslash(method):\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\ndef addslash(method):\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\nNext line of code:\n", "input": "", "context": "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\"\"\"``tornado.web`` provides a simple web framework with asynchronous\nfeatures that allow it to scale to large numbers of open connections,\nmaking it ideal for `long polling\n<http://en.wikipedia.org/wiki/Push_technology#Long_polling>`_.\nHere is a simple \"Hello, world\" example app:\n.. testcode::\n    import tornado.ioloop\n    import tornado.web\n    class MainHandler(tornado.web.RequestHandler):\n        def get(self):\n            self.write(\"Hello, world\")\n    if __name__ == \"__main__\":\n        application = tornado.web.Application([\n            (r\"/\", MainHandler),\n        ])\n        application.listen(8888)\n        tornado.ioloop.IOLoop.current().start()\n.. testoutput::\n   :hide:\nSee the :doc:`guide` for additional information.\nThread-safety notes\n-------------------\nIn general, methods on `RequestHandler` and elsewhere in Tornado are\nnot thread-safe.  In particular, methods such as\n`~RequestHandler.write()`, `~RequestHandler.finish()`, and\n`~RequestHandler.flush()` must only be called from the main thread.  If\nyou use multiple threads it is important to use `.IOLoop.add_callback`\nto transfer control back to the main thread before finishing the\nrequest.\n\"\"\"\nfrom __future__ import (absolute_import, division,\n                        print_function, with_statement)\nimport base64\nimport binascii\nimport datetime\nimport email.utils\nimport functools\nimport gzip\nimport hashlib\nimport hmac\nimport mimetypes\nimport numbers\nimport os.path\nimport re\nimport stat\nimport sys\nimport threading\nimport time\nimport tornado\nimport traceback\nimport types\nfrom io import BytesIO\nfrom tornado.concurrent import Future, is_future\nfrom tornado import escape\nfrom tornado import gen\nfrom tornado import httputil\nfrom tornado import iostream\nfrom tornado import locale\nfrom tornado.log import access_log, app_log, gen_log\nfrom tornado import stack_context\nfrom tornado import template\nfrom tornado.escape import utf8, _unicode\nfrom tornado.util import (import_object, ObjectDict, raise_exc_info,\n                          unicode_type, _websocket_mask)\nfrom tornado.httputil import split_host_and_port\ntry:\n    import Cookie  # py2\nexcept ImportError:\n    import http.cookies as Cookie  # py3\ntry:\n    import urlparse  # py2\nexcept ImportError:\n    import urllib.parse as urlparse  # py3\ntry:\n    from urllib import urlencode  # py2\nexcept ImportError:\n    from urllib.parse import urlencode  # py3\nMIN_SUPPORTED_SIGNED_VALUE_VERSION = 1\n\"\"\"The oldest signed value version supported by this version of Tornado.\nSigned values older than this version cannot be decoded.\n.. versionadded:: 3.2.1\n\"\"\"\nMAX_SUPPORTED_SIGNED_VALUE_VERSION = 2\n\"\"\"The newest signed value version supported by this version of Tornado.\nSigned values newer than this version cannot be decoded.\n.. versionadded:: 3.2.1\n\"\"\"\nDEFAULT_SIGNED_VALUE_VERSION = 2\n\"\"\"The signed value version produced by `.RequestHandler.create_signed_value`.\nMay be overridden by passing a ``version`` keyword argument.\n.. versionadded:: 3.2.1\n\"\"\"\nDEFAULT_SIGNED_VALUE_MIN_VERSION = 1\n\"\"\"The oldest signed value accepted by `.RequestHandler.get_secure_cookie`.\nMay be overridden by passing a ``min_version`` keyword argument.\n.. versionadded:: 3.2.1\n\"\"\"\nclass RequestHandler(object):\n    \"\"\"Base class for HTTP request handlers.\n    Subclasses must define at least one of the methods defined in the\n    \"Entry points\" section below.\n    \"\"\"\n    SUPPORTED_METHODS = (\"GET\", \"HEAD\", \"POST\", \"DELETE\", \"PATCH\", \"PUT\",\n                         \"OPTIONS\")\n    _template_loaders = {}  # {path: template.BaseLoader}\n    _template_loader_lock = threading.Lock()\n    _remove_control_chars_regex = re.compile(r\"[\\x00-\\x08\\x0e-\\x1f]\")\n    def __init__(self, application, request, **kwargs):\n        super(RequestHandler, self).__init__()\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._transforms = None  # will be set in _execute\n        self._prepared_future = None\n        self.path_args = None\n        self.path_kwargs = None\n        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in\n                             application.ui_methods.items())\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self,\n                                                    application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        self.request.connection.set_close_callback(self.on_connection_close)\n        self.initialize(**kwargs)\n    def initialize(self):\n        \"\"\"Hook for subclass initialization.\n        A dictionary passed as the third argument of a url spec will be\n        supplied as keyword arguments to initialize().\n        Example::\n            class ProfileHandler(RequestHandler):\n                def initialize(self, database):\n                    self.database = database\n                def get(self, username):\n                    ...\n            app = Application([\n                (r'/user/(.*)', ProfileHandler, dict(database=database)),\n                ])\n        \"\"\"\n        pass\n    @property\n    def settings(self):\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings\n    def head(self, *args, **kwargs):\n        raise HTTPError(405)\n    def get(self, *args, **kwargs):\n        raise HTTPError(405)\n    def post(self, *args, **kwargs):\n        raise HTTPError(405)\n    def delete(self, *args, **kwargs):\n        raise HTTPError(405)\n    def patch(self, *args, **kwargs):\n        raise HTTPError(405)\n    def put(self, *args, **kwargs):\n        raise HTTPError(405)\n    def options(self, *args, **kwargs):\n        raise HTTPError(405)\n    def prepare(self):\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n        Override this method to perform common initialization regardless\n        of the request method.\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or `.return_future` to make it asynchronous (the\n        `asynchronous` decorator cannot be used on `prepare`).\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass\n    def on_finish(self):\n        \"\"\"Called after the end of a request.\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass\n    def on_connection_close(self):\n        \"\"\"Called in async handlers if the client closed the connection.\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        if _has_stream_request_body(self.__class__):\n            if not self.request.body.done():\n                self.request.body.set_exception(iostream.StreamClosedError())\n                self.request.body.exception()\n    def clear(self):\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders({\n            \"Server\": \"TornadoServer/%s\" % tornado.version,\n            \"Content-Type\": \"text/html; charset=UTF-8\",\n            \"Date\": httputil.format_timestamp(time.time()),\n        })\n        self.set_default_headers()\n        self._write_buffer = []\n        self._status_code = 200\n        self._reason = httputil.responses[200]\n    def set_default_headers(self):\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass\n    def set_status(self, status_code, reason=None):\n        \"\"\"Sets the status code for our response.\n        :arg int status_code: Response status code. If ``reason`` is ``None``,\n            it must be present in `httplib.responses <http.client.responses>`.\n        :arg string reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `httplib.responses <http.client.responses>`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            try:\n                self._reason = httputil.responses[status_code]\n            except KeyError:\n                raise ValueError(\"unknown status code %d\", status_code)\n    def get_status(self):\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code\n    def set_header(self, name, value):\n        \"\"\"Sets the given response header name and value.\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)\n    def add_header(self, name, value):\n        \"\"\"Adds the given response header and value.\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))\n    def clear_header(self, name):\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]\n    _INVALID_HEADER_CHAR_RE = re.compile(br\"[\\x00-\\x1f]\")\n    def _convert_header_value(self, value):\n        if isinstance(value, bytes):\n            pass\n        elif isinstance(value, unicode_type):\n            value = value.encode('utf-8')\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request.\n        if RequestHandler._INVALID_HEADER_CHAR_RE.search(value):\n            raise ValueError(\"Unsafe header value %r\", value)\n        return value\n    _ARG_DEFAULT = []\n    def get_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)\n    def get_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        \"\"\"\n        # Make sure `get_arguments` isn't accidentally being called with a\n        # positional argument that's assumed to be a default (like in\n        # `get_argument`.)\n        assert isinstance(strip, bool)\n        return self._get_arguments(name, self.request.arguments, strip)\n    def get_body_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments,\n                                  strip)\n    def get_body_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the body arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)\n    def get_query_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n        If the argument appears in the url more than once, we return the\n        last value.\n        The returned value is always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default,\n                                  self.request.query_arguments, strip)\n    def get_query_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the query arguments with the given name.\n        If the argument is not present, returns an empty list.\n        The returned values are always unicode.\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)\n    def _get_argument(self, name, default, source, strip=True):\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if default is self._ARG_DEFAULT:\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]\n    def _get_arguments(self, name, source, strip=True):\n        values = []\n        for v in source.get(name, []):\n            v = self.decode_argument(v, name=name)\n            if isinstance(v, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                v = RequestHandler._remove_control_chars_regex.sub(\" \", v)\n            if strip:\n                v = v.strip()\n            values.append(v)\n        return values\n    def decode_argument(self, value, name=None):\n        \"\"\"Decodes an argument from the request.\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(400, \"Invalid unicode in %s: %r\" %\n                            (name or \"url\", value[:40]))\n    @property\n    def cookies(self):\n        \"\"\"An alias for\n        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`.\"\"\"\n        return self.request.cookies\n    def get_cookie(self, name, default=None):\n        \"\"\"Gets the value of the cookie with the given name, else default.\"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default\n    def set_cookie(self, name, value, domain=None, expires=None, path=\"/\",\n                   expires_days=None, **kwargs):\n        \"\"\"Sets the given cookie name/value with the given options.\n        Additional keyword arguments are set on the Cookie.Morsel\n        directly.\n        See http://docs.python.org/library/cookie.html#morsel-objects\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = Cookie.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(\n                days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == 'max_age':\n                k = 'max-age'\n            # skip falsy values for httponly and secure flags because\n            # SimpleCookie sets them regardless\n            if k in ['httponly', 'secure'] and not v:\n                continue\n            morsel[k] = v\n    def clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires,\n                        domain=domain)\n    def clear_all_cookies(self, path=\"/\", domain=None):\n        \"\"\"Deletes all the cookies the user sent with this request.\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n        .. versionchanged:: 3.2\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)\n    def set_secure_cookie(self, name, value, expires_days=30, version=None,\n                          **kwargs):\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n        To read a cookie set with this method, use `get_secure_cookie()`.\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n        .. versionchanged:: 3.2.1\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(name, self.create_signed_value(name, value,\n                                                       version=version),\n                        expires_days=expires_days, **kwargs)\n    def create_signed_value(self, name, value, version=None):\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n        .. versionchanged:: 3.2.1\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        secret = self.application.settings[\"cookie_secret\"]\n        key_version = None\n        if isinstance(secret, dict):\n            if self.application.settings.get(\"key_version\") is None:\n                raise Exception(\"key_version setting must be used for secret_key dicts\")\n            key_version = self.application.settings[\"key_version\"]\n        return create_signed_value(secret, name, value, version=version,\n                                   key_version=key_version)\n    def get_secure_cookie(self, name, value=None, max_age_days=31,\n                          min_version=None):\n        \"\"\"Returns the given signed cookie if it validates, or None.\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n        .. versionchanged:: 3.2.1\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, max_age_days=max_age_days,\n                                   min_version=min_version)\n    def get_secure_cookie_key_version(self, name, value=None):\n        \"\"\"Returns the signing key version of the secure cookie.\n        The version is returned as int.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return get_signature_key_version(value)\n    def redirect(self, url, permanent=False, status=None):\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", utf8(url))\n        self.finish()\n    def write(self, chunk):\n        \"\"\"Writes the given chunk to the output buffer.\n        To write the output to the network, use the flush() method below.\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and\n        https://github.com/facebook/tornado/issues/1009\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish()\")\n        if not isinstance(chunk, (bytes, unicode_type, dict)):\n            message = \"write() only accepts bytes, unicode, and dict objects\"\n            if isinstance(chunk, list):\n                message += \". Lists not accepted for security reasons; see http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write\"\n            raise TypeError(message)\n        if isinstance(chunk, dict):\n            if 'unwrap_json' in chunk:\n                chunk = chunk['unwrap_json']\n            else:\n                chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)\n    def render(self, template_name, **kwargs):\n        \"\"\"Renders the template with the given arguments as the response.\"\"\"\n        html = self.render_string(template_name, **kwargs)\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    js_files.append(file_part)\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    css_files.append(file_part)\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n        def is_absolute(path):\n            return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            paths = []\n            unique_paths = set()\n            for path in js_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            js = ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                         '\" type=\"text/javascript\"></script>'\n                         for p in paths)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        if js_embed:\n            js = b'<script type=\"text/javascript\">\\n//<![CDATA[\\n' + \\\n                b'\\n'.join(js_embed) + b'\\n//]]>\\n</script>'\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + js + b'\\n' + html[sloc:]\n        if css_files:\n            paths = []\n            unique_paths = set()\n            for path in css_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            css = ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                          'type=\"text/css\" rel=\"stylesheet\"/>'\n                          for p in paths)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + utf8(css) + b'\\n' + html[hloc:]\n        if css_embed:\n            css = b'<style type=\"text/css\">\\n' + b'\\n'.join(css_embed) + \\\n                b'\\n</style>'\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + css + b'\\n' + html[hloc:]\n        if html_heads:\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + b''.join(html_heads) + b'\\n' + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b'</body>')\n            html = html[:hloc] + b''.join(html_bodies) + b'\\n' + html[hloc:]\n        self.finish(html)\n    def render_string(self, template_name, **kwargs):\n        \"\"\"Generate the given template with the given arguments.\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)\n    def get_template_namespace(self):\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n        May be overridden by subclasses to add or modify values.\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            pgettext=self.locale.pgettext,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        namespace.update(self.ui)\n        return namespace\n    def create_template_loader(self, template_path):\n        \"\"\"Returns a new template loader for the given path.\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` and ``template_whitespace`` application\n        settings.  If a ``template_loader`` application setting is\n        supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        if \"template_whitespace\" in settings:\n            kwargs[\"whitespace\"] = settings[\"template_whitespace\"]\n        return template.Loader(template_path, **kwargs)\n    def flush(self, include_footers=False, callback=None):\n        \"\"\"Flushes the current output buffer to the network.\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n        .. versionchanged:: 4.0\n           Now returns a `.Future` if no callback is given.\n        \"\"\"\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                self._status_code, self._headers, chunk = \\\n                    transform.transform_first_chunk(\n                        self._status_code, self._headers,\n                        chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method == \"HEAD\":\n                chunk = None\n            # Finalize the cookie headers (which have been stored in a side\n            # object so an outgoing cookie could be overwritten before it\n            # is sent).\n            if hasattr(self, \"_new_cookie\"):\n                for cookie in self._new_cookie.values():\n                    self.add_header(\"Set-Cookie\", cookie.OutputString(None))\n            start_line = httputil.ResponseStartLine('',\n                                                    self._status_code,\n                                                    self._reason)\n            return self.request.connection.write_headers(\n                start_line, self._headers, chunk, callback=callback)\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method != \"HEAD\":\n                return self.request.connection.write(chunk, callback=callback)\n            else:\n                future = Future()\n                future.set_result(None)\n                return future\n    def finish(self, chunk=None):\n        \"\"\"Finishes this response, ending the HTTP request.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice\")\n        if chunk is not None:\n            self.write(chunk)\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (self._status_code == 200 and\n                self.request.method in (\"GET\", \"HEAD\") and\n                    \"Etag\" not in self._headers):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if self._status_code == 304:\n                assert not self._write_buffer, \"Cannot send body with 304\"\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n        if hasattr(self.request, \"connection\"):\n            # Now that the request is finished, clear the callback we\n            # set on the HTTPConnection (which would otherwise prevent the\n            # garbage collection of the RequestHandler when there\n            # are keepalive connections)\n            self.request.connection.set_close_callback(None)\n        self.flush(include_footers=True)\n        self.request.finish()\n        self._log()\n        self._finished = True\n        self.on_finish()\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None\n    def send_error(self, status_code=500, **kwargs):\n        \"\"\"Sends the given HTTP error code to the browser.\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                # If we get an error between writing headers and finishing,\n                # we are unlikely to be able to finish due to a\n                # Content-Length mismatch. Try anyway to release the\n                # socket.\n                try:\n                    self.finish()\n                except Exception:\n                    gen_log.error(\"Failed to flush partial response\",\n                                  exc_info=True)\n            return\n        self.clear()\n        reason = kwargs.get('reason')\n        if 'exc_info' in kwargs:\n            exception = kwargs['exc_info'][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()\n    def write_error(self, status_code, **kwargs):\n        \"\"\"Override to implement custom error pages.\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n        \"\"\"\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                        \"<body>%(code)d: %(message)s</body></html>\" % {\n                            \"code\": status_code,\n                            \"message\": self._reason,\n                        })\n    @property\n    def locale(self):\n        \"\"\"The locale for the current session.\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n        .. versionchanged: 4.1\n           Added a property setter.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            self._locale = self.get_user_locale()\n            if not self._locale:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale\n    @locale.setter\n    def locale(self, value):\n        self._locale = value\n    def get_user_locale(self):\n        \"\"\"Override to determine the locale from the authenticated user.\n        If None is returned, we fall back to `get_browser_locale()`.\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None\n    def get_browser_locale(self, default=\"en_US\"):\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)\n    @property\n    def current_user(self):\n        \"\"\"The authenticated user for this request.\n        This is a cached version of `get_current_user`, which you can\n        override to set the user based on, e.g., a cookie. If that\n        method is not overridden, this method always returns None.\n        We lazy-load the current user the first time this method is called\n        and cache the result after that.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user\n    @current_user.setter\n    def current_user(self, value):\n        self._current_user = value\n    def get_current_user(self):\n        \"\"\"Override to determine the current user from, e.g., a cookie.\"\"\"\n        return None\n    def get_login_url(self):\n        \"\"\"Override to customize the login URL based on the request.\n        By default, we use the ``login_url`` application setting.\n        \"\"\"\n        self.require_setting(\"login_url\", \"@tornado.web.authenticated\")\n        return self.application.settings[\"login_url\"]\n    def get_template_path(self):\n        \"\"\"Override to customize template path for each handler.\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")\n    @property\n    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            version, token, timestamp = self._get_raw_xsrf_token()\n            output_version = self.settings.get(\"xsrf_cookie_version\", 2)\n            if output_version == 1:\n                self._xsrf_token = binascii.b2a_hex(token)\n            elif output_version == 2:\n                mask = os.urandom(4)\n                self._xsrf_token = b\"|\".join([\n                    b\"2\",\n                    binascii.b2a_hex(mask),\n                    binascii.b2a_hex(_websocket_mask(mask, token)),\n                    utf8(str(int(timestamp)))])\n            else:\n                raise ValueError(\"unknown xsrf cookie version %d\",\n                                 output_version)\n            if version is None:\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", self._xsrf_token,\n                                expires_days=expires_days)\n        return self._xsrf_token\n    def _get_raw_xsrf_token(self):\n        \"\"\"Read or generate the xsrf token in its raw form.\n        The raw_xsrf_token is a tuple containing:\n        * version: the version of the cookie from which this token was read,\n          or None if we generated a new token in this request.\n        * token: the raw token data; random (non-ascii) bytes.\n        * timestamp: the time this token was generated (will not be accurate\n          for version 1 cookies)\n        \"\"\"\n        if not hasattr(self, '_raw_xsrf_token'):\n            cookie = self.get_cookie(\"_xsrf\")\n            if cookie:\n                version, token, timestamp = self._decode_xsrf_token(cookie)\n            else:\n                version, token, timestamp = None, None, None\n            if token is None:\n                version = None\n                token = os.urandom(16)\n                timestamp = time.time()\n            self._raw_xsrf_token = (version, token, timestamp)\n        return self._raw_xsrf_token\n    def _decode_xsrf_token(self, cookie):\n        \"\"\"Convert a cookie string into a the tuple form returned by\n        _get_raw_xsrf_token.\n        \"\"\"\n        try:\n            m = _signed_value_version_re.match(utf8(cookie))\n            if m:\n                version = int(m.group(1))\n                if version == 2:\n                    _, mask, masked_token, timestamp = cookie.split(\"|\")\n                    mask = binascii.a2b_hex(utf8(mask))\n                    token = _websocket_mask(\n                        mask, binascii.a2b_hex(utf8(masked_token)))\n                    timestamp = int(timestamp)\n                    return version, token, timestamp\n                else:\n                    # Treat unknown versions as not present instead of failing.\n                    raise Exception(\"Unknown xsrf cookie version\")\n            else:\n                version = 1\n                try:\n                    token = binascii.a2b_hex(utf8(cookie))\n                except (binascii.Error, TypeError):\n                    token = utf8(cookie)\n                # We don't have a usable timestamp in older versions.\n                timestamp = int(time.time())\n                return (version, token, timestamp)\n        except Exception:\n            # Catch exceptions and return nothing instead of failing.\n            gen_log.debug(\"Uncaught exception in _decode_xsrf_token\",\n                          exc_info=True)\n            return None, None, None\n    def check_xsrf_cookie(self):\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n        .. versionchanged:: 3.2.2\n           Added support for cookie version 2.  Both versions 1 and 2 are\n           supported.\n        \"\"\"\n        token = (self.get_argument(\"_xsrf\", None) or\n                 self.request.headers.get(\"X-Xsrftoken\") or\n                 self.request.headers.get(\"X-Csrftoken\"))\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        _, token, _ = self._decode_xsrf_token(token)\n        _, expected_token, _ = self._get_raw_xsrf_token()\n        if not _time_independent_equals(utf8(token), utf8(expected_token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")\n    def xsrf_form_html(self):\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return '<input type=\"hidden\" name=\"_xsrf\" value=\"' + \\\n            escape.xhtml_escape(self.xsrf_token) + '\"/>'\n    def static_url(self, path, include_host=None, **kwargs):\n        \"\"\"Returns a static URL for the given relative static file path.\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\"static_handler_class\",\n                                    StaticFileHandler).make_static_url\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n        return base + get_url(self.settings, path, **kwargs)\n    def require_setting(self, name, feature=\"this feature\"):\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\"You must define the '%s' setting in your \"\n                            \"application to use %s\" % (name, feature))\n    def reverse_url(self, name, *args):\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)\n    def compute_etag(self):\n        \"\"\"Computes the etag header to be used for this request.\n        By default uses a hash of the content written so far.\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()\n    def set_etag_header(self):\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)\n    def check_etag_header(self):\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        computed_etag = utf8(self._headers.get(\"Etag\", \"\"))\n        # Find all weak and strong etag values from If-None-Match header\n        # because RFC 7232 allows multiple etag values in a single header.\n        etags = re.findall(\n            br'\\*|(?:W/)?\"[^\"]*\"',\n            utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        )\n        if not computed_etag or not etags:\n            return False\n        match = False\n        if etags[0] == b'*':\n            match = True\n        else:\n            # Use a weak comparison when comparing entity-tags.\n            val = lambda x: x[2:] if x.startswith(b'W/') else x\n            for etag in etags:\n                if val(etag) == val(computed_etag):\n                    match = True\n                    break\n        return match\n    def _stack_context_handle_exception(self, type, value, traceback):\n        try:\n            # For historical reasons _handle_request_exception only takes\n            # the exception value instead of the full triple,\n            # so re-raise the exception to ensure that it's in\n            # sys.exc_info()\n            raise_exc_info((type, value, traceback))\n        except Exception:\n            self._handle_request_exception(value)\n        return True\n    @gen.coroutine\n    def _execute(self, transforms, *args, **kwargs):\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                    for (k, v) in kwargs.items())\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                    self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n            result = self.prepare()\n            if result is not None:\n                result = yield result\n            if self._prepared_future is not None:\n                # Tell the Application we've finished with prepare()\n                # and are ready for the body to arrive.\n                self._prepared_future.set_result(None)\n            if self._finished:\n                return\n            if _has_stream_request_body(self.__class__):\n                # In streaming mode request.body is a Future that signals\n                # the body has been completely received.  The Future has no\n                # result; the data has been passed to self.data_received\n                # instead.\n                try:\n                    yield self.request.body\n                except iostream.StreamClosedError:\n                    return\n            method = getattr(self, self.request.method.lower())\n            result = method(*self.path_args, **self.path_kwargs)\n            if result is not None:\n                result = yield result\n            if self._auto_finish and not self._finished:\n                self.finish()\n        except Exception as e:\n            try:\n                self._handle_request_exception(e)\n            except Exception:\n                app_log.error(\"Exception in exception handler\", exc_info=True)\n            if (self._prepared_future is not None and\n                    not self._prepared_future.done()):\n                # In case we failed before setting _prepared_future, do it\n                # now (to unblock the HTTP server).  Note that this is not\n                # in a finally block to avoid GC issues prior to Python 3.4.\n                self._prepared_future.set_result(None)\n    def data_received(self, chunk):\n        \"\"\"Implement this method to handle streamed request data.\n        Requires the `.stream_request_body` decorator.\n        \"\"\"\n        raise NotImplementedError()\n    def _log(self):\n        \"\"\"Logs the current request.\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)\n    def _request_summary(self):\n        return \"%s %s (%s)\" % (self.request.method, self.request.uri,\n                               self.request.remote_ip)\n    def _handle_request_exception(self, e):\n        if isinstance(e, Finish):\n            # Not an error; just finish the request without logging.\n            if not self._finished:\n                self.finish()\n            return\n        try:\n            self.log_exception(*sys.exc_info())\n        except Exception:\n            # An error here should still get a best-effort send_error()\n            # to avoid leaking the connection.\n            app_log.error(\"Error in exception logger\", exc_info=True)\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            if e.status_code not in httputil.responses and not e.reason:\n                gen_log.error(\"Bad HTTP status code: %d\", e.status_code)\n                self.send_error(500, exc_info=sys.exc_info())\n            else:\n                self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())\n    def log_exception(self, typ, value, tb):\n        \"\"\"Override to customize logging of uncaught exceptions.\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = ([value.status_code, self._request_summary()] +\n                        list(value.args))\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(\"Uncaught exception %s\\n%r\", self._request_summary(),\n                          self.request, exc_info=(typ, value, tb))\n    def _ui_module(self, name, module):\n        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n        return render\n    def _ui_method(self, method):\n        return lambda *args, **kwargs: method(self, *args, **kwargs)\n    def _clear_headers_for_304(self):\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\"Allow\", \"Content-Encoding\", \"Content-Language\",\n                   \"Content-Length\", \"Content-MD5\", \"Content-Range\",\n                   \"Content-Type\", \"Last-Modified\"]\n        for h in headers:\n            self.clear_header(h)\ndef asynchronous(method):\n    \"\"\"Wrap request handler methods with this if they are asynchronous.\n    This decorator is for callback-style asynchronous methods; for\n    coroutines, use the ``@gen.coroutine`` decorator without\n    ``@asynchronous``. (It is legal for legacy reasons to use the two\n    decorators together provided ``@asynchronous`` is first, but\n    ``@asynchronous`` will be ignored in this case)\n    This decorator should only be applied to the :ref:`HTTP verb\n    methods <verbs>`; its behavior is undefined for any other method.\n    This decorator does not *make* a method asynchronous; it tells\n    the framework that the method *is* asynchronous.  For this decorator\n    to be useful the method must (at least sometimes) do something\n    asynchronous.\n    If this decorator is given, the response is not finished when the\n    method returns. It is up to the request handler to call\n    `self.finish() <RequestHandler.finish>` to finish the HTTP\n    request. Without this decorator, the request is automatically\n    finished when the ``get()`` or ``post()`` method returns. Example:\n    .. testcode::\n       class MyRequestHandler(RequestHandler):\n           @asynchronous\n           def get(self):\n              http = httpclient.AsyncHTTPClient()\n              http.fetch(\"http://friendfeed.com/\", self._on_download)\n           def _on_download(self, response):\n              self.write(\"Downloaded!\")\n              self.finish()\n    .. testoutput::\n       :hide:\n    .. versionadded:: 3.1\n       The ability to use ``@gen.coroutine`` without ``@asynchronous``.\n    \"\"\"\n    # Delay the IOLoop import because it's not available on app engine.\n    from tornado.ioloop import IOLoop\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if is_future(result):\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result\n    return wrapper\ndef stream_request_body(cls):\n    \"\"\"Apply to `RequestHandler` subclasses to enable streaming body support.\n    This decorator implies the following changes:\n    * `.HTTPServerRequest.body` is undefined, and body arguments will not\n      be included in `RequestHandler.get_argument`.\n    * `RequestHandler.prepare` is called when the request headers have been\n      read instead of after the entire body has been read.\n    * The subclass must define a method ``data_received(self, data):``, which\n      will be called zero or more times as data is available.  Note that\n      if the request has an empty body, ``data_received`` may not be called.\n    * ``prepare`` and ``data_received`` may return Futures (such as via\n      ``@gen.coroutine``, in which case the next method will not be called\n      until those futures have completed.\n    * The regular HTTP method (``post``, ``put``, etc) will be called after\n      the entire body has been read.\n    There is a subtle interaction between ``data_received`` and asynchronous\n    ``prepare``: The first call to ``data_received`` may occur at any point\n    after the call to ``prepare`` has returned *or yielded*.\n    \"\"\"\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    cls._stream_request_body = True\n    return cls\ndef _has_stream_request_body(cls):\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return getattr(cls, '_stream_request_body', False)\ndef removeslash(method):\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\ndef addslash(method):\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\n", "answers": ["    like ``r'/foo/?'`` in conjunction with using the decorator."], "pred": "Next line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code:\nNext line of code", "length": 6502, "dataset": "lcc", "language": "python", "all_classes": null, "_id": "d5dde130982bcbe6f095c65d1d5a928669bc3a458df26cc6"}
